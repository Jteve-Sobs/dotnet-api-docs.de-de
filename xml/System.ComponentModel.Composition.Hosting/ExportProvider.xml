<Type Name="ExportProvider" FullName="System.ComponentModel.Composition.Hosting.ExportProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aa793273dbcd2a8e8cddc5d93a374542a76bcf24" /><Meta Name="ms.sourcegitcommit" Value="f1d16425528e237257ca3b58eb49217a514849ea" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/24/2019" /><Meta Name="ms.locfileid" Value="63905699" /></Metadata><TypeSignature Language="C#" Value="public abstract class ExportProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ExportProvider extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Composition.Hosting.ExportProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ExportProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class ExportProvider abstract" />
  <TypeSignature Language="F#" Value="type ExportProvider = class" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.Composition</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Ruft Exporte ab, die einem angegebenen <see cref="T:System.ComponentModel.Composition.Primitives.ImportDefinition" />-Objekt entsprechen.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ExportProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ExportProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.ComponentModel.Composition.Hosting.ExportProvider" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExportsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs&gt; ExportsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs&gt; ExportsChanged" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Composition.Hosting.ExportProvider.ExportsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ExportsChanged As EventHandler(Of ExportsChangeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::ComponentModel::Composition::Hosting::ExportsChangeEventArgs ^&gt; ^ ExportsChanged;" />
      <MemberSignature Language="F#" Value="member this.ExportsChanged : EventHandler&lt;System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs&gt; " Usage="member this.ExportsChanged : System.EventHandler&lt;System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich die Exporte in <see cref="T:System.ComponentModel.Composition.Hosting.ExportProvider" /> ändern.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExportsChanging">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs&gt; ExportsChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs&gt; ExportsChanging" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Composition.Hosting.ExportProvider.ExportsChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ExportsChanging As EventHandler(Of ExportsChangeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::ComponentModel::Composition::Hosting::ExportsChangeEventArgs ^&gt; ^ ExportsChanging;" />
      <MemberSignature Language="F#" Value="member this.ExportsChanging : EventHandler&lt;System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs&gt; " Usage="member this.ExportsChanging : System.EventHandler&lt;System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn sich die bereitgestellten Exporte ändern.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetExport&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen angegebenen Export ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetExport&lt;T&gt;">
      <MemberSignature Language="C#" Value="public Lazy&lt;T&gt; GetExport&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Lazy`1&lt;!!T&gt; GetExport&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExport``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExport(Of T) () As Lazy(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; Lazy&lt;T&gt; ^ GetExport();" />
      <MemberSignature Language="F#" Value="member this.GetExport : unit -&gt; Lazy&lt;'T&gt;" Usage="exportProvider.GetExport " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Lazy&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typparameter des zurückzugebenden <see cref="T:System.Lazy`1" />-Objekts. Der Vertragsname wird auch von diesem Typparameter abgeleitet.</typeparam>
        <summary>Gibt den Export mit dem vom angegebenen Typparameter abgeleiteten Vertragsnamen zurück. Wenn nicht genau ein übereinstimmender Export vorhanden ist, wird eine Ausnahme ausgelöst.</summary>
        <returns>Der Export mit dem vom angegebenen Typparameter abgeleiteten Vertragsnamen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vertragsname ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Composition.ImportCardinalityMismatchException">Es gibt keine <see cref="T:System.Lazy`1" />-Objekte mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt.  
  
- oder - 
Es gibt mehr als ein <see cref="T:System.Lazy`1" />-Objekt mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExport&lt;T&gt;">
      <MemberSignature Language="C#" Value="public Lazy&lt;T&gt; GetExport&lt;T&gt; (string contractName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Lazy`1&lt;!!T&gt; GetExport&lt;T&gt;(string contractName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExport``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExport(Of T) (contractName As String) As Lazy(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; Lazy&lt;T&gt; ^ GetExport(System::String ^ contractName);" />
      <MemberSignature Language="F#" Value="member this.GetExport : string -&gt; Lazy&lt;'T&gt;" Usage="exportProvider.GetExport contractName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Lazy&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typparameter des zurückzugebenden <see cref="T:System.Lazy`1" />-Objekts.</typeparam>
        <param name="contractName">Der Vertragsname des zurückzugebenden <see cref="T:System.Lazy`1" />-Objekts oder <see langword="null" /> oder eine leere Zeichenfolge (""), um den Standardvertragsnamen zu verwenden.</param>
        <summary>Gibt den Export mit dem angegebenen Vertragsnamen zurück. Wenn nicht genau ein übereinstimmender Export vorhanden ist, wird eine Ausnahme ausgelöst.</summary>
        <returns>Der Export mit dem angegebenen Vertragsnamen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardname für den Vertrag ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Composition.ImportCardinalityMismatchException">Es gibt keine <see cref="T:System.Lazy`1" />-Objekte mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt.  
  
- oder - 
Es gibt mehr als ein <see cref="T:System.Lazy`1" />-Objekt mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExport&lt;T,TMetadataView&gt;">
      <MemberSignature Language="C#" Value="public Lazy&lt;T,TMetadataView&gt; GetExport&lt;T,TMetadataView&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Lazy`2&lt;!!T, !!TMetadataView&gt; GetExport&lt;T, TMetadataView&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExport``2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExport(Of T, TMetadataView) () As Lazy(Of T, TMetadataView)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TMetadataView&gt;&#xA; Lazy&lt;T, TMetadataView&gt; ^ GetExport();" />
      <MemberSignature Language="F#" Value="member this.GetExport : unit -&gt; Lazy&lt;'T, 'MetadataView&gt;" Usage="exportProvider.GetExport " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Lazy&lt;T,TMetadataView&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TMetadataView" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typparameter des zurückzugebenden <see cref="T:System.Lazy`2" />-Objekts. Der Vertragsname wird auch von diesem Typparameter abgeleitet.</typeparam>
        <typeparam name="TMetadataView">Der Typ der Metadatenansicht des zurückzugebenden <see cref="T:System.Lazy`2" />-Objekts.</typeparam>
        <summary>Gibt den Export mit dem vom angegebenen Typparameter abgeleiteten Vertragsnamen zurück. Wenn nicht genau ein übereinstimmender Export vorhanden ist, wird eine Ausnahme ausgelöst.</summary>
        <returns>System.Lazy'2</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vertragsname ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Composition.ImportCardinalityMismatchException">Es gibt keine <see cref="T:System.Lazy`2" />-Objekte mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt.  
  
- oder - 
Es gibt mehr als ein <see cref="T:System.Lazy`2" />-Objekt mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="TMetadataView" /> ist kein gültiger Metadatenansichtstyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExport&lt;T,TMetadataView&gt;">
      <MemberSignature Language="C#" Value="public Lazy&lt;T,TMetadataView&gt; GetExport&lt;T,TMetadataView&gt; (string contractName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Lazy`2&lt;!!T, !!TMetadataView&gt; GetExport&lt;T, TMetadataView&gt;(string contractName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExport``2(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExport(Of T, TMetadataView) (contractName As String) As Lazy(Of T, TMetadataView)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TMetadataView&gt;&#xA; Lazy&lt;T, TMetadataView&gt; ^ GetExport(System::String ^ contractName);" />
      <MemberSignature Language="F#" Value="member this.GetExport : string -&gt; Lazy&lt;'T, 'MetadataView&gt;" Usage="exportProvider.GetExport contractName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Lazy&lt;T,TMetadataView&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TMetadataView" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typparameter des zurückzugebenden <see cref="T:System.Lazy`2" />-Objekts.</typeparam>
        <typeparam name="TMetadataView">Der Typ der Metadatenansicht des zurückzugebenden <see cref="T:System.Lazy`2" />-Objekts.</typeparam>
        <param name="contractName">Der Vertragsname des zurückzugebenden <see cref="T:System.Lazy`2" />-Objekts oder <see langword="null" /> oder eine leere Zeichenfolge (""), um den Standardvertragsnamen zu verwenden.</param>
        <summary>Gibt den Export mit dem angegebenen Vertragsnamen zurück. Wenn nicht genau ein übereinstimmender Export vorhanden ist, wird eine Ausnahme ausgelöst.</summary>
        <returns>Der Export mit dem angegebenen Vertragsnamen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardname für den Vertrag ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Composition.ImportCardinalityMismatchException">Es gibt keine <see cref="T:System.Lazy`2" />-Objekte mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt.  
  
- oder - 
Es gibt mehr als ein <see cref="T:System.Lazy`2" />-Objekt mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="TMetadataView" /> ist kein gültiger Metadatenansichtstyp.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetExportedValue&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein exportiertes Objekt ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetExportedValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetExportedValue&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetExportedValue&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValue``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExportedValue(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; T GetExportedValue();" />
      <MemberSignature Language="F#" Value="member this.GetExportedValue : unit -&gt; 'T" Usage="exportProvider.GetExportedValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typ des zurückzugebenden exportierten Objekts. Der Vertragsname wird auch von diesem Typparameter abgeleitet.</typeparam>
        <summary>Gibt das exportierte Objekt mit dem vom angegebenen Typparameter abgeleiteten Vertragsnamen zurück. Wenn nicht genau ein übereinstimmendes exportiertes Objekt vorhanden ist, wird eine Ausnahme ausgelöst.</summary>
        <returns>Das exportierte Objekt mit dem vom angegebenen Typparameter abgeleiteten Vertragsnamen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vertragsname ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Composition.ImportCardinalityMismatchException">Es gibt 0 (null) exportierte Objekte mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />.  
  
- oder - 
Es gibt mehr als ein exportiertes Objekt mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionContractMismatchException">Das zugrunde liegende exportierte Objekt kann nicht in <paramref name="T" /> umgewandelt werden.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionException">Fehler bei der Komposition. <see cref="P:System.ComponentModel.Composition.CompositionException.Errors" /> enthält eine Auflistung der aufgetretenen Fehler.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExportedValue&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetExportedValue&lt;T&gt; (string contractName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetExportedValue&lt;T&gt;(string contractName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValue``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExportedValue(Of T) (contractName As String) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; T GetExportedValue(System::String ^ contractName);" />
      <MemberSignature Language="F#" Value="member this.GetExportedValue : string -&gt; 'T" Usage="exportProvider.GetExportedValue contractName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des zurückzugebenden exportierten Objekts.</typeparam>
        <param name="contractName">Der Vertragsname des zurückzugebenden exportierten Objekts oder <see langword="null" /> oder eine leere Zeichenfolge (""), um den Standardvertragsnamen zu verwenden.</param>
        <summary>Gibt das exportierte Objekt mit dem angegebenen Vertragsnamen zurück. Wenn nicht genau ein übereinstimmendes exportiertes Objekt vorhanden ist, wird eine Ausnahme ausgelöst.</summary>
        <returns>Das exportierte Objekt mit dem angegebenen Vertragsnamen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardname für den Vertrag ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Composition.ImportCardinalityMismatchException">Es gibt 0 (null) exportierte Objekte mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />.  
  
- oder - 
Es gibt mehr als ein exportiertes Objekt mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionContractMismatchException">Das zugrunde liegende exportierte Objekt kann nicht in <paramref name="T" /> umgewandelt werden.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionException">Fehler bei der Komposition. <see cref="P:System.ComponentModel.Composition.CompositionException.Errors" /> enthält eine Auflistung der aufgetretenen Fehler.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetExportedValueOrDefault&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein angegebenes exportiertes Objekt oder (wenn es nicht verfügbar ist) einen Standardwert ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetExportedValueOrDefault&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetExportedValueOrDefault&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetExportedValueOrDefault&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueOrDefault``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExportedValueOrDefault(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; T GetExportedValueOrDefault();" />
      <MemberSignature Language="F#" Value="member this.GetExportedValueOrDefault : unit -&gt; 'T" Usage="exportProvider.GetExportedValueOrDefault " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typ des zurückzugebenden exportierten Objekts. Der Vertragsname wird auch von diesem Typparameter abgeleitet.</typeparam>
        <summary>Ruft das exportierte Objekt mit dem vom angegebenen Typparameter abgeleiteten Vertragsnamen oder den Standardwert für den angegebenen Typ ab, oder löst eine Ausnahme aus, falls mehrere übereinstimmende exportierte Objekte vorhanden sind.</summary>
        <returns>Das exportierte Objekt mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen, sofern es gefunden wird, andernfalls der Standardwert für <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das exportierte Objekt nicht gefunden wird, gibt diese Methode den entsprechenden Standardwert für `T`; z. B. 0 (null) für ganzzahlige Typen, `false` für boolesche Typen und `null` für Verweistypen zulässig.  
  
 Der Vertragsname ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Composition.ImportCardinalityMismatchException">Es gibt mehr als ein exportiertes Objekt mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionContractMismatchException">Das zugrunde liegende exportierte Objekt kann nicht in <paramref name="T" /> umgewandelt werden.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionException">Fehler bei der Komposition. <see cref="P:System.ComponentModel.Composition.CompositionException.Errors" /> enthält eine Auflistung der aufgetretenen Fehler.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExportedValueOrDefault&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T GetExportedValueOrDefault&lt;T&gt; (string contractName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T GetExportedValueOrDefault&lt;T&gt;(string contractName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueOrDefault``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExportedValueOrDefault(Of T) (contractName As String) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; T GetExportedValueOrDefault(System::String ^ contractName);" />
      <MemberSignature Language="F#" Value="member this.GetExportedValueOrDefault : string -&gt; 'T" Usage="exportProvider.GetExportedValueOrDefault contractName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des zurückzugebenden exportierten Objekts.</typeparam>
        <param name="contractName">Der Vertragsname des zurückzugebenden exportierten Objekts oder <see langword="null" /> oder eine leere Zeichenfolge (""), um den Standardvertragsnamen zu verwenden.</param>
        <summary>Ruft das exportierte Objekt mit dem angegebenen Vertragsnamen oder den Standardwert für den angegebenen Typ ab, oder löst eine Ausnahme aus, falls mehrere übereinstimmende exportierte Objekte vorhanden sind.</summary>
        <returns>Das exportierte Objekt mit dem angegebenen Vertragsnamen, sofern es gefunden wird, andernfalls der Standardwert für <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das exportierte Objekt nicht gefunden wird, gibt diese Methode den entsprechenden Standardwert für `T`; z. B. 0 (null) für ganzzahlige Typen, `false` für boolesche Typen und `null` für Verweistypen zulässig.  
  
 Der Standardname für den Vertrag ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Composition.ImportCardinalityMismatchException">Es gibt mehr als ein exportiertes Objekt mit dem angegebenen Vertragsnamen im <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionContractMismatchException">Das zugrunde liegende exportierte Objekt kann nicht in <paramref name="T" /> umgewandelt werden.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionException">Fehler bei der Komposition. <see cref="P:System.ComponentModel.Composition.CompositionException.Errors" /> enthält eine Auflistung der aufgetretenen Fehler.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetExportedValues&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein oder mehrere exportierte Objekte ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetExportedValues&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetExportedValues&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; GetExportedValues&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValues``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExportedValues(Of T) () As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetExportedValues();" />
      <MemberSignature Language="F#" Value="member this.GetExportedValues : unit -&gt; seq&lt;'T&gt;" Usage="exportProvider.GetExportedValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typ des zurückzugebenden exportierten Objekts. Der Vertragsname wird auch von diesem Typparameter abgeleitet.</typeparam>
        <summary>Ruft alle exportierten Objekte mit dem vom angegebenen Typparameter abgeleiteten Vertragsnamen ab.</summary>
        <returns>Die exportierten Objekte mit dem vom angegebenen Typparameter abgeleiteten Vertragsnamen, sofern sie gefunden werden, andernfalls ein leeres <see cref="T:System.Collections.ObjectModel.Collection`1" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vertragsname ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionContractMismatchException">Eines oder mehrere der zugrunde liegenden exportierten Objekte kann nicht in <paramref name="T" /> umgewandelt werden.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionException">Fehler bei der Komposition. <see cref="P:System.ComponentModel.Composition.CompositionException.Errors" /> enthält eine Auflistung der aufgetretenen Fehler.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExportedValues&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetExportedValues&lt;T&gt; (string contractName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; GetExportedValues&lt;T&gt;(string contractName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValues``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExportedValues(Of T) (contractName As String) As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetExportedValues(System::String ^ contractName);" />
      <MemberSignature Language="F#" Value="member this.GetExportedValues : string -&gt; seq&lt;'T&gt;" Usage="exportProvider.GetExportedValues contractName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typ des zurückzugebenden exportierten Objekts.</typeparam>
        <param name="contractName">Der Vertragsname der zurückzugebenden exportierten Objekte oder <see langword="null" /> oder eine leere Zeichenfolge (""), um den Standardvertragsnamen zu verwenden.</param>
        <summary>Ruft alle exportierten Objekte mit dem angegebenen Vertragsnamen ab.</summary>
        <returns>Die exportierten Objekte mit dem angegebenen Vertragsnamen, sofern sie gefunden werden, andernfalls ein leeres <see cref="T:System.Collections.ObjectModel.Collection`1" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardname für den Vertrag ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionContractMismatchException">Einer oder mehrere der zugrunde liegenden exportierten Werte kann nicht in <paramref name="T" /> umgewandelt werden.</exception>
        <exception cref="T:System.ComponentModel.Composition.CompositionException">Fehler bei der Komposition. <see cref="P:System.ComponentModel.Composition.CompositionException.Errors" /> enthält eine Auflistung der aufgetretenen Fehler.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetExports">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft alle Exporte ab, die mit den angegebenen Bedingungen übereinstimmen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetExports">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.ComponentModel.Composition.Primitives.Export&gt; GetExports (System.ComponentModel.Composition.Primitives.ImportDefinition definition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.ComponentModel.Composition.Primitives.Export&gt; GetExports(class System.ComponentModel.Composition.Primitives.ImportDefinition definition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(System.ComponentModel.Composition.Primitives.ImportDefinition)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExports (definition As ImportDefinition) As IEnumerable(Of Export)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::ComponentModel::Composition::Primitives::Export ^&gt; ^ GetExports(System::ComponentModel::Composition::Primitives::ImportDefinition ^ definition);" />
      <MemberSignature Language="F#" Value="member this.GetExports : System.ComponentModel.Composition.Primitives.ImportDefinition -&gt; seq&lt;System.ComponentModel.Composition.Primitives.Export&gt;" Usage="exportProvider.GetExports definition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.ComponentModel.Composition.Primitives.Export&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="definition" Type="System.ComponentModel.Composition.Primitives.ImportDefinition" />
      </Parameters>
      <Docs>
        <param name="definition">Das Objekt, das die Bedingungen der abzurufenden <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekte definiert.</param>
        <summary>Ruft alle Exporte ab, die mit den Bedingungen der angegebenen Importdefinition übereinstimmen.</summary>
        <returns>Eine Auflistung aller <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekte, die mit den durch <paramref name="definition" /> angegebenen Bedingungen übereinstimmen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Composition.ImportCardinalityMismatchException"><see cref="P:System.ComponentModel.Composition.Primitives.ImportDefinition.Cardinality" /> ist <see cref="F:System.ComponentModel.Composition.Primitives.ImportCardinality.ExactlyOne" />, und es gibt null <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekte, die mit den Bedingungen des angegebenen <see cref="T:System.ComponentModel.Composition.Primitives.ImportDefinition" />-Objekts übereinstimmen.  
  
- oder - 
 <see cref="P:System.ComponentModel.Composition.Primitives.ImportDefinition.Cardinality" /> ist <see cref="F:System.ComponentModel.Composition.Primitives.ImportCardinality.ZeroOrOne" /> oder <see cref="F:System.ComponentModel.Composition.Primitives.ImportCardinality.ExactlyOne" />, und es gibt mehr als ein <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekt, das mit den Bedingungen des angegebenen <see cref="T:System.ComponentModel.Composition.Primitives.ImportDefinition" />-Objekts übereinstimmt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="definition" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExports">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.ComponentModel.Composition.Primitives.Export&gt; GetExports (System.ComponentModel.Composition.Primitives.ImportDefinition definition, System.ComponentModel.Composition.Hosting.AtomicComposition atomicComposition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.ComponentModel.Composition.Primitives.Export&gt; GetExports(class System.ComponentModel.Composition.Primitives.ImportDefinition definition, class System.ComponentModel.Composition.Hosting.AtomicComposition atomicComposition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(System.ComponentModel.Composition.Primitives.ImportDefinition,System.ComponentModel.Composition.Hosting.AtomicComposition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::ComponentModel::Composition::Primitives::Export ^&gt; ^ GetExports(System::ComponentModel::Composition::Primitives::ImportDefinition ^ definition, System::ComponentModel::Composition::Hosting::AtomicComposition ^ atomicComposition);" />
      <MemberSignature Language="F#" Value="member this.GetExports : System.ComponentModel.Composition.Primitives.ImportDefinition * System.ComponentModel.Composition.Hosting.AtomicComposition -&gt; seq&lt;System.ComponentModel.Composition.Primitives.Export&gt;" Usage="exportProvider.GetExports (definition, atomicComposition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.ComponentModel.Composition.Primitives.Export&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="definition" Type="System.ComponentModel.Composition.Primitives.ImportDefinition" />
        <Parameter Name="atomicComposition" Type="System.ComponentModel.Composition.Hosting.AtomicComposition" />
      </Parameters>
      <Docs>
        <param name="definition">Das Objekt, das die Bedingungen der abzurufenden <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekte definiert.</param>
        <param name="atomicComposition">Der Transaktionscontainer für die Komposition.</param>
        <summary>Ruft alle Exporte ab, die den Bedingungen der angegebenen Importdefinition und Komposition entsprechen.</summary>
        <returns>Eine Auflistung aller <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekte, die mit der durch <paramref name="definition" /> und <paramref name="atomicComposition" /> angegebenen Bedingung übereinstimmen.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Composition.ImportCardinalityMismatchException"><see cref="P:System.ComponentModel.Composition.Primitives.ImportDefinition.Cardinality" /> ist <see cref="F:System.ComponentModel.Composition.Primitives.ImportCardinality.ExactlyOne" />, und es gibt null <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekte, die mit den Bedingungen des angegebenen <see cref="T:System.ComponentModel.Composition.Primitives.ImportDefinition" />-Objekts übereinstimmen.  
  
- oder - 
 <see cref="P:System.ComponentModel.Composition.Primitives.ImportDefinition.Cardinality" /> ist <see cref="F:System.ComponentModel.Composition.Primitives.ImportCardinality.ZeroOrOne" /> oder <see cref="F:System.ComponentModel.Composition.Primitives.ImportCardinality.ExactlyOne" />, und es gibt mehr als ein <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekt, das mit den Bedingungen des angegebenen <see cref="T:System.ComponentModel.Composition.Primitives.ImportDefinition" />-Objekts übereinstimmt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="definition" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="atomicComposition" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExports">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Lazy&lt;object,object&gt;&gt; GetExports (Type type, Type metadataViewType, string contractName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Lazy`2&lt;object, object&gt;&gt; GetExports(class System.Type type, class System.Type metadataViewType, string contractName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Lazy&lt;System::Object ^, System::Object ^&gt; ^&gt; ^ GetExports(Type ^ type, Type ^ metadataViewType, System::String ^ contractName);" />
      <MemberSignature Language="F#" Value="member this.GetExports : Type * Type * string -&gt; seq&lt;Lazy&lt;obj, obj&gt;&gt;" Usage="exportProvider.GetExports (type, metadataViewType, contractName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Lazy&lt;System.Object,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="metadataViewType" Type="System.Type" />
        <Parameter Name="contractName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typparameter der zurückzugebenden <see cref="T:System.Lazy`2" />-Objekte.</param>
        <param name="metadataViewType">Der Typ der Metadatenansicht der zurückzugebenden <see cref="T:System.Lazy`2" />-Objekte.</param>
        <param name="contractName">Der Vertragsname des zurückzugebenden <see cref="T:System.Lazy`2" />-Objekts oder <see langword="null" /> oder eine leere Zeichenfolge (""), um den Standardvertragsnamen zu verwenden.</param>
        <summary>Ruft alle Exporte mit dem angegebenen Vertragsnamen ab.</summary>
        <returns>Eine Auflistung aller <see cref="T:System.Lazy`2" />-Objekte für den mit <paramref name="contractName" /> übereinstimmenden Vertrag.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardname für den Vertrag ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `type`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="metadataViewType" /> ist kein gültiger Metadatenansichtstyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExports&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Lazy&lt;T&gt;&gt; GetExports&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Lazy`1&lt;!!T&gt;&gt; GetExports&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExports``1" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExports(Of T) () As IEnumerable(Of Lazy(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Collections::Generic::IEnumerable&lt;Lazy&lt;T&gt; ^&gt; ^ GetExports();" />
      <MemberSignature Language="F#" Value="member this.GetExports : unit -&gt; seq&lt;Lazy&lt;'T&gt;&gt;" Usage="exportProvider.GetExports " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Lazy&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typparameter der zurückzugebenden <see cref="T:System.Lazy`1" />-Objekte. Der Vertragsname wird auch von diesem Typparameter abgeleitet.</typeparam>
        <summary>Ruft alle Exporte mit dem vom angegebenen Typparameter abgeleiteten Vertragsnamen ab.</summary>
        <returns>Die <see cref="T:System.Lazy`1" />-Objekte mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen, sofern sie gefunden werden, andernfalls ein leeres <see cref="T:System.Collections.Generic.IEnumerable`1" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vertragsname ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExports&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Lazy&lt;T&gt;&gt; GetExports&lt;T&gt; (string contractName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Lazy`1&lt;!!T&gt;&gt; GetExports&lt;T&gt;(string contractName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExports``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExports(Of T) (contractName As String) As IEnumerable(Of Lazy(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Collections::Generic::IEnumerable&lt;Lazy&lt;T&gt; ^&gt; ^ GetExports(System::String ^ contractName);" />
      <MemberSignature Language="F#" Value="member this.GetExports : string -&gt; seq&lt;Lazy&lt;'T&gt;&gt;" Usage="exportProvider.GetExports contractName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Lazy&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typparameter der zurückzugebenden <see cref="T:System.Lazy`1" />-Objekte.</typeparam>
        <param name="contractName">Der Vertragsname der zurückzugebenden <see cref="T:System.Lazy`1" />-Objekte oder <see langword="null" /> oder eine leere Zeichenfolge (""), um den Standardvertragsnamen zu verwenden.</param>
        <summary>Ruft alle Exporte mit dem angegebenen Vertragsnamen ab.</summary>
        <returns>Die <see cref="T:System.Lazy`1" />-Objekte mit dem angegebenen Vertragsnamen, sofern sie gefunden werden, andernfalls ein leeres <see cref="T:System.Collections.Generic.IEnumerable`1" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardname für den Vertrag ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExports&lt;T,TMetadataView&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Lazy&lt;T,TMetadataView&gt;&gt; GetExports&lt;T,TMetadataView&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Lazy`2&lt;!!T, !!TMetadataView&gt;&gt; GetExports&lt;T, TMetadataView&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExports``2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExports(Of T, TMetadataView) () As IEnumerable(Of Lazy(Of T, TMetadataView))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TMetadataView&gt;&#xA; System::Collections::Generic::IEnumerable&lt;Lazy&lt;T, TMetadataView&gt; ^&gt; ^ GetExports();" />
      <MemberSignature Language="F#" Value="member this.GetExports : unit -&gt; seq&lt;Lazy&lt;'T, 'MetadataView&gt;&gt;" Usage="exportProvider.GetExports " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Lazy&lt;T,TMetadataView&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TMetadataView" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der Typparameter der zurückzugebenden <see cref="T:System.Lazy`2" />-Objekte. Der Vertragsname wird auch von diesem Typparameter abgeleitet.</typeparam>
        <typeparam name="TMetadataView">Der Typ der Metadatenansicht der zurückzugebenden <see cref="T:System.Lazy`2" />-Objekte.</typeparam>
        <summary>Ruft alle Exporte mit dem vom angegebenen Typparameter abgeleiteten Vertragsnamen ab.</summary>
        <returns>Die <see cref="T:System.Lazy`2" />-Objekte mit dem von <paramref name="T" /> abgeleiteten Vertragsnamen, sofern sie gefunden werden, andernfalls ein leeres <see cref="T:System.Collections.Generic.IEnumerable`1" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vertragsname ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="TMetadataView" /> ist kein gültiger Metadatenansichtstyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExports&lt;T,TMetadataView&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Lazy&lt;T,TMetadataView&gt;&gt; GetExports&lt;T,TMetadataView&gt; (string contractName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Lazy`2&lt;!!T, !!TMetadataView&gt;&gt; GetExports&lt;T, TMetadataView&gt;(string contractName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExports``2(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExports(Of T, TMetadataView) (contractName As String) As IEnumerable(Of Lazy(Of T, TMetadataView))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TMetadataView&gt;&#xA; System::Collections::Generic::IEnumerable&lt;Lazy&lt;T, TMetadataView&gt; ^&gt; ^ GetExports(System::String ^ contractName);" />
      <MemberSignature Language="F#" Value="member this.GetExports : string -&gt; seq&lt;Lazy&lt;'T, 'MetadataView&gt;&gt;" Usage="exportProvider.GetExports contractName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Lazy&lt;T,TMetadataView&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TMetadataView" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">Der Typparameter der zurückzugebenden <see cref="T:System.Lazy`2" />-Objekte. Der Vertragsname wird auch von diesem Typparameter abgeleitet.</typeparam>
        <typeparam name="TMetadataView">Der Typ der Metadatenansicht der zurückzugebenden <see cref="T:System.Lazy`2" />-Objekte.</typeparam>
        <param name="contractName">Der Vertragsname der zurückzugebenden <see cref="T:System.Lazy`2" />-Objekte oder <see langword="null" /> oder eine leere Zeichenfolge (""), um den Standardvertragsnamen zu verwenden.</param>
        <summary>Ruft alle Exporte mit dem angegebenen Vertragsnamen ab.</summary>
        <returns>Die <see cref="T:System.Lazy`2" />-Objekte mit dem angegebenen Vertragsnamen, sofern sie gefunden werden, andernfalls ein leeres <see cref="T:System.Collections.Generic.IEnumerable`1" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardname für den Vertrag ist das Ergebnis des Aufrufs der <xref:System.ComponentModel.Composition.AttributedModelServices.GetContractName%2A> Methode `T`.  
  
 Der Vertragsname wird verglichen, mit der <xref:System.StringComparer.Ordinal%2A> Eigenschaft, um einen Groß-/Kleinschreibung beachtet, nicht linguistischen Vergleich auszuführen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.ComponentModel.Composition.Hosting.CompositionContainer" />-Objekt wurde freigegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="TMetadataView" /> ist kein gültiger Metadatenansichtstyp.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetExportsCore">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.ComponentModel.Composition.Primitives.Export&gt; GetExportsCore (System.ComponentModel.Composition.Primitives.ImportDefinition definition, System.ComponentModel.Composition.Hosting.AtomicComposition atomicComposition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.ComponentModel.Composition.Primitives.Export&gt; GetExportsCore(class System.ComponentModel.Composition.Primitives.ImportDefinition definition, class System.ComponentModel.Composition.Hosting.AtomicComposition atomicComposition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.GetExportsCore(System.ComponentModel.Composition.Primitives.ImportDefinition,System.ComponentModel.Composition.Hosting.AtomicComposition)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::ComponentModel::Composition::Primitives::Export ^&gt; ^ GetExportsCore(System::ComponentModel::Composition::Primitives::ImportDefinition ^ definition, System::ComponentModel::Composition::Hosting::AtomicComposition ^ atomicComposition);" />
      <MemberSignature Language="F#" Value="abstract member GetExportsCore : System.ComponentModel.Composition.Primitives.ImportDefinition * System.ComponentModel.Composition.Hosting.AtomicComposition -&gt; seq&lt;System.ComponentModel.Composition.Primitives.Export&gt;" Usage="exportProvider.GetExportsCore (definition, atomicComposition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.ComponentModel.Composition.Primitives.Export&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="definition" Type="System.ComponentModel.Composition.Primitives.ImportDefinition" />
        <Parameter Name="atomicComposition" Type="System.ComponentModel.Composition.Hosting.AtomicComposition" />
      </Parameters>
      <Docs>
        <param name="definition">Das Objekt, das die Bedingungen der zurückzugebenden <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekte definiert.</param>
        <param name="atomicComposition">Der Transaktionscontainer für die Komposition.</param>
        <summary>Ruft alle Exporte ab, die mit der durch die angegebene Definition definierten Einschränkung übereinstimmen.</summary>
        <returns>Eine Auflistung, die alle der angegebenen Bedingung entsprechenden Exporte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Außerkraftsetzungen für diese Methode Kardinalität bezogene Konflikte sollten nicht als Fehler behandeln, und in diesen Fällen sollte keine Ausnahmen auslösen. Z. B. wenn <xref:System.ComponentModel.Composition.Primitives.ImportDefinition.Cardinality%2A> ist <xref:System.ComponentModel.Composition.Primitives.ImportCardinality.ExactlyOne> und es gibt keine <xref:System.ComponentModel.Composition.Primitives.Export> Objekte, die die Bedingungen des angegebenen <xref:System.ComponentModel.Composition.Primitives.ImportDefinition>, eine leere <xref:System.Collections.Generic.IEnumerable%601> Auflistung zurückgegeben werden sollen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnExportsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnExportsChanged (System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExportsChanged(class System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.OnExportsChanged(System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExportsChanged (e As ExportsChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExportsChanged(System::ComponentModel::Composition::Hosting::ExportsChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExportsChanged : System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs -&gt; unit&#xA;override this.OnExportsChanged : System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs -&gt; unit" Usage="exportProvider.OnExportsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.Composition.Hosting.ExportProvider.ExportsChanged" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnExportsChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnExportsChanging (System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExportsChanging(class System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.OnExportsChanging(System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExportsChanging (e As ExportsChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExportsChanging(System::ComponentModel::Composition::Hosting::ExportsChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExportsChanging : System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs -&gt; unit&#xA;override this.OnExportsChanging : System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs -&gt; unit" Usage="exportProvider.OnExportsChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.ComponentModel.Composition.Hosting.ExportsChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.Composition.Hosting.ExportProvider.ExportsChanging" />-Ereignis aus.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetExports">
      <MemberSignature Language="C#" Value="public bool TryGetExports (System.ComponentModel.Composition.Primitives.ImportDefinition definition, System.ComponentModel.Composition.Hosting.AtomicComposition atomicComposition, out System.Collections.Generic.IEnumerable&lt;System.ComponentModel.Composition.Primitives.Export&gt; exports);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetExports(class System.ComponentModel.Composition.Primitives.ImportDefinition definition, class System.ComponentModel.Composition.Hosting.AtomicComposition atomicComposition, [out] class System.Collections.Generic.IEnumerable`1&lt;class System.ComponentModel.Composition.Primitives.Export&gt;&amp; exports) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Hosting.ExportProvider.TryGetExports(System.ComponentModel.Composition.Primitives.ImportDefinition,System.ComponentModel.Composition.Hosting.AtomicComposition,System.Collections.Generic.IEnumerable{System.ComponentModel.Composition.Primitives.Export}@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetExports(System::ComponentModel::Composition::Primitives::ImportDefinition ^ definition, System::ComponentModel::Composition::Hosting::AtomicComposition ^ atomicComposition, [Runtime::InteropServices::Out] System::Collections::Generic::IEnumerable&lt;System::ComponentModel::Composition::Primitives::Export ^&gt; ^ % exports);" />
      <MemberSignature Language="F#" Value="member this.TryGetExports : System.ComponentModel.Composition.Primitives.ImportDefinition * System.ComponentModel.Composition.Hosting.AtomicComposition *  -&gt; bool" Usage="exportProvider.TryGetExports (definition, atomicComposition, exports)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="definition" Type="System.ComponentModel.Composition.Primitives.ImportDefinition" />
        <Parameter Name="atomicComposition" Type="System.ComponentModel.Composition.Hosting.AtomicComposition" />
        <Parameter Name="exports" Type="System.Collections.Generic.IEnumerable&lt;System.ComponentModel.Composition.Primitives.Export&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="definition">Das Objekt, das die Bedingungen der abzurufenden <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekte definiert.</param>
        <param name="atomicComposition">Der Transaktionscontainer für die Komposition.</param>
        <param name="exports">Diese Methode gibt eine Auflistung von <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekten zurück, die mit den durch <see cref="T:System.ComponentModel.Composition.Primitives.ImportDefinition" /> definierten Bedingungen übereinstimmen, sofern sie gefunden werden. Andernfalls wird ein leeres <see cref="T:System.Collections.Generic.IEnumerable`1" />-Objekt zurückgegeben. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Ruft alle Exporte ab, die den Bedingungen für den angegebenen Import entsprechen.</summary>
        <returns><see langword="true" />, wenn <see cref="P:System.ComponentModel.Composition.Primitives.ImportDefinition.Cardinality" /> <see cref="F:System.ComponentModel.Composition.Primitives.ImportCardinality.ZeroOrOne" /> oder <see cref="F:System.ComponentModel.Composition.Primitives.ImportCardinality.ZeroOrMore" /> ist und 0 (null) <see cref="T:System.ComponentModel.Composition.Primitives.Export" />-Objekte den Bedingungen der angegebenen <see cref="T:System.ComponentModel.Composition.Primitives.ImportDefinition" /> entsprechen. <see langword="true" />, wenn <see cref="P:System.ComponentModel.Composition.Primitives.ImportDefinition.Cardinality" /> <see cref="F:System.ComponentModel.Composition.Primitives.ImportCardinality.ZeroOrOne" /> oder <see cref="F:System.ComponentModel.Composition.Primitives.ImportCardinality.ExactlyOne" /> ist und genau ein <see cref="T:System.ComponentModel.Composition.Primitives.Export" /> den Bedingungen der angegebenen <see cref="T:System.ComponentModel.Composition.Primitives.ImportDefinition" /> entspricht; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="definition" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>