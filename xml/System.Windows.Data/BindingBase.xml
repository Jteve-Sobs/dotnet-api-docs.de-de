<Type Name="BindingBase" FullName="System.Windows.Data.BindingBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e1507c2e63aefccace93535e7c70e215ed65c0eb" /><Meta Name="ms.sourcegitcommit" Value="b6b9d5f3f9c7eb43f14a8a1a68d044603cb8ed73" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/18/2020" /><Meta Name="ms.locfileid" Value="83522532" /></Metadata><TypeSignature Language="C#" Value="public abstract class BindingBase : System.Windows.Markup.MarkupExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit BindingBase extends System.Windows.Markup.MarkupExtension" FrameworkAlternate="dotnet-plat-ext-5.0;net-5.0;netcore-3.0;netcore-3.1;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class BindingBase&#xA;Inherits MarkupExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingBase abstract : System::Windows::Markup::MarkupExtension" />
  <TypeSignature Language="F#" Value="type BindingBase = class&#xA;    inherit MarkupExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract BindingBase extends System.Windows.Markup.MarkupExtension" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Markup.MarkupExtension</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Modifiability=System.Windows.Modifiability.Unmodifiable, Readability=System.Windows.Readability.Unreadable)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.MarkupExtensionReturnType(typeof(System.Object))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiert die gemeinsamen Merkmale der Klassen <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.PriorityBinding" /> und <see cref="T:System.Windows.Data.MultiBinding" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da die <xref:System.Windows.Data.BindingBase.ProvideValue%2A?displayProperty=nameWithType>-Methode versiegelt ist, funktioniert eine benutzerdefinierte Bindungs Klasse, die von <xref:System.Windows.Data.BindingBase> abgeleitet wird, nicht ordnungsgemäß als [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] Markup Erweiterung.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BindingGroupName">
      <MemberSignature Language="C#" Value="public string BindingGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BindingGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingBase.BindingGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BindingGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroupName : string with get, set" Usage="System.Windows.Data.BindingBase.BindingGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der <see cref="T:System.Windows.Data.BindingGroup" /> ab, zu der diese Bindung gehört, oder legt diesen fest.</summary>
        <value>Der Name der <see cref="T:System.Windows.Data.BindingGroup" />, zu der diese Bindung gehört.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> nicht festgelegt ist, gehört die Bindung nur zu einem <xref:System.Windows.Data.BindingGroup>, wenn die Quelle der Bindung und der <xref:System.Windows.FrameworkElement.DataContext%2A> des übergeordneten Elements, das <xref:System.Windows.Data.BindingGroup> ist, das gleiche Objekt sind.  
  
 Wenn <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> auf einen Wert festgelegt ist, gehört die Bindung zu einer <xref:System.Windows.Data.BindingGroup>, wenn die folgenden Bedingungen zutreffen:  
  
-   Die <xref:System.Windows.Data.BindingGroup.Name%2A> der <xref:System.Windows.Data.BindingGroup> und <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> sind gleich.  
  
-   Der <xref:System.Windows.Data.BindingGroup> gehört zu einem übergeordneten Element des Target-Elements der Bindung.  
  
 Wenn <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> auf `null`festgelegt ist, ist die Bindung nie Teil eines <xref:System.Windows.Data.BindingGroup>.  
  
 Sie können Bindungen einschließen, die eine Quelle aufweisen, die sich vom <xref:System.Windows.FrameworkElement.DataContext%2A> des übergeordneten Elements unterscheidet, das die <xref:System.Windows.Data.BindingGroup> hat, indem Sie <xref:System.Windows.Data.BindingGroup.Name%2A> der <xref:System.Windows.Data.BindingGroup> und die <xref:System.Windows.Data.BindingBase.BindingGroupName%2A>-Eigenschaft einer Bindung auf denselben Wert festlegen.  Sie können Bindungen ausschließen, die dieselbe Quelle wie <xref:System.Windows.FrameworkElement.DataContext%2A> des übergeordneten Elements aufweisen, das über die <xref:System.Windows.Data.BindingGroup> verfügt, indem Sie <xref:System.Windows.Data.BindingGroup.Name%2A> der <xref:System.Windows.Data.BindingGroup> und die <xref:System.Windows.Data.BindingBase.BindingGroupName%2A>-Eigenschaft einer Bindung auf andere Werte festlegen.  
  
   
  
## Examples  
 Die folgenden Beispiele sind Teil einer Anwendung, die überprüft, ob der Benutzer die Eigenschaften von zwei-Objekten auf die gleichen Werte festgelegt hat. Im ersten Beispiel werden zwei <xref:System.Windows.Controls.TextBox>-Steuerelemente erstellt, von denen jede Daten an eine andere Quelle gebunden ist: die Bindung des ersten <xref:System.Windows.Controls.TextBox> ist Teil des <xref:System.Windows.Data.BindingGroup>, weil der <xref:System.Windows.Controls.TextBox> den <xref:System.Windows.FrameworkElement.DataContext%2A> erbt und von seinem übergeordneten <xref:System.Windows.Data.BindingGroup> <xref:System.Windows.Controls.StackPanel>  
  
 Die Bindung auf dem zweiten <xref:System.Windows.Controls.TextBox> ist Teil des <xref:System.Windows.Data.BindingGroup>, da die <xref:System.Windows.Data.BindingGroup.Name%2A> der <xref:System.Windows.Data.BindingGroup> und <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> der <xref:System.Windows.Data.Binding> beide auf `bindingGroup`festgelegt sind.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 Das folgende Beispiel zeigt die <xref:System.Windows.Controls.ValidationRule>, die im vorherigen Beispiel verwendet werden.  In der <xref:System.Windows.Controls.ValidationRule.Validate%2A>-Methode ruft das Beispiel jedes Quell Objekt vom <xref:System.Windows.Data.BindingGroup> ab und überprüft, ob die Eigenschaften der Objekte gleich sind.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public int Delay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Delay" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingBase.Delay" />
      <MemberSignature Language="VB.NET" Value="Public Property Delay As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Delay { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Delay : int with get, set" Usage="System.Windows.Data.BindingBase.Delay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;netcore-3.1;net-5.0;dotnet-plat-ext-5.0">
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Zeitdauer in Millisekunden ab, die gewartet wird, ehe die Bindungsquelle aktualisiert wird, nachdem sich der Wert im Ziel geändert hat, oder legt diese fest.</summary>
        <value>Die Zeitdauer in Millisekunden, die gewartet werden soll, bevor die Bindungsquelle aktualisiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Bindung verwenden, um die Bindungs Quelle zu aktualisieren, wenn sich der Wert der-Eigenschaft auf dem Ziel ändert, legen Sie die <xref:System.Windows.Data.Binding.Mode%2A>-Eigenschaft auf <xref:System.Windows.Data.BindingMode.TwoWay> und die <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> auf <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>fest.  In diesem Fall können Sie die <xref:System.Windows.Data.BindingBase.Delay%2A>-Eigenschaft verwenden, um anzugeben, ob eine Zeitverzögerung zwischen dem Ändern des Ziels und dem Aktualisieren der Quelle auftreten soll.  Dies ist hilfreich, wenn Sie es Benutzern ermöglichen möchten, eine Eigenschaft für ein Quell Objekt zu ändern, aber Sie möchten nicht, dass jede Änderung sofort an die Quelle übertragen wird.  Angenommen, Sie verfügen über ein Textfeld, das Daten bidirektional an eine Eigenschaft eines Datenobjekts gebunden ist.  Wenn der Benutzer den Wert im Textfeld ändert, wird die Quelle aktualisiert.  Um dieses Szenario zu aktivieren, legen Sie die <xref:System.Windows.Data.Binding.Mode%2A>-Eigenschaft des <xref:System.Windows.Data.Binding> auf <xref:System.Windows.Data.BindingMode.TwoWay> und die <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> auf <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>fest.  Legen Sie die <xref:System.Windows.Data.BindingBase.Delay%2A>-Eigenschaft auf einen angemessenen Wert fest, um zu verhindern, dass die Bindung nur dann aktualisiert wird, nachdem diese Zeitspanne verstrichen ist, nachdem der Benutzer die Eingabe beendet hat.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FallbackValue">
      <MemberSignature Language="C#" Value="public object FallbackValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object FallbackValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingBase.FallbackValue" />
      <MemberSignature Language="VB.NET" Value="Public Property FallbackValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ FallbackValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FallbackValue : obj with get, set" Usage="System.Windows.Data.BindingBase.FallbackValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der verwendet werden soll, wenn die Bindung keinen Wert zurückgeben kann, oder legt diesen fest.</summary>
        <value>Standardwert: <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Bindung gibt erfolgreich einen Wert zurück, wenn:  
  
1.  Der Pfad zur Bindungs Quelle wird erfolgreich aufgelöst.  
  
2.  Der Wert Konverter kann ggf. den resultierenden Wert konvertieren.  
  
3.  Der resultierende Wert ist für die Bindungs Ziel-Eigenschaft (Ziel) gültig.  
  
 Wenn 1 und 2 <xref:System.Windows.DependencyProperty.UnsetValue?displayProperty=nameWithType>zurückgegeben werden, wird die Ziel Eigenschaft auf den Wert der <xref:System.Windows.Data.BindingBase.FallbackValue%2A>festgelegt, sofern eine verfügbar ist. Wenn keine <xref:System.Windows.Data.BindingBase.FallbackValue%2A>vorhanden ist, wird der Standardwert der Ziel Eigenschaft verwendet.  
  
 Der Wert <xref:System.Windows.DependencyProperty.UnsetValue?displayProperty=nameWithType> wird nicht als erfolgreicher Rückgabewert angesehen.  
  
<a name="xamlTextUsage_FallbackValue"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
  
```  
<object FallbackValue="fallbackValue" />  
```  
  
 **noch**  
  
```  
<object>  
  <object.FallbackValue>  
    fallbackValue  
    </object.FallbackValue>  
</object>  
```  
  
<a name="xamlValues_FallbackValue"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *FallbackValue*  
 Ein Attribut-oder Objekt Elementwert desselben Typs wie die Ziel Eigenschaft. Informationen zur XAML-Verwendung finden Sie in der Dokumentation des betreffenden Typs. Dieser Typ unterstützt möglicherweise die Attribut Syntax für seine Werte oder unterstützt die Objekt Element Syntax (für die ein Parameter loser Konstruktor für diesen Typ erforderlich ist). Der Ziel Eigenschaftentyp beeinflusst daher die Syntax, die Sie für den Wert der <xref:System.Windows.Data.BindingBase.FallbackValue%2A>-Eigenschaft verwenden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.IValueConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ProvideValue">
      <MemberSignature Language="C#" Value="public override sealed object ProvideValue (IServiceProvider serviceProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object ProvideValue(class System.IServiceProvider serviceProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingBase.ProvideValue(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function ProvideValue (serviceProvider As IServiceProvider) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ ProvideValue(IServiceProvider ^ serviceProvider);" />
      <MemberSignature Language="F#" Value="override this.ProvideValue : IServiceProvider -&gt; obj" Usage="bindingBase.ProvideValue serviceProvider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="serviceProvider">Das Objekt, das Dienste für die Markuperweiterung bereitstellen kann. Kann <see langword="null" /> sein.</param>
        <summary>Gibt ein Objekt zurück, das auf die Eigenschaft festgelegt werden soll, auf die diese Bindung und Erweiterung angewendet werden.</summary>
        <returns>Der Wert, auf den die Bindungszieleigenschaft festgelegt werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung bietet die Unterstützung der Basis Syntax für die Bindung über [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] für alle bereitgestellten praktischen abgeleiteten Klassen (<xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>und <xref:System.Windows.Data.MultiBinding>).  
  
 Die <xref:System.Windows.Data.BindingBase> Klassen Implementierung dieser Methode erwartet, dass ein Expression-Objekt zurückgegeben wird, das das Ergebnis einer Bindung ist. Das Binden einer Eigenschaft funktioniert, indem eine angegebene <xref:System.Windows.DependencyProperty> auf eine angegebene <xref:System.Windows.DependencyObject>ausgerichtet wird. Diese beiden Informationen werden durch Abfragen einer <xref:System.Windows.Markup.IProvideValueTarget>-Implementierung auf dem `serviceProvider`übertragen, die der [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Reader während der Verarbeitung einer Bindung verfügbar macht. Diese Basisklassen Implementierung ist für die Prüfung auf gültige <xref:System.Windows.DependencyProperty> und <xref:System.Windows.DependencyObject>verantwortlich. Wenn diese gefunden werden, fällt die tatsächliche Implementierung der Rückgabe eines Bindungs Ausdrucks in verschiedene abgeleitete Klassen, die implementiert werden, indem die Basisklasse eine interne abstrakte Methode aufruft. Andernfalls gibt die Erweiterung das Bindungs Objekt selbst zurück. Das Zurückgeben der Bindung selbst führt zu einem Typen Konflikt Fehler, aber dies sollte unter normalen Umständen nicht eintreten.  
  
> [!IMPORTANT]
>  Da die Syntax für die Bindung durch [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], wie in dieser Methode implementiert, eine interne Überschreibung implementiert und da <xref:System.Windows.Data.BindingBase.ProvideValue%2A?displayProperty=nameWithType> selbst versiegelt ist, wird eine benutzerdefinierte Bindungs Klasse, die von <xref:System.Windows.Data.BindingBase> abgeleitet ist, nicht ordnungsgemäß als [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Markup Erweiterung funktionieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeFallbackValue">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeFallbackValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeFallbackValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingBase.ShouldSerializeFallbackValue" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeFallbackValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeFallbackValue();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeFallbackValue : unit -&gt; bool" Usage="bindingBase.ShouldSerializeFallbackValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, mit dem angegeben wird, ob Serialisierungsprozesse den tatsächlichen Wert der <see cref="P:System.Windows.Data.BindingBase.FallbackValue" />-Eigenschaft für Instanzen dieser Klasse serialisieren sollen.</summary>
        <returns><see langword="true" />, wenn der <see cref="P:System.Windows.Data.BindingBase.FallbackValue" />-Eigenschaftswert serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTargetNullValue">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTargetNullValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTargetNullValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingBase.ShouldSerializeTargetNullValue" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTargetNullValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTargetNullValue();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTargetNullValue : unit -&gt; bool" Usage="bindingBase.ShouldSerializeTargetNullValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob die <see cref="P:System.Windows.Data.BindingBase.TargetNullValue" />-Eigenschaft serialisiert werden soll.</summary>
        <returns><see langword="true" />, wenn die <see cref="P:System.Windows.Data.BindingBase.TargetNullValue" />-Eigenschaft serialisiert werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringFormat">
      <MemberSignature Language="C#" Value="public string StringFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StringFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingBase.StringFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property StringFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StringFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StringFormat : string with get, set" Usage="System.Windows.Data.BindingBase.StringFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolge ab, die angibt, wie die Bindung formatiert werden soll, wenn diese den gebundenen Wert als Zeichenfolge anzeigt, oder legt diese fest.</summary>
        <value>Eine Zeichenfolge, die angibt, wie die Bindung formatiert werden soll, wenn diese den gebundenen Wert als Zeichenfolge anzeigt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingBase.StringFormat%2A> kann ein vordefiniertes, zusammengesetztes oder benutzerdefiniertes Zeichen folgen Format sein. Weitere Informationen zu Zeichen folgen Formaten finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Wenn Sie die Eigenschaften <xref:System.Windows.Data.Binding.Converter%2A> und <xref:System.Windows.Data.BindingBase.StringFormat%2A> festlegen, wird der Konverter zuerst auf den Datenwert angewendet, und dann wird der <xref:System.Windows.Data.BindingBase.StringFormat%2A> angewendet.  
  
 Wenn Sie die <xref:System.Windows.Data.BindingBase.StringFormat%2A> eines <xref:System.Windows.Data.Binding> auf ein zusammengesetztes Zeichen folgen Format festlegen, können Sie nur einen Parameter angeben.  
  
 Wenn Sie ein <xref:System.Windows.Data.MultiBinding>verwenden, gilt die <xref:System.Windows.Data.BindingBase.StringFormat%2A>-Eigenschaft nur, wenn Sie für die <xref:System.Windows.Data.MultiBinding>festgelegt wird.  Der Wert <xref:System.Windows.Data.BindingBase.StringFormat%2A>, der für alle untergeordneten <xref:System.Windows.Data.Binding> Objekte festgelegt wird, wird ignoriert.  Die Anzahl von Parametern in einem zusammengesetzten Zeichen folgen Format darf die Anzahl der untergeordneten <xref:System.Windows.Data.Binding> Objekte in der <xref:System.Windows.Data.MultiBinding>nicht überschreiten.  
  
 Wenn Sie ein <xref:System.Windows.Data.PriorityBinding>verwenden, können Sie die <xref:System.Windows.Data.BindingBase.StringFormat%2A> auf dem <xref:System.Windows.Data.PriorityBinding>, auf untergeordneten Bindungs Objekten oder beides festlegen.  Wenn die <xref:System.Windows.Data.BindingBase.StringFormat%2A> für die angewendete untergeordnete Bindung festgelegt wird, wird dieser Wert verwendet.  Wenn die <xref:System.Windows.Data.BindingBase.StringFormat%2A> für die angewendete untergeordnete Bindung nicht festgelegt ist, wird die <xref:System.Windows.Data.BindingBase.StringFormat%2A> der <xref:System.Windows.Data.PriorityBinding> angewendet, wenn Sie festgelegt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Windows.Data.BindingBase.StringFormat%2A>-Eigenschaft verwendet, um `Price`, d. h. eine <xref:System.Double>, in eine Zeichenfolge zu konvertieren, die eine Währung darstellt.  
  
 [!code-xaml[ContentStringSnippets#Binding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentStringSnippets/CSharp/Window1.xaml#binding)]  
  
 Im folgenden Beispiel wird die <xref:System.Windows.Data.BindingBase.StringFormat%2A>-Eigenschaft auf einem <xref:System.Windows.Data.MultiBinding> verwendet, um eine Zeichenfolge zu erstellen, die die `Description` und `Price` der einzelnen Elemente in einer <xref:System.Windows.Controls.ListBox>enthält.  
  
 [!code-xaml[ContentStringSnippets#MultiBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentStringSnippets/CSharp/Window1.xaml#multibinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNullValue">
      <MemberSignature Language="C#" Value="public object TargetNullValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object TargetNullValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingBase.TargetNullValue" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetNullValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ TargetNullValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetNullValue : obj with get, set" Usage="System.Windows.Data.BindingBase.TargetNullValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, der im Ziel verwendet wird, wenn der Wert der Quelle <see langword="null" /> ist, oder legt diesen fest.</summary>
        <value>Der Wert, der im Ziel verwendet wird, wenn der Wert der Quelle <see langword="null" /> ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlTextUsage_TargetNullValue"></a>   
## <a name="xaml-text-usage"></a>Verwendung von XAML-Text  
  
```  
<object TargetNullValue="nullValue" />  
```  
  
 **noch**  
  
```  
<object>  
  <object.TargetNullValue>  
    nullValue  
    </object.TargetNullValue>  
</object>  
```  
  
<a name="xamlValues_TargetNullValue"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *NullValue*  
 Ein Attribut-oder Objekt Elementwert desselben Typs wie die Ziel Eigenschaft. Informationen zur XAML-Verwendung finden Sie in der Dokumentation des betreffenden Typs. Dieser Typ unterstützt möglicherweise die Attribut Syntax für seine Werte oder unterstützt die Objekt Element Syntax (für die ein Parameter loser Konstruktor für diesen Typ erforderlich ist).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Windows.Controls.TextBox> an eine Eigenschaft eines-Objekts gebunden.  Wenn die Eigenschaft `null`ist, wird im <xref:System.Windows.Controls.TextBox> "Bitte geben Sie eine Zeichenfolge ein" angezeigt.  
  
 [!code-xaml[BindingGroupSnippets#TargetNullValue](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#targetnullvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
