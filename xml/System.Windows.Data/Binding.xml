<Type Name="Binding" FullName="System.Windows.Data.Binding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="801b9b6758c7503f88433233450bd01c6f7f068d" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56372836" /></Metadata><TypeSignature Language="C#" Value="public class Binding : System.Windows.Data.BindingBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Binding extends System.Windows.Data.BindingBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.Binding" />
  <TypeSignature Language="VB.NET" Value="Public Class Binding&#xA;Inherits BindingBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class Binding : System::Windows::Data::BindingBase" />
  <TypeSignature Language="F#" Value="type Binding = class&#xA;    inherit BindingBase" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Data.BindingBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Bietet Zugriff auf hoher Ebene auf die Definition einer Bindung, die die Eigenschaften von Bindungszielobjekten (üblicherweise WPF-Elemente) und eine Datenquelle (etwa eine Datenbank, eine XML-Datei oder ein beliebiges Objekt mit Daten) verbindet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Datenbindung bietet für Anwendungen eine einfache und konsistente Möglichkeit, Daten darzustellen und mit ihnen zu interagieren. Die Datenbindung können Sie die Werte der Eigenschaften von zwei verschiedenen Objekten zu synchronisieren.  
  
 Um eine Bindung herzustellen, verwenden die <xref:System.Windows.Data.Binding> Klasse oder eine der anderen Klassen, die erben <xref:System.Windows.Data.BindingBase>. Unabhängig davon, welches Objekt Sie binden, und der Art der Datenquelle, die jede Bindung folgt dem Modells, die in der folgenden Abbildung dargestellt.  
  
 ![Grundlegendes Datenbindungsdiagramm](~/add/media/databindingmostbasic.png "Grundlegendes Datenbindungsdiagramm")  
  
 Die Abbildung veranschaulicht die folgenden grundlegenden [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Konzepte zur Datenbindung.  
  
-   Jede Bindung in der Regel hat vier Komponenten: einem Bindungszielobjekt, einer Zieleigenschaft, Bindungsquelle, und ein <xref:System.Windows.Data.Binding.Path%2A> auf den Wert in der Bindungsquelle verwenden. Z. B., wenn Sie den Inhalt einer binden möchten eine <xref:System.Windows.Controls.TextBox> der Name-Eigenschaft eines Objekts für die Mitarbeiter Ihre Zielobjekt ist die <xref:System.Windows.Controls.TextBox>, die Zieleigenschaft der <xref:System.Windows.Controls.TextBox.Text%2A> Eigenschaft, die zu verwendende Wert Namen, und das Quellobjekt ist der Mitarbeiter -Objekt.  
  
-   Die Zieleigenschaft muss eine Abhängigkeitseigenschaft sein. Dies bedeutet auch, dass Sie ein Feld nicht gebunden werden können. Die meisten Eigenschaften von <xref:System.Windows.UIElement> Objekte sind Abhängigkeitseigenschaften, und die meisten Abhängigkeitseigenschaften, außer schreibgeschützten, unterstützen die Datenbindung standardmäßig. (Nur <xref:System.Windows.DependencyObject> -Typen können Abhängigkeitseigenschaften und alle definieren <xref:System.Windows.UIElement> Objekte ableiten <xref:System.Windows.DependencyObject>.)  
  
-   Obwohl nicht in der Abbildung angegeben, sollte beachtet werden, dass das Bindungsquellenobjekt nicht darauf beschränkt ist, als benutzerdefiniertes [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]-Objekt zu fungieren. Die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]-Datenbindung unterstützt Daten in Form von [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]-Objekten und [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]. Um Beispiele zu ermöglichen, die Bindungsquelle möglicherweise eine <xref:System.Windows.UIElement>, beliebiges Listenobjekt, ein [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] -Objekt, das zugeordnet ist [!INCLUDE[TLA#tla_adonet](~/includes/tlasharptla-adonet-md.md)] Daten oder Webdienste oder eine XmlNode-Klasse, die enthält Ihre [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] Daten.  
  
 Verwenden der <xref:System.Windows.Data.Binding.Mode%2A> Eigenschaft, um die Richtung des Datenflusses anzugeben. Zum Erkennen von quelländerungen uni- oder bidirektionale Bindungen, die Quelle muss einen geeignete Eigenschaft Änderungsbenachrichtigungsmechanismus implementieren z. B. <xref:System.ComponentModel.INotifyPropertyChanged>. Ein Beispiel finden Sie unter [Gewusst wie: Implementieren Sie die Benachrichtigung der Eigenschaftenänderung](~/docs/framework/wpf/data/how-to-implement-property-change-notification.md). Die <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> Eigenschaft gibt an, die zeitsteuerung von quellenaktualisierungen. Weitere Informationen finden Sie unter "Data Binding Grundkonzepte" in [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
<a name="xamlAttributeUsage_PriorityBinding"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object property="{Binding  declaration}"/>  
```  
  
<a name="xamlValues_PriorityBinding"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *declaration*  
 NULL oder mehr attributzuweisung Klauseln durch Kommas (,) getrennt. Weitere Informationen finden Sie unter [Binding als Markuperweiterung](~/docs/framework/wpf/advanced/binding-markup-extension.md) oder [Deklarationen Übersicht über Datenbindung](~/docs/framework/wpf/data/binding-declarations-overview.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Data.MultiBinding" />
    <altmember cref="T:System.Windows.Data.PriorityBinding" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Data.Binding" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Binding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Binding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Data.Binding" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Binding (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Binding(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Windows.Data.Binding : string -&gt; System.Windows.Data.Binding" Usage="new System.Windows.Data.Binding path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der anfängliche <see cref="P:System.Windows.Data.Binding.Path" /> für die Bindung.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Data.Binding" />-Klasse mit einem Anfangspfad.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSourceUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void AddSourceUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddSourceUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.AddSourceUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddSourceUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddSourceUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddSourceUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.AddSourceUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das das Ereignis überwacht.</param>
        <param name="handler">Der hinzuzufügende Handler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Data.Binding.SourceUpdated" />-Ereignis hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt die Verwendung angefügter Ereignisse in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddTargetUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void AddTargetUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddTargetUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.AddTargetUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddTargetUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddTargetUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddTargetUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.AddTargetUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das das Ereignis überwacht.</param>
        <param name="handler">Der hinzuzufügende Handler.</param>
        <summary>Fügt einen Handler für das angefügte <see cref="E:System.Windows.Data.Binding.TargetUpdated" />-Ereignis hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt die Verwendung angefügter Ereignisse in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj with get, set" Usage="System.Windows.Data.Binding.AsyncState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft opake Daten ab, die an den asynchronen Datenverteiler übergeben werden, oder legt diese fest.</summary>
        <value>Daten, die an den asynchronen Datenverteiler übergeben werden.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Data.Binding.IsAsync" />
        <altmember cref="P:System.Windows.Data.ObjectDataProvider.IsAsynchronous" />
        <altmember cref="P:System.Windows.Data.XmlDataProvider.IsAsynchronous" />
      </Docs>
    </Member>
    <Member MemberName="BindsDirectlyToSource">
      <MemberSignature Language="C#" Value="public bool BindsDirectlyToSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsDirectlyToSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.BindsDirectlyToSource" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsDirectlyToSource As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsDirectlyToSource { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsDirectlyToSource : bool with get, set" Usage="System.Windows.Data.Binding.BindsDirectlyToSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt diesen fest, der anzeigt, ob der <see cref="P:System.Windows.Data.Binding.Path" /> relativ zum Datenelement oder zum <see cref="T:System.Windows.Data.DataSourceProvider" />-Objekt ausgewertet werden soll.</summary>
        <value><see langword="false" />, um den Pfad relativ zum Datenelement selbst auszuwerten, andernfalls <see langword="true" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das normale Verhalten (Wenn diese Eigenschaft ist `false`) beinhaltet eine besondere Behandlung für <xref:System.Windows.Data.DataSourceProvider> Objekte. In diesem Fall die Bindungs-Engine wertet die <xref:System.Windows.Data.Binding.Path%2A> Bezug auf das Objekt abgerufen, die von der <xref:System.Windows.Data.DataSourceProvider.Data%2A> Eigenschaft. Darüber hinaus überwacht die Bindung der <xref:System.Windows.Data.DataSourceProvider.DataChanged> Ereignis und reagiert entsprechend. Wenn diese Eigenschaft auf `true` wird dieses Verhalten überschrieben, und erhalten Sie die Bindung wird der Zugriff auf Eigenschaften der <xref:System.Windows.Data.DataSourceProvider> Objekt selbst.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.ObjectDataProvider" />
        <altmember cref="T:System.Windows.Data.XmlDataProvider" />
      </Docs>
    </Member>
    <Member MemberName="Converter">
      <MemberSignature Language="C#" Value="public System.Windows.Data.IValueConverter Converter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.IValueConverter Converter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Converter" />
      <MemberSignature Language="VB.NET" Value="Public Property Converter As IValueConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::IValueConverter ^ Converter { System::Windows::Data::IValueConverter ^ get(); void set(System::Windows::Data::IValueConverter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Converter : System.Windows.Data.IValueConverter with get, set" Usage="System.Windows.Data.Binding.Converter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.IValueConverter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zu verwendenden Konverter ab oder legt diesen fest.</summary>
        <value>Ein Wert vom Typ <see cref="T:System.Windows.Data.IValueConverter" />. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Bindung verwendet implizit einen Standardkonverter, der versucht, eine typkonvertierung zwischen der Quelle und der Zielwert ist. Wenn keine Konvertierung durchgeführt werden kann, gibt der Standardkonverter `null` zurück.  
  
 Wenn Sie einen benutzerdefinierten Wertkonverter eine Bindung zuordnen möchten, erstellen Sie eine Klasse, implementiert die <xref:System.Windows.Data.IValueConverter> Schnittstelle, und geben Sie Implementierungen für die <xref:System.Windows.Data.IValueConverter.Convert%2A> und <xref:System.Windows.Data.IValueConverter.ConvertBack%2A> Methoden. Wertkonverter können zum Ändern von Daten von einem Typ in einen anderen, zwischen kulturellen Informationen wie z. B. Zeichensätzen übersetzen oder ändern andere Aspekte der ihre Präsentation. Beispiele für typische konvertierungsszenarien, finden Sie unter "Datenkonvertierung" in der [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
<a name="xamlAttributeUsage_Converter"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Converter="myConverter"/>  
```  
  
<a name="xamlValues_Converter"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *myConverter*  
 Einen Ressourcenverweis auf eine Klasse, die implementiert die <xref:System.Windows.Data.IValueConverter> -Schnittstelle, die Implementierungen von beinhaltet die <xref:System.Windows.Data.IValueConverter.Convert%2A> und <xref:System.Windows.Data.IValueConverter.ConvertBack%2A> Methoden. Verwenden Sie zum Verweisen auf einen Wertkonverter den [StaticResource-Markuperweiterung](~/docs/framework/wpf/advanced/staticresource-markup-extension.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConverterCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo ConverterCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo ConverterCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ConverterCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property ConverterCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ ConverterCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConverterCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Data.Binding.ConverterCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.CultureInfoIetfLanguageTagConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dient zum Abrufen oder Festlegen der Kultur, in der der Konverter ausgewertet werden soll.</summary>
        <value>Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft nicht festlegen, verwendet die Bindungs-Engine die `Language` -Eigenschaft des Bindungsziel-Objekts. In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Standardwert "En-US", oder den Wert aus dem Stammelement (oder ein Element) der Seite erbt, wenn eine explizit festgelegt wurde.  
  
 Informationen zur Datenkonvertierung finden Sie im Abschnitt "Datenkonvertierung" in der [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConverterParameter">
      <MemberSignature Language="C#" Value="public object ConverterParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ConverterParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ConverterParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property ConverterParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ConverterParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConverterParameter : obj with get, set" Usage="System.Windows.Data.Binding.ConverterParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Parameter ab, der an den <see cref="P:System.Windows.Data.Binding.Converter" /> übergeben wird, oder legt diesen fest.</summary>
        <value>Der Parameter, der an den <see cref="P:System.Windows.Data.Binding.Converter" /> übergeben wird. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Windows.Data.Binding.ConverterParameter%2A> Eigenschaft, um anzugeben, wie ein Objekt konvertiert wird.  Diese Eigenschaft übergibt die zusätzliche Informationen an einen Konverter, den Sie für eine Bindung zu verwenden.  Beim Angeben einer <xref:System.Windows.Data.Binding.ConverterParameter%2A>, der Wert wird übergeben, um die <xref:System.Windows.Data.IValueConverter.Convert%2A> und <xref:System.Windows.Data.IValueConverter.ConvertBack%2A> Methoden wie die `parameter` Parameter.  
  
 Ein Beispiel finden Sie unter [Gewusst wie: Erzeugen eines Werts auf Grundlage einer Liste gebundener Elemente](~/docs/framework/wpf/data/how-to-produce-a-value-based-on-a-list-of-bound-items.md). Dieses Beispiel zeigt eine Implementierung einer <xref:System.Windows.Data.IMultiValueConverter> die Nutzung, gelten aber weiterhin.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoNothing">
      <MemberSignature Language="C#" Value="public static readonly object DoNothing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object DoNothing" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.DoNothing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DoNothing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ DoNothing;" />
      <MemberSignature Language="F#" Value=" staticval mutable DoNothing : obj" Usage="System.Windows.Data.Binding.DoNothing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird als ein zurückgegebener Wert verwendet, der die Bindungs-Engine anweist, keine Aktion auszuführen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Datenquelle zu bindende Eigenschaft oder einen Konverter kann zurückgeben <xref:System.Windows.Data.Binding.DoNothing?displayProperty=nameWithType> um anzuweisen, die Bindungs-Engine nicht zum Ausführen aller Aktionen. Um beispielsweise anweisen, die Bindungs-Engine nicht auf einen Wert an das Bindungsziel, nicht zum Verschieben in den nächsten übertragen <xref:System.Windows.Data.Binding> in einer <xref:System.Windows.Data.PriorityBinding>, oder nicht verwendet die `FallBackValue` oder Standardwert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementName">
      <MemberSignature Language="C#" Value="public string ElementName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ElementName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ElementName" />
      <MemberSignature Language="VB.NET" Value="Public Property ElementName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ElementName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ElementName : string with get, set" Usage="System.Windows.Data.Binding.ElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Elements ab, das als Bindungsquellenobjekt verwendet werden soll, oder legt diesen fest.</summary>
        <value>Der Wert des der <see langword="Name" /> Eigenschaft oder [X: Name Directive](~/docs/framework/xaml-services/x-name-directive.md) des relevanten Elements. Sie können in Code nur auf Elemente verweisen, wenn diese über <see langword="RegisterName" /> im entsprechenden <see cref="T:System.Windows.NameScope" /> registriert sind. Weitere Informationen finden Sie unter [WPF-XAML-Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist nützlich, wenn Sie an die Eigenschaft eines anderen Elements in der Anwendung binden möchten. Angenommen, Sie verwenden möchten eine <xref:System.Windows.Controls.Slider> steuern die Höhe eines anderen Steuerelements in der Anwendung oder wenn die Bindung erfolgen soll die <xref:System.Windows.Controls.ContentControl.Content%2A> des Steuerelements die <xref:System.Windows.Controls.Primitives.Selector.SelectedValue%2A> Eigenschaft Ihre <xref:System.Windows.Controls.ListBox> Steuerelement.  
  
 Standardmäßig erben die Bindungen den Datenkontext, der gemäß der `DataContext` -Eigenschaft, wenn eine festgelegt wurde. Allerdings die <xref:System.Windows.Data.Binding.ElementName%2A> Eigenschaft ist eine der Möglichkeiten, Sie explizit, die Quelle des festlegen können, eine <xref:System.Windows.Data.Binding> und den geerbten Datenkontext zu überschreiben. Weitere Informationen finden Sie unter [Vorgehensweise: Angeben der Bindungsquelle](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 Die <xref:System.Windows.Data.Binding.Source%2A> und <xref:System.Windows.Data.Binding.RelativeSource%2A> Eigenschaften der <xref:System.Windows.Data.Binding> Klasse ermöglichen es Ihnen auch die Quelle der Bindung festgelegt explizit. Allerdings nur eine der drei Eigenschaften <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, und <xref:System.Windows.Data.Binding.RelativeSource%2A>sollten werden für jede Bindung festgelegt oder kann ein Konflikt auftreten. Diese Eigenschaft löst eine Ausnahme aus, wenn ein Bindung Quellkonflikt vorliegt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlNamespaceManager">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlNamespaceManager GetXmlNamespaceManager (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlNamespaceManager GetXmlNamespaceManager(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.GetXmlNamespaceManager(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetXmlNamespaceManager (target As DependencyObject) As XmlNamespaceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlNamespaceManager ^ GetXmlNamespaceManager(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member GetXmlNamespaceManager : System.Windows.DependencyObject -&gt; System.Xml.XmlNamespaceManager" Usage="System.Windows.Data.Binding.GetXmlNamespaceManager target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNamespaceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, von dem Namespaceinformationen abgerufen werden sollen.</param>
        <summary>Gibt ein [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)]-Namespace-Manager-Objekt zurück, das von der an das angegebene Objekt angefügten Bindung verwendet wird.</summary>
        <returns>Ein zurückgegebenes Objekt, das zum Anzeigen von [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]-Namespaces verwendet wird, die sich auf die Bindung des übergebenen Objektelements beziehen. Dieses Objekt muss in <see cref="T:System.Xml.XmlNamespaceManager" /> umgewandelt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt die Verwendung der angefügten Eigenschaft für die <xref:System.Windows.Data.Binding.XmlNamespaceManager%2A> angefügte Eigenschaft.  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] Namespace-Manager sind nur relevant, wenn die Daten in der Bindung stammen ein [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] Bindungsquelle (<xref:System.Windows.Data.XmlDataProvider> Objekt).  
  
 Wenn ein Namespace-Manager oder Erstellen der ursprünglichen Datenquelle als auch durch anschließendes Aufrufen von nicht speziell angewendet wurde <xref:System.Windows.Data.Binding.SetXmlNamespaceManager%2A> für die Bindung, klicken Sie dann diese Methode gibt `null`.  
  
 Diese Methode gibt stets `null` ist die Daten hinter der Bindung nicht [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="target" />-Parameter darf nicht <see langword="null" /> sein.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexerName">
      <MemberSignature Language="C#" Value="public const string IndexerName;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string IndexerName" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.IndexerName" />
      <MemberSignature Language="VB.NET" Value="Public Const IndexerName As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ IndexerName;" />
      <MemberSignature Language="F#" Value="val mutable IndexerName : string" Usage="System.Windows.Data.Binding.IndexerName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wird als <see cref="P:System.ComponentModel.PropertyChangedEventArgs.PropertyName" /> von <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> verwendet, um anzugeben, dass sich eine Indexereigenschaft geändert hat.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool with get, set" Usage="System.Windows.Data.Binding.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Data.Binding" /> Werte asynchron abrufen und setzen soll.</summary>
        <value>Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Data.Binding.IsAsync%2A> Eigenschaft bei der `get` Accessor der Bindungsquelleigenschaft möglicherweise sehr lange dauern. Ein Beispiel ist eine Image-Eigenschaft mit einem `get` Accessor, der aus dem Web herunterlädt. Festlegen von <xref:System.Windows.Data.Binding.IsAsync%2A> zu `true` verhindert werden, die [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] während der Download erfolgt.  
  
 Beim Warten auf des Werts auf das eintreffen, meldet die Bindung der <xref:System.Windows.Data.BindingBase.FallbackValue%2A>, wenn eine verfügbar ist oder der Standardwert der Bindung der Zieleigenschaft.  
  
 Allerdings gibt es sollte nicht viele Szenarios müssen Sie mit der <xref:System.Windows.Data.Binding.IsAsync%2A> Eigenschaft. Die [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] Richtlinien wird die Definition von Eigenschaften, erheblich langsamer sind, als wäre eine Feldgruppe, empfohlen. Wenn Sie die Klasse erstellen, sollten in Betracht ziehen extrem langsam Vorgänge außerhalb der der `get` -Accessor und Zwischenspeichern des Resultsets.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.AsyncState" />
        <altmember cref="P:System.Windows.Data.ObjectDataProvider.IsAsynchronous" />
        <altmember cref="P:System.Windows.Data.XmlDataProvider.IsAsynchronous" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="Mode">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingMode Mode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.BindingMode Mode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Mode" />
      <MemberSignature Language="VB.NET" Value="Public Property Mode As BindingMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingMode Mode { System::Windows::Data::BindingMode get(); void set(System::Windows::Data::BindingMode value); };" />
      <MemberSignature Language="F#" Value="member this.Mode : System.Windows.Data.BindingMode with get, set" Usage="System.Windows.Data.Binding.Mode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Richtung des Datenflusses in der Bindung angibt, oder legt diesen Wert fest.</summary>
        <value>Einer der <see cref="T:System.Windows.Data.BindingMode" />-Werte. Die Standardeinstellung ist <see cref="F:System.Windows.Data.BindingMode.Default" />. Diese bewirkt, dass der Bindungsmodus-Standardwert der Zielabhängigkeitseigenschaft zurückgegeben wird. Der Standardwert ist aber für jede Abhängigkeitseigenschaft unterschiedlich. In der Regel haben von einem Benutzer bearbeitbare Steuerelementeigenschaften, z. B. solche von Textfeldern und Kontrollkästchen, standardmäßig bidirektionale Bindungen, wogegen die meisten anderen Eigenschaften standardmäßig unidirektionale Bindungen haben.  
  
Eine programmgesteuerte Methode zum Bestimmen, ob eine Abhängigkeitseigenschaft standardmäßig uni- oder bidirektional bindet, besteht darin, die Metadaten der Eigenschaft mit <see cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" /> abzurufen und dann den booleschen Wert der <see cref="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />-Eigenschaft zu überprüfen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zur Unterstützung <xref:System.Windows.Data.BindingMode.OneWay> und <xref:System.Windows.Data.BindingMode.TwoWay> Bindungen die zugrunde liegenden Daten müssen implementieren <xref:System.ComponentModel.INotifyPropertyChanged>. Weitere Informationen finden Sie unter [Vorgehensweise: Implementieren Sie die Benachrichtigung der Eigenschaftenänderung](~/docs/framework/wpf/data/how-to-implement-property-change-notification.md).  
  
 Für <xref:System.Windows.Data.BindingMode.TwoWay> oder <xref:System.Windows.Data.BindingMode.OneWayToSource> Bindungen, Sie können die Ziel-to-Source-Updates steuern, durch Festlegen der <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> Eigenschaft. Weitere Informationen finden Sie unter <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A>.  
  
 Weitere Informationen zu den anderen Bindung-Modi finden Sie unter [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnSourceUpdated">
      <MemberSignature Language="C#" Value="public bool NotifyOnSourceUpdated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnSourceUpdated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.NotifyOnSourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnSourceUpdated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnSourceUpdated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnSourceUpdated : bool with get, set" Usage="System.Windows.Data.Binding.NotifyOnSourceUpdated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="E:System.Windows.Data.Binding.SourceUpdated" />-Ereignis ausgelöst werden soll, wenn ein Wert vom Bindungsziel zur Bindungsquelle übertragen wird, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn das <see cref="E:System.Windows.Data.Binding.SourceUpdated" />-Ereignis bei der Aktualisierung des Bindungsquellwerts ausgelöst werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.BindingExpression.UpdateSource" />
      </Docs>
    </Member>
    <Member MemberName="NotifyOnTargetUpdated">
      <MemberSignature Language="C#" Value="public bool NotifyOnTargetUpdated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnTargetUpdated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.NotifyOnTargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnTargetUpdated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnTargetUpdated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnTargetUpdated : bool with get, set" Usage="System.Windows.Data.Binding.NotifyOnTargetUpdated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="E:System.Windows.Data.Binding.TargetUpdated" />-Ereignis ausgelöst werden soll, wenn ein Wert von der Bindungsquelle zum Bindungsziel übertragen wird, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn das <see cref="E:System.Windows.Data.Binding.TargetUpdated" />-Ereignis bei der Aktualisierung des Bindungszielwerts ausgelöst werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.BindingExpression.UpdateTarget" />
      </Docs>
    </Member>
    <Member MemberName="NotifyOnValidationError">
      <MemberSignature Language="C#" Value="public bool NotifyOnValidationError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.NotifyOnValidationError" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnValidationError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnValidationError : bool with get, set" Usage="System.Windows.Data.Binding.NotifyOnValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das angefügte <see cref="E:System.Windows.Controls.Validation.Error" />-Ereignis für das gebundene Objekt ausgelöst werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" /> Wenn die <see cref="E:System.Windows.Controls.Validation.Error" /> angefügtes Ereignis muss für das gebundene Objekt bei ein Validierungsfehler während der quellaktualisierungen ausgelöst; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Bindung wurde <xref:System.Windows.Data.Binding.ValidationRules%2A> zugeordnet, die die Bindungs-Engine überprüft jede Regel jedes Mal, wenn es überträgt der Wert der Zieleigenschaft an die Source-Eigenschaft. Wenn eine Regel einen Wert für ungültig erklärt, erstellt die Bindungs-Engine eine <xref:System.Windows.Controls.ValidationError> -Objekt und fügt es der <xref:System.Windows.Controls.Validation>.<xref:System.Windows.Controls.Validation.Errors%2A> die Auflistung des gebundenen Objekts. Wenn die <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> Eigenschaft ist nicht leer ist, die <xref:System.Windows.Controls.Validation.HasError%2A?displayProperty=nameWithType> angefügte Eigenschaft des Objekts nastaven NA hodnotu `true`. Wenn die <xref:System.Windows.Data.Binding.NotifyOnValidationError%2A> Eigenschaft der <xref:System.Windows.Data.Binding> nastaven NA hodnotu `true`, löst die Bindungs-Engine die <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> angefügtes Ereignis für das Objekt.  
  
 Eine ausführliche Erläuterung des Überprüfungsprozesses, finden Sie im Abschnitt "Datenvalidierung" in der [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyPath Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyPath Path" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyPath ^ Path { System::Windows::PropertyPath ^ get(); void set(System::Windows::PropertyPath ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : System.Windows.PropertyPath with get, set" Usage="System.Windows.Data.Binding.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad zur Bindungsquelleneigenschaft fest ab oder legt diesen fest.</summary>
        <value>Der Pfad zur Bindungsquelle. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Bindung in der Regel hat vier Komponenten: einem Bindungszielobjekt, einer Zieleigenschaft, Bindungsquelle und einen Pfad auf den Wert in der Bindungsquelle verwenden. Weitere Informationen über diese Datenbindungskonzepte finden Sie unter [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Verwenden der <xref:System.Windows.Data.Binding.Path%2A> -Eigenschaft den Wert des an Sie binden möchten:  
  
-   Im einfachsten Fall die <xref:System.Windows.Data.Binding.Path%2A> Eigenschaftswert ist der Name der Eigenschaft des Quellobjekts, das für die Bindung, verwenden z. B. `Path=PropertyName`.  
  
-   Untergeordnete Eigenschaften einer Eigenschaft können durch eine in C# verwendet ähnliche Syntax angegeben werden. So legt zum Beispiel die Klausel `Path=ShoppingCart.Order` die Bindung für die untergeordnete `Order`-Eigenschaft des Objekts oder die `ShoppingCart`-Eigenschaft fest.  
  
-   Um eine angefügte Eigenschaft zu binden, schließen Sie die angefügte Eigenschaft in Klammern ein. Beispielsweise zum Binden an die angefügte Eigenschaft <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, die Syntax ist `Path=(DockPanel.Dock)`.  
  
-   Indexer einer Eigenschaft können durch eckige Klammern nach dem Namen der indizierten Eigenschaft angegeben werden. So legt zum Beispiel die `Path=ShoppingCart[0]`-Klausel die Bindung auf den Index fest, der der Art und Weise entspricht, wie die interne Indizierung der Eigenschaft das Zeichenfolgenliteral „0“ handhabt. Mehrere Indexer werden ebenfalls unterstützt.  
  
-   Indexer und untergeordnete Eigenschaften können in einer `Path`-Klausel kombiniert werden, z. B. `Path=ShoppingCart.ShippingInfo[MailingAddress,Street].`.  
  
-   Indexer können mehrere durch Kommata (,) getrennte Indexer-Parameter aufweisen. Der Typ der einzelnen Parameter kann in Klammern angegeben werden. Sie können beispielsweise über `Path="[(sys:Int32)42,(sys:Int32)24]"` verfügen, wobei `sys` dem `System`-Namespace zugeordnet ist.  
  
-   Wenn die Quelle eine Auflistungsansicht darstellt, kann das aktuelle Element mit einem Schrägstrich (/) angegeben werden. Beispielsweise legt die Klausel `Path=/` die Bindung auf das aktuelle Element in der Ansicht fest. Wenn die Quelle eine Auflistung darstellt, gibt diese Syntax das aktuelle Element der Standardauflistungsansicht an.  
  
-   Eigenschaftennamen und Schrägstriche können kombiniert werden, um Eigenschaften zu durchlaufen, die Auflistungen darstellen. Beispielsweise gibt `Path=/Offices/ManagerName` das aktuelle Element der Quellauflistung an, die eine `Offices`-Eigenschaft enthält, bei der es sich ebenfalls um eine Auflistung handelt. Bei dem aktuellen Element handelt es sich um ein Objekt, das eine `ManagerName`-Eigenschaft enthält.  
  
-   Optional kann ein Pfad mit einem Punkt (.) für die Bindung an die aktuelle Quelle verwendet werden. `Text="{Binding}"` entspricht beispielsweise `Text="{Binding Path=.}"`.  
  
 Informationen über die Syntax für elementpfade, finden Sie unter [Deklarationen Übersicht über Datenbindung](~/docs/framework/wpf/data/binding-declarations-overview.md) oder [XAML-Syntax "PropertyPath"](~/docs/framework/wpf/advanced/propertypath-xaml-syntax.md).  
  
 Für [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] Bindungen finden Sie unter den <xref:System.Windows.Data.Binding.XPath%2A> Eigenschaft.  
  
 Um an ein vollständiges Objekt zu binden, Sie müssen nicht an die <xref:System.Windows.Data.Binding.Path%2A> Eigenschaft. Weitere Informationen finden Sie unter "Angeben des Pfads, der Wert" in [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Auslösen einer Formatvorlage, die erstellt eine <xref:System.Windows.Controls.ToolTip> meldet, dass eine Validierungsfehlermeldung angezeigt. Der Wert der Setter-Methode bindet, auf den Fehler Inhalt des aktuellen <xref:System.Windows.Controls.TextBox> (die <xref:System.Windows.Controls.TextBox> mit dem Stil) mithilfe der <xref:System.Windows.Data.Binding.RelativeSource%2A> Eigenschaft. Weitere Informationen zu diesem Beispiel finden Sie unter [Vorgehensweise: Implementieren der Bindungsvalidierung](~/docs/framework/wpf/data/how-to-implement-binding-validation.md).  
  
 [!code-xaml[BindValidation#5](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RelativeSource">
      <MemberSignature Language="C#" Value="public System.Windows.Data.RelativeSource RelativeSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.RelativeSource RelativeSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.RelativeSource" />
      <MemberSignature Language="VB.NET" Value="Public Property RelativeSource As RelativeSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::RelativeSource ^ RelativeSource { System::Windows::Data::RelativeSource ^ get(); void set(System::Windows::Data::RelativeSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSource : System.Windows.Data.RelativeSource with get, set" Usage="System.Windows.Data.Binding.RelativeSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.RelativeSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Bindungsquelle ab, indem deren Speicherort relativ zur Position des Bindungsziels angegeben wird, oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Windows.Data.RelativeSource" />-Objekt, das den relativen Speicherort der zu verwendenden Bindungsquelle angibt. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird häufig verwendet, um eine Eigenschaft eines Objekts an eine andere Eigenschaft desselben Objekts binden oder eine Bindung in Stilen oder Vorlagen definieren.  
  
 Standardmäßig erben die Bindungen den Datenkontext, der gemäß der `DataContext` -Eigenschaft, wenn eine festgelegt wurde. Allerdings die <xref:System.Windows.Data.Binding.RelativeSource%2A> Eigenschaft ist eine der Möglichkeiten, Sie explizit, die Quelle des festlegen können, eine <xref:System.Windows.Data.Binding> und den geerbten Datenkontext zu überschreiben. Weitere Informationen finden Sie unter [Vorgehensweise: Angeben der Bindungsquelle](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 Die <xref:System.Windows.Data.Binding.ElementName%2A?displayProperty=nameWithType> und <xref:System.Windows.Data.Binding.Source%2A?displayProperty=nameWithType> Eigenschaften ermöglichen es Ihnen auch die Quelle der Bindung festgelegt explizit. Allerdings nur eine der drei Eigenschaften <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, und <xref:System.Windows.Data.Binding.RelativeSource%2A>sollten werden für jede Bindung festgelegt oder ein Konflikt kann auftreten. Diese Eigenschaft löst eine Ausnahme aus, wenn ein Bindung Quellkonflikt vorliegt.  
  
 Für [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Informationen finden Sie unter [RelativeSource MarkupExtension](~/docs/framework/wpf/advanced/relativesource-markupextension.md).  
    
## Examples  
 Das folgende Beispiel zeigt das Auslösen einer Formatvorlage, die erstellt eine <xref:System.Windows.Controls.ToolTip> meldet, dass eine Validierungsfehlermeldung angezeigt. Der Wert der Setter-Methode bindet, auf den Fehler Inhalt des aktuellen <xref:System.Windows.Controls.TextBox> (die <xref:System.Windows.Controls.TextBox> mit dem Stil) mithilfe der <xref:System.Windows.Data.Binding.RelativeSource%2A> Eigenschaft. Weitere Informationen zu diesem Beispiel finden Sie unter [Vorgehensweise: Implementieren der Bindungsvalidierung](~/docs/framework/wpf/data/how-to-implement-binding-validation.md).  
  
 [!code-xaml[BindValidation#5](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml#5)]  
  
 Das vollständige Beispiel finden Sie unter [Beispiel für Bindungsvalidierung](https://go.microsoft.com/fwlink/?LinkID=159972).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.Source" />
      </Docs>
    </Member>
    <Member MemberName="RemoveSourceUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void RemoveSourceUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveSourceUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.RemoveSourceUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveSourceUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveSourceUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveSourceUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.RemoveSourceUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das das Ereignis überwacht.</param>
        <param name="handler">Der zu entfernende Handler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Data.Binding.SourceUpdated" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt die Verwendung angefügter Ereignisse in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveTargetUpdatedHandler">
      <MemberSignature Language="C#" Value="public static void RemoveTargetUpdatedHandler (System.Windows.DependencyObject element, EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveTargetUpdatedHandler(class System.Windows.DependencyObject element, class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.RemoveTargetUpdatedHandler(System.Windows.DependencyObject,System.EventHandler{System.Windows.Data.DataTransferEventArgs})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveTargetUpdatedHandler (element As DependencyObject, handler As EventHandler(Of DataTransferEventArgs))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveTargetUpdatedHandler(System::Windows::DependencyObject ^ element, EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveTargetUpdatedHandler : System.Windows.DependencyObject * EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; -&gt; unit" Usage="System.Windows.Data.Binding.RemoveTargetUpdatedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;" />
      </Parameters>
      <Docs>
        <param name="element">Das <see cref="T:System.Windows.UIElement" /> oder das <see cref="T:System.Windows.ContentElement" />, das das Ereignis überwacht.</param>
        <param name="handler">Der zu entfernende Handler.</param>
        <summary>Entfernt einen Handler für das angefügte <see cref="E:System.Windows.Data.Binding.TargetUpdated" />-Ereignis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt die Verwendung angefügter Ereignisse in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetXmlNamespaceManager">
      <MemberSignature Language="C#" Value="public static void SetXmlNamespaceManager (System.Windows.DependencyObject target, System.Xml.XmlNamespaceManager value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetXmlNamespaceManager(class System.Windows.DependencyObject target, class System.Xml.XmlNamespaceManager value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.SetXmlNamespaceManager(System.Windows.DependencyObject,System.Xml.XmlNamespaceManager)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetXmlNamespaceManager (target As DependencyObject, value As XmlNamespaceManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetXmlNamespaceManager(System::Windows::DependencyObject ^ target, System::Xml::XmlNamespaceManager ^ value);" />
      <MemberSignature Language="F#" Value="static member SetXmlNamespaceManager : System.Windows.DependencyObject * System.Xml.XmlNamespaceManager -&gt; unit" Usage="System.Windows.Data.Binding.SetXmlNamespaceManager (target, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Xml.XmlNamespaceManager" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, von dem Namespaceinformationen abgerufen werden sollen.</param>
        <param name="value">Der <see cref="T:System.Xml.XmlNamespaceManager" />, der für die Namespaceauswertung im übergebenen Element verwendet werden soll.</param>
        <summary>Legt ein Namespace-Manager-Objekt fest, das von der an das bereitgestellte Element angefügten Bindung verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt die Verwendung der angefügten Eigenschaft für die <xref:System.Windows.Data.Binding.XmlNamespaceManager%2A> angefügte Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializePath">
      <MemberSignature Language="C#" Value="public bool ShouldSerializePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.ShouldSerializePath" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializePath () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializePath();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializePath : unit -&gt; bool" Usage="binding.ShouldSerializePath " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob die <see cref="P:System.Windows.Data.Binding.Path" />-Eigenschaft beibehalten werden soll.</summary>
        <returns><see langword="true" />, wenn der Eigenschaftswert geändert wurde und nicht mehr dem Standardwert entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies `ShouldSerialize` Methode wird bereitgestellt, da die <xref:System.Windows.Data.Binding.Path%2A> Eigenschaft hat keine einfachen Standardwert. Diese Methode gibt an, ob die Eigenschaft von seinem Standardwert geändert hat. Diese Methode wird in der Regel aufgerufen, wenn Sie entweder einen Designer für das Entwickeln der <xref:System.Windows.Data.Binding> oder entwickeln Ihre eigenen Steuerelement Integrieren der <xref:System.Windows.Data.Binding>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSource">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.ShouldSerializeSource" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeSource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeSource();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeSource : unit -&gt; bool" Usage="binding.ShouldSerializeSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob die <see cref="P:System.Windows.Data.Binding.Source" />-Eigenschaft beibehalten werden soll.</summary>
        <returns><see langword="true" />, wenn der Eigenschaftswert geändert wurde und nicht mehr dem Standardwert entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies `ShouldSerialize` Methode wird bereitgestellt, da die <xref:System.Windows.Data.Binding.Source%2A> Eigenschaft hat keine einfachen Standardwert. Diese Methode gibt an, ob die Eigenschaft von seinem Standardwert geändert hat. Diese Methode wird in der Regel aufgerufen, wenn Sie entweder einen Designer für das Entwickeln der <xref:System.Windows.Data.Binding> oder entwickeln Ihre eigenen Steuerelement Integrieren der <xref:System.Windows.Data.Binding>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeValidationRules">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeValidationRules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeValidationRules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.Binding.ShouldSerializeValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeValidationRules () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeValidationRules();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeValidationRules : unit -&gt; bool" Usage="binding.ShouldSerializeValidationRules " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob die <see cref="P:System.Windows.Data.Binding.ValidationRules" />-Eigenschaft beibehalten werden soll.</summary>
        <returns><see langword="true" />, wenn der Eigenschaftswert geändert wurde und nicht mehr dem Standardwert entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies `ShouldSerialize` Methode wird bereitgestellt, da die <xref:System.Windows.Data.Binding.ValidationRules%2A> Eigenschaft hat keine einfachen Standardwert. Diese Methode gibt an, ob die Eigenschaft von seinem Standardwert geändert hat. Diese Methode wird in der Regel aufgerufen, wenn Sie entweder einen Designer für das Entwickeln der <xref:System.Windows.Data.Binding> oder entwickeln Ihre eigenen Steuerelement Integrieren der <xref:System.Windows.Data.Binding>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.Data.Binding.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab oder legt es fest, das als Bindungsquelle verwendet werden soll.</summary>
        <value>Das Objekt, das als Bindungsquelle verwendet werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig erben die Bindungen den Datenkontext, der gemäß der `DataContext` -Eigenschaft, wenn eine festgelegt wurde. Allerdings die <xref:System.Windows.Data.Binding.Source%2A> Eigenschaft ist eine der Möglichkeiten, Sie explizit, die Quelle des festlegen können, eine <xref:System.Windows.Data.Binding> und den geerbten Datenkontext zu überschreiben. Wenn Sie nicht benötigen, dass die Funktionalität der Einrichtung eines Bereichs erbt die mehrere Eigenschaften denselben Datenkontext, können Sie verwenden die <xref:System.Windows.Data.Binding.Source%2A> -Eigenschaft anstelle der `DataContext` Eigenschaft.  
  
 Die <xref:System.Windows.Data.Binding.ElementName%2A?displayProperty=nameWithType> und <xref:System.Windows.Data.Binding.RelativeSource%2A?displayProperty=nameWithType> Eigenschaften ermöglichen es Ihnen auch die Quelle der Bindung festgelegt explizit. Allerdings nur eine der drei Eigenschaften <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, und <xref:System.Windows.Data.Binding.RelativeSource%2A>sollten werden für jede Bindung festgelegt oder ein Konflikt kann auftreten. Diese Eigenschaft löst eine Ausnahme aus, wenn ein Bindung Quellkonflikt vorliegt.  
  
 Um diese Eigenschaft deaktivieren, legen Sie ihn auf <xref:System.Windows.DependencyProperty.UnsetValue?displayProperty=nameWithType>.  
  
<a name="xamlAttributeUsage_Source"></a>   
## <a name="xaml-attribute-usage"></a>Verwendung von XAML-Attributen  
  
```  
<object Source="object"/>  
```  
  
<a name="xamlValues_Source"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *object*  
 Ein vorhandenes Objekt. Verwenden Sie zum Verweisen auf ein vorhandenes Objekt die [StaticResource-Markuperweiterung](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine `Person` Objekt mit einer Zeichenfolgeneigenschaft, die mit dem Namen `PersonName` , definiert ist, der `SDKSample` Namespace, als das erste hervorgehobene Zeile zeigt. In der hervorgehobenen Zeile mit der `<src>` -Element, es instanziiert die `Person` Objekt mit einer `PersonName` Eigenschaftswert `Joe`. Dies erfolgt in der `Resources` Abschnitt zugewiesen, und wählen Sie eine `x:Key`.  
  
 [!code-xaml[BindingInstantiation](~/samples/snippets/csharp/VS_Snippets_Wpf/SimpleBinding/CSharp/Page1.xaml?highlight=4,9,37)]  
  
 Die hervorgehobene Zeile mit der `<TextBlock>` Elemente wird gezeigt, wie zum Binden an die `PersonName` Eigenschaft. Daher die <xref:System.Windows.Controls.TextBlock> Steuerelement angezeigt wird, mit dem Wert "Joe".  
  
 Im folgenden Beispiel die <xref:System.Windows.Data.Binding.Source%2A> Werte der <xref:System.Windows.Data.Binding> Objekte werden festgelegt, um die `static` Eigenschaft <xref:System.Windows.Application.Current%2A?displayProperty=nameWithType>:  
  
 [!code-xaml[DataBindingLab#ComboBoxMultiBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/DataBindingLab/CSharp/AddProductWindow.xaml#comboboxmultibinding)]  
  
 Das vollständige Beispiel finden Sie unter [Demo für die Datenbindung](https://go.microsoft.com/fwlink/?LinkID=163703).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberSignature Language="ILAsm" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.Binding.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberSignature Language="F#" Value="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" Usage="see AddSourceUpdatedHandler, and RemoveSourceUpdatedHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn ein Wert vom Bindungsziel zur Bindungsquelle übertragen wird. Dies gilt jedoch nur für Bindungen, deren <see cref="P:System.Windows.Data.Binding.NotifyOnSourceUpdated" />-Wert auf <see langword="true" /> festgelegt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_SourceUpdatedEvent"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Data.Binding.SourceUpdatedEvent>|  
|Routing-Strategie|Bubbling|  
|delegate|<xref:System.EventHandler%601>, beschränkt auf <xref:System.Windows.Data.DataTransferEventArgs>.|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.BindingExpression.UpdateSource" />
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="SourceUpdatedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SourceUpdatedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SourceUpdatedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.SourceUpdatedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SourceUpdatedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SourceUpdatedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SourceUpdatedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Data.Binding.SourceUpdatedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Data.Binding.SourceUpdated" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberSignature Language="ILAsm" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.Binding.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberSignature Language="F#" Value="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" Usage="see AddTargetUpdatedHandler, and RemoveTargetUpdatedHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tritt auf, wenn ein Wert vom Bindungsziel zur Bindungsquelle übertragen wird. Dies gilt jedoch nur für Bindungen, deren <see cref="P:System.Windows.Data.Binding.NotifyOnTargetUpdated" />-Wert auf <see langword="true" /> festgelegt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TargetUpdatedEvent"></a>   
## <a name="routed-event-information"></a>Informationen zum Routingereignis  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Data.Binding.TargetUpdatedEvent>|  
|Routing-Strategie|Bubbling|  
|delegate|<xref:System.EventHandler%601>, beschränkt auf <xref:System.Windows.Data.DataTransferEventArgs>.|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.BindingExpression.UpdateTarget" />
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TargetUpdatedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TargetUpdatedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TargetUpdatedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.TargetUpdatedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetUpdatedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TargetUpdatedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetUpdatedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Data.Binding.TargetUpdatedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet das angefügte <see cref="E:System.Windows.Data.Binding.TargetUpdated" />-Ereignis.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSourceExceptionFilter">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.UpdateSourceExceptionFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateSourceExceptionFilter As UpdateSourceExceptionFilterCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceExceptionFilterCallback ^ UpdateSourceExceptionFilter { System::Windows::Data::UpdateSourceExceptionFilterCallback ^ get(); void set(System::Windows::Data::UpdateSourceExceptionFilterCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateSourceExceptionFilter : System.Windows.Data.UpdateSourceExceptionFilterCallback with get, set" Usage="System.Windows.Data.Binding.UpdateSourceExceptionFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceExceptionFilterCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Handler ab oder legt ihn fest, mit dem Sie benutzerdefinierte Logik für das Behandeln von Ausnahmen bereitstellen können, die beim Aktualisieren des Bindungsquellwerts durch die Bindungs-Engine auftreten. Dies gilt nur, wenn Sie Ihrer Bindung eine <see cref="T:System.Windows.Controls.ExceptionValidationRule" /> zugeordnet haben.</summary>
        <value>Eine Methode, die eine benutzerdefinierte Logik für das Behandeln von Ausnahmen bereitstellt, die beim Aktualisieren des Bindungsquellwerts durch die Bindungs-Engine auftreten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.ExceptionValidationRule> ist eine integrierte Validierungsregel, die prüft, ob während der Aktualisierung der Bindungsquelleneigenschaft ausgelöste Ausnahmen. Wenn Sie verknüpft haben die <xref:System.Windows.Controls.ExceptionValidationRule> mit Ihrer <xref:System.Windows.Data.Binding> Objekt ist, können Sie diese Eigenschaft verwenden, um einen Handler, der benutzerdefinierte Logik bereitzustellen, für die Behandlung dieser Ausnahmen festzulegen. Wenn ein <xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A> nicht angegeben ist, auf die <xref:System.Windows.Data.Binding>, erstellt die Bindungs-Engine eine <xref:System.Windows.Controls.ValidationError> mit der Ausnahme und fügt es der <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> -Auflistung des gebundenen Elements.  
  
   
  
## Examples  
 Die <xref:System.Windows.Controls.TextBox.Text%2A> Eigenschaft der folgenden <xref:System.Windows.Controls.TextBox> ist eine Datenbindung an eine Quelleigenschaft `Age3` vom Typ `int`. Die <xref:System.Windows.Controls.ExceptionValidationRule> Überprüfungen für Ausnahmen, die ausgelöst werden, während der Aktualisierung der Source-Eigenschaft (beispielsweise wenn der Benutzer einen Wert, der in eine ganze Zahl konvertiert werden kann).  
  
 [!code-xaml[BindValidation#tbExceptionFilter](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml#tbexceptionfilter)]  
  
 Sie können benutzerdefinierte Logik zum Behandeln von Ausnahmen angeben. Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Windows.Data.Binding.UpdateSourceExceptionFilter%2A> festzulegende Eigenschaft eine <xref:System.Windows.Data.UpdateSourceExceptionFilterCallback>.  
  
 [!code-csharp[BindValidation#filtercallback](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml.cs#filtercallback)]  
  
 Im folgenden finden Sie eine beispielimplementierung einer <xref:System.Windows.Data.UpdateSourceExceptionFilterCallback>.  
  
 [!code-csharp[BindValidation#Handler](~/samples/snippets/csharp/VS_Snippets_Wpf/BindValidation/CSharp/Window1.xaml.cs#handler)]  
  
 Die <xref:System.Windows.Data.UpdateSourceExceptionFilterCallback> können auch zurückgeben `null`, die Ausnahme selbst, oder ein <xref:System.Windows.Controls.ValidationError>. Weitere Informationen finden Sie unter <xref:System.Windows.Data.UpdateSourceExceptionFilterCallback>.  
  
 Das vollständige Beispiel finden Sie unter [Beispiel für Bindungsvalidierung](https://go.microsoft.com/fwlink/?LinkID=159972).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger UpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger UpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.UpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property UpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger UpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.UpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.Data.Binding.UpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die zeitliche Steuerung der Updates für die Bindungsquelle bestimmt, oder legt diesen fest.</summary>
        <value>Einer der <see cref="T:System.Windows.Data.UpdateSourceTrigger" />-Werte. Der Standardwert ist <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />. Dieser bewirkt, dass der standardmäßige <see cref="T:System.Windows.Data.UpdateSourceTrigger" />-Wert der Zielabhängigkeitseigenschaft zurückgegeben wird. Der Standardwert für die meisten Abhängigkeitseigenschaften ist jedoch <see cref="F:System.Windows.Data.UpdateSourceTrigger.PropertyChanged" />, während die <see cref="P:System.Windows.Controls.TextBox.Text" />-Eigenschaft den Standardwert <see cref="F:System.Windows.Data.UpdateSourceTrigger.LostFocus" /> aufweist.  
  
Eine programmgesteuerte Methode zum Bestimmen des standardmäßigen <see cref="P:System.Windows.Data.Binding.UpdateSourceTrigger" />-Werts einer Abhängigkeitseigenschaft besteht darin, die Metadaten der Eigenschaft mithilfe von <see cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" /> abzurufen und dann den Wert der <see cref="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />-Eigenschaft zu überprüfen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bindungen <xref:System.Windows.Data.BindingMode.TwoWay> oder <xref:System.Windows.Data.BindingMode.OneWayToSource> Lauschen auf Änderungen in der Zieleigenschaft und übertragen sie zurück an die Quelle. Dies wird als Aktualisieren der Quelle bezeichnet. Diese Updates in der Regel auftreten, wenn sich die Zieleigenschaft ändert. Dies ist in Ordnung, Kontrollkästchen und anderen einfachen Steuerelementen, eignet sich jedoch in der Regel nicht für Textfelder. Aktualisieren nach jeder Tastatureingabe kann die Leistung mindern und dem Benutzer die übliche Möglichkeit verweigert zu RÜCKTASTE Tippfehler beheben, vor dem Commit in den neuen Wert ein. Aus diesem Grund standardmäßig <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> Wert der <xref:System.Windows.Controls.TextBox.Text%2A> Eigenschaft <xref:System.Windows.Data.UpdateSourceTrigger.LostFocus> und nicht <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>.  
  
 Setzen Sie die <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> Wert <xref:System.Windows.Data.UpdateSourceTrigger.Explicit>, rufen Sie die <xref:System.Windows.Data.BindingExpression.UpdateSource%2A> Methode oder die Änderungen nicht zurück an die Quelle weitergegeben werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.Mode" />
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnDataErrors">
      <MemberSignature Language="C#" Value="public bool ValidatesOnDataErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnDataErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidatesOnDataErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnDataErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnDataErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnDataErrors : bool with get, set" Usage="System.Windows.Data.Binding.ValidatesOnDataErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Controls.DataErrorValidationRule" /> eingeschlossen werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Windows.Controls.DataErrorValidationRule" /> eingeschlossen werden soll, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen dieser Eigenschaft stellt eine Alternative zur Verwendung der <xref:System.Windows.Controls.DataErrorValidationRule> Element explizit. Die <xref:System.Windows.Controls.DataErrorValidationRule> ist eine integrierte Validierungsregel, die auf Fehler, die ausgelöst werden überprüft, indem die <xref:System.ComponentModel.IDataErrorInfo> Implementierung des Quellobjekts. Wenn ein Fehler ausgelöst wird, erstellt die Bindungs-Engine eine <xref:System.Windows.Controls.ValidationError> mit dem Fehler und fügt es der <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> -Auflistung des gebundenen Elements. Das Fehlen eines Fehlers löscht dieses Validierungsfeedback, es sei denn, eine neue Regel ein Überprüfungsproblem löst.  
  
 <xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A> wird in .NET Framework, Version 3.5 eingeführt.  Weitere Informationen finden Sie unter [.NET Framework-Versionen und -Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.ComponentModel.IDataErrorInfo> und <xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A> zum Überprüfen von Benutzereingaben in einem <xref:System.Windows.Controls.TextBox>. Im erste Beispiel erstellt einen Datentyp, der implementiert <xref:System.ComponentModel.IDataErrorInfo> Überprüfung um Fehler zu melden.  
  
 [!code-csharp[BindingValidationAttributesSnippets#IDataErrorInfoData](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/data.cs#idataerrorinfodata)]
 [!code-vb[BindingValidationAttributesSnippets#IDataErrorInfoData](~/samples/snippets/visualbasic/VS_Snippets_Wpf/bindingvalidationattributessnippets/visualbasic/window1.xaml.vb#idataerrorinfodata)]  
  
 Im folgenden Beispiel wird der `Age` Eigenschaft, um die <xref:System.Windows.Controls.TextBox> und legt <xref:System.Windows.Data.Binding.ValidatesOnDataErrors%2A> zu `true` auf die <xref:System.Windows.Data.Binding>.  Wenn der Benutzer einen ungültigen Wert eingibt, ein roter Rahmen angezeigt wird, der <xref:System.Windows.Controls.TextBox> und die <xref:System.Windows.Controls.ToolTip> meldet die Fehlermeldung.  
  
 [!code-xaml[BindingValidationAttributesSnippets#IDataErrorInfoXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/window1.xaml#idataerrorinfoxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.ValidatesOnExceptions" />
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnExceptions">
      <MemberSignature Language="C#" Value="public bool ValidatesOnExceptions { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnExceptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidatesOnExceptions" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnExceptions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnExceptions { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnExceptions : bool with get, set" Usage="System.Windows.Data.Binding.ValidatesOnExceptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Controls.ExceptionValidationRule" /> eingeschlossen werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Windows.Controls.ExceptionValidationRule" /> eingeschlossen werden soll, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen dieser Eigenschaft stellt eine Alternative zur Verwendung der <xref:System.Windows.Controls.ExceptionValidationRule> Element explizit. Die <xref:System.Windows.Controls.ExceptionValidationRule> ist eine integrierte Validierungsregel, die zur Überprüfung von Ausnahmen, die während der Aktualisierung der Source-Eigenschaft ausgelöst werden. Wenn eine Ausnahme ausgelöst wird, erstellt die Bindungs-Engine eine <xref:System.Windows.Controls.ValidationError> mit der Ausnahme und fügt es der <xref:System.Windows.Controls.Validation.Errors%2A?displayProperty=nameWithType> -Auflistung des gebundenen Elements. Das Fehlen eines Fehlers löscht dieses Validierungsfeedback, es sei denn, eine neue Regel ein Überprüfungsproblem löst.  
  
 <xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A> wird in .NET Framework, Version 3.5 eingeführt.  Weitere Informationen finden Sie unter [.NET Framework-Versionen und -Abhängigkeiten](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Verwenden Sie die folgenden Beispielen <xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A> zum Überprüfen von Benutzereingaben in einem <xref:System.Windows.Controls.TextBox>. Im erste Beispiel erstellt einen Datentyp, der eine Ausnahme auslöst, wenn die `Age` -Eigenschaftensatz auf eine ungültige Eigenschaft.  
  
 [!code-csharp[BindingValidationAttributesSnippets#ThrowExceptionData](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/data.cs#throwexceptiondata)]
 [!code-vb[BindingValidationAttributesSnippets#ThrowExceptionData](~/samples/snippets/visualbasic/VS_Snippets_Wpf/bindingvalidationattributessnippets/visualbasic/window1.xaml.vb#throwexceptiondata)]  
  
 Im folgenden Beispiel wird der `Age` Eigenschaft, um die <xref:System.Windows.Controls.TextBox> und legt <xref:System.Windows.Data.Binding.ValidatesOnExceptions%2A> zu `true` auf die <xref:System.Windows.Data.Binding>. Wenn der Benutzer einen ungültigen Wert eingibt, ein roter Rahmen angezeigt wird, der <xref:System.Windows.Controls.TextBox> und die <xref:System.Windows.Controls.ToolTip> meldet die Fehlermeldung.  
  
 [!code-xaml[BindingValidationAttributesSnippets#ThrowExceptionXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/bindingvalidationattributessnippets/csharp/window1.xaml#throwexceptionxaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.Binding.ValidatesOnDataErrors" />
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnNotifyDataErrors">
      <MemberSignature Language="C#" Value="public bool ValidatesOnNotifyDataErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnNotifyDataErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidatesOnNotifyDataErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnNotifyDataErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnNotifyDataErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnNotifyDataErrors : bool with get, set" Usage="System.Windows.Data.Binding.ValidatesOnNotifyDataErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" /> eingeschlossen werden soll, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" /> eingeschlossen werden soll, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Data.Binding.ValidatesOnNotifyDataErrors%2A> ist `true`, die Bindung überprüft und meldet Fehler, die von einer Datenquelle ausgelöst werden, die implementiert <xref:System.ComponentModel.INotifyDataErrorInfo>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationRules">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt; ValidationRules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Controls.ValidationRule&gt; ValidationRules" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.ValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationRules As Collection(Of ValidationRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ ValidationRules { System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationRules : System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;" Usage="System.Windows.Data.Binding.ValidationRules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von Regeln ab, durch die die Benutzereingabe auf Gültigkeit überprüft wird.</summary>
        <value>Eine Auflistung von <see cref="T:System.Windows.Controls.ValidationRule" />-Objekten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] -Datenbindungsmodell ermöglicht Ihnen die Zuordnung <xref:System.Windows.Data.Binding.ValidationRules%2A> mit Ihrem <xref:System.Windows.Data.Binding> oder <xref:System.Windows.Data.MultiBinding> Objekt. Können Sie benutzerdefinierte Regeln erstellen, durch Ableiten von der <xref:System.Windows.Controls.ValidationRule> -Klasse und Implementieren der <xref:System.Windows.Controls.ValidationRule.Validate%2A> -Methode, oder Sie können die integrierte <xref:System.Windows.Controls.ExceptionValidationRule>, die einen Wert ungültig, wenn Ausnahmen vorhanden, während der quellaktualisierungen sind.  
  
 Die Bindungs-Engine überprüft jeden <xref:System.Windows.Controls.ValidationRule> eine Bindung, die jedes Mal ein Eingabewert (Bindung der Wert der Zieleigenschaft) wird an die Bindungsquelleigenschaft übertragen zugeordnet. Eine ausführliche Erläuterung des Überprüfungsprozesses, finden Sie im Abschnitt "Datenvalidierung" in der [Übersicht über die Datenbindung](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!NOTE]
>  Diese Eigenschaft kann festgelegt werden, [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] nur mithilfe der Auflistungssyntax angezeigt, oder indem Sie den Zugriff auf das Auflistungsobjekt und über verschiedene Methoden, wie z. B. `Add`. Die Eigenschaft auf das Objekt ist schreibgeschützt, während der Auflistung mit Lese-/ Schreibzugriff besteht.  
  
<a name="xamlPropertyElementUsage_ValidationRules"></a>   
## <a name="xaml-property-element-usage"></a>Verwendung von XAML-Eigenschaftenelementen  
  
```  
<object>  
  <object.ValidationRules>  
    oneOrMoreValidationRules  
  </object.ValidationRules>  
</object>  
  
```  
  
<a name="xamlValues_ValidationRules"></a>   
## <a name="xaml-values"></a>XAML-Werte  
 *oneOrMoreValidationRules*  
 Eine oder mehrere <xref:System.Windows.Controls.ValidationRule> Objekte. Können Sie die <xref:System.Windows.Controls.ExceptionValidationRule> Klasse oder benutzerdefinierte Regeln erstellen, indem Unterklassen der <xref:System.Windows.Controls.ValidationRule> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Validation" />
      </Docs>
    </Member>
    <Member MemberName="XmlNamespaceManager">
      <MemberSignature Language="C#" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberSignature Language="ILAsm" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.XmlNamespaceManager" />
      <MemberSignature Language="VB.NET" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberSignature Language="F#" Value="see GetXmlNamespaceManager, and SetXmlNamespaceManager" Usage="see GetXmlNamespaceManager, and SetXmlNamespaceManager" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xml.XmlNamespaceManager" />-Objekt ab, das zum Ausführen von namespacekompatiblen <see langword="XPath" />-Abfragen in XML-Bindungen verwendet wird, oder legt es fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Angefügte Eigenschaft verwendet die Vererbung von Eigenschaftswerten, die das Verhalten der Namespace-Vererbung reproduziert werden, die im [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)]. Weitere Informationen finden Sie unter [Vererbung von Eigenschaftswerten](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
<a name="dependencyPropertyInfo_XmlNamespaceManager"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Data.Binding.XmlNamespaceManagerProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlNamespaceManagerProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty XmlNamespaceManagerProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty XmlNamespaceManagerProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Data.Binding.XmlNamespaceManagerProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly XmlNamespaceManagerProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ XmlNamespaceManagerProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable XmlNamespaceManagerProperty : System.Windows.DependencyProperty" Usage="System.Windows.Data.Binding.XmlNamespaceManagerProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Data.Binding.XmlNamespaceManager" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="XPath">
      <MemberSignature Language="C#" Value="public string XPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.Binding.XPath" />
      <MemberSignature Language="VB.NET" Value="Public Property XPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ XPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XPath : string with get, set" Usage="System.Windows.Data.Binding.XPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see langword="XPath" />-Abfrage ab, die den Wert der zu verwendenden [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)]-Bindungsquelle zurückgibt, oder legt sie fest.</summary>
        <value>Die <see langword="XPath" />-Abfrage. Die Standardeinstellung ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Bindungsquelle ist [!INCLUDE[TLA#tla_xml](~/includes/tlasharptla-xml-md.md)] Daten anstelle von eine [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Objekt, das <xref:System.Windows.Data.Binding.XPath%2A> Eigenschaft wird verwendet, statt die <xref:System.Windows.Data.Binding.Path%2A> Eigenschaft, die den Pfad zu einem Wert in der zu verwendenden Bindungsquelle angibt.  
  
 Durch Festlegen der <xref:System.Windows.Data.Binding.XPath%2A> -Eigenschaft, erstellen Sie eine `XPath` -Abfrage zum Auswählen eines Knotens oder eine Auflistung von Knoten (<xref:System.Xml.XmlElement?displayProperty=nameWithType> und <xref:System.Xml.XmlAttribute?displayProperty=nameWithType> sowohl abgeleitet <xref:System.Xml.XmlNode?displayProperty=nameWithType>). <xref:System.Xml.XmlNode?displayProperty=nameWithType> ist eine [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] -Objekt, das bedeutet, dass Sie an die Eigenschaften binden, die <xref:System.Windows.Data.Binding.Path%2A> Eigenschaft.  
  
 Die <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> verarbeitet die `XPath` Ausdrücke aus der <xref:System.Windows.Data.Binding.XPath%2A> Eigenschaft. `XPath` Funktionen werden nicht unterstützt. Für `XPath` Ausdrucksinformationen finden Sie unter den <xref:System.Xml.XmlNode.SelectNodes%2A> Dokumentation und Beispiele finden Sie in der Beispiel-Abschnitt.  
  
 LINQ to XML-Objekte <xref:System.Xml.Linq.XDocument> und <xref:System.Xml.Linq.XElement> verwenden Sie keine `XPath`. Weitere Informationen finden Sie unter [Vorgehensweise: Binden an XDocument, XElement oder LINQ für XML-Abfrageergebnisse](~/docs/framework/wpf/data/how-to-bind-to-xdocument-xelement-or-linq-for-xml-query-results.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>