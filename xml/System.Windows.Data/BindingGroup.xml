<Type Name="BindingGroup" FullName="System.Windows.Data.BindingGroup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f72467816af2fa6f2c9300920c84418d9f5bb23a" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39876849" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BindingGroup : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingGroup extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingGroup" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingGroup&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingGroup : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type BindingGroup = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Enthält eine Auflistung von Bindungen und <see cref="T:System.Windows.Controls.ValidationRule" />-Objekten, die zum Überprüfen eines Objekts verwendet werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Data.BindingGroup> erstellt eine Beziehung zwischen mehreren Bindungen, die überprüft und gemeinsam aktualisiert werden können. Nehmen wir beispielsweise an, dass eine Anwendung den Benutzer zur Eingabe einer Adresse auffordert. Die Anwendung füllt dann ein Objekt des Typs `Address`, die über die Eigenschaften, verfügt `Street`, `City`, `ZipCode`, und `Country`, mit den Werten, die der Benutzer bereitgestellt. Die Anwendung verfügt über einen Bereich, das vier <xref:System.Windows.Controls.TextBox> -Steuerelemente, von denen jeder Daten an eine der Eigenschaften des Objekts gebunden wird. Können Sie eine <xref:System.Windows.Controls.ValidationRule> in einem <xref:System.Windows.Data.BindingGroup> zum Überprüfen der `Address` Objekt. Wenn die Bindungen in der gleichen beteiligt <xref:System.Windows.Data.BindingGroup>, können Sie sicherstellen, dass die Postleitzahl für das Land der Adresse gültig ist.  
  
 Festlegen der <xref:System.Windows.FrameworkElement.BindingGroup%2A> Eigenschaft <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>. Untergeordnete Elemente erben die <xref:System.Windows.Data.BindingGroup> von ihren übergeordneten Elementen, genauso wie bei jedem anderen vererbbare Eigenschaft. Eine Bindung an ein Nachfolgerelement wurde eine <xref:System.Windows.Data.BindingGroup> eine der folgenden Situationen eintritt:  
  
-   Die Quelle der Bindung und die <xref:System.Windows.FrameworkElement.DataContext%2A> des Elements, das ist die <xref:System.Windows.Data.BindingGroup> das gleiche Objekt und die <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> Eigenschaft nicht festgelegt.  
  
-   Die <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> -Eigenschaft der Bindung entspricht der <xref:System.Windows.Data.BindingGroup.Name%2A> von der <xref:System.Windows.FrameworkContentElement.BindingGroup%2A> und werden nicht explizit festgelegt, um `null`.  
  
 Nehmen wir an, die im Beispiel der Adresse der <xref:System.Windows.FrameworkElement.DataContext%2A> von der <xref:System.Windows.Controls.Panel> festgelegt ist, auf das Objekt des Typs `Address`. Die Bindung für die einzelnen <xref:System.Windows.Controls.TextBox> wird hinzugefügt, um die <xref:System.Windows.Data.BindingGroup> des Bereichs.  
  
 Sie fügen <xref:System.Windows.Controls.ValidationRule> Objekte eine <xref:System.Windows.Data.BindingGroup>. Die <xref:System.Windows.Data.BindingGroup> wird als der erste Parameter übergeben, die <xref:System.Windows.Controls.ValidationRule.Validate%2A> Methode bei der <xref:System.Windows.Controls.ValidationRule> ausgeführt wird. Können Sie die <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> oder <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> Methode auf, die <xref:System.Windows.Data.BindingGroup> um die vorgeschlagenen Werte des Objekts abzurufen und die <xref:System.Windows.Data.BindingGroup.Items%2A> Eigenschaft, um die Quellen der Bindungen abzurufen.  
  
 Ein <xref:System.Windows.Data.BindingGroup> aktualisiert die Quellen der Bindung zur gleichen Zeit statt jede Bindung, die separat aktualisiert werden. Beim Aufrufen einer der Methoden zum Überprüfen der Daten (<xref:System.Windows.Data.BindingGroup.ValidateWithoutUpdate%2A>, <xref:System.Windows.Data.BindingGroup.UpdateSources%2A>, oder <xref:System.Windows.Data.BindingGroup.CommitEdit%2A>), die Bindung für die einzelnen <xref:System.Windows.Controls.TextBox> in das Beispiel wird überprüft und ggf. aktualisiert. Wenn eine Bindung ist Teil einer <xref:System.Windows.Data.BindingGroup>, die Quelle der Bindung wird nicht aktualisiert werden, bis zum Aufruf von <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> oder <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> auf die <xref:System.Windows.Data.BindingGroup>, es sei denn, Sie explizit festlegen, die <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> Eigenschaft.  
  
   
  
## Examples  
 In den folgenden Beispielen erstellen Sie eine Anwendung, die den Benutzer auffordert, geben Sie die Beschreibung und den Preis eines Elements und das Datum, das Angebot abläuft. Die Anwendung zeigt die aktuelle Informationen für das Element unterhalb des Formulars. Der Benutzer kann die Änderungen abzubrechen, oder übermitteln.  
  
 Die Anwendung führt Folgendes aus, um dieses Verhalten zu erzielen.  
  
-   Erstellt eine <xref:System.Windows.Data.BindingGroup> und fügt es den Stamm <xref:System.Windows.Controls.StackPanel> beim Erstellen der [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] der Anwendung.  
  
-   Aufrufe <xref:System.Windows.Data.BindingGroup.BeginEdit%2A>, <xref:System.Windows.Data.BindingGroup.CommitEdit%2A>, und <xref:System.Windows.Data.BindingGroup.CancelEdit%2A> in der Anwendung Logik zum Aktivieren Rollback der Änderungen.  
  
-   Aufrufe <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> in einem <xref:System.Windows.Controls.ValidationRule.Validate%2A> Methode, um die Eingabe des Benutzers abrufen und überprüfen Sie, dass ein Element über 100 Dollar mindestens sieben Tage lang verfügbar ist.  
  
 Das folgende Beispiel erstellt die [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] der Anwendung. Der Stamm <xref:System.Windows.Controls.StackPanel> verfügt über eine <xref:System.Windows.Data.BindingGroup> , enthält eine <xref:System.Windows.Controls.ValidationRule> , überprüft das Element, wie zuvor beschrieben. Das Binden von Objekten auf der `Price` Eigenschaft und die `OfferExpires` -Eigenschaft werden Teil der <xref:System.Windows.Data.BindingGroup> und jede Bindung hat ein <xref:System.Windows.Controls.ValidationRule> um sicherzustellen, dass der Preis, Datum, gültige Werte sind. Die Validierungsregeln für die einzelnen Eigenschaften ausführen, bevor die <xref:System.Windows.Controls.ValidationRule> auf die <xref:System.Windows.Data.BindingGroup>.  
  
 [!code-xaml[BindingGroupSnippets#WindowLayout](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#windowlayout)]  
  
 Das folgende Beispiel zeigt die Ereignishandler für die Anwendung. Wenn der Benutzer die Schaltfläche "Senden" klickt, ruft die Anwendung <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> jeweils ausgeführt <xref:System.Windows.Controls.ValidationRule> zugeordnete der <xref:System.Windows.Data.BindingGroup>. Wenn jeder <xref:System.Windows.Controls.ValidationRule> erfolgreich ist, <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> speichert die Werte auf das Objekt, und beendet die Transaktion zum Bearbeiten. Wenn <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> ist erfolgreich, die Anwendung beginnt eine andere Transaktion zum Bearbeiten. Wenn eine <xref:System.Windows.Controls.ValidationRule> ein Fehler auftritt, die <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> Ereignis tritt auf, da die Anwendung festgelegt <xref:System.Windows.Data.BindingGroup.NotifyOnValidationError%2A> zu `true` auf die <xref:System.Windows.Data.BindingGroup> (im vorherigen Beispiel). `ItemError` verarbeitet die <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> -Ereignis und zeigt Informationen zu den Validierungsfehler, die dem Benutzer. Im Beispiel verarbeitet auch die <xref:System.Windows.FrameworkElement.Loaded> -Ereignis für die <xref:System.Windows.Controls.StackPanel> und <xref:System.Windows.Controls.Primitives.ButtonBase.Click> -Ereignis für die **Abbrechen** Schaltfläche.  
  
 [!code-csharp[BindingGroupSnippets#WindowLogic](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#windowlogic)]
 [!code-vb[BindingGroupSnippets#WindowLogic](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#windowlogic)]  
  
 Das folgende Beispiel zeigt die benutzerdefinierte <xref:System.Windows.Controls.ValidationRule> `ValidateDateAndPrice`, dem wurde hinzugefügt, um die <xref:System.Windows.Data.BindingGroup> im ersten Beispiel. Die <xref:System.Windows.Controls.ValidationRule> verwendet die <xref:System.Windows.Data.BindingGroup> in seine <xref:System.Windows.Controls.ValidationRule.Validate%2A> Methode, um die Werte abzurufen, vom Benutzer eingegebenen in das Formular, und überprüft, ob ein Element über 100 Dollar ist, es mindestens sieben Tage lang zur Verfügung stehen.  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingGroup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingGroup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Data.BindingGroup" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginEdit">
      <MemberSignature Language="C#" Value="public void BeginEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.BeginEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginEdit();" />
      <MemberSignature Language="F#" Value="member this.BeginEdit : unit -&gt; unit" Usage="bindingGroup.BeginEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet eine Bearbeitungstransaktion für die Quellen in der <see cref="T:System.Windows.Data.BindingGroup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Quellen in der <xref:System.Windows.Data.BindingGroup> unterstützen, ausstehende Änderungen verwerfen, rufen Sie <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> aufrufen, um die Transaktion zum Bearbeiten zu beginnen, <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> aufrufen, um die ausstehenden Änderungen zu speichern, <xref:System.Windows.Data.BindingGroup.CancelEdit%2A> um die ausstehenden Änderungen zu verwerfen.  
  
 Für jedes Objekt in <xref:System.Windows.Data.BindingGroup.Items%2A> implementiert <xref:System.ComponentModel.IEditableObject>, <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> Aufrufe <xref:System.ComponentModel.IEditableObject.BeginEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> beim Laden eines Fensters, um die Transaktion zum Bearbeiten zu beginnen.  
  
 [!code-csharp[BindingGroupSnippets#BeginEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#beginedit)]
 [!code-vb[BindingGroupSnippets#BeginEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#beginedit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingExpressions">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt; BindingExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Data.BindingExpressionBase&gt; BindingExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.BindingExpressions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingExpressions As Collection(Of BindingExpressionBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ BindingExpressions { System::Collections::ObjectModel::Collection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BindingExpressions : System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt;" Usage="System.Windows.Data.BindingGroup.BindingExpressions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Data.BindingExpressionBase&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Windows.Data.BindingExpression" />-Objekten mit Informationen für jede Bindung in der <see cref="T:System.Windows.Data.BindingGroup" /> ab.</summary>
        <value>Eine Auflistung von <see cref="T:System.Windows.Data.BindingExpression" />-Objekten mit Informationen für jede Bindung in der <see cref="T:System.Windows.Data.BindingGroup" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Data.BindingExpression> gehört zu einer <xref:System.Windows.Data.BindingGroup> eine der folgenden Fälle eintritt:  
  
-   Die Quelle der Bindung und die <xref:System.Windows.FrameworkElement.DataContext%2A> des Elements, das ist die <xref:System.Windows.Data.BindingGroup> das gleiche Objekt und die <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> ist nicht festgelegt.  
  
-   Die <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> -Eigenschaft der Bindung und die <xref:System.Windows.Data.BindingGroup.Name%2A> von der <xref:System.Windows.Data.BindingGroup> auf denselben Wert ungleich Null festgelegt sind und die <xref:System.Windows.Data.BindingGroup> gehört zu einem übergeordneten Element, das Ziel der Bindungselements.  
  
-   Sie fügen eine <xref:System.Windows.Data.BindingExpression> zu <xref:System.Windows.Data.BindingGroup.BindingExpressions%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelEdit">
      <MemberSignature Language="C#" Value="public void CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.CancelEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelEdit();" />
      <MemberSignature Language="F#" Value="member this.CancelEdit : unit -&gt; unit" Usage="bindingGroup.CancelEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Bearbeitungstransaktion und verwirft die ausstehenden Änderungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bewirkt, dass die Quellen aus, die ausstehenden Änderungen zu verwerfen, wenn ein Quellobjekt auf diese Weise kann ein, und beenden die Transaktion zum Bearbeiten. Die Methode aktualisiert dann die Zieleigenschaften mit den gespeicherten Quellwerten.  
  
 Für jedes Objekt in <xref:System.Windows.Data.BindingGroup.Items%2A> implementiert <xref:System.ComponentModel.IEditableObject>, <xref:System.Windows.Data.BindingGroup.CancelEdit%2A> Aufrufe <xref:System.ComponentModel.IEditableObject.CancelEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Data.BindingGroup.CancelEdit%2A> zum Verwerfen der ausstehenden Änderungen und ruft dann <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> zum Vorbereiten der Quelle erneut bearbeitet werden.  
  
 [!code-csharp[BindingGroupSnippets#CancelEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#canceledit)]
 [!code-vb[BindingGroupSnippets#CancelEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#canceledit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanRestoreValues">
      <MemberSignature Language="C#" Value="public bool CanRestoreValues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRestoreValues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.CanRestoreValues" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRestoreValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRestoreValues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRestoreValues : bool" Usage="System.Windows.Data.BindingGroup.CanRestoreValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab, ob jede Quelle in der Bindung ausstehende Änderungen verwerfen und die ursprünglichen Werte wiederherstellen kann.</summary>
        <value>
          <see langword="true" />, wenn jede Quelle in der Bindung ausstehende Änderungen verwerfen und die ursprünglichen Werte wiederherstellen kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Quelle kann ausstehende Änderungen verwerfen, wenn er implementiert <xref:System.ComponentModel.IEditableObject>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommitEdit">
      <MemberSignature Language="C#" Value="public bool CommitEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CommitEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.CommitEdit" />
      <MemberSignature Language="VB.NET" Value="Public Function CommitEdit () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CommitEdit();" />
      <MemberSignature Language="F#" Value="member this.CommitEdit : unit -&gt; bool" Usage="bindingGroup.CommitEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt alle <see cref="T:System.Windows.Controls.ValidationRule" />-Objekte aus und aktualisiert die Bindungsquellen, wenn alle Validierungsregeln erfolgreich ausgeführt wurden.</summary>
        <returns>
          <see langword="true" />, wenn jede <see cref="T:System.Windows.Controls.ValidationRule" /> erfolgreich ausgeführt wurde und für die Werte ein Commit an die Quellen ausgeführt wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn alle <xref:System.Windows.Controls.ValidationRule> erfolgreich ist, diese Methode bewirkt, dass die Quellen aus, übernehmen Sie die ausstehenden Änderungen, und beenden die Transaktion zum Bearbeiten, wenn ein Quellobjekt auf diese Weise kann.  
  
 Für jedes Objekt in <xref:System.Windows.Data.BindingGroup.Items%2A> implementiert <xref:System.ComponentModel.IEditableObject>, <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> Aufrufe <xref:System.ComponentModel.IEditableObject.EndEdit%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> , speichern Sie die ausstehenden Änderungen und ruft dann <xref:System.Windows.Data.BindingGroup.BeginEdit%2A> zum Vorbereiten der Quelle erneut bearbeitet werden.  
  
 [!code-csharp[BindingGroupSnippets#BeginEdit](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#beginedit)]
 [!code-vb[BindingGroupSnippets#BeginEdit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#beginedit)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (object item, string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(object item, string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.GetValue(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (item As Object, propertyName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Object ^ item, System::String ^ propertyName);" />
      <MemberSignature Language="F#" Value="member this.GetValue : obj * string -&gt; obj" Usage="bindingGroup.GetValue (item, propertyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">Das Objekt, das die angegebene Eigenschaft enthält.</param>
        <param name="propertyName">Die Eigenschaft, deren vorgeschlagener Wert abgerufen werden soll.</param>
        <summary>Gibt den vorgeschlagenen Wert für die angegebene Eigenschaft und das Element zurück.</summary>
        <returns>Der vorgeschlagene Eigenschaftswert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode in der <xref:System.Windows.Controls.ValidationRule.Validate%2A?displayProperty=nameWithType> -Methode zum Abrufen des Wert, der an die Quelle übertragen werden. Der Typ des Rückgabewerts abhängig ist, auf der Bühne, an dem die <xref:System.Windows.Controls.ValidationRule> auftritt. Z. B. wenn ein <xref:System.Windows.Controls.TextBox> datengebunden ist auf eine Eigenschaft vom typinteger und <xref:System.Windows.Controls.ValidationRule> aufruft, <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> hat seine <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> festgelegt <xref:System.Windows.Controls.ValidationStep.RawProposedValue>, die Methode gibt eine Zeichenfolge zurück. Wenn die <xref:System.Windows.Controls.ValidationRule> hat seine <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> festgelegt <xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue>, die Methode gibt den Typ, der vom Konverter der Bindung zurückgegeben wird. In diesem Beispiel <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> in der Regel eine ganze Zahl zurückgibt.  
  
   
  
## Examples  
 Im folgende Beispiel ist Teil einer Anwendung, die der Benutzer aufgefordert, geben mehrere Kunden aus, und weisen Sie jedem Kunden einen Vertriebsmitarbeiter. Die Anwendung überprüft, dass der Vertriebsmitarbeiter und dem Kunden in derselben Region gehören. Das Beispiel zeigt die <xref:System.Windows.Controls.ValidationRule.Validate%2A> Methode, die verwendet die <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> Methode, um Werte zu erhalten, die der Kunde eingegeben haben.  
  
 [!code-csharp[BindingGroupSnippets#ItemBindGroupValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#itembindgroupvalidationrule)]
 [!code-vb[BindingGroupSnippets#ItemBindGroupValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#itembindgroupvalidationrule)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es besteht keine Bindung für das angegebene Element und die Eigenschaft.</exception>
        <exception cref="T:System.Windows.Data.ValueUnavailableException">Der Wert der angegebenen Eigenschaft ist aufgrund eines Konvertierungsfehlers oder einer zuvor fehlgeschlagenen Validierungsregel nicht verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValidationError">
      <MemberSignature Language="C#" Value="public bool HasValidationError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.HasValidationError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidationError { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidationError : bool" Usage="System.Windows.Data.BindingGroup.HasValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob bei der Validierungsregel für die <see cref="T:System.Windows.Data.BindingGroup" /> ein Fehler aufgetreten ist.</summary>
        <value>
          <see langword="true" />, wenn <see cref="T:System.Windows.Data.BindingGroup" /> einen Fehler bei einer Validierungsregel aufweist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirty : bool" Usage="System.Windows.Data.BindingGroup.IsDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab oder legt einen Wert fest, der angibt, ob <see cref="T:System.Windows.Data.BindingGroup" /> einen vorgeschlagenen Wert enthält, der nicht in der Quelle geschrieben wurde.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="T:System.Windows.Data.BindingGroup" /> einen vorgeschlagenen Wert enthält, der nicht in der Quelle geschrieben wurde; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IList Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ Items { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IList" Usage="System.Windows.Data.BindingGroup.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die von den Bindungsobjekten in der <see cref="T:System.Windows.Data.BindingGroup" /> verwendeten Quellen ab.</summary>
        <value>Die von den Bindungsobjekten in der <see cref="T:System.Windows.Data.BindingGroup" /> verwendeten Quellen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes Objekt, das verwendet wird, wie eine Quelle, in hinzugefügt wird der <xref:System.Windows.Data.BindingGroup.Items%2A> Eigenschaft, auch wenn das Objekt als Quelle für mehrere Bindungen verwendet wird. In vielen Fällen ist nur ein Element in <xref:System.Windows.Data.BindingGroup.Items%2A>, d.h., dass das Objekt, das <xref:System.Windows.FrameworkElement.DataContext%2A> des Elements, das verwendet die <xref:System.Windows.Data.BindingGroup>. Es ist möglich, dass eine <xref:System.Windows.Data.BindingGroup> mehreren Quellen, jedoch haben. Angenommen, Bindungsobjekten denselben <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> jedoch unterschiedliche Quellobjekte, jedes Objekt, das als Quelle verwendet wird, ist in <xref:System.Windows.Data.BindingGroup.Items%2A>.  
  
 Es können auch mehrere Objekte in sein <xref:System.Windows.Data.BindingGroup.Items%2A> Wenn der Pfad einer Bindung in eine geschachtelte Eigenschaft der Quelle aufgelöst wird. Nehmen wir beispielsweise an eine <xref:System.Windows.Controls.TextBox> Bindung des Steuerelements ist ein Teil einer <xref:System.Windows.Data.BindingGroup> und die zugehörige <xref:System.Windows.FrameworkElement.DataContext%2A> ist eine `Customer` -Objekt, das eine Eigenschaft des Typs hat `Address`. Wenn die <xref:System.Windows.Data.Binding.Path%2A> von der <xref:System.Windows.Data.Binding> ist die `Address.ZipCode` -Eigenschaft, die `Address` hinzugefügt wird die <xref:System.Windows.Data.BindingGroup.Items%2A> Eigenschaft.  
  
   
  
## Examples  
 Die folgenden Beispiele sind Teil einer Anwendung, die überprüft, ob der Benutzer die Eigenschaften von zwei Objekten, auf die gleichen Werte festgelegt hat. Im erste Beispiel erstellt zwei <xref:System.Windows.Controls.TextBox> -Steuerelemente, von denen jede auf eine andere Datenquelle gebunden sind. Die Bindung des ersten <xref:System.Windows.Controls.TextBox> Ruft die Quelle, `object1`, aus der <xref:System.Windows.FrameworkElement.DataContext%2A> von der <xref:System.Windows.Controls.TextBox> die übergeordnete Element des Steuerelements (der <xref:System.Windows.Controls.StackPanel>). Auf der zweiten <xref:System.Windows.Controls.TextBox>, die Quelle der Bindung nastaven NA hodnotu `object2`. Außerdem erstellt das Beispiel einer <xref:System.Windows.Controls.Label> , die Validierungsfehler anzeigt.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 Das folgende Beispiel zeigt die <xref:System.Windows.Controls.ValidationRule> , die im vorherigen Beispiel verwendet. In der <xref:System.Windows.Controls.ValidationRule.Validate%2A> -Methode, die im Beispiel wird jede Quellobjekts, aus der <xref:System.Windows.Data.BindingGroup> und überprüft, ob die Eigenschaften der Objekte gleich sind.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Data.BindingGroup.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen ab, der die <see cref="T:System.Windows.Data.BindingGroup" /> bezeichnet, die zum Einbeziehen und Ausschließen von Bindungsobjekten in der <see cref="T:System.Windows.Data.BindingGroup" /> verwendet werden kann.</summary>
        <value>Der Name, der die <see cref="T:System.Windows.Data.BindingGroup" /> bezeichnet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Data.BindingGroup.Name%2A> ist `null`, Bindungen, die eine Datenquelle verfügen, die das gleiche Objekt wie die <xref:System.Windows.FrameworkElement.DataContext%2A> des Elements, das ist die <xref:System.Windows.Data.BindingGroup> teilnehmen die <xref:System.Windows.Data.BindingGroup>.  
  
 Können Sie Bindungen mit einer Datenquelle, die von unterscheidet einschließen der <xref:System.Windows.FrameworkElement.DataContext%2A> des übergeordneten Elements, die die <xref:System.Windows.Data.BindingGroup> durch Festlegen von <xref:System.Windows.Data.BindingGroup.Name%2A> von der <xref:System.Windows.Data.BindingGroup> und <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> Eigenschaft eine Bindung an den gleichen Wert. Können Sie Bindungen, die die gleiche Quelle als ausschließen <xref:System.Windows.FrameworkElement.DataContext%2A> des übergeordneten Elements, die die <xref:System.Windows.Data.BindingGroup> durch Festlegen von <xref:System.Windows.Data.BindingGroup.Name%2A> von der <xref:System.Windows.Data.BindingGroup> und <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> Eigenschaft eine Bindung an verschiedene Werte.  
  
   
  
## Examples  
 Die folgenden Beispiele sind Teil einer Anwendung, die überprüft, ob der Benutzer die Eigenschaften von zwei Objekten, auf die gleichen Werte festgelegt hat. Im erste Beispiel erstellt zwei <xref:System.Windows.Controls.TextBox> -Steuerelemente, von denen jede auf eine andere Datenquelle gebunden sind. Die Bindung des ersten <xref:System.Windows.Controls.TextBox> ist Teil der <xref:System.Windows.Data.BindingGroup> da die <xref:System.Windows.Controls.TextBox> erbt die <xref:System.Windows.FrameworkElement.DataContext%2A> und <xref:System.Windows.Data.BindingGroup> von seinem übergeordneten Element <xref:System.Windows.Controls.StackPanel>.  
  
 Die Bindung auf der zweiten <xref:System.Windows.Controls.TextBox> ist Teil der <xref:System.Windows.Data.BindingGroup> da der <xref:System.Windows.Data.BindingGroup.Name%2A> von der <xref:System.Windows.Data.BindingGroup> und <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> von der <xref:System.Windows.Data.Binding> auf festlegen `bindingGroup`.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 Das folgende Beispiel zeigt die <xref:System.Windows.Controls.ValidationRule> , die im vorherigen Beispiel verwendet. In der <xref:System.Windows.Controls.ValidationRule.Validate%2A> -Methode, die im Beispiel wird jede Quellobjekts, aus der <xref:System.Windows.Data.BindingGroup> und überprüft, ob die Eigenschaften der Objekte gleich sind.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnValidationError">
      <MemberSignature Language="C#" Value="public bool NotifyOnValidationError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NotifyOnValidationError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.NotifyOnValidationError" />
      <MemberSignature Language="VB.NET" Value="Public Property NotifyOnValidationError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NotifyOnValidationError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NotifyOnValidationError : bool with get, set" Usage="System.Windows.Data.BindingGroup.NotifyOnValidationError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ab oder legt fest, ob bei Änderungen am Zustand einer <see cref="E:System.Windows.Controls.Validation.Error" /> das <see cref="T:System.Windows.Controls.ValidationRule" />-Ereignis eintritt.</summary>
        <value>
          <see langword="true" />, wenn bei Änderungen am Zustand einer <see cref="E:System.Windows.Controls.Validation.Error" /> das <see cref="T:System.Windows.Controls.ValidationRule" />-Ereignis eintritt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> angefügtes Ereignis tritt auf, auf das Element mit dem <xref:System.Windows.Data.BindingGroup>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Windows.Data.BindingGroup> und legt sie fest <xref:System.Windows.Data.BindingGroup.NotifyOnValidationError%2A> zu `true` , damit die Anwendung verarbeiten kann die <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> Ereignis bei der eine <xref:System.Windows.Controls.ValidationRule> ein Fehler auftritt.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#bindinggroup)]  
  
 Das folgende Beispiel verarbeitet die <xref:System.Windows.Controls.Validation.Error?displayProperty=nameWithType> Ereignis.  
  
 [!code-csharp[BindingGroupSnippets#ErrorHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml.cs#errorhandler)]
 [!code-vb[BindingGroupSnippets#ErrorHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window1.xaml.vb#errorhandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.Owner" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Owner As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Owner { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.DependencyObject" Usage="System.Windows.Data.BindingGroup.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Objekt ab, dem dieses <see cref="T:System.Windows.Data.BindingGroup" /> zugewiesen ist.</summary>
        <value>Das Objekt, dem dieses <see cref="T:System.Windows.Data.BindingGroup" /> zugewiesen ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SharesProposedValues">
      <MemberSignature Language="C#" Value="public bool SharesProposedValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SharesProposedValues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.SharesProposedValues" />
      <MemberSignature Language="VB.NET" Value="Public Property SharesProposedValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SharesProposedValues { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SharesProposedValues : bool with get, set" Usage="System.Windows.Data.BindingGroup.SharesProposedValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Data.BindingGroup" />-Klasse Zielwerte wiederverwendet, die nicht an die Quelle übertragen wurden, oder legt einen Wert fest.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="T:System.Windows.Data.BindingGroup" />-Klasse Zielwerte wiederverwendet, die nicht an die Quelle übertragen wurden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein vorgeschlagener Wert ist ein Wert, der auf dem Ziel einer Bindung geändert wurde, jedoch wurde nicht an die Quelle ein Commit ausgeführt wurde. Nehmen wir beispielsweise an, dass eine bidirektionale Bindung auf einen <xref:System.Windows.Controls.TextBox> und <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> -Eigenschaftensatz auf <xref:System.Windows.Data.UpdateSourceTrigger.Explicit>. Wenn der Benutzer den Wert der ändert die <xref:System.Windows.Controls.TextBox>, der vorgeschlagene Wert ist der Wert, der in der <xref:System.Windows.Controls.TextBox> bevor es an Quelle übertragen wird.  
  
 Wenn <xref:System.Windows.Data.BindingGroup.SharesProposedValues%2A> ist `true`, <xref:System.Windows.Data.BindingGroup> den vorgeschlagenen Wert verwendet, wenn eine Bindung, die BindingGroup verlässt und eine andere Bindung mit der gleichen Quelle damit verknüpft.  Nehmen wir beispielsweise an, dass es sich bei einer Anwendung ermöglicht einen Benutzer mehrere Felder bearbeiten und das Quellobjekt durch Klicken auf eine Schaltfläche zu aktualisieren. Wenn ein Feld nicht bearbeitet wird, wird die Anwendung zeigt es in einem <xref:System.Windows.Controls.TextBlock>. Wenn der Benutzer beginnt, ein Feld zu bearbeiten, ersetzt die Anwendung die <xref:System.Windows.Controls.TextBlock> mit einem <xref:System.Windows.Controls.TextBox>. Wenn der Benutzer beendet die Bearbeitung eines Felds, ersetzt die Anwendung die <xref:System.Windows.Controls.TextBox> mit einem <xref:System.Windows.Controls.TextBlock>. Da die Quelle nicht aktualisiert werden, bis der Benutzer die Schaltfläche klickt, es muss eine Möglichkeit für die <xref:System.Windows.Controls.TextBlock> den vorgeschlagenen Wert angezeigt. Durch Festlegen von <xref:System.Windows.Data.BindingGroup.SharesProposedValues%2A> zu `true`, die Anwendung werden die Änderungen des Benutzers auf ein Feld angezeigt, auch wenn die Quelle nicht aktualisiert wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (object item, string propertyName, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(object item, string propertyName, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.TryGetValue(System.Object,System.String,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (item As Object, propertyName As String, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(System::Object ^ item, System::String ^ propertyName, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : obj * string *  -&gt; bool" Usage="bindingGroup.TryGetValue (item, propertyName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">Das Objekt, das die angegebene Eigenschaft enthält.</param>
        <param name="propertyName">Die Eigenschaft, deren vorgeschlagener Wert abgerufen werden soll.</param>
        <param name="value">Enthält nach dem Beenden dieser Methode ein Objekt, das den vorgeschlagenen Eigenschaftswert darstellt. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Versucht, den vorgeschlagenen Wert für die angegebene Eigenschaft und das Element abzurufen.</summary>
        <returns>
          <see langword="true" />, wenn der Wert der vorgeschlagene Wert für die angegebene Eigenschaft ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> Gibt `false` Wenn eine Bindung für das angegebene Element und die Eigenschaft nicht vorhanden ist oder wenn der Wert der angegebenen Eigenschaft nicht verfügbar ist, aufgrund eines Konvertierungsfehlers ist oder weil es sich bei einer zuvor fehlgeschlagenen Validierungsregel.  
  
 Verwenden Sie diese Methode in der <xref:System.Windows.Controls.ValidationRule.Validate%2A?displayProperty=nameWithType> -Methode zum Abrufen des Wert, der an die Quelle übertragen werden. Der Typ `value` hängt von der Phase, an dem die <xref:System.Windows.Controls.ValidationRule> auftritt. Z. B. wenn ein <xref:System.Windows.Controls.TextBox> an eine Eigenschaft vom typinteger, datengebunden ist `value` ist eine Zeichenfolge, wenn die <xref:System.Windows.Controls.ValidationRule> aufruft, <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> hat seine <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> festgelegt <xref:System.Windows.Controls.ValidationStep.RawProposedValue>. Wenn die <xref:System.Windows.Controls.ValidationRule> hat seine <xref:System.Windows.Controls.ValidationRule.ValidationStep%2A> festgelegt <xref:System.Windows.Controls.ValidationStep.ConvertedProposedValue>, den Typ des `value` ist der Typ, der vom Konverter der Bindung zurückgegeben wird. In diesem Beispiel `value` ist in der Regel eine ganze Zahl.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine benutzerdefinierte <xref:System.Windows.Controls.ValidationRule> mit dem Namen `ValidateDateAndPrice`. In der <xref:System.Windows.Controls.ValidationRule.Validate%2A> -Methode, um das Beispiel verwendet die <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> Methode und die <xref:System.Windows.Data.BindingGroup.Items%2A> Eigenschaft, um die Werte den Benutzer, die im Formular eingegebenen abzurufen. Und dann im Beispiel wird überprüft, ob ein Element über 100 Dollar ist, es mindestens sieben Tage lang zur Verfügung stehen. In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Windows.Data.BindingGroup> Klasse  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateSources">
      <MemberSignature Language="C#" Value="public bool UpdateSources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool UpdateSources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.UpdateSources" />
      <MemberSignature Language="VB.NET" Value="Public Function UpdateSources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool UpdateSources();" />
      <MemberSignature Language="F#" Value="member this.UpdateSources : unit -&gt; bool" Usage="bindingGroup.UpdateSources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt den Konverter für die Bindung und die <see cref="T:System.Windows.Controls.ValidationRule" />-Objekte aus, deren <see cref="P:System.Windows.Controls.ValidationRule.ValidationStep" />-Eigenschaft auf <see cref="F:System.Windows.Controls.ValidationStep.RawProposedValue" />, <see cref="F:System.Windows.Controls.ValidationStep.ConvertedProposedValue" /> oder <see cref="F:System.Windows.Controls.ValidationStep.UpdatedValue" /> festgelegt ist, und speichert die Werte der Ziele in den Quellobjekten, sofern alle Validierungsregeln erfolgreich ausgeführt wurden.</summary>
        <returns>
          <see langword="true" />, wenn alle Validierungsregeln erfolgreich ausgeführt wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird die Quelle aktualisiert, wenn alle <xref:System.Windows.Controls.ValidationRule> erfolgreich ist, aber es führt nicht die Quellen aus, übernehmen Sie die ausstehenden Änderungen, und beenden die Transaktion zum Bearbeiten. D.h., wenn das Quellobjekt implementiert <xref:System.ComponentModel.IEditableObject>. Aufrufen, die diese Methode führt nicht dazu, dass <xref:System.ComponentModel.IEditableObject.EndEdit%2A> aufgerufen werden. Verwenden der <xref:System.Windows.Data.BindingGroup.CommitEdit%2A> Methode, damit die Quellen, die die ausstehenden Änderungen zu übernehmen.  
  
   
  
## Examples  
 Im folgende Beispiel ist Teil einer Anwendung, die der Benutzer aufgefordert, geben mehrere Kunden aus, und weisen Sie jedem Kunden einen Vertriebsmitarbeiter. Die Anwendung überprüft, dass der Vertriebsmitarbeiter und dem Kunden in derselben Region gehören. Das Beispiel ruft <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> überprüfen die Bindungen, und speichern Sie die Werte an die Quelle an, wenn alle Validierungsregeln erfolgreich ausgeführt werden.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSources](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window2.xaml.cs#updatesources)]
 [!code-vb[BindingGroupSnippets#UpdateSources](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window2.xaml.vb#updatesources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidatesOnNotifyDataError">
      <MemberSignature Language="C#" Value="public bool ValidatesOnNotifyDataError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidatesOnNotifyDataError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidatesOnNotifyDataError As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidatesOnNotifyDataError { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidatesOnNotifyDataError : bool with get, set" Usage="System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" /> eingeschlossen werden soll, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="T:System.Windows.Controls.NotifyDataErrorValidationRule" /> eingeschlossen werden soll, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Windows.Data.BindingGroup.ValidatesOnNotifyDataError%2A> ist `true`, die Bindung überprüft und meldet Fehler, die von einer Datenquelle ausgelöst werden, die implementiert <xref:System.ComponentModel.INotifyDataErrorInfo>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateWithoutUpdate">
      <MemberSignature Language="C#" Value="public bool ValidateWithoutUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ValidateWithoutUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingGroup.ValidateWithoutUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function ValidateWithoutUpdate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ValidateWithoutUpdate();" />
      <MemberSignature Language="F#" Value="member this.ValidateWithoutUpdate : unit -&gt; bool" Usage="bindingGroup.ValidateWithoutUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt den Konverter für die Bindung und die <see cref="T:System.Windows.Controls.ValidationRule" />-Objekte aus, deren <see cref="P:System.Windows.Controls.ValidationRule.ValidationStep" />-Eigenschaft auf <see cref="F:System.Windows.Controls.ValidationStep.RawProposedValue" /> oder <see cref="F:System.Windows.Controls.ValidationStep.ConvertedProposedValue" /> festgelegt ist.</summary>
        <returns>
          <see langword="true" />, wenn die Validierungsregeln erfolgreich ausgeführt wurden, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Quellen werden nicht aktualisiert werden, wenn Sie diese Methode aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationErrors">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt; ValidationErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Controls.ValidationError&gt; ValidationErrors" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidationErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationErrors As ReadOnlyCollection(Of ValidationError)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Controls::ValidationError ^&gt; ^ ValidationErrors { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Controls::ValidationError ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationErrors : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt;" Usage="System.Windows.Data.BindingGroup.ValidationErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Controls.ValidationError&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Sammlung der <see cref="T:System.Windows.Controls.ValidationError" />-Objekte ab, die dazu führten, dass <see cref="T:System.Windows.Data.BindingGroup" /> ungültig war.</summary>
        <value>Eine Sammlung der <see cref="T:System.Windows.Controls.ValidationError" />-Objekte, die <see cref="T:System.Windows.Data.BindingGroup" /> veranlassten, ungültig zu sein.  Der Wert ist <see langword="null" />, wenn keine Fehler auftreten.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidationRules">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt; ValidationRules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.Collection`1&lt;class System.Windows.Controls.ValidationRule&gt; ValidationRules" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingGroup.ValidationRules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidationRules As Collection(Of ValidationRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ ValidationRules { System::Collections::ObjectModel::Collection&lt;System::Windows::Controls::ValidationRule ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidationRules : System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;" Usage="System.Windows.Data.BindingGroup.ValidationRules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.Windows.Controls.ValidationRule&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung von <see cref="T:System.Windows.Controls.ValidationRule" />-Objekten ab, die die Quellobjekte in der <see cref="T:System.Windows.Data.BindingGroup" /> überprüfen.</summary>
        <value>Eine Auflistung von <see cref="T:System.Windows.Controls.ValidationRule" />-Objekten, die die Quellobjekte in der <see cref="T:System.Windows.Data.BindingGroup" /> überprüfen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Windows.Controls.ValidationRule> hinzugefügt wird eine <xref:System.Windows.Data.BindingGroup>, <xref:System.Windows.Data.BindingGroup> wird als der erste Parameter übergeben die <xref:System.Windows.Controls.ValidationRule.Validate%2A> Methode. Sie können die vorgeschlagenen Werte des Objekts abrufen, indem Sie mit der <xref:System.Windows.Data.BindingGroup.TryGetValue%2A> oder <xref:System.Windows.Data.BindingGroup.GetValue%28System.Object%2CSystem.String%29> Methode. Erhalten Sie die Objekte, sind die Quellen für die Bindungen aus, der <xref:System.Windows.Data.BindingGroup.Items%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die benutzerdefinierte <xref:System.Windows.Controls.ValidationRule>, `ValidateDateAndPrice`, zu der <xref:System.Windows.Data.BindingGroup>.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroup](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window1.xaml#bindinggroup)]  
  
 Im folgenden Beispiel wird die `ValidateDateAndPrice`-Klasse gezeigt. Die <xref:System.Windows.Controls.ValidationRule.Validate%2A> -Methode verwendet die <xref:System.Windows.Data.BindingGroup> zum Abrufen der Werte vom Benutzers eingegebenen in das Formular, und überprüft, ob ein Element über 100 Dollar ist, es mindestens sieben Tage lang zur Verfügung stehen.  
  
 [!code-csharp[BindingGroupSnippets#ValidateObject](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Data.cs#validateobject)]
 [!code-vb[BindingGroupSnippets#ValidateObject](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/data.vb#validateobject)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>