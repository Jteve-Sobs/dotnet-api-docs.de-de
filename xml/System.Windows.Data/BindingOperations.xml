<Type Name="BindingOperations" FullName="System.Windows.Data.BindingOperations">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9cc449894fff95cd6a3750ab3ac29b923170bf08" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75052241" /></Metadata><TypeSignature Language="C#" Value="public static class BindingOperations" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit BindingOperations extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingOperations" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingOperations" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingOperations abstract sealed" />
  <TypeSignature Language="F#" Value="type BindingOperations = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt statische Methoden zum Bearbeiten von Bindungen bereit, u. a. die Objekte <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" /> und <see cref="T:System.Windows.Data.PriorityBinding" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse stellt einen Satz statischer Methoden zur Verfügung, die als Hilfsvorgänge für Daten Bindungen dienen.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AccessCollection">
      <MemberSignature Language="C#" Value="public static void AccessCollection (System.Collections.IEnumerable collection, Action accessMethod, bool writeAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AccessCollection(class System.Collections.IEnumerable collection, class System.Action accessMethod, bool writeAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.AccessCollection(System.Collections.IEnumerable,System.Action,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AccessCollection (collection As IEnumerable, accessMethod As Action, writeAccess As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AccessCollection(System::Collections::IEnumerable ^ collection, Action ^ accessMethod, bool writeAccess);" />
      <MemberSignature Language="F#" Value="static member AccessCollection : System.Collections.IEnumerable * Action * bool -&gt; unit" Usage="System.Windows.Data.BindingOperations.AccessCollection (collection, accessMethod, writeAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="accessMethod" Type="System.Action" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="writeAccess" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, auf die zugegriffen werden soll.</param>
        <param name="accessMethod">Die Aktion, die für die Auflistung ausgeführt werden soll.</param>
        <param name="writeAccess"><see langword="true" />, wenn <paramref name="accessMethod" /> in die Auflistung schreiben wird; andernfalls <see langword="false" />.</param>
        <summary>Bietet Zugriff auf eine Auflistung mithilfe des Synchronisierungsmechanismus, den die angegebene Anwendung angegeben hat, als sie EnableCollectionSynchronization aufgerufen hat.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearAllBindings">
      <MemberSignature Language="C#" Value="public static void ClearAllBindings (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearAllBindings(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearAllBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearAllBindings (target As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearAllBindings(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member ClearAllBindings : System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Data.BindingOperations.ClearAllBindings target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, aus dem Bindungen entfernt werden sollen.</param>
        <summary>Entfernt alle Bindungen, einschließlich Bindungen des Typs <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" /> und <see cref="T:System.Windows.Data.PriorityBinding" />, aus dem angegebenen <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das angegebene Objekt nicht Daten gebunden ist, hat diese Methode keine Auswirkungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wenn <paramref name="target" /> gleich <see langword="null" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearBinding">
      <MemberSignature Language="C#" Value="public static void ClearBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearBinding (target As DependencyObject, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member ClearBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="System.Windows.Data.BindingOperations.ClearBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, aus dem die Bindung entfernt werden soll.</param>
        <param name="dp">Die Abhängigkeitseigenschaft, aus der die Bindung entfernt werden soll.</param>
        <summary>Entfernt die Bindung aus einer Eigenschaft an, sofern vorhanden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die angegebene Eigenschaft an eine <xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>oder <xref:System.Windows.Data.MultiBinding>gebunden ist, entfernt diese Methode den entsprechenden Bindungs Ausdruck und stellt den Wert der-Eigenschaft wieder her, bevor ein lokaler Wert durch die Bindung festgelegt wurde.  
  
 Wenn die angegebene Eigenschaft nicht Daten gebunden ist, hat diese Methode keine Auswirkungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Parameter <paramref name="target" /> und <paramref name="dp" /> dürfen nicht gleich <see langword="null" /> sein.</exception>
      </Docs>
    </Member>
    <Member MemberName="CollectionRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event CollectionRegistering As EventHandler(Of CollectionRegisteringEventArgs) " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionRegisteringEventArgs ^&gt; ^ CollectionRegistering;" />
      <MemberSignature Language="F#" Value="member this.CollectionRegistering : EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; " Usage="member this.CollectionRegistering : System.EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionRegistering As EventHandler(Of CollectionRegisteringEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Datenbindungssystem eine Auflistung feststellt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionViewRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionViewRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event CollectionViewRegistering As EventHandler(Of CollectionViewRegisteringEventArgs) " FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionViewRegisteringEventArgs ^&gt; ^ CollectionViewRegistering;" />
      <MemberSignature Language="F#" Value="member this.CollectionViewRegistering : EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; " Usage="member this.CollectionViewRegistering : System.EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; " />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionViewRegistering As EventHandler(Of CollectionViewRegisteringEventArgs) " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn das Datenbindungssystem eine Auflistungsansicht feststellt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void DisableCollectionSynchronization (System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DisableCollectionSynchronization(class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.DisableCollectionSynchronization(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DisableCollectionSynchronization (collection As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DisableCollectionSynchronization(System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="static member DisableCollectionSynchronization : System.Collections.IEnumerable -&gt; unit" Usage="System.Windows.Data.BindingOperations.DisableCollectionSynchronization collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, für die synchronisierter Zugriff entfernt werden sollen.</param>
        <summary>Entfernen der Synchronisierung, die für die angegebene Auflistung registriert ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisconnectedSource">
      <MemberSignature Language="C#" Value="public static object DisconnectedSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property object DisconnectedSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingOperations.DisconnectedSource" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DisconnectedSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Object ^ DisconnectedSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisconnectedSource : obj" Usage="System.Windows.Data.BindingOperations.DisconnectedSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, das <see cref="P:System.Windows.FrameworkElement.DataContext" /> ersetzt, wenn ein Elementcontainer in der visuellen Struktur entfernt wird.</summary>
        <value>Ein Objekt, das <see cref="P:System.Windows.FrameworkElement.DataContext" /> ersetzt, wenn ein Elementcontainer in der visuellen Struktur entfernt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, wenn Sie die <xref:System.Windows.FrameworkElement.DataContext%2A> eines Element Containers behandeln müssen.  Ein Elementcontainer ist das Benutzeroberflächenelement, das ein Element in einem <xref:System.Windows.Controls.ItemsControl> anzeigt.  Wenn ein <xref:System.Windows.Controls.ItemsControl> an eine Auflistung datengebunden ist, wird ein Elementcontainer für jedes Element generiert.  In einigen Fällen werden Elementcontainer aus der visuellen Struktur entfernt.  Zwei typische Situationen, in denen ein Elementcontainer entfernt wird, sind folgende: Wenn ein Element aus der zugrunde liegenden Auflistung entfernt wird, und wenn Virtualisierung auf <xref:System.Windows.Controls.ItemsControl> aktiviert wird.  In diesen Fällen wird die <xref:System.Windows.FrameworkElement.DataContext%2A>-Eigenschaft des Element Containers auf die <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A>-Eigenschaft festgelegt. Sie sollten prüfen, ob die <xref:System.Windows.FrameworkElement.DataContext%2A> gleich der <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> ist, bevor Sie auf die <xref:System.Windows.FrameworkElement.DataContext%2A> im <xref:System.Windows.FrameworkElement.DataContextChanged>-Ereignis für Element Container zugreifen. Weitere Informationen zu Element Containern und zur Virtualisierung finden Sie in den Hinweisen in der <xref:System.Windows.Controls.VirtualizingStackPanel>-Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnableCollectionSynchronization">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ermöglicht es einem <see cref="T:System.Windows.Data.CollectionView" />-Objekt, an einem synchronisierten Zugriff auf eine Auflistung teilzunehmen, die in mehreren Threads verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Eine WPF-Anwendung kann eine Auflistung von Daten mit Anzeigen einer <xref:System.Windows.Controls.ItemsControl> oder eine ihrer Unterklassen (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>usw.). WPF leitet den gesamten Zugriff auf die Auflistung durch eine Unterklasse von <xref:System.Windows.Data.CollectionView>um. Sowohl die <xref:System.Windows.Controls.ItemsControl> als auch die <xref:System.Windows.Data.CollectionView> haben eine Affinität zu dem Thread, in dem die <xref:System.Windows.Controls.ItemsControl> erstellt wurde. Dies bedeutet, dass die Verwendung in einem anderen Thread unzulässig ist und eine Ausnahme auslöst. Diese Einschränkung gilt tatsächlich auch für die Auflistung.
 
Möglicherweise möchten Sie die Sammlung für mehrere Threads verwenden.   Sie möchten z. b. die Sammlung (hinzufügen oder Entfernen von Elementen) in einem Thread für die Datenerfassung aktualisieren, während die Ergebnisse in einem Benutzeroberflächen Thread angezeigt werden, damit die Benutzeroberfläche reaktionsfähig bleibt, während die Datensammlung stattfindet. In einer solchen Situation sind Sie dafür verantwortlich, den synchronisierten ("Thread sicheren") Zugriff auf die Auflistung sicherzustellen.   Dies erfolgt in der Regel mithilfe eines einfachen Sperrmechanismus oder eines ausführlicheren Synchronisierungs Mechanismus, wie z. b. Semaphore, Zurücksetzungs Ereignisse usw.   während Sie den Zugriff der Anwendung auf die Sammlung synchronisieren müssen, müssen Sie auch sicherstellen, dass der Zugriff von WPF (insbesondere von <xref:System.Windows.Data.CollectionView>) an demselben Synchronisierungs Mechanismus beteiligt ist.  Dies erreichen Sie, indem Sie die <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A>-Methode aufrufen.
 
Um eine Auflistung in mehreren Threads zu verwenden, von denen einer der Benutzeroberflächen-Thread ist, der den <xref:System.Windows.Controls.ItemsControl>besitzt, hat eine Anwendung die folgenden Zuständigkeiten:

1. Wählen Sie einen Synchronisierungs Mechanismus aus.

1. Synchronisieren Sie mithilfe dieses Mechanismus den gesamten Zugriff von der Anwendung auf die Sammlung.

1. Ruft <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> auf, um WPF über den Mechanismus zu informieren.

   - Der-Rückruf muss im UI-Thread erfolgen.

   - Der-Befehl muss vor der Verwendung der-Auflistung in einem anderen Thread oder vor dem Anfügen der Auflistung an den <xref:System.Windows.Controls.ItemsControl>erfolgen, je nachdem, welcher Wert später vorliegt.

   - Aufrufen der <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> Überladung, wenn ein einfacher Sperrmechanismus verwendet wird. Aufrufen der <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> Überladung, wenn ein ausführlichere Mechanismus verwendet wird.

1. Stellen Sie sicher, dass eine Änderung an der Sammlung und die Benachrichtigung über die Änderung (durch <xref:System.Collections.Specialized.INotifyCollectionChanged>) atomarisch sind. kein Zugriff von anderen Threads kann eingreifen.  (Dies ist in der Regel kostenlos. <xref:System.Collections.ObjectModel.ObservableCollection%601> gewährleistet beispielsweise dies, vorausgesetzt, dass alle Änderungen durch Synchronisierung geschützt sind.)

1. Wenn Sie <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>aufzurufen, muss dieser auch im UI-Thread auftreten.

1. Wenn Sie dieselbe Sammlung für mehrere UI-Threads verwenden möchten, müssen Sie <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (<xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>und bei Bedarf) separat für jeden UI-Thread abrufen.

1. Vermeiden Sie Deadlocks.  Diese Aufgabe liegt bereits in der Zuständigkeit der Anwendung, nachdem Sie sich für die Synchronisierung entschieden hat, Sie muss aber auch die Teilnahme an der Synchronisierung von WPF berücksichtigen, wie im folgenden Absatz erläutert.

In der Rückgabe bietet WPF das folgende Verhalten:

- Der <xref:System.Windows.Data.CollectionView> auf die Auflistung mit dem angegebenen Synchronisierungs Mechanismus zugreift.

- Der <xref:System.Windows.Data.CollectionView> verwaltet eine "Schatten Kopie" der Sammlung für die Verwendung im UI-Thread.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> Ereignisse werden in die Warteschlange eingereiht, sobald sie eintreffen (in einem beliebigen Thread).

- Ausstehende Ereignisse werden im UI-Thread asynchron auf die Schatten Kopie angewendet, wenn Sie die Möglichkeit haben, dies zu erreichen.

- Der <xref:System.Windows.Data.CollectionView> verwendet nicht direkt einen anderen für die Anwendung sichtbaren Synchronisierungs Mechanismus. Dies ist die Methode von WPF zur Vermeidung von Deadlocks (siehe das vorherige Element 7).   

Der Nettoeffekt besteht darin, dass Sie die Sammlung in jedem Thread ändern können, und diese Änderungen werden schließlich in der <xref:System.Windows.Controls.ItemsControl> angezeigt, wenn der UI-Thread Zeit zum "aufholen" hat.  Die-Implementierung wurde optimiert, um die Rate zu drosseln, mit der Änderungen in den UI-Thread übertragen werden, um Hintergrundthreads daran zu halten, den UI-Thread zu sättige und die Antwort auf normale Benutzereingaben

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object lockObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object lockObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, lockObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ lockObject);" />
      <MemberSignature Language="F#" Value="static member EnableCollectionSynchronization : System.Collections.IEnumerable * obj -&gt; unit" Usage="System.Windows.Data.BindingOperations.EnableCollectionSynchronization (collection, lockObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="lockObject" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, die synchronisierten Zugriff benötigt.</param>
        <param name="lockObject">Das beim Zugriff auf die Auflistung zu sperrende Objekt.</param>
        <summary>Ermöglicht es einem <see cref="T:System.Windows.Data.CollectionView" />-Objekt durch einen einfachen Sperrmechanismus, an einem synchronisierten Zugriff auf eine Auflistung teilzunehmen, die von mehreren Threads verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Eine WPF-Anwendung kann eine Auflistung von Daten mit Anzeigen einer <xref:System.Windows.Controls.ItemsControl> oder eine ihrer Unterklassen (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>usw.). WPF leitet den gesamten Zugriff auf die Auflistung durch eine Unterklasse von <xref:System.Windows.Data.CollectionView>um. Sowohl die <xref:System.Windows.Controls.ItemsControl> als auch die <xref:System.Windows.Data.CollectionView> haben eine Affinität zu dem Thread, in dem die <xref:System.Windows.Controls.ItemsControl> erstellt wurde. Dies bedeutet, dass die Verwendung in einem anderen Thread unzulässig ist und eine Ausnahme auslöst. Diese Einschränkung gilt tatsächlich auch für die Auflistung.
 
Möglicherweise möchten Sie die Sammlung für mehrere Threads verwenden.   Sie möchten z. b. die Sammlung (hinzufügen oder Entfernen von Elementen) in einem Thread für die Datenerfassung aktualisieren, während die Ergebnisse in einem Benutzeroberflächen Thread angezeigt werden, damit die Benutzeroberfläche reaktionsfähig bleibt, während die Datensammlung stattfindet. In einer solchen Situation sind Sie dafür verantwortlich, den synchronisierten ("Thread sicheren") Zugriff auf die Auflistung zu gewährleisten und sicherzustellen, dass der Zugriff von WPF (insbesondere von <xref:System.Windows.Data.CollectionView>) an demselben Synchronisierungs Mechanismus beteiligt ist. Indem Sie die <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)>-Methode aufrufen, können Sie dazu einen einfachen Sperrmechanismus verwenden. 
 
Um eine Auflistung für mehrere Threads zu verwenden, von denen einer der Benutzeroberflächen-Thread ist, der den <xref:System.Windows.Controls.ItemsControl>besitzt, müssen Sie die folgenden Schritte ausführen:

1. Instanziieren Sie ein Objekt, das beim Zugriff auf die Auflistung gesperrt werden soll.

1. Synchronisieren Sie den gesamten Zugriff von der Anwendung auf die Sammlung, indem Sie das Objekt Sperren.

1. Wenden Sie <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> an, um WPF darüber zu informieren, dass Sie einen einfachen Sperrmechanismus verwenden.

   - Der-Rückruf muss im UI-Thread erfolgen.

   - Der-Befehl muss vor der Verwendung der-Auflistung in einem anderen Thread oder vor dem Anfügen der Auflistung an den <xref:System.Windows.Controls.ItemsControl>erfolgen, je nachdem, welcher Wert später vorliegt.

1. Stellen Sie sicher, dass eine Änderung an der Sammlung und die Benachrichtigung über die Änderung (durch <xref:System.Collections.Specialized.INotifyCollectionChanged>) atomarisch sind. kein Zugriff von anderen Threads kann eingreifen.  (Dies ist in der Regel kostenlos. <xref:System.Collections.ObjectModel.ObservableCollection%601> gewährleistet beispielsweise dies, vorausgesetzt, dass alle Änderungen durch Synchronisierung geschützt sind.)

1. Wenn Sie <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>aufzurufen, muss dieser auch im UI-Thread auftreten.

1. Wenn Sie dieselbe Sammlung für mehrere UI-Threads verwenden möchten, müssen Sie <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (<xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>und bei Bedarf) separat für jeden UI-Thread abrufen.

1. Vermeiden Sie Deadlocks.  Diese Aufgabe liegt bereits in der Zuständigkeit der Anwendung, wenn Sie die Synchronisierung verwendet, aber auch die Teilnahme an der Synchronisierung von WPF berücksichtigt werden muss. (Weitere Informationen finden Sie weiter unten.)

In der Rückgabe bietet WPF das folgende Verhalten:

- Der <xref:System.Windows.Data.CollectionView> greift mithilfe des Sperrmechanismus auf die Auflistung zu.

- Der <xref:System.Windows.Data.CollectionView> verwaltet eine "Schatten Kopie" der Sammlung für die Verwendung im UI-Thread.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> Ereignisse werden in die Warteschlange eingereiht, sobald sie eintreffen (in einem beliebigen Thread).

- Ausstehende Ereignisse werden im UI-Thread asynchron auf die Schatten Kopie angewendet, wenn Sie die Möglichkeit haben, dies zu erreichen.

- Der <xref:System.Windows.Data.CollectionView> verwendet nicht direkt einen anderen für die Anwendung sichtbaren Synchronisierungs Mechanismus. Dies ist die Methode von WPF zur Vermeidung von Deadlocks (siehe das vorherige Element 7).   

Der Nettoeffekt besteht darin, dass Sie die Sammlung in jedem Thread ändern können, und diese Änderungen werden schließlich in der <xref:System.Windows.Controls.ItemsControl> angezeigt, wenn der UI-Thread Zeit zum "aufholen" hat.  Die-Implementierung wurde optimiert, um die Rate zu drosseln, mit der Änderungen in den UI-Thread übertragen werden, um Hintergrundthreads daran zu halten, den UI-Thread zu sättige und die Antwort auf normale Benutzereingaben
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object context, System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object context, class System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, context As Object, synchronizationCallback As CollectionSynchronizationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ context, System::Windows::Data::CollectionSynchronizationCallback ^ synchronizationCallback);" />
      <MemberSignature Language="F#" Value="static member EnableCollectionSynchronization : System.Collections.IEnumerable * obj * System.Windows.Data.CollectionSynchronizationCallback -&gt; unit" Usage="System.Windows.Data.BindingOperations.EnableCollectionSynchronization (collection, context, synchronizationCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="context" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="synchronizationCallback" Type="System.Windows.Data.CollectionSynchronizationCallback" Index="2" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, die synchronisierten Zugriff benötigt.</param>
        <param name="context">Ein Objekt, das an den Rückruf übergeben wird.</param>
        <param name="synchronizationCallback">Der Rückruf, der aufgerufen wird, wenn der Zugriff auf die Auflistung erforderlich ist. Sie können diesen verwenden, um sicherzustellen, dass die Auflistung nur von einem Thread gleichzeitig verwendet wird.</param>
        <summary>Ermöglicht es einem <see cref="T:System.Windows.Data.CollectionView" />-Objekt durch einen anderen Mechanismus als eine einfache Sperre, an einem synchronisierten Zugriff auf eine Auflistung teilzunehmen, die von mehreren Threads verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Eine WPF-Anwendung kann eine Auflistung von Daten mit Anzeigen einer <xref:System.Windows.Controls.ItemsControl> oder eine ihrer Unterklassen (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>usw.). WPF leitet den gesamten Zugriff auf die Auflistung durch eine Unterklasse von <xref:System.Windows.Data.CollectionView>um. Sowohl die <xref:System.Windows.Controls.ItemsControl> als auch die <xref:System.Windows.Data.CollectionView> haben eine Affinität zu dem Thread, in dem die <xref:System.Windows.Controls.ItemsControl> erstellt wurde. Dies bedeutet, dass die Verwendung in einem anderen Thread unzulässig ist und eine Ausnahme auslöst. Diese Einschränkung gilt tatsächlich auch für die Auflistung.
 
Möglicherweise möchten Sie die Sammlung für mehrere Threads verwenden.   Sie möchten z. b. die Sammlung (hinzufügen oder Entfernen von Elementen) in einem Thread für die Datenerfassung aktualisieren, während die Ergebnisse in einem Benutzeroberflächen Thread angezeigt werden, damit die Benutzeroberfläche reaktionsfähig bleibt, während die Datensammlung stattfindet. In einer solchen Situation sind Sie dafür verantwortlich, den synchronisierten ("Thread sicheren") Zugriff auf die Auflistung zu gewährleisten und sicherzustellen, dass der Zugriff von WPF (insbesondere von <xref:System.Windows.Data.CollectionView>) an demselben Synchronisierungs Mechanismus beteiligt ist. Wenn Sie die <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)>-Methode aufrufen, können Sie dazu einen Synchronisierungs Mechanismus verwenden, wie z. b. ein Semaphore, ein Reset-Ereignis usw.  , um eine Auflistung in mehreren Threads zu verwenden, von denen einer der Benutzeroberflächen-Thread ist, der die <xref:System.Windows.Controls.ItemsControl>besitzt, müssen Sie folgende Schritte ausführen:

1. Wählen Sie einen Synchronisierungs Mechanismus aus.

1. Synchronisieren Sie mithilfe dieses Mechanismus den gesamten Zugriff von der Anwendung auf die Sammlung.

1. Aufrufen der <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> Überladung, um WPF zu informieren, dass Sie einen anderen Mechanismus als einfache Sperren verwenden.

   - Der-Rückruf muss im UI-Thread erfolgen.

   - Der-Befehl muss vor der Verwendung der-Auflistung in einem anderen Thread oder vor dem Anfügen der Auflistung an den <xref:System.Windows.Controls.ItemsControl>erfolgen, je nachdem, welcher Wert später vorliegt.

1. Stellen Sie sicher, dass eine Änderung an der Sammlung und die Benachrichtigung über die Änderung (durch <xref:System.Collections.Specialized.INotifyCollectionChanged>) atomarisch sind. kein Zugriff von anderen Threads kann eingreifen.  (Dies ist in der Regel kostenlos. <xref:System.Collections.ObjectModel.ObservableCollection%601> gewährleistet beispielsweise dies, vorausgesetzt, dass alle Änderungen durch Synchronisierung geschützt sind.)

1. Wenn Sie <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>aufzurufen, muss dieser auch im UI-Thread auftreten.

1. Wenn Sie dieselbe Sammlung für mehrere UI-Threads verwenden möchten, müssen Sie <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (<xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>und bei Bedarf) separat für jeden UI-Thread abrufen.

1. Vermeiden Sie Deadlocks.  Diese Aufgabe liegt bereits in der Zuständigkeit der Anwendung, wenn Sie die Synchronisierung verwendet, aber auch die Teilnahme an der Synchronisierung von WPF berücksichtigt werden muss. (Weitere Informationen finden Sie weiter unten.)

In der Rückgabe bietet WPF das folgende Verhalten:

- Der <xref:System.Windows.Data.CollectionView> greift auf die Auflistung zu, indem er die registrierten <xref:System.Windows.Data.CollectionSynchronizationCallback> mit den folgenden Argumenten aufruft:

   - `collection`: die Auflistung, die von Interesse ist.
   - `context`: das registrierte Kontext Objekt.
   - `accessMethod`: ein Delegat, der den tatsächlichen Zugriff ausführt.
   - `writeAccess`: `true`, wenn der Delegat die Auflistung ändert. Andernfalls `false`.

   Der <xref:System.Windows.Data.CollectionSynchronizationCallback> sollte eine Synchronisierung für die Sammlung einrichten (mit dem `context` Objekt und dem `writeAccess` Wert, falls zutreffend), den `accessMethod`aufzurufen und dann die Synchronisierung freigeben.

- Der <xref:System.Windows.Data.CollectionView> verwaltet eine "Schatten Kopie" der Sammlung für die Verwendung im UI-Thread.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> Ereignisse werden in die Warteschlange eingereiht, sobald sie eintreffen (in einem beliebigen Thread).

- Ausstehende Ereignisse werden im UI-Thread asynchron auf die Schatten Kopie angewendet, wenn Sie die Möglichkeit haben, dies zu erreichen.

- Der <xref:System.Windows.Data.CollectionView> verwendet nicht direkt einen anderen für die Anwendung sichtbaren Synchronisierungs Mechanismus. Dies ist die Methode von WPF zur Vermeidung von Deadlocks (siehe das vorherige Element 7).   

Der Nettoeffekt besteht darin, dass Sie die Sammlung in jedem Thread ändern können, und diese Änderungen werden schließlich in der <xref:System.Windows.Controls.ItemsControl> angezeigt, wenn der UI-Thread Zeit zum "aufholen" hat.  Die-Implementierung wurde optimiert, um die Rate zu drosseln, mit der Änderungen in den UI-Thread übertragen werden, um Hintergrundthreads daran zu halten, den UI-Thread zu sättige und die Antwort auf normale Benutzereingaben

 Der `context`-Parameter ist ein beliebiges Objekt, das an die `callback`übergeben wird. Sie können es verwenden, um den Synchronisierungs Mechanismus zu bestimmen, der zum Steuern des Zugriffs auf `collection`verwendet wird. `Context` können `null`werden.  
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.Binding GetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.Binding GetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBinding (target As DependencyObject, dp As DependencyProperty) As Binding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::Binding ^ GetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.Binding" Usage="System.Windows.Data.BindingOperations.GetBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.Binding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, das bei <paramref name="dp" /> ist.</param>
        <param name="dp">Die Bindungsziel-Eigenschaft, von der die Bindung abgerufen werden soll.</param>
        <summary>Ruft das für die angegebene Eigenschaft festgelegte <see cref="T:System.Windows.Data.Binding" />-Objekt ab.</summary>
        <returns>Das für die angegebene Eigenschaft festgelegte <see cref="T:System.Windows.Data.Binding" />-Objekt oder <see langword="null" />, wenn kein <see cref="T:System.Windows.Data.Binding" />-Objekt festgelegt wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="target" />-Parameter und der <paramref name="dp" />-Parameter können nicht NULL sein.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingBase GetBindingBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingBase GetBindingBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingBase (target As DependencyObject, dp As DependencyProperty) As BindingBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingBase ^ GetBindingBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingBase : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingBase" Usage="System.Windows.Data.BindingOperations.GetBindingBase (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, das bei <paramref name="dp" /> ist.</param>
        <param name="dp">Die Bindungszieleigenschaft, aus der das <see cref="T:System.Windows.Data.BindingBase" />-Objekt abgerufen werden soll.</param>
        <summary>Ruft das für die angegebene Eigenschaft festgelegte <see cref="T:System.Windows.Data.BindingBase" />-Objekt ab.</summary>
        <returns>Das für die angegebene Eigenschaft festgelegte <see cref="T:System.Windows.Data.BindingBase" />-Objekt oder <see langword="null" />, wenn kein Bindungsobjekt festgelegt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Data.BindingBase>-Klasse ist die allgemeine Basisklasse für die Klassen <xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>und <xref:System.Windows.Data.MultiBinding>. Sie können die Methoden <xref:System.Windows.Data.BindingOperations.GetBinding%2A>, <xref:System.Windows.Data.BindingOperations.GetPriorityBinding%2A>und <xref:System.Windows.Data.BindingOperations.GetMultiBinding%2A> verwenden, wenn Sie den Bindungstyp, der für die Eigenschaft festgelegt ist, vorab kennen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Parameter <paramref name="target" /> und <paramref name="dp" /> dürfen nicht gleich <see langword="null" /> sein.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpression (target As DependencyObject, dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="System.Windows.Data.BindingOperations.GetBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Das Bindungszielobjekt, zu dem <paramref name="dp" /> gehört.</param>
        <param name="dp">Die Bindungszieleigenschaft, aus der das <see cref="T:System.Windows.Data.BindingExpression" />-Objekt abgerufen werden soll.</param>
        <summary>Gibt das <see cref="T:System.Windows.Data.BindingExpression" />-Objekt zurück, das der angegebenen Bindungszieleigenschaft für das angegebene Objekt zugeordnet ist.</summary>
        <returns>Das <see cref="T:System.Windows.Data.BindingExpression" />-Objekt, das der angegebenen Eigenschaft zugeordnet ist, oder <see langword="null" />, wenn es kein Objekt gibt. Wenn ein <see cref="T:System.Windows.Data.PriorityBindingExpression" />-Objekt für die Eigenschaft festgelegt ist, wird der <see cref="P:System.Windows.Data.PriorityBindingExpression.ActiveBindingExpression" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Data.BindingExpression>-Objekt verwaltet die Verbindung zwischen der Bindungs Quelle und dem Bindungs Ziel. Sie können das <xref:System.Windows.Data.BindingExpression> Objekt abrufen, indem Sie diese statische Methode aufrufen, oder indem Sie die <xref:System.Windows.FrameworkElement.GetBindingExpression%2A>-Methode für ein Daten gebundenes <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement> Objekt aufrufen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Implementierung eines <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Ereignis Handlers, der die <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A>-Methode verwendet, um die <xref:System.Windows.Data.BindingExpression> abzurufen, und dann die <xref:System.Windows.Data.BindingExpression.DataItem%2A>-Eigenschaft für den Zugriff auf das Bindungs Quell Objekt aufruft.  
  
 Der <xref:System.Windows.Controls.TextBlock>`SavingsText` ist das Bindungs Zielobjekt, und <xref:System.Windows.Controls.TextBlock.Text%2A> ist die Bindungs Ziel Eigenschaft.  
  
 [!code-csharp[DirectionalBinding#OnRentRaise](~/samples/snippets/csharp/VS_Snippets_Wpf/DirectionalBinding/CSharp/Page1.xaml.cs#onrentraise)]
 [!code-vb[DirectionalBinding#OnRentRaise](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DirectionalBinding/VisualBasic/DirectionalBinding.vb#onrentraise)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Parameter <paramref name="target" /> und <paramref name="dp" /> dürfen nicht gleich <see langword="null" /> sein.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpressionBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase GetBindingExpressionBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase GetBindingExpressionBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpressionBase (target As DependencyObject, dp As DependencyProperty) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ GetBindingExpressionBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetBindingExpressionBase : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpressionBase" Usage="System.Windows.Data.BindingOperations.GetBindingExpressionBase (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, das bei <paramref name="dp" /> ist.</param>
        <param name="dp">Die Bindungszieleigenschaft, aus der das <see cref="T:System.Windows.Data.BindingExpressionBase" />-Objekt abgerufen werden soll.</param>
        <summary>Ruft das für die angegebene Eigenschaft festgelegte <see cref="T:System.Windows.Data.BindingExpressionBase" />-Objekt ab.</summary>
        <returns>Das für die angegebene Eigenschaft festgelegte <see cref="T:System.Windows.Data.BindingExpressionBase" />-Objekt oder <see langword="null" />, wenn kein Bindungsobjekt festgelegt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Data.BindingExpressionBase>-Klasse ist die allgemeine Basisklasse für die Klassen <xref:System.Windows.Data.BindingExpression>, <xref:System.Windows.Data.PriorityBindingExpression>und <xref:System.Windows.Data.MultiBindingExpression>. Sie können die Methoden <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A>, <xref:System.Windows.Data.BindingOperations.GetPriorityBindingExpression%2A>und <xref:System.Windows.Data.BindingOperations.GetMultiBindingExpression%2A> verwenden, wenn Sie den Typ der Bindung kennen, die für die-Eigenschaft festgelegt ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="target" />-Parameter und der <paramref name="dp" />-Parameter können nicht NULL sein.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBinding GetMultiBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBinding GetMultiBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBinding (target As DependencyObject, dp As DependencyProperty) As MultiBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBinding ^ GetMultiBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetMultiBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.MultiBinding" Usage="System.Windows.Data.BindingOperations.GetMultiBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, das bei <paramref name="dp" /> ist.</param>
        <param name="dp">Die Bindungsziel-Eigenschaft, von der die Bindung abgerufen werden soll.</param>
        <summary>Ruft das für die angegebene Eigenschaft festgelegte <see cref="T:System.Windows.Data.MultiBinding" />-Objekt ab.</summary>
        <returns>Das für die angegebene Eigenschaft festgelegte <see cref="T:System.Windows.Data.MultiBinding" />-Objekt oder <see langword="null" />, wenn kein <see cref="T:System.Windows.Data.MultiBinding" />-Objekt festgelegt wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="target" />-Parameter und der <paramref name="dp" />-Parameter können nicht NULL sein.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBindingExpression GetMultiBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBindingExpression GetMultiBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBindingExpression (target As DependencyObject, dp As DependencyProperty) As MultiBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBindingExpression ^ GetMultiBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetMultiBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.MultiBindingExpression" Usage="System.Windows.Data.BindingOperations.GetMultiBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Das Bindungszielobjekt, zu dem <paramref name="dp" /> gehört.</param>
        <param name="dp">Die Bindungszieleigenschaft, aus der das <see cref="T:System.Windows.Data.MultiBindingExpression" />-Objekt abgerufen werden soll.</param>
        <summary>Gibt das <see cref="T:System.Windows.Data.MultiBindingExpression" />-Objekt zurück, das der angegebenen Bindungszieleigenschaft für das angegebene Objekt zugeordnet ist.</summary>
        <returns>Das <see cref="T:System.Windows.Data.MultiBindingExpression" />-Objekt, das der angegebenen Eigenschaft zugeordnet ist, oder <see langword="null" />, wenn es kein Objekt gibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Windows.Data.MultiBindingExpression>-Objekt, das der angegebenen Eigenschaft zugeordnet ist, oder `null`, wenn es kein Objekt gibt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die Parameter <paramref name="target" /> und <paramref name="dp" /> dürfen nicht gleich <see langword="null" /> sein.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBinding GetPriorityBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBinding GetPriorityBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBinding (target As DependencyObject, dp As DependencyProperty) As PriorityBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBinding ^ GetPriorityBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetPriorityBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.PriorityBinding" Usage="System.Windows.Data.BindingOperations.GetPriorityBinding (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, das bei <paramref name="dp" /> ist.</param>
        <param name="dp">Die Bindungsziel-Eigenschaft, von der die Bindung abgerufen werden soll.</param>
        <summary>Ruft das für die angegebene Eigenschaft festgelegte <see cref="T:System.Windows.Data.PriorityBinding" />-Objekt ab.</summary>
        <returns>Das für die angegebene Eigenschaft festgelegte <see cref="T:System.Windows.Data.PriorityBinding" />-Objekt oder <see langword="null" />, wenn kein <see cref="T:System.Windows.Data.PriorityBinding" />-Objekt festgelegt wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="target" />-Parameter und der <paramref name="dp" />-Parameter können nicht NULL sein.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBindingExpression (target As DependencyObject, dp As DependencyProperty) As PriorityBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBindingExpression ^ GetPriorityBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member GetPriorityBindingExpression : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; System.Windows.Data.PriorityBindingExpression" Usage="System.Windows.Data.BindingOperations.GetPriorityBindingExpression (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Das Bindungszielobjekt, zu dem <paramref name="dp" /> gehört.</param>
        <param name="dp">Die Bindungszieleigenschaft, aus der das <see cref="T:System.Windows.Data.PriorityBindingExpression" />-Objekt abgerufen werden soll.</param>
        <summary>Gibt das <see cref="T:System.Windows.Data.PriorityBindingExpression" />-Objekt zurück, das der angegebenen Bindungszieleigenschaft für das angegebene Objekt zugeordnet ist.</summary>
        <returns>Das <see cref="T:System.Windows.Data.PriorityBindingExpression" />-Objekt, das der angegebenen Eigenschaft zugeordnet ist, oder <see langword="null" />, wenn es kein Objekt gibt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Die Parameter <paramref name="target" /> und <paramref name="dp" /> dürfen nicht gleich <see langword="null" /> sein.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindingGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindingGroups (root As DependencyObject) As ReadOnlyCollection(Of BindingGroup)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingGroup ^&gt; ^ GetSourceUpdatingBindingGroups(System::Windows::DependencyObject ^ root);" />
      <MemberSignature Language="F#" Value="static member GetSourceUpdatingBindingGroups : System.Windows.DependencyObject -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt;" Usage="System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="root">Das Stamm-<see cref="T:System.Windows.UIElement" />, für das Bindungsgruppen abgerufen werden.  Diese Methode gibt <see cref="T:System.Windows.Data.BindingGroup" />-Objekte zurück, die diesem Element oder seinen untergeordneten Elementen zugeordnet sind.</param>
        <summary>Ruft alle <see cref="T:System.Windows.Data.BindingGroup" />-Objekte ab, die ungültige Werte oder Zielwerte, die nicht aktualisiert wurden, aufweisen.</summary>
        <returns>Eine Sammlung von <see cref="T:System.Windows.Data.BindingGroup" />-Objekten, die dem angegebenen Element zugeordnet sind und ungültige Werte oder Zielwerte, die nicht aktualisiert wurden, aufweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `root` `null`ist, gibt <xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups%2A> alle <xref:System.Windows.Data.BindingGroup> Objekte zurück, die ungültig sind oder nicht aktualisiert wurden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindings">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindings (root As DependencyObject) As ReadOnlyCollection(Of BindingExpressionBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ GetSourceUpdatingBindings(System::Windows::DependencyObject ^ root);" />
      <MemberSignature Language="F#" Value="static member GetSourceUpdatingBindings : System.Windows.DependencyObject -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt;" Usage="System.Windows.Data.BindingOperations.GetSourceUpdatingBindings root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="root">Das Stamm-<see cref="T:System.Windows.UIElement" />, für das Bindungsgruppen abgerufen werden.  Diese Methode gibt <see cref="T:System.Windows.Data.BindingExpressionBase" />-Objekte zurück, die diesem Element oder seinen untergeordneten Elementen zugeordnet sind.</param>
        <summary>Ruft alle <see cref="T:System.Windows.Data.BindingExpressionBase" />-Objekte ab, die ungültige Werte oder Zielwerte, die nicht aktualisiert wurden, aufweisen.</summary>
        <returns>Eine Sammlung von <see cref="T:System.Windows.Data.BindingExpressionBase" />-Objekten, die dem angegebenen Element zugeordnet sind und ungültige Werte oder Zielwerte, die nicht aktualisiert wurden, aufweisen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `root` `null`ist, gibt <xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings%2A> alle <xref:System.Windows.Data.BindingExpressionBase> Objekte zurück, die ungültig sind oder nicht aktualisiert wurden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDataBound">
      <MemberSignature Language="C#" Value="public static bool IsDataBound (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDataBound(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.IsDataBound(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDataBound (target As DependencyObject, dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDataBound(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="static member IsDataBound : System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; bool" Usage="System.Windows.Data.BindingOperations.IsDataBound (target, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Das Objekt, das bei <paramref name="dp" /> ist.</param>
        <param name="dp">Die zu überprüfende Abhängigkeitseigenschaft.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Eigenschaft derzeit datengebunden ist.</summary>
        <returns><see langword="true" />, wenn die angegebene Eigenschaft datengebunden ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Wenn <paramref name="target" /> gleich <see langword="null" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetBinding (target As DependencyObject, dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="static member SetBinding : System.Windows.DependencyObject * System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="System.Windows.Data.BindingOperations.SetBinding (target, dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="target">Das Bindungsziel der Bindung.</param>
        <param name="dp">Die Zieleigenschaft der Bindung.</param>
        <param name="binding">Da <see cref="T:System.Windows.Data.BindingBase" />-Objekt, das die Bindung beschreibt.</param>
        <summary>Erstellt eine neue Instanz von <see cref="T:System.Windows.Data.BindingExpressionBase" /> und ordnet diese der angegebenen Bindungszieleigenschaft zu.</summary>
        <returns>Die Instanz von <see cref="T:System.Windows.Data.BindingExpressionBase" />, die für die angegebene Eigenschaft erstellt und dieser zugeordnet wurde. Die <see cref="T:System.Windows.Data.BindingExpressionBase" />-Klasse ist die Basisklasse von <see cref="T:System.Windows.Data.BindingExpression" />, <see cref="T:System.Windows.Data.MultiBindingExpression" /> und <see cref="T:System.Windows.Data.PriorityBindingExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine neue Instanz eines <xref:System.Windows.Data.BindingExpressionBase> und ordnet die-Instanz der angegebenen Abhängigkeits Eigenschaft des angegebenen-Objekts zu. Diese Methode ist die Möglichkeit, eine Bindung an eine beliebige <xref:System.Windows.DependencyObject> anzufügen, die möglicherweise nicht Ihre eigene SetBinding-Methode verfügbar macht.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie diese Methode verwendet wird, um eine Bindung festzulegen. In diesem Beispiel ist `myNewBindDef` ein <xref:System.Windows.Data.Binding> Objekt, das die Bindung beschreibt. Das Bindungs Ziel ist `myDateText`, eine Instanz der <xref:System.Windows.Controls.TextBlock>-Klasse.  
  
 [!code-csharp[BindConversion#BOSetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/BindConversion/CSharp/Window1.xaml.cs#bosetbinding)]
 [!code-vb[BindConversion#BOSetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindConversion/visualbasic/window1.xaml.vb#bosetbinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="binding" />-Parameter darf nicht <see langword="null" /> sein.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
