<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="403111ea96a944cbf2b6adc84b6c3caf3ed6e344" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58686816" /></Metadata><TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <TypeSignature Language="F#" Value="type DynamicObject = class&#xA;    interface IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Basisklasse zum Angeben von dynamischen Verhalten zur Laufzeit bereit. Aus dieser Klasse muss geerbt werden, und sie kann nicht direkt instanziiert werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `DynamicObject` -Klasse können Sie definieren, welche Vorgänge für dynamische Objekte ausgeführt werden können und wie diese Vorgänge ausgeführt. Beispielsweise können Sie definieren, was geschieht, wenn Sie versuchen, Abrufen oder eine Objekteigenschaft festlegen, eine Methode aufrufen oder standard mathematische Operationen wie Addition und Multiplikation durchführen.  
  
 Diese Klasse ist nützlich, wenn Sie ein praktischer Protokoll für eine Bibliothek erstellen möchten. Wenn Benutzer der Bibliothek verwenden eine Syntax wie beispielsweise `Scriptobj.SetProperty("Count", 1)`, Sie bieten die Möglichkeit, viel einfachere Syntax, zu verwenden, etwa `scriptobj.Count = 1`.  
  
 Sie können eine Instanz der nicht direkt erstellen die `DynamicObject` Klasse. Um das dynamische Verhalten zu implementieren, sollten Sie das erben die `DynamicObject` Klasse, und überschreiben Sie die erforderlichen Methoden. Z. B. Wenn Sie nur Vorgänge zum Festlegen und Abrufen von Eigenschaften benötigen, können Sie überschreiben lediglich die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden.  
  
 In C# geschrieben, um dynamisches Verhalten zu aktivieren, für die Instanzen von Klassen abgeleitet der `DynamicObject` -Klasse, müssen Sie verwenden die `dynamic` Schlüsselwort. Weitere Informationen finden Sie unter [Verwenden von dynamischen Typen](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 In Visual Basic werden die dynamischen Vorgänge durch späte Bindung unterstützt. Weitere Informationen finden Sie unter [frühes und spätes Binden](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie eine Instanz einer Klasse zu erstellen, das von abgeleitet ist die `DynamicObject` Klasse.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 Sie können auch eigene Member hinzufügen, um Klassen, die von der `DynamicObject` Klasse. Wenn Ihre Klasse Eigenschaften definiert und auch überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> -Methode, die dynamic Language Runtime (DLR) verwendet zuerst die Sprache Binder nach einer Eigenschaft in der Klasse eine statische Definition gesucht werden soll. Wenn keine solche Eigenschaft vorhanden ist, ruft die DLR die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> Methode.  
  
 Die `DynamicObject` Klasse implementiert die Schnittstelle für die DLR <xref:System.Dynamic.IDynamicMetaObjectProvider>, können Sie Instanzen von Teilen der `DynamicObject` Klassenschema in Sprachen, die das Modell der DLR-Interoperabilität unterstützen. Sie können z. B. erstellen eine Instanz von der `DynamicObject` in C#-Klasse, und klicken Sie dann an eine IronPython-Funktion übergeben. Weitere Informationen finden Sie unter [Übersicht über die Dynamic Language Runtime](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md).  
  
> [!NOTE]
>  Wenn Sie ein einfaches Szenario haben, in denen, die Sie ein Objekt benötigen, das nur hinzufügen und Entfernen von Mitgliedern zur Laufzeit jedoch, die nicht auf bestimmte Vorgänge definieren und nicht statische Member aufweisen, verwenden Sie, die <xref:System.Dynamic.ExpandoObject> Klasse.  
>   
>  Wenn Sie ein erweitertes Szenario haben, in denen Sie definieren, wie dynamische Objekte, die Interoperabilitätsprotokoll teilnehmen aus, oder Sie müssen zum Zwischenspeichern von DLR schnellen dynamischen Versand verwalten müssen, erstellen Sie eine eigene Implementierung der <xref:System.Dynamic.IDynamicMetaObjectProvider> Schnittstelle.  
  
   
  
## Examples  
 Angenommen, Sie alternative Syntax bereitstellen, für den Zugriff auf Werte in einem Wörterbuch, also, dass anstelle des Schreibens möchten `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), können Sie schreiben `sampleDictionary.Text = "Sample text"`. Darüber hinaus soll diese Syntax als Groß-/Kleinschreibung, sodass `sampleDictionary.Text` entspricht `sampleDictionary.text`.  
  
 Im folgenden Codebeispiel wird veranschaulicht, die `DynamicDictionary` -Klasse, die von abgeleitet ist die `DynamicObject` Klasse. Die `DynamicDictionary` Klasse enthält ein Objekt des der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern der Schlüssel-Wert-Paare und überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum unterstützen der neuen Syntax. Es bietet auch eine `Count` Eigenschaft, die zeigt, wie viele dynamischen Eigenschaften des Wörterbuchs enthält.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 Weitere Beispiele finden Sie unter [Erstellen von Wrappern mit DynamicObject](https://devblogs.microsoft.com/csharpfaq/dynamic-in-c-4-0-creating-wrappers-with-dynamicobject/) Blog des C#-häufig gestellte Fragen.  
 
 
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Ermöglicht es abgeleiteten Typen, eine neue Instanz des <see cref="T:System.Dynamic.DynamicObject" />-Typs zu initialisieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können eine Instanz der nicht direkt erstellen die <xref:System.Dynamic.DynamicObject> Klasse. Um dynamisches Verhalten zu implementieren, müssen Sie erben die <xref:System.Dynamic.DynamicObject> Klasse, und überschreiben Sie die erforderlichen Methoden.  
  
 In C# geschrieben, um dynamisches Verhalten zu aktivieren, für die Instanzen der Klassen abgeleitet der <xref:System.Dynamic.DynamicObject> -Klasse, müssen Sie verwenden die `dynamic` Schlüsselwort. Weitere Informationen finden Sie unter [Verwenden von dynamischen Typen](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 In Visual Basic werden die dynamischen Vorgänge durch späte Bindung unterstützt. Weitere Informationen finden Sie unter [frühes und spätes Binden](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine Instanz der Klassen zu erstellen, das von abgeleitet werden die <xref:System.Dynamic.DynamicObject> Klasse.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;&#xA;override this.GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;" Usage="dynamicObject.GetDynamicMemberNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Enumeration aller dynamischen Membernamen zurück.</summary>
        <returns>Eine Sequenz, die dynamische Membernamen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt es nur für Debugzwecke bestimmt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject&#xA;override this.GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject" Usage="dynamicObject.GetMetaObject parameter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">Der Ausdruck, der das an die dynamischen virtuellen Methoden zu sendende <see cref="T:System.Dynamic.DynamicMetaObject" /> darstellt.</param>
        <summary>Stellt ein <see cref="T:System.Dynamic.DynamicMetaObject" /> bereit, das an die dynamischen virtuellen Methoden sendet. Das Objekt kann in einem anderen <see cref="T:System.Dynamic.DynamicMetaObject" /> gekapselt werden, um benutzerdefiniertes Verhalten für einzelne Aktionen bereitzustellen. Diese Methode unterstützt die Dynamic Language Runtime-Infrastruktur für Sprachimplementierungen und ist nicht für die direkte Verwendung im Code vorgesehen.</summary>
        <returns>Ein Objekt des <see cref="T:System.Dynamic.DynamicMetaObject" />-Typs.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool&#xA;override this.TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool" Usage="dynamicObject.TryBinaryOperation (binder, arg, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zur binären Operation bereit. Die <c>binder.Operation</c>-Eigenschaft gibt ein <see cref="T:System.Linq.Expressions.ExpressionType" />-Objekt zurück. Für die Anweisung <c>sum = first + second</c>, bei der <c>first</c> und <c>second</c> von der <see langword="DynamicObject" />-Klasse abgeleitet wurden, gibt <c>binder.Operation</c> beispielsweise <c>ExpressionType.Add</c> zurück.</param>
        <param name="arg">Der rechte Operand für die binäre Operation. Für die Anweisung <c>sum = first + second</c>, bei der <c>first</c> und <c>second</c> von der <see langword="DynamicObject" />-Klasse abgeleitet wurden, ist <paramref name="arg" /> beispielsweise gleich <c>second</c>.</param>
        <param name="result">Das Ergebnis der binären Operation.</param>
        <summary>Stellt die Implementierung für binäre Operationen bereit. Von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitete Klassen können diese Methode überschreiben, um dynamisches Verhalten für Operationen wie Addition oder Multiplikation anzugeben.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie die binäre Operationen für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 Diese Methode wird aufgerufen, wenn Sie die binäre Operationen wie Addition und Multiplikation verfügen. Z. B. wenn die <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> -Methode überschrieben wird, wird automatisch aufgerufen, für Anweisungen wie `sum = first + second` oder `multiply = first*second`, wobei `first` ergibt sich aus der `DynamicObject` Klasse.  
  
 Sie erhalten Informationen über den Typ der binären Operation mit den `Operation` Eigenschaft der `binder` Parameter.  
  
 Wenn das dynamische Objekt, nur in C# und Visual Basic verwendet wird die `binder.Operation` Eigenschaft sind die folgenden Werte aus der <xref:System.Linq.Expressions.ExpressionType> Enumeration. In anderen Sprachen wie IronPython oder IronRuby erstellen, können Sie jedoch andere Werte haben.
  
|Wert|Beschreibung |C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|Eine Addition ohne überlaufüberprüfung für numerische Operanden.|`a + b`|`a + b`|  
|`AddAssign`|Eine zusammengesetzte additionszuweisungsoperation ohne überlaufüberprüfung für numerische Operanden.|`a += b`|Wird nicht unterstützt.|  
|`And`|Eine bitweise `AND` Vorgang.|`a & b`|`a And b`|  
|`AndAssign`|Eine bitweise `AND` -Zuweisungsvorgang.|`a &= b`|Wird nicht unterstützt.|  
|`Divide`|Eine arithmetische Division.|`a / b`|`a / b`|  
|`DivideAssign`|Eine arithmetische zusammengesetzte Zuweisungsoperation.|`a /= b`|Wird nicht unterstützt.|  
|`ExclusiveOr`|Eine bitweise `XOR` Vorgang.|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|Eine bitweise `XOR` -Zuweisungsvorgang.|`a ^= b`|Wird nicht unterstützt.|  
|`GreaterThan`|Ein "größer als"-Vergleich an.|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|Eine Prüfung auf "größer als oder gleich".|`a >= b`|Wird nicht unterstützt.|  
|`LeftShift`|Eine bitweise Linksschiebe-Operation.|`a << b`|`a << b`|  
|`LeftShiftAssign`|Eine bitweise zusammengesetzte Linksschiebezuweisung-Vorgang.|`a <<= b`|Wird nicht unterstützt.|  
|`LessThan`|Ein Vergleich "kleiner als".|`a < b`|`a < b`|  
|`LessThanOrEqual`|Ein "kleiner als oder gleich"-Vergleich.|`a <= b`|Wird nicht unterstützt.|  
|`Modulo`|Eine arithmetische Restoperation.|`a % b`|`a Mod b`|  
|`ModuloAssign`|Eine arithmetische zusammengesetzte Restzuweisungsoperation.|`a %= b`|Wird nicht unterstützt.|  
|`Multiply`|Ein Multiplikationsvorgang ohne überlaufüberprüfung für numerische Operanden.|`a * b`|`a * b`|  
|`MultiplyAssign`|Eine zusammengesetzte multiplikationszuweisungsoperation ohne überlaufüberprüfung für numerische Operanden.|`a *= b`|Wird nicht unterstützt.|  
|`NotEqual`|Ein Ungleichheitsvergleich.|`a != b`|`a <> b`|  
|`Or`|Eine bitweise oder logische `OR` Vorgang.|`a &#124; b`|`a Or b`|  
|`OrAssign`|Eine bitweise oder logische `OR` verbundzuweisung.|`a &#124;= b`|Wird nicht unterstützt.|  
|`Power`|Eine mathematische Operation des Potenzieren einer Zahl in eine Potenz.|Wird nicht unterstützt.|`a ^ b`|  
|`RightShift`|Eine bitweise Rechtsschiebe-Operation.|`a >> b`|`a >> b`|  
|`RightShiftAssign`|Eine bitweise Rechtsschiebe-Zuweisungsoperation zusammengesetzten.|`a >>= b`|Wird nicht unterstützt.|  
|`Subtract`|Eine Subtraktion ohne überlaufüberprüfung für numerische Operanden.|`a - b`|`a - b`|  
|`SubtractAssign`|Eine zusammengesetzte subtraktionszuweisungsoperation ohne überlaufüberprüfung für numerische Operanden.|`a -= b`|Wird nicht unterstützt.|  
  
> [!NOTE]
>  Zum Implementieren `OrElse` (`a || b`) und `AndAlso` (`a && b`) Vorgänge für dynamische Objekte in C#, Sie möchten beide implementieren die <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> Methode und die <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> Methode.  
>   
>  Die `OrElse` Vorgang besteht aus den unären `IsTrue` Vorgang und den binären `Or` Vorgang. Die `Or` Vorgang erfolgt nur, wenn das Ergebnis der `IsTrue` Vorgang `false`.  
>   
>  Die `AndAlso` Vorgang besteht aus den unären `IsFalse` Vorgang und den binären `And` Vorgang. Die `And` Vorgang erfolgt nur, wenn das Ergebnis der `IsFalse` Vorgang `false`.  
  
   
  
## Examples  
 Angenommen Sie, Sie eine Datenstruktur zum Speichern von Text und die numerische Darstellung von Zahlen benötigen, und Sie einfache mathematische Operationen wie Addition und Subtraktion für solche Daten definieren möchten.  
  
 Im folgenden Codebeispiel wird veranschaulicht, die `DynamicNumber` -Klasse, die von abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. `DynamicNumber` überschreibt die <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> Methode, um die mathematische Operationen zu aktivieren. Außerdem überschreibt er die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden, um den Zugriff auf die Elemente zu ermöglichen.  
  
 In diesem Beispiel werden nur die Operationen Addition und Subtraktion unterstützt. Wenn Sie versuchen, eine Anweisung wie schreiben `resultNumber = firstNumber*secondNumber`, wird eine Laufzeitausnahme ausgelöst.  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool&#xA;override this.TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool" Usage="dynamicObject.TryConvert (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zur Konvertierungsoperation bereit. Die <c>binder.Type</c>-Eigenschaft stellt den Typ bereit, in den das Objekt konvertiert werden muss. Für die Anweisung <c>(String)sampleObject</c> in C# (<c>CType(sampleObject, Type)</c> in Visual Basic), bei der <c>sampleObject</c> eine Instanz der Klasse ist, die von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitet wurde, gibt <c>binder.Type</c> beispielsweise den <see cref="T:System.String" />-Typ zurück. Die <c>binder.Explicit</c>-Eigenschaft stellt Informationen zur Art der ausgeführten Konvertierung bereit. Für die explizite Konvertierung wird <see langword="true" /> und für die implizite Konvertierung wird <see langword="false" /> zurückgegeben.</param>
        <param name="result">Das Ergebnis des Typkonvertierungsvorgangs.</param>
        <summary>Stellt die Implementierung für Typkonvertierungsvorgänge bereit. Von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitete Klassen können diese Methode überschreiben, um dynamisches Verhalten für Operationen anzugeben, die ein Objekt von einem Typ in einen anderen konvertieren.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie eine typkonvertierung für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 In C# geschrieben Wenn diese Methode überschrieben wird, wird sie automatisch aufgerufen, wenn Sie eine explizite oder implizite Konvertierung haben wie im folgenden Codebeispiel wird gezeigt.  
  
 In Visual Basic wird nur die explizite Konvertierung unterstützt. Wenn Sie diese Methode überschreiben, rufen Sie sie mithilfe der <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> oder <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> Funktionen.  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 Angenommen Sie, Sie eine Datenstruktur zum Speichern von Text und die numerische Darstellung von Zahlen benötigen und zum Definieren von Konvertierungen von dieser Datenstruktur für Zeichenfolgen und Zahlen werden sollen.  
  
 Im folgenden Codebeispiel wird veranschaulicht, die `DynamicNumber` -Klasse, die von abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. `DynamicNumber` überschreibt die <xref:System.Dynamic.DynamicObject.TryConvert%2A> Methode zum Aktivieren von typkonvertierung. Außerdem überschreibt er die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum Aktivieren des Zugriffs auf die Datenelemente.  
  
 In diesem Beispiel wird nur die Konvertierung in Zeichenfolgen und Zahlen unterstützt. Wenn Sie versuchen, ein Objekt in einen anderen Typ zu konvertieren, wird eine Laufzeitausnahme ausgelöst.  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool&#xA;override this.TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryCreateInstance (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zum Initialisierungsvorgang bereit.</param>
        <param name="args">Die Argumente, die während der Initialisierung an das Objekt übergeben werden. Für den Vorgang <c>new SampleType(100)</c>, bei dem <c>SampleType</c> der Typ ist, der von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitet wurde, ist <c>args[0]</c> beispielsweise gleich 100.</param>
        <param name="result">Das Ergebnis der Initialisierung.</param>
        <summary>Stellt die Implementierung für Vorgänge bereit, die eine neue Instanz eines dynamischen Objekts initialisieren. Diese Methode ist nicht zur Verwendung in C# oder Visual Basic vorgesehen.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie eine neue Instanz des dynamischen Objekts initialisiert werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 C# und Visual Basic-Compiler geben nie Code aus, um diese Methode verwenden, da sie nicht über die erstklassige Typen unterstützen. Diese Methode ist für Sprachen, die die Initialisierung von dynamischen Objekten zu unterstützen, indem Sie mit einer Syntax wie vorgesehen `dynamic new`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool&#xA;override this.TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool" Usage="dynamicObject.TryDeleteIndex (binder, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zum Löschen bereit.</param>
        <param name="indexes">Die zu löschenden Indizes.</param>
        <summary>Stellt die Implementierung für Vorgänge bereit, die ein Objekt nach Index löschen. Diese Methode ist nicht zur Verwendung in C# oder Visual Basic vorgesehen.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie ein Wert, der einem angegebenen Index gelöscht werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 C# und Visual Basic-Compiler geben nie Code aus, um diese Methode verwenden, da sie nicht über diese Art von Vorgang unterstützen. Diese Methode ist für Sprachen, die Syntax zum Löschen von Objekten wie z. B. nach Index unterstützen vorgesehen `del sampleObject[1,2]` in Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool&#xA;override this.TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool" Usage="dynamicObject.TryDeleteMember binder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zum Löschen bereit.</param>
        <summary>Stellt die Implementierung für Vorgänge bereit, die einen Objektmember löschen. Diese Methode ist nicht zur Verwendung in C# oder Visual Basic vorgesehen.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie ein Objektmember gelöscht werden soll. Wenn diese Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 C# und Visual Basic-Compiler geben nie Code aus, um diese Methode verwenden, da sie nicht über diese Art von Vorgang unterstützen. Diese Methode ist für Sprachen, die Syntax zum Löschen von Elementen, z. B. unterstützen vorgesehen `del sampleObject.SampleMember` in Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool&#xA;override this.TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryGetIndex (binder, indexes, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zum Vorgang bereit.</param>
        <param name="indexes">Die Indizes, die bei dem Vorgang verwendet werden. Für den Vorgang <c>sampleObject[3]</c> in C# (<c>sampleObject(3)</c> in Visual Basic), bei dem <c>sampleObject</c> von der <see langword="DynamicObject" />-Klasse abgeleitet wurde, ist <c>indexes[0]</c> beispielsweise gleich 3.</param>
        <param name="result">Das Ergebnis des Indexvorgangs.</param>
        <summary>Stellt die Implementierung für Vorgänge bereit, die einen Wert nach Index abrufen. Von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitete Klassen können diese Methode überschreiben, um dynamisches Verhalten für Indexvorgänge anzugeben.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie das Abrufen eines Werts über einen Index für ein dynamisches Objekt ausgeführt werden sollte. Wenn die Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine Laufzeitausnahme ausgelöst.)  
  
 Wenn diese Methode überschrieben wird, wird Sie automatisch aufgerufen, wenn ein Vorgang wie vorliegt `sampleObject[3]` in C# oder `sampleObject(3)` in Visual Basic, wobei `sampleObject` ergibt sich aus der <xref:System.Dynamic.DynamicObject> Klasse.  
  
   
  
## Examples  
 Wird davon ausgegangen, dass Sie ein Objekt zu erstellen, in denen Eigenschaften können sein, möchten Zugriff auf durch die Namen z. B. `Property0`, `Property1`, und so weiter, oder anhand des Indexes, damit, z. B. `sampleObject.Property0` entspricht `sampleObject[0]` in C# geschrieben oder `sampleObject(0)` in Visual Basic.  
  
 Im folgenden Codebeispiel wird veranschaulicht, die `SampleDynamicObject` -Klasse, die von abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. Die `SampleDynamicObject` -Klasse enthält ein Objekt von der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern von Schlüssel-Wert-Paare. `SampleDynamicObject` überschreibt die <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> und <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> Methoden zum Aktivieren des Zugriffs nach Index. Es überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum Aktivieren des Zugriffs nach Eigenschaftenname an.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool&#xA;override this.TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool" Usage="dynamicObject.TryGetMember (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zum Objekt bereit, das den dynamischen Vorgang aufgerufen hat. Die <c>binder.Name</c>-Eigenschaft gibt den Namen des Members an, für den der dynamische Vorgang ausgeführt wird. Für die Anweisung <c>Console.WriteLine(sampleObject.SampleProperty)</c>, bei der <c>sampleObject</c> eine Instanz der Klasse ist, die von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitet wurde, gibt <c>binder.Name</c> beispielsweise „SampleProperty“ zurück. Die <c>binder.IgnoreCase</c>-Eigenschaft gibt an, ob der Membername die Groß-/Kleinschreibung berücksichtigt.</param>
        <param name="result">Das Ergebnis des get-Vorgangs. Wenn die Methode z. B. für eine Eigenschaft aufgerufen wird, können Sie <paramref name="result" /> den Eigenschaftswert zuweisen.</param>
        <summary>Stellt die Implementierung für Vorgänge bereit, die Memberwerte abrufen. Von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitete Klassen können diese Methode überschreiben, um dynamisches Verhalten für Vorgänge wie das Abrufen eines Werts für eine Eigenschaft anzugeben.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie die Vorgänge, die Elementwerte abrufen für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine Laufzeitausnahme ausgelöst.)  
  
 Diese Methode wird aufgerufen, wenn Sie die Anweisungen wie verfügen `Console.WriteLine(sampleObject.SampleProperty)`, wobei `sampleObject` ist eine Instanz der abgeleiteten Klasse von der <xref:System.Dynamic.DynamicObject> Klasse.  
  
 Sie können auch eigene Member hinzufügen, um Klassen, die von der `DynamicObject` Klasse. Wenn Ihre Klasse Eigenschaften definiert und auch überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> -Methode, die dynamic Language Runtime (DLR) verwendet zuerst die Sprache Binder nach einer Eigenschaft in der Klasse eine statische Definition gesucht werden soll. Wenn keine solche Eigenschaft vorhanden ist, ruft die DLR die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> Methode.  
  
   
  
## Examples  
 Angenommen, Sie alternative Syntax bereitstellen, für den Zugriff auf Werte in einem Wörterbuch, also, dass anstelle des Schreibens möchten `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), können Sie schreiben `sampleDictionary.Text = "Sample text"`. Darüber hinaus muss diese Syntax Groß-/Kleinschreibung, sodass `sampleDictionary.Text` entspricht `sampleDictionary.text`.  
  
 Im folgenden Codebeispiel wird veranschaulicht, die `DynamicDictionary` -Klasse, die von abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. Die `DynamicDictionary` Klasse enthält ein Objekt des der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern der Schlüssel-Wert-Paare und überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum unterstützen der neuen Syntax. Es bietet auch eine `Count` Eigenschaft, die zeigt, wie viele dynamischen Eigenschaften des Wörterbuchs enthält.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool&#xA;override this.TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvoke (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zum Aufrufvorgang bereit.</param>
        <param name="args">Die Argumente, die während des Aufrufvorgangs an das Objekt übergeben werden. Für den Vorgang <c>sampleObject(100)</c>, bei dem <c>sampleObject</c> von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitet wurde, ist <c>args[0]</c> beispielsweise gleich 100.</param>
        <param name="result">Das Ergebnis des Objektaufrufs.</param>
        <summary>Stellt die Implementierung für Vorgänge bereit, die ein Objekt aufrufen. Von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitete Klassen können diese Methode überschreiben, um dynamisches Verhalten für Vorgänge wie das Aufrufen eines Objekts oder Delegaten anzugeben.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie die Vorgänge, die ein Objekt aufgerufen werden für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine Laufzeitausnahme ausgelöst.)  
  
 Wenn diese Methode überschrieben wird, wird Sie automatisch aufgerufen, wenn ein Vorgang wie vorliegt `sampleObject(100)`, wobei `sampleObject` ergibt sich aus der <xref:System.Dynamic.DynamicObject> Klasse.  
  
 Der Vorgang zum Aufrufen eines Objekts wird in C#, aber nicht in Visual Basic unterstützt. Visual Basic-Compiler gibt nie Code zur Verwendung dieser Methode aus, und Visual Basic-Sprache unterstützt nicht die Syntax wie `sampleObject(100)`.  
  
   
  
## Examples  
 Angenommen Sie, Sie eine Datenstruktur zum Speichern von Text und die numerische Darstellung von Zahlen benötigen. Sie möchten den Wert für jede Eigenschaft einzeln angeben und auch, um alle Eigenschaften in einer einzelnen Anweisung initialisieren zu können.  
  
 Im folgenden Codebeispiel wird veranschaulicht, die `DynamicNumber` -Klasse, die von abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. `DynamicNumber` überschreibt die <xref:System.Dynamic.DynamicObject.TryInvoke%2A> Methode, um die Initialisierung aller Eigenschaften gleichzeitig zu aktivieren. Außerdem überschreibt er die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden, um den Zugriff auf einzelne Objekt – Eigenschaften ermöglichen.  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool&#xA;override this.TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvokeMember (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zum dynamischen Vorgang bereit. Die <c>binder.Name</c>-Eigenschaft gibt den Namen des Members an, für den der dynamische Vorgang ausgeführt wird. Für die Anweisung <c>sampleObject.SampleMethod(100)</c>, bei der <c>sampleObject</c> eine Instanz der Klasse ist, die von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitet wurde, gibt <c>binder.Name</c> beispielsweise „SampleMethod“ zurück. Die <c>binder.IgnoreCase</c>-Eigenschaft gibt an, ob der Membername die Groß-/Kleinschreibung berücksichtigt.</param>
        <param name="args">Die Argumente, die während des Aufrufvorgangs an den Objektmember übergeben werden. Für die Anweisung <c>sampleObject.SampleMethod(100)</c>, bei der <c>sampleObject</c> von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitet wurde, ist <c>args[0]</c> beispielsweise gleich 100.</param>
        <param name="result">Das Ergebnis des Memberaufrufs.</param>
        <summary>Stellt die Implementierung für Vorgänge bereit, die einen Member aufrufen. Von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitete Klassen können diese Methode überschreiben, um dynamisches Verhalten für Vorgänge wie das Aufrufen einer Methode anzugeben.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie Vorgänge, die einen Objektmember aufrufen für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 Wenn diese Methode außer Kraft gesetzt wird, wird Sie automatisch aufgerufen, bei der Durchführung von Operationen wie `sampleObject.SampleMethod(100)`, wobei `sampleObject` ergibt sich aus der `DynamicObject` Klasse.  
  
 Sie können auch Ihren eigenen Methoden hinzufügen, um Klassen, die abgeleitet sind die <xref:System.Dynamic.DynamicObject> Klasse. Angenommen, Sie überschreiben die <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> -Methode, dynamischen Verteiler versucht das System zuerst zu bestimmen, ob die angegebene Methode in der Klasse vorhanden ist. Wenn sie die Methode nicht gefunden wird, wird die <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> Implementierung.  
  
 Diese Methode unterstützt keine `ref` und `out` Parameter. Alle Parameter in der `args` Array als Wert übergeben werden.  
  
   
  
## Examples  
 Angenommen, Sie alternative Syntax bereitstellen, für den Zugriff auf Werte in einem Wörterbuch, also, dass anstelle des Schreibens möchten `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), können Sie schreiben `sampleDictionary.Text = "Sample text"`. Darüber hinaus möchten alle standard-Wörterbuch-Methoden auf dieses Wörterbuch aufrufen kann.  
  
 Im folgenden Codebeispiel wird veranschaulicht, die `DynamicDictionary` -Klasse, die von abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. Die `DynamicDictionary` -Klasse enthält ein Objekt von der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern von Schlüssel-Wert-Paare. Überschreibt es die <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> Methode, um die Methoden zum unterstützen der <xref:System.Collections.Generic.Dictionary%602> -Klasse und überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum unterstützen der neuen Syntax. Es bietet auch eine `Print` -Methode, die alle Wörterbuchschlüssel und Werte ausgibt.  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TrySetIndex (binder, indexes, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zum Vorgang bereit.</param>
        <param name="indexes">Die Indizes, die bei dem Vorgang verwendet werden. Für den Vorgang <c>sampleObject[3] = 10</c> in C# (<c>sampleObject(3) = 10</c> in Visual Basic), bei dem <c>sampleObject</c> von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitet wurde, ist <c>indexes[0]</c> beispielsweise gleich 3.</param>
        <param name="value">Der Wert, der auf das Objekt mit dem angegebenen Index festgelegt werden soll. Für den Vorgang <c>sampleObject[3] = 10</c> in C# (<c>sampleObject(3) = 10</c> in Visual Basic), bei dem <c>sampleObject</c> von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitet wurde, ist <paramref name="value" /> beispielsweise gleich 10.</param>
        <summary>Stellt die Implementierung für Vorgänge bereit, die einen Wert nach Index festlegen. Von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitete Klassen können diese Methode überschreiben, um dynamisches Verhalten für Vorgänge anzugeben, die auf Objekte mit einem angegebenen Index zugreifen.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie Vorgänge, bei denen ein Objekt nach Index für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 Wenn diese Methode überschrieben wird, wird Sie automatisch aufgerufen, wenn ein Vorgang wie vorliegt `sampleObject[3] = 10` in C# oder `sampleObject(3) = 10` in Visual Basic, wobei `sampleObject` ergibt sich aus der <xref:System.Dynamic.DynamicObject> Klasse.  
  
   
  
## Examples  
 Wird davon ausgegangen, dass Sie ein Objekt zu erstellen, in denen Eigenschaften können sein, möchten Zugriff auf durch die Namen z. B. `Property0`, `Property1`, und so weiter, oder anhand des Indexes, damit, z. B. `sampleObject.Property0` entspricht `sampleObject[0]` in C# geschrieben oder `sampleObject(0)` in Visual Basic.  
  
 Im folgenden Codebeispiel wird veranschaulicht, die `SampleDynamicObject` -Klasse, die von abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. Die `SampleDynamicObject` -Klasse enthält ein Objekt von der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern von Schlüssel-Wert-Paare. `SampleDynamicObject` überschreibt die <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> und <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> Methoden zum Aktivieren des Zugriffs nach Index. Es überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum Aktivieren des Zugriffs nach Eigenschaftenname an.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool&#xA;override this.TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TrySetMember (binder, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zum Objekt bereit, das den dynamischen Vorgang aufgerufen hat. Die <c>binder.Name</c>-Eigenschaft gibt den Namen des Members an, dem der Wert zugewiesen wird. Für die Anweisung <c>sampleObject.SampleProperty = "Test"</c>, bei der <c>sampleObject</c> eine Instanz der Klasse ist, die von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitet wurde, gibt <c>binder.Name</c> beispielsweise „SampleProperty“ zurück. Die <c>binder.IgnoreCase</c>-Eigenschaft gibt an, ob der Membername die Groß-/Kleinschreibung berücksichtigt.</param>
        <param name="value">Der Wert, der auf den Member festgelegt werden soll. Für die Anweisung <c>sampleObject.SampleProperty = "Test"</c>, bei der <c>sampleObject</c> eine Instanz der Klasse ist, die von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitet wurde, ist <paramref name="value" />beispielsweise „Test“.</param>
        <summary>Stellt die Implementierung für Vorgänge bereit, die Memberwerte festlegen. Von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitete Klassen können diese Methode überschreiben, um dynamisches Verhalten für Vorgänge wie das Festlegen eines Werts für eine Eigenschaft anzugeben.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie Vorgänge, die einen Wert, auf einen Member festzulegen für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 Diese Methode wird aufgerufen, wenn Sie die Anweisungen wie verfügen `sampleObject.SampleProperty = "Test"`, wobei `sampleObject` ist eine Instanz der Klasse abgeleitet ist, die die <xref:System.Dynamic.DynamicObject> Klasse.  
  
 Sie können auch eigene Member hinzufügen, um Klassen, die von der `DynamicObject` Klasse. Wenn Ihre Klasse Eigenschaften definiert und auch überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> -Methode, die dynamic Language Runtime (DLR) verwendet zuerst die Sprache Binder nach einer Eigenschaft in der Klasse eine statische Definition gesucht werden soll. Wenn keine solche Eigenschaft vorhanden ist, ruft die DLR die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> Methode.  
  
   
  
## Examples  
 Angenommen, Sie alternative Syntax bereitstellen, für den Zugriff auf Werte in einem Wörterbuch, also, dass anstelle des Schreibens möchten `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), können Sie schreiben `sampleDictionary.Text = "Sample text"`. Darüber hinaus muss diese Syntax Groß-/Kleinschreibung, sodass `sampleDictionary.Text` entspricht `sampleDictionary.text`.  
  
 Im folgenden Codebeispiel wird veranschaulicht, die `DynamicDictionary` -Klasse, die von abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. Die `DynamicDictionary` Klasse enthält ein Objekt des der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern der Schlüssel-Wert-Paare und überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum unterstützen der neuen Syntax. Es bietet auch eine `Count` Eigenschaft, die zeigt, wie viele dynamischen Eigenschaften des Wörterbuchs enthält.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool&#xA;override this.TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool" Usage="dynamicObject.TryUnaryOperation (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Stellt Informationen zur unären Operation bereit. Die <c>binder.Operation</c>-Eigenschaft gibt ein <see cref="T:System.Linq.Expressions.ExpressionType" />-Objekt zurück. Für die Anweisung <c>negativeNumber = -number</c>, bei der <c>number</c> von der <see langword="DynamicObject" />-Klasse abgeleitet wurde, gibt <c>binder.Operation</c> „Negate“ zurück.</param>
        <param name="result">Das Ergebnis der unären Operation.</param>
        <summary>Stellt die Implementierung für unäre Operationen bereit. Von der <see cref="T:System.Dynamic.DynamicObject" />-Klasse abgeleitete Klassen können diese Methode überschreiben, um dynamisches Verhalten für Vorgänge wie Negation, Inkrement oder Dekrement anzugeben.</summary>
        <returns><see langword="true" />, wenn der Vorgang erfolgreich ist, andernfalls <see langword="false" />. Wenn die Methode <see langword="false" /> zurückgibt, wird das Verhalten vom Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Von abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse kann überschreiben diese Methode, um anzugeben, wie der unäre Operationen für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von der Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 Diese Methode wird aufgerufen, wenn Sie unäre Operationen wie Negation, Inkrement oder Dekrement. Z. B. wenn die <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> -Methode überschrieben wird, diese Methode wird automatisch aufgerufen, für Anweisungen wie `negativeNumber = -number`, wobei `number` ergibt sich aus der <xref:System.Dynamic.DynamicObject> Klasse.  
  
 Erhalten Sie Informationen über den Typ der unären Operation mit den `Operation` Eigenschaft der `binder` Parameter.  
  
 Wenn das dynamische Objekt, nur in C# und Visual Basic verwendet wird die `binder.Operation` Eigenschaft sind die folgenden Werte aus der <xref:System.Linq.Expressions.ExpressionType> Enumeration. In anderen Sprachen wie IronPython oder IronRuby erstellen, können Sie jedoch andere Werte haben.
  
|Wert|Beschreibung |C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|Eine unäre Dekrementoperation.|`a--`|Wird nicht unterstützt.|  
|`Increment`|Eine unäre Inkrementoperation.|`a++`|Wird nicht unterstützt.|  
|`Negate`|Eine arithmetische Negation.|`-a`|`-a`|  
|`Not`|Eine logische Negation.|`!a`|`Not a`|  
|`OnesComplement`|Ein zu ergänzen.|`~a`|Wird nicht unterstützt.|  
|`IsFalse`|Ein false Bedingungswert.|`a && b`|Wird nicht unterstützt.|  
|`IsTrue`|Ein true Bedingungswert.|`a &#124;&#124; b`|Wird nicht unterstützt.|  
|`UnaryPlus`|Ein unäres plus.|`+a`|`+a`|  
  
> [!NOTE]
>  Zum Implementieren `OrElse` (`a || b`) und `AndAlso` (`a && b`) Vorgänge für dynamische Objekte in C#, Sie möchten beide implementieren die <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> Methode und die <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> Methode.  
>   
>  Die `OrElse` Vorgang besteht aus den unären `IsTrue` Vorgang und den binären `Or` Vorgang. Die `Or` Vorgang erfolgt nur, wenn das Ergebnis der `IsTrue` Vorgang `false`.  
>   
>  Die `AndAlso` Vorgang besteht aus den unären `IsFalse` Vorgang und den binären `And` Vorgang. Die `And` Vorgang erfolgt nur, wenn das Ergebnis der `IsFalse` Vorgang `false`.  
  
   
  
## Examples  
 Angenommen Sie, Sie eine Datenstruktur zum Speichern von Text und die numerische Darstellung von Zahlen benötigen, und Sie eine mathematische Negationsoperation für solche Daten zu definieren möchten.  
  
 Im folgenden Codebeispiel wird veranschaulicht, die `DynamicNumber` -Klasse, die von abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. `DynamicNumber` überschreibt die <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> Methode, um die mathematische Negationsoperation zu aktivieren. Ist auch Außerkraftsetzungen der <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden, um den Zugriff auf die Elemente zu ermöglichen.  
  
 In diesem Beispiel wird nur die mathematische Negationsoperation unterstützt. Wenn Sie versuchen, eine Anweisung wie schreiben `negativeNumber = +number`, tritt eine Laufzeitausnahme.  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
