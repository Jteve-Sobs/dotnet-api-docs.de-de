<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6ae5ac708ed9c03e90259aa11dc3fd96557d5c21" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36488967" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <TypeSignature Language="F#" Value="type DynamicObject = class&#xA;    interface IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Provides a base class for specifying dynamic behavior at run time. This class must be inherited from; you cannot instantiate it directly.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `DynamicObject` -Klasse können Sie definieren, welche Vorgänge für dynamische Objekte ausgeführt werden können und wie diese Vorgänge ausgeführt. Beispielsweise können Sie definieren, was geschieht, wenn Sie versuchen, erhalten eine Objekteigenschaft festlegen, eine Methode aufrufen oder standard mathematische Operationen wie Addition und Multiplikation ausführen.  
  
 Diese Klasse ist hilfreich, wenn Sie ein bequemer Protokoll für eine Bibliothek erstellen möchten. Wenn Benutzern der Bibliothek verwenden Syntax wie beispielsweise `Scriptobj.SetProperty("Count", 1)`, können Sie die Möglichkeit, viel einfachere Syntax zu verwenden, etwa geben `scriptobj.Count = 1`.  
  
 Eine Instanz kann nicht direkt erstellt die `DynamicObject` Klasse. Um das dynamische Verhalten zu implementieren, sollten Sie erben die `DynamicObject` Klasse, und überschreiben Sie die erforderlichen Methoden. Z. B. Wenn Sie nur Vorgänge zum Festlegen und Abrufen von Eigenschaften benötigen, können Sie überschreiben nur die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden.  
  
 In c# zum Aktivieren von dynamischen Verhaltens für Instanzen von Klassen abgeleitet der `DynamicObject` -Klasse, müssen Sie verwenden die `dynamic` Schlüsselwort. Weitere Informationen finden Sie unter [Verwenden von dynamischen Typen](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 In Visual Basic werden die dynamische Vorgängen von spätes Binden unterstützt. Weitere Informationen finden Sie unter [frühe und späte Bindung](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen einer Instanz einer Klasse, die abgeleitet ist die `DynamicObject` Klasse.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 Sie können auch eigene Member hinzufügen, um von abgeleiteten Klassen der `DynamicObject` Klasse. Wenn Ihre Klasse Eigenschaften definiert und auch überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> -Methode, die dynamic Language Runtime (DLR) verwendet zuerst den Binder Sprache nach einer statischen Definition einer Eigenschaft in der Klasse gesucht werden soll. Wenn keine solche Eigenschaft vorhanden ist, ruft die DLR die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> Methode.  
  
 Die `DynamicObject` Klasse implementiert die Schnittstelle DLR <xref:System.Dynamic.IDynamicMetaObjectProvider>, können Sie Instanzen von Teilen der `DynamicObject` Klassenschema in Sprachen, die das Modell der DLR-Interoperabilität unterstützen. Sie können z. B. erstellen eine Instanz von der `DynamicObject` in C#-Klasse, und klicken Sie dann an eine IronPython-Funktion übergeben. Weitere Informationen finden Sie unter [Übersicht über die Dynamic Language Runtime](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md).  
  
> [!NOTE]
>  Wenn Sie ein einfaches Szenario haben, in denen, die Sie ein Objekt benötigen, das nur hinzufügen und Entfernen von Mitgliedern zur Laufzeit können, aber, die nicht auf bestimmte Vorgänge zu definieren und nicht statische Member aufweisen, verwenden Sie, die <xref:System.Dynamic.ExpandoObject> Klasse.  
>   
>  Wenn Sie ein erweiterten Szenario haben, in denen Sie definieren, wie dynamische Objekte, die Interoperabilitätsprotokoll teilnehmen, oder Sie müssen DLR schnellen dynamischen Dispatch Zwischenspeichern verwalten müssen, erstellen Sie eine eigene Implementierung von der <xref:System.Dynamic.IDynamicMetaObjectProvider> Schnittstelle.  
  
   
  
## Examples  
 Angenommen, Sie, um alternative Syntax bereitstellen, für den Zugriff auf Werte in einem Wörterbuch, damit der Verfassung möchten `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), können Sie schreiben `sampleDictionary.Text = "Sample text"`. Darüber hinaus diese Syntax die Groß-/Kleinschreibung, werden sollen, damit `sampleDictionary.Text` entspricht `sampleDictionary.text`.  
  
 Das folgende Codebeispiel veranschaulicht die `DynamicDictionary` -Klasse, die abgeleitet ist die `DynamicObject` Klasse. Die `DynamicDictionary` Klasse enthält ein Objekt des der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern der Schlüssel-Wert-Paare und überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum unterstützen der neuen Syntax. Sie bietet außerdem eine `Count` Eigenschaft, die zeigt, wie viele dynamischen Eigenschaften des Wörterbuchs enthält.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 Weitere Beispiele finden Sie unter [Wrapper erstellen, mit DynamicObject](http://go.microsoft.com/fwlink/?LinkId=169008) im C#-häufig gestellte Fragen-Blog.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Enables derived types to initialize a new instance of the <see cref="T:System.Dynamic.DynamicObject" /> type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz kann nicht direkt erstellt die <xref:System.Dynamic.DynamicObject> Klasse. Um dynamische Verhalten zu implementieren, müssen Sie erben die <xref:System.Dynamic.DynamicObject> Klasse, und überschreiben Sie die erforderlichen Methoden.  
  
 In c# zum Aktivieren von dynamischen Verhaltens für Instanzen der Klassen abgeleitet der <xref:System.Dynamic.DynamicObject> -Klasse, müssen Sie verwenden die `dynamic` Schlüsselwort. Weitere Informationen finden Sie unter [Verwenden von dynamischen Typen](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 In Visual Basic werden die dynamische Vorgängen von spätes Binden unterstützt. Weitere Informationen finden Sie unter [frühe und späte Bindung](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen einer Instanz von Klassen, die abgeleitet sind die <xref:System.Dynamic.DynamicObject> Klasse.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;&#xA;override this.GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;" Usage="dynamicObject.GetDynamicMemberNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the enumeration of all dynamic member names.</summary>
        <returns>A sequence that contains dynamic member names.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist nur für Debugzwecke bestimmt vorhanden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject&#xA;override this.GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject" Usage="dynamicObject.GetMetaObject parameter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">The expression that represents <see cref="T:System.Dynamic.DynamicMetaObject" /> to dispatch to the dynamic virtual methods.</param>
        <summary>Provides a <see cref="T:System.Dynamic.DynamicMetaObject" /> that dispatches to the dynamic virtual methods. The object can be encapsulated inside another <see cref="T:System.Dynamic.DynamicMetaObject" /> to provide custom behavior for individual actions. This method supports the Dynamic Language Runtime infrastructure for language implementers and it is not intended to be used directly from your code.</summary>
        <returns>An object of the <see cref="T:System.Dynamic.DynamicMetaObject" /> type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool&#xA;override this.TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool" Usage="dynamicObject.TryBinaryOperation (binder, arg, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the binary operation. The <c>binder.Operation</c> property returns an <see cref="T:System.Linq.Expressions.ExpressionType" /> object. For example, for the <c>sum = first + second</c> statement, where <c>first</c> and <c>second</c> are derived from the <see langword="DynamicObject" /> class, <c>binder.Operation</c> returns <c>ExpressionType.Add</c>.</param>
        <param name="arg">The right operand for the binary operation. For example, for the <c>sum = first + second</c> statement, where <c>first</c> and <c>second</c> are derived from the <see langword="DynamicObject" /> class, <c>arg</c> is equal to <c>second</c>.</param>
        <param name="result">The result of the binary operation.</param>
        <summary>Provides implementation for binary operations. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as addition and multiplication.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie binäre Operationen für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen ist eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 Diese Methode wird aufgerufen, wenn Sie die binäre Operationen wie Addition und Multiplikation verfügen. Z. B. wenn die <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> -Methode überschrieben wird, wird automatisch aufgerufen, für Anweisungen wie `sum = first + second` oder `multiply = first*second`, wobei `first` stammt aus dem `DynamicObject` Klasse.  
  
 Sie erhalten Informationen über den Typ der binären Operation mit den `Operation` Eigenschaft von der `binder` Parameter.  
  
 Wenn das dynamische Objekt nur in c# und Visual Basic verwendet wird die `binder.Operation` Eigenschaft kann einen der folgenden Werte aus haben die <xref:System.Linq.Expressions.ExpressionType> Enumeration. In anderen Sprachen wie z. B. IronPython oder IronRuby, können Sie jedoch andere Werte haben.
  
|Wert|Beschreibung|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|Eine Addition ohne überlaufüberprüfung für numerische Operanden.|`a + b`|`a + b`|  
|`AddAssign`|Eine zusammengesetzte additionszuweisungsoperation ohne überlaufüberprüfung für numerische Operanden.|`a += b`|Wird nicht unterstützt.|  
|`And`|Eine bitweise `AND` Vorgang.|`a & b`|`a And b`|  
|`AndAssign`|Eine bitweise `AND` zusammengesetzte Zuweisungsoperation.|`a &= b`|Wird nicht unterstützt.|  
|`Divide`|Eine arithmetische Division.|`a / b`|`a / b`|  
|`DivideAssign`|Eine arithmetische verbundzuweisung Division.|`a /= b`|Wird nicht unterstützt.|  
|`ExclusiveOr`|Eine bitweise `XOR` Vorgang.|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|Eine bitweise `XOR` zusammengesetzte Zuweisungsoperation.|`a ^= b`|Wird nicht unterstützt.|  
|`GreaterThan`|Eine "größer als"-Vergleich.|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|Ein Vergleich "größer als oder gleich".|`a >= b`|Wird nicht unterstützt.|  
|`LeftShift`|Eine bitweise Linksschiebeoperation.|`a << b`|`a << b`|  
|`LeftShiftAssign`|Eine bitweise Linksschiebe-Zuweisungsoperation zusammengesetzten.|`a <<= b`|Wird nicht unterstützt.|  
|`LessThan`|Eine "kleiner als"-Vergleich.|`a < b`|`a < b`|  
|`LessThanOrEqual`|Ein "kleiner als oder gleich"-Vergleich.|`a <= b`|Wird nicht unterstützt.|  
|`Modulo`|Eine arithmetische Restoperation.|`a % b`|`a Mod b`|  
|`ModuloAssign`|Ein Vorgang für den arithmetischen Rest-verbundzuweisung.|`a %= b`|Wird nicht unterstützt.|  
|`Multiply`|Einen Multiplikationsvorgang ohne überlaufüberprüfung für numerische Operanden.|`a * b`|`a * b`|  
|`MultiplyAssign`|Eine zusammengesetzte multiplikationszuweisungsoperation ohne überlaufüberprüfung für numerische Operanden.|`a *= b`|Wird nicht unterstützt.|  
|`NotEqual`|Einen Ungleichheitsvergleich.|`a != b`|`a <> b`|  
|`Or`|Eine bitweise oder logische `OR` Vorgang.|`a &#124; b`|`a Or b`|  
|`OrAssign`|Eine bitweise oder logische `OR` verbundzuweisung.|`a &#124;= b`|Wird nicht unterstützt.|  
|`Power`|Eine mathematische Operation, der Potenzieren einer Zahl in eine Potenz.|Wird nicht unterstützt.|`a ^ b`|  
|`RightShift`|Eine bitweise Rechtsschiebeoperation.|`a >> b`|`a >> b`|  
|`RightShiftAssign`|Eine bitweise Rechtsschiebe-Zuweisungsoperation zusammengesetzten.|`a >>= b`|Wird nicht unterstützt.|  
|`Subtract`|Eine Subtraktion ohne überlaufüberprüfung für numerische Operanden.|`a - b`|`a - b`|  
|`SubtractAssign`|Eine zusammengesetzte subtraktionszuweisungsoperation ohne überlaufüberprüfung für numerische Operanden.|`a -= b`|Wird nicht unterstützt.|  
  
> [!NOTE]
>  Implementiert `OrElse` (`a || b`) und `AndAlso` (`a && b`) Operationen für dynamische Objekte in c#, Sie wollen beide implementieren die <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> Methode und die <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> Methode.  
>   
>  Die `OrElse` Vorgang besteht aus den unären `IsTrue` Vorgang und der Binärdatei `Or` Vorgang. Die `Or` Vorgang wird nur ausgeführt, wenn das Ergebnis der `IsTrue` Vorgang ist `false`.  
>   
>  Die `AndAlso` Vorgang besteht aus den unären `IsFalse` Vorgang und der Binärdatei `And` Vorgang. Die `And` Vorgang wird nur ausgeführt, wenn das Ergebnis der `IsFalse` Vorgang ist `false`.  
  
   
  
## Examples  
 Angenommen Sie, Sie eine Datenstruktur zum Speichern von Text und numerischer Darstellungen von Zahlen benötigen, und Sie grundlegende mathematische Operationen wie Addition und Subtraktion für solche Daten definieren möchten.  
  
 Das folgende Codebeispiel veranschaulicht die `DynamicNumber` -Klasse, die abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. `DynamicNumber` überschreibt die <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> Methode zum Aktivieren von mathematischer Operations. Es überschreibt auch die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum Aktivieren des Zugriffs auf die Elemente.  
  
 In diesem Beispiel werden nur die Operationen Addition und Subtraktion unterstützt. Wenn Sie versuchen, eine Anweisung wie schreiben `resultNumber = firstNumber*secondNumber`, eine Laufzeitausnahme wird ausgelöst.  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool&#xA;override this.TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool" Usage="dynamicObject.TryConvert (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the conversion operation. The <c>binder.Type</c> property provides the type to which the object must be converted. For example, for the statement <c>(String)sampleObject</c> in C# (<c>CType(sampleObject, Type)</c> in Visual Basic), where <c>sampleObject</c> is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <c>binder.Type</c> returns the <see cref="T:System.String" /> type. The <c>binder.Explicit</c> property provides information about the kind of conversion that occurs. It returns <see langword="true" /> for explicit conversion and <see langword="false" /> for implicit conversion.</param>
        <param name="result">The result of the type conversion operation.</param>
        <summary>Provides implementation for type conversion operations. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations that convert an object from one type to another.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie eine typkonvertierung für ein dynamisches Objekt ausgeführt werden sollen. Wenn die Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen ist eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 In C# geschrieben Wenn diese Methode überschrieben wird, wird es automatisch aufgerufen, wenn stehen Ihnen eine explizite oder implizite Konvertierung wie im folgenden Codebeispiel gezeigt.  
  
 In Visual Basic wird nur die explizite Konvertierung unterstützt. Wenn Sie diese Methode überschreiben, rufen Sie es mithilfe der <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> oder <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> Funktionen.  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 Angenommen Sie, Sie eine Datenstruktur zum Speichern von Text und numerischer Darstellungen von Zahlen benötigen und definieren Konvertierungen von diesem Datenstruktur anwendbar auf Zeichenfolgen und ganzen Zahlen werden sollen.  
  
 Das folgende Codebeispiel veranschaulicht die `DynamicNumber` -Klasse, die abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. `DynamicNumber` überschreibt die <xref:System.Dynamic.DynamicObject.TryConvert%2A> Methode, um die Konvertierung vom Typ zu aktivieren. Es überschreibt auch die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum Aktivieren des Zugriffs auf die Datenelemente.  
  
 In diesem Beispiel wird nur die Konvertierung in Zeichenfolgen und ganzen Zahlen unterstützt. Wenn Sie versuchen, ein Objekt in einen anderen Typ zu konvertieren, wird eine Laufzeitausnahme ausgelöst.  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool&#xA;override this.TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryCreateInstance (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the initialization operation.</param>
        <param name="args">The arguments that are passed to the object during initialization. For example, for the <c>new SampleType(100)</c> operation, where <c>SampleType</c> is the type derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <c>args[0]</c> is equal to 100.</param>
        <param name="result">The result of the initialization.</param>
        <summary>Provides the implementation for operations that initialize a new instance of a dynamic object. This method is not intended for use in C# or Visual Basic.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie eine neue Instanz des dynamischen Objekts initialisiert werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen ist eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 C# und Visual Basic-Compiler geben nie Code aus, um diese Methode verwenden, da sie nicht über die erstrangige Typen unterstützen. Diese Methode ist für Sprachen, die Unterstützung für die Initialisierung von dynamischen Objekten mithilfe von Syntax wie vorgesehen `dynamic new`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool&#xA;override this.TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool" Usage="dynamicObject.TryDeleteIndex (binder, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the deletion.</param>
        <param name="indexes">The indexes to be deleted.</param>
        <summary>Provides the implementation for operations that delete an object by index. This method is not intended for use in C# or Visual Basic.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie ein Wert, der einem angegebenen Index gelöscht werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen ist eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 C# und Visual Basic-Compiler geben nie Code aus, um diese Methode verwenden, da sie diese Art von Vorgang nicht unterstützen. Diese Methode ist für Sprachen, die Syntax zum Löschen von Objekten wie z. B. nach Index unterstützen vorgesehen `del sampleObject[1,2]` in Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool&#xA;override this.TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool" Usage="dynamicObject.TryDeleteMember binder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the deletion.</param>
        <summary>Provides the implementation for operations that delete an object member. This method is not intended for use in C# or Visual Basic.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie einem Objektelement gelöscht werden soll. Wenn diese Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen ist eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 C# und Visual Basic-Compiler geben nie Code aus, um diese Methode verwenden, da sie diese Art von Vorgang nicht unterstützen. Diese Methode ist für Sprachen, die Syntax zum Löschen von Elementen, z. B. unterstützen vorgesehen `del sampleObject.SampleMember` in Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool&#xA;override this.TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryGetIndex (binder, indexes, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the operation.</param>
        <param name="indexes">The indexes that are used in the operation. For example, for the <c>sampleObject[3]</c> operation in C# (<c>sampleObject(3)</c> in Visual Basic), where <c>sampleObject</c> is derived from the <see langword="DynamicObject" /> class, <c>indexes[0]</c> is equal to 3.</param>
        <param name="result">The result of the index operation.</param>
        <summary>Provides the implementation for operations that get a value by index. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for indexing operations.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a run-time exception is thrown.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie das Abrufen eines Werts über einen Index für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine Laufzeitausnahme ausgelöst.)  
  
 Wenn diese Methode überschrieben wird, wird Sie automatisch aufgerufen, wenn ein Vorgang wie vorliegt `sampleObject[3]` in c# oder `sampleObject(3)` in Visual Basic, Where `sampleObject` stammt aus dem <xref:System.Dynamic.DynamicObject> Klasse.  
  
   
  
## Examples  
 Gehen davon aus entweder nach Namen an, dass ein Objekt zu erstellen, in dem Eigenschaften werden können, sollen z. B. zugegriffen `Property0`, `Property1`usw., oder nach Index, damit, z. B. `sampleObject.Property0` entspricht `sampleObject[0]` in c# oder `sampleObject(0)` in Visual Basic.  
  
 Das folgende Codebeispiel veranschaulicht die `SampleDynamicObject` -Klasse, die abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. Die `SampleDynamicObject` Klasse enthält ein Objekt von der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern von Schlüssel-Wert-Paare. `SampleDynamicObject` überschreibt die <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> und <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> Methoden zum Aktivieren des Zugriffs über einen Index. Es überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum Aktivieren des Zugriffs nach Eigenschaftenname an.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool&#xA;override this.TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool" Usage="dynamicObject.TryGetMember (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the object that called the dynamic operation. The <c>binder.Name</c> property provides the name of the member on which the dynamic operation is performed. For example, for the <c>Console.WriteLine(sampleObject.SampleProperty)</c> statement, where <c>sampleObject</c> is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <c>binder.Name</c> returns "SampleProperty". The <c>binder.IgnoreCase</c> property specifies whether the member name is case-sensitive.</param>
        <param name="result">The result of the get operation. For example, if the method is called for a property, you can assign the property value to <c>result</c>.</param>
        <summary>Provides the implementation for operations that get member values. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as getting a value for a property.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a run-time exception is thrown.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie Vorgänge, die Elementwerte abrufen für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine Laufzeitausnahme ausgelöst.)  
  
 Diese Methode wird aufgerufen, wenn Sie die Anweisungen wie haben `Console.WriteLine(sampleObject.SampleProperty)`, wobei `sampleObject` ist eine Instanz der abgeleiteten Klasse aus der <xref:System.Dynamic.DynamicObject> Klasse.  
  
 Sie können auch eigene Member hinzufügen, um von abgeleiteten Klassen der `DynamicObject` Klasse. Wenn Ihre Klasse Eigenschaften definiert und auch überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> -Methode, die dynamic Language Runtime (DLR) verwendet zuerst den Binder Sprache nach einer statischen Definition einer Eigenschaft in der Klasse gesucht werden soll. Wenn keine solche Eigenschaft vorhanden ist, ruft die DLR die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> Methode.  
  
   
  
## Examples  
 Angenommen, Sie, um alternative Syntax bereitstellen, für den Zugriff auf Werte in einem Wörterbuch, damit der Verfassung möchten `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), können Sie schreiben `sampleDictionary.Text = "Sample text"`. Darüber hinaus muss diese Syntax Groß-/Kleinschreibung, sodass `sampleDictionary.Text` entspricht `sampleDictionary.text`.  
  
 Das folgende Codebeispiel veranschaulicht die `DynamicDictionary` -Klasse, die abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. Die `DynamicDictionary` Klasse enthält ein Objekt des der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern der Schlüssel-Wert-Paare und überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum unterstützen der neuen Syntax. Sie bietet außerdem eine `Count` Eigenschaft, die zeigt, wie viele dynamischen Eigenschaften des Wörterbuchs enthält.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool&#xA;override this.TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvoke (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the invoke operation.</param>
        <param name="args">The arguments that are passed to the object during the invoke operation. For example, for the <c>sampleObject(100)</c> operation, where <c>sampleObject</c> is derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <c>args[0]</c> is equal to 100.</param>
        <param name="result">The result of the object invocation.</param>
        <summary>Provides the implementation for operations that invoke an object. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as invoking an object or a delegate.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie Vorgänge, die ein Objekt aufrufen für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen wird eine Laufzeitausnahme ausgelöst.)  
  
 Wenn diese Methode überschrieben wird, wird Sie automatisch aufgerufen, wenn ein Vorgang wie vorliegt `sampleObject(100)`, wobei `sampleObject` stammt aus dem <xref:System.Dynamic.DynamicObject> Klasse.  
  
 Der Vorgang zum Aufrufen eines Objekts wird in c#, aber nicht in Visual Basic unterstützt. Visual Basic-Compiler gibt nie Code aus, um diese Methode verwenden, und die Sprache Visual Basic unterstützt keine Syntax wie `sampleObject(100)`.  
  
   
  
## Examples  
 Angenommen Sie, Sie eine Datenstruktur zum Speichern von Text und numerischer Darstellungen von Zahlen benötigen. Sie möchten zu können, um den Wert für jede Eigenschaft einzeln anzugeben sowie um alle Eigenschaften in einer einzelnen Anweisung initialisieren zu können.  
  
 Das folgende Codebeispiel veranschaulicht die `DynamicNumber` -Klasse, die abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. `DynamicNumber` überschreibt die <xref:System.Dynamic.DynamicObject.TryInvoke%2A> Methode, um die Initialisierung aller Eigenschaften, die gleichzeitig aktivieren. Es überschreibt auch die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden für den Zugriff auf einzelne Objekteigenschaften.  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool&#xA;override this.TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvokeMember (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the dynamic operation. The <c>binder.Name</c> property provides the name of the member on which the dynamic operation is performed. For example, for the statement <c>sampleObject.SampleMethod(100)</c>, where <c>sampleObject</c> is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <c>binder.Name</c> returns "SampleMethod". The <c>binder.IgnoreCase</c> property specifies whether the member name is case-sensitive.</param>
        <param name="args">The arguments that are passed to the object member during the invoke operation. For example, for the statement <c>sampleObject.SampleMethod(100)</c>, where <c>sampleObject</c> is derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <c>args[0]</c> is equal to 100.</param>
        <param name="result">The result of the member invocation.</param>
        <summary>Provides the implementation for operations that invoke a member. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as calling a method.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie Vorgänge, die einem Objektelement Aufrufen für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen ist eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 Wenn diese Methode überschrieben wird, wird Sie automatisch aufgerufen, wenn Sie einen Vorgang wie ausführen `sampleObject.SampleMethod(100)`, wobei `sampleObject` stammt aus dem `DynamicObject` Klasse.  
  
 Sie können auch Ihre eigenen Methoden hinzufügen, die von der abgeleiteten Klassen der <xref:System.Dynamic.DynamicObject> Klasse. Angenommen, Sie überschreiben die <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> -Methode, die dynamische Verteilung-System versucht zunächst zu bestimmen, ob die angegebene Methode in der Klasse vorhanden ist. Wenn sie die Methode nicht gefunden wird, verwendet die <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> Implementierung.  
  
 Diese Methode unterstützt keine `ref` und `out` Parameter. Alle Parameter in der `args` Array als Wert übergeben.  
  
   
  
## Examples  
 Angenommen, Sie, um alternative Syntax bereitstellen, für den Zugriff auf Werte in einem Wörterbuch, damit der Verfassung möchten `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), können Sie schreiben `sampleDictionary.Text = "Sample text"`. Darüber hinaus möchten dieses Wörterbuch aufweist und die standard-Wörterbuch-Methoden aufgerufen werden können.  
  
 Das folgende Codebeispiel veranschaulicht die `DynamicDictionary` -Klasse, die abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. Die `DynamicDictionary` Klasse enthält ein Objekt von der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern von Schlüssel-Wert-Paare. Es überschreibt die <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> -Methode zur Unterstützung der Methoden der der <xref:System.Collections.Generic.Dictionary%602> -Klasse ab und überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum unterstützen der neuen Syntax. Sie bietet außerdem eine `Print` -Methode, die alle Wörterbuchschlüssel und-Werte ausgegeben.  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TrySetIndex (binder, indexes, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the operation.</param>
        <param name="indexes">The indexes that are used in the operation. For example, for the <c>sampleObject[3] = 10</c> operation in C# (<c>sampleObject(3) = 10</c> in Visual Basic), where <c>sampleObject</c> is derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <c>indexes[0]</c> is equal to 3.</param>
        <param name="value">The value to set to the object that has the specified index. For example, for the <c>sampleObject[3] = 10</c> operation in C# (<c>sampleObject(3) = 10</c> in Visual Basic), where <c>sampleObject</c> is derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <c>value</c> is equal to 10.</param>
        <summary>Provides the implementation for operations that set a value by index. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations that access objects by a specified index.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie Vorgänge, die ein Objekt nach Index zugegriffen für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen ist eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 Wenn diese Methode überschrieben wird, wird Sie automatisch aufgerufen, wenn ein Vorgang wie vorliegt `sampleObject[3] = 10` in c# oder `sampleObject(3) = 10` in Visual Basic, Where `sampleObject` stammt aus dem <xref:System.Dynamic.DynamicObject> Klasse.  
  
   
  
## Examples  
 Gehen davon aus entweder nach Namen an, dass ein Objekt zu erstellen, in dem Eigenschaften werden können, sollen z. B. zugegriffen `Property0`, `Property1`usw., oder nach Index, damit, z. B. `sampleObject.Property0` entspricht `sampleObject[0]` in c# oder `sampleObject(0)` in Visual Basic.  
  
 Das folgende Codebeispiel veranschaulicht die `SampleDynamicObject` -Klasse, die abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. Die `SampleDynamicObject` Klasse enthält ein Objekt von der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern von Schlüssel-Wert-Paare. `SampleDynamicObject` überschreibt die <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> und <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> Methoden zum Aktivieren des Zugriffs über einen Index. Es überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum Aktivieren des Zugriffs nach Eigenschaftenname an.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool&#xA;override this.TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TrySetMember (binder, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the object that called the dynamic operation. The <c>binder.Name</c> property provides the name of the member to which the value is being assigned. For example, for the statement <c>sampleObject.SampleProperty = "Test"</c>, where <c>sampleObject</c> is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <c>binder.Name</c> returns "SampleProperty". The <c>binder.IgnoreCase</c> property specifies whether the member name is case-sensitive.</param>
        <param name="value">The value to set to the member. For example, for <c>sampleObject.SampleProperty = "Test"</c>, where <c>sampleObject</c> is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, the <c>value</c> is "Test".</param>
        <summary>Provides the implementation for operations that set member values. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as setting a value for a property.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie Vorgänge, die auf einen Member ein Wert festgelegt für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen ist eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 Diese Methode wird aufgerufen, wenn Sie die Anweisungen wie haben `sampleObject.SampleProperty = "Test"`, wobei `sampleObject` ist eine Instanz der Klasse, die abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse.  
  
 Sie können auch eigene Member hinzufügen, um von abgeleiteten Klassen der `DynamicObject` Klasse. Wenn Ihre Klasse Eigenschaften definiert und auch überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> -Methode, die dynamic Language Runtime (DLR) verwendet zuerst den Binder Sprache nach einer statischen Definition einer Eigenschaft in der Klasse gesucht werden soll. Wenn keine solche Eigenschaft vorhanden ist, ruft die DLR die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> Methode.  
  
   
  
## Examples  
 Angenommen, Sie, um alternative Syntax bereitstellen, für den Zugriff auf Werte in einem Wörterbuch, damit der Verfassung möchten `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` in Visual Basic), können Sie schreiben `sampleDictionary.Text = "Sample text"`. Darüber hinaus muss diese Syntax Groß-/Kleinschreibung, sodass `sampleDictionary.Text` entspricht `sampleDictionary.text`.  
  
 Das folgende Codebeispiel veranschaulicht die `DynamicDictionary` -Klasse, die abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. Die `DynamicDictionary` Klasse enthält ein Objekt des der `Dictionary<string, object>` Typ (`Dictionary(Of String, Object)` in Visual Basic) zum Speichern der Schlüssel-Wert-Paare und überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum unterstützen der neuen Syntax. Sie bietet außerdem eine `Count` Eigenschaft, die zeigt, wie viele dynamischen Eigenschaften des Wörterbuchs enthält.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool&#xA;override this.TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool" Usage="dynamicObject.TryUnaryOperation (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Provides information about the unary operation. The <c>binder.Operation</c> property returns an <see cref="T:System.Linq.Expressions.ExpressionType" /> object. For example, for the <c>negativeNumber = -number</c> statement, where <c>number</c> is derived from the <see langword="DynamicObject" /> class, <c>binder.Operation</c> returns "Negate".</param>
        <param name="result">The result of the unary operation.</param>
        <summary>Provides implementation for unary operations. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as negation, increment, or decrement.</summary>
        <returns>
          <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen aus der <xref:System.Dynamic.DynamicObject> Klasse überschreiben, kann diese Methode, um anzugeben, wie unäre Operationen für ein dynamisches Objekt ausgeführt werden soll. Wenn die Methode nicht überschrieben wird, wird das Verhalten von Laufzeitbinder der Sprache bestimmt. (In den meisten Fällen ist eine sprachspezifische Laufzeitausnahme ausgelöst.)  
  
 Diese Methode wird aufgerufen, wenn unäre Operationen, wie z. B. Negation, Inkrement oder Dekrement. Z. B. wenn die <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> -Methode überschrieben wird, diese Methode wird automatisch aufgerufen, für Anweisungen wie `negativeNumber = -number`, wobei `number` stammt aus dem <xref:System.Dynamic.DynamicObject> Klasse.  
  
 Sie erhalten Informationen über den Typ der unären Operation mit den `Operation` Eigenschaft von der `binder` Parameter.  
  
 Wenn das dynamische Objekt nur in c# und Visual Basic verwendet wird die `binder.Operation` Eigenschaft kann einen der folgenden Werte aus haben die <xref:System.Linq.Expressions.ExpressionType> Enumeration. In anderen Sprachen wie z. B. IronPython oder IronRuby, können Sie jedoch andere Werte haben.
  
|Wert|Beschreibung|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|Eine unäre-dekrementierungsoperation an.|`a--`|Wird nicht unterstützt.|  
|`Increment`|Eine unäre-Inkrementierungsoperation an.|`a++`|Wird nicht unterstützt.|  
|`Negate`|Eine arithmetische Negation.|`-a`|`-a`|  
|`Not`|Eine logische Negation.|`!a`|`Not a`|  
|`OnesComplement`|Ein Komplement darstellt.|`~a`|Wird nicht unterstützt.|  
|`IsFalse`|Ein Bedingungswert "false.|`a && b`|Wird nicht unterstützt.|  
|`IsTrue`|Ein Bedingungswert "true.|`a &#124;&#124; b`|Wird nicht unterstützt.|  
|`UnaryPlus`|Ein unäres plus.|`+a`|`+a`|  
  
> [!NOTE]
>  Implementiert `OrElse` (`a || b`) und `AndAlso` (`a && b`) Operationen für dynamische Objekte in c#, Sie wollen beide implementieren die <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> Methode und die <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> Methode.  
>   
>  Die `OrElse` Vorgang besteht aus den unären `IsTrue` Vorgang und der Binärdatei `Or` Vorgang. Die `Or` Vorgang wird nur ausgeführt, wenn das Ergebnis der `IsTrue` Vorgang ist `false`.  
>   
>  Die `AndAlso` Vorgang besteht aus den unären `IsFalse` Vorgang und der Binärdatei `And` Vorgang. Die `And` Vorgang wird nur ausgeführt, wenn das Ergebnis der `IsFalse` Vorgang ist `false`.  
  
   
  
## Examples  
 Angenommen Sie, Sie eine Datenstruktur zum Speichern von Text und numerischer Darstellungen von Zahlen benötigen, und Sie eine mathematische Negationsoperation für solche Daten zu definieren möchten.  
  
 Das folgende Codebeispiel veranschaulicht die `DynamicNumber` -Klasse, die abgeleitet ist die <xref:System.Dynamic.DynamicObject> Klasse. `DynamicNumber` überschreibt die <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> Methode, um die mathematische Negationsoperation zu aktivieren. Wird auch überschreibt die <xref:System.Dynamic.DynamicObject.TrySetMember%2A> und <xref:System.Dynamic.DynamicObject.TryGetMember%2A> Methoden zum Aktivieren des Zugriffs auf die Elemente.  
  
 In diesem Beispiel wird nur die mathematische Negationsoperation unterstützt. Wenn Sie versuchen, eine Anweisung wie schreiben `negativeNumber = +number`, eine Laufzeitausnahme tritt auf.  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>