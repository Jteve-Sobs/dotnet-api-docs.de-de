<Type Name="AddInStore" FullName="System.AddIn.Hosting.AddInStore">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="98f85622c6ec975a7aa552ad2f4ff6628d696c51" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30360354" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class AddInStore" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit AddInStore extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.AddIn.Hosting.AddInStore" />
  <TypeSignature Language="VB.NET" Value="Public Class AddInStore" />
  <TypeSignature Language="C++ CLI" Value="public ref class AddInStore abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.AddIn</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt Methoden zum Speichern und Suchen von Informationen über verfügbare Add-Ins und Pipelinesegmente bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Klasse erstellen, neu erstellen und aktualisieren zwei Cachedateien, wie in der folgenden Tabelle beschrieben.  
  
|Cache-Datei|Methoden, die zum Erstellen der das|  
|----------------|----------------------------------|  
|PipelineSegments.store<br /><br /> Diese Datei befindet sich im Stammverzeichnis der Pipelineverzeichnisstruktur.|<xref:System.AddIn.Hosting.AddInStore.Update%2A><br /><br /> Die Datei aktualisiert mit neuen Pipelinesegmente. Wenn keine neuen Segmente installiert sind, überprüft diese Methode nur den Cache.<br /><br /> <xref:System.AddIn.Hosting.AddInStore.Rebuild%2A><br /><br /> Erstellt die Datei neu, und neue Pipelinesegmente enthält.|  
|AddIns.store<br /><br /> Diese Datei befindet sich in einem Verzeichnis, das eine oder mehrere Add-in-Unterverzeichnisse enthält. Wenn dieses Verzeichnis in der Pipelineverzeichnisstruktur befindet, muss er-Add-Ins benannt werden.|<xref:System.AddIn.Hosting.AddInStore.UpdateAddIns%2A><br /><br /> Aktualisiert die Datei mit neuen Add-Ins an einer angegebenen Position. Rufen Sie diese Methode, wenn Ihre Add-Ins außerhalb der Pipelineverzeichnisstruktur enthalten sind.<br /><br /> Wenn keine neuen Add-Ins installiert sind, überprüft diese Methode nur den Cache.<br /><br /> <xref:System.AddIn.Hosting.AddInStore.RebuildAddIns%2A><br /><br /> Erstellt die Datei neu, und enthält Add-Ins an einer angegebenen Position. Rufen Sie diese Methode, wenn Ihre Add-Ins außerhalb der Pipelineverzeichnisstruktur enthalten sind.<br /><br /> <xref:System.AddIn.Hosting.AddInStore.Update%2A><br /><br /> Wenn die Add-ins in der Pipelineverzeichnisstruktur befinden, aktualisiert diese Methode die Datei mit neuen-Add-ins.<br /><br /> <xref:System.AddIn.Hosting.AddInStore.Rebuild%2A><br /><br /> Wenn die Add-ins in der Pipelineverzeichnisstruktur befinden, wird diese Methode stellt die Datei und schließt neue Add-Ins.|  
  
 Diese Methoden erstellen die Cache-Dateien aus, wenn sie nicht bereits vorhanden sind.  
  
 Nachdem der Cache-Dateien erstellt wurden, verwenden die <xref:System.AddIn.Hosting.AddInStore.FindAddIns%2A> Methode, um die Dateien, um alle Add-ins finden, die mit einer angegebenen Hostansicht des Add-Ins zu untersuchen. Sie können auch die <xref:System.AddIn.Hosting.AddInStore.FindAddIn%2A> Methode, um ein bestimmtes Add-in ermitteln.  
  
> [!IMPORTANT]
>  Es wird nicht unterstützt, um nicht vertrauenswürdige Benutzer oder Entitäten PipelineSegments.store und Addins.store zugreifen können. Dadurch kann Probleme mit beschädigten Daten für Anwendungen auftreten.  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie Cachedateien aktualisiert wird.  
  
 [!code-csharp[AddInP3Host#2](~/samples/snippets/csharp/VS_Snippets_CLR/addinP3Host/cs/P3Host.cs#2)]
 [!code-vb[AddInP3Host#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/addinP3Host/vb/p3host.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="FindAddIn">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt; FindAddIn (Type hostViewOfAddIn, string pipelineRootFolderPath, string addInFilePath, string addInTypeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.Collection`1&lt;class System.AddIn.Hosting.AddInToken&gt; FindAddIn(class System.Type hostViewOfAddIn, string pipelineRootFolderPath, string addInFilePath, string addInTypeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.FindAddIn(System.Type,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAddIn (hostViewOfAddIn As Type, pipelineRootFolderPath As String, addInFilePath As String, addInTypeName As String) As Collection(Of AddInToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::Collection&lt;System::AddIn::Hosting::AddInToken ^&gt; ^ FindAddIn(Type ^ hostViewOfAddIn, System::String ^ pipelineRootFolderPath, System::String ^ addInFilePath, System::String ^ addInTypeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostViewOfAddIn" Type="System.Type" />
        <Parameter Name="pipelineRootFolderPath" Type="System.String" />
        <Parameter Name="addInFilePath" Type="System.String" />
        <Parameter Name="addInTypeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hostViewOfAddIn">Der Typ, der die Hostansicht des Add-Ins definiert.</param>
        <param name="pipelineRootFolderPath">Der Pfad zum Stamm der Pipelineverzeichnisstruktur.</param>
        <param name="addInFilePath">Der Pfad und Dateiname des zu suchenden Add-Ins.</param>
        <param name="addInTypeName">Der Typname des Add-Ins.</param>
        <summary>Sucht ein bestimmtes Add-In.</summary>
        <returns>Eine Auflistung von Token, die nur das Token enthält, das das gefundene Add-In darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine einzelne Pipeline für ein Add-in gefunden wird, wird es das einzige Element in der <xref:System.AddIn.Hosting.AddInToken> Auflistung. Wenn mehrere Pipelines für das angegebene Add-in gefunden werden, können Sie diese unterscheiden, indem Sie untersuchen die <xref:System.AddIn.Hosting.AddInToken.QualificationData%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgende Beispiel sucht nach einem bestimmten add-in.  
  
 [!code-csharp[AddInP3Host#6](~/samples/snippets/csharp/VS_Snippets_CLR/addinP3Host/cs/P3Host.cs#6)]
 [!code-vb[AddInP3Host#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/addinP3Host/vb/p3host.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="pipelineRootFolderPath" />, <paramref name="addInFilePath" /> oder <paramref name="addInTypeName" /> ist 0.  
  
 \- oder –  
  
 Die Add-In-Datei ist in <paramref name="addInfilePath" /> nicht vorhanden.</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens ein Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer besitzt keine Lesezugriffsberechtigung für <paramref name="pipelineRootFolderPath" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Fähigkeit, die Add-in-Ordner zu lesen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="M:System.AddIn.Hosting.AddInStore.FindAddIns(System.Type,System.String,System.String[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindAddIns">
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht alle Add-Ins für eine angegebene Hostansicht des Add-Ins.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindAddIns">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt; FindAddIns (Type hostViewOfAddIn, System.AddIn.Hosting.PipelineStoreLocation location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.Collection`1&lt;class System.AddIn.Hosting.AddInToken&gt; FindAddIns(class System.Type hostViewOfAddIn, valuetype System.AddIn.Hosting.PipelineStoreLocation location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.FindAddIns(System.Type,System.AddIn.Hosting.PipelineStoreLocation)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAddIns (hostViewOfAddIn As Type, location As PipelineStoreLocation) As Collection(Of AddInToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::Collection&lt;System::AddIn::Hosting::AddInToken ^&gt; ^ FindAddIns(Type ^ hostViewOfAddIn, System::AddIn::Hosting::PipelineStoreLocation location);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostViewOfAddIn" Type="System.Type" />
        <Parameter Name="location" Type="System.AddIn.Hosting.PipelineStoreLocation" />
      </Parameters>
      <Docs>
        <param name="hostViewOfAddIn">Der Typ, der die Hostansicht des Add-Ins definiert.</param>
        <param name="location">Das Basisverzeichnis der Hostanwendung.</param>
        <summary>Sucht alle Add-Ins für eine angegebene Hostansicht des Add-Ins an dem vom <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" />-Enumerationswert angegebenen Speicherort.</summary>
        <returns>Eine Auflistung von Token, die die gefundenen Add-Ins darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AddIn.Hosting.PipelineStoreLocation> Enumeration enthält derzeit nur die <xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase> -Wert, der auf dem Host Anwendungsbasisverzeichnis verweist.  
  
   
  
## Examples  
 Das folgende Beispiel findet-add-ins an der Position, die gemäß der <xref:System.AddIn.Hosting.PipelineStoreLocation> Enumeration.  
  
 [!code-csharp[AddInP3Host#4](~/samples/snippets/csharp/VS_Snippets_CLR/addinP3Host/cs/P3Host.cs#4)]
 [!code-vb[AddInP3Host#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/addinP3Host/vb/p3host.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Es ist eine Zugriffsverletzung bei der Pipelineverzeichnisstruktur aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="location" /> ist ein ungültiger <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindAddIns">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt; FindAddIns (Type hostViewOfAddIn, System.AddIn.Hosting.PipelineStoreLocation location, params string[] addInFolderPaths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.Collection`1&lt;class System.AddIn.Hosting.AddInToken&gt; FindAddIns(class System.Type hostViewOfAddIn, valuetype System.AddIn.Hosting.PipelineStoreLocation location, string[] addInFolderPaths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.FindAddIns(System.Type,System.AddIn.Hosting.PipelineStoreLocation,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAddIns (hostViewOfAddIn As Type, location As PipelineStoreLocation, ParamArray addInFolderPaths As String()) As Collection(Of AddInToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::Collection&lt;System::AddIn::Hosting::AddInToken ^&gt; ^ FindAddIns(Type ^ hostViewOfAddIn, System::AddIn::Hosting::PipelineStoreLocation location, ... cli::array &lt;System::String ^&gt; ^ addInFolderPaths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostViewOfAddIn" Type="System.Type" />
        <Parameter Name="location" Type="System.AddIn.Hosting.PipelineStoreLocation" />
        <Parameter Name="addInFolderPaths" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="hostViewOfAddIn">Der Typ, der die Hostansicht des Add-Ins definiert.</param>
        <param name="location">Einer der Enumerationswerte.  
  
 Derzeit ist der einzige Wert in dieser Enumeration das von der <see cref="P:System.AppDomainSetup.ApplicationBase" />-Eigenschaft angegebene Verzeichnis, mit dem die Anwendungsdomäne des Hosts eingerichtet wurde.</param>
        <param name="addInFolderPaths">(Optional) Der Pfad des Verzeichnisses, das ein oder mehrere Unterverzeichnisse von Add-Ins enthält. Da dieser Parameter ein Zeichenfolgenarray akzeptiert, können Sie mehrere Pfade angeben.  
  
 Dieser Parameter ist nicht erforderlich, wenn sich die Add-Ins in der Pipelineverzeichnisstruktur im Ordner AddIns befinden.</param>
        <summary>Sucht alle Add-Ins für eine angegebene Hostansicht des Add-Ins an dem von einem <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" />-Wert angegebenen Speicherort und einem optionalen Add-In-Ordner.</summary>
        <returns>Eine Auflistung von Token, die die gefundenen Add-Ins darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um einem teilweise vertrauenswürdigen Host, die nicht über Pfad Discovery-Berechtigung, einen eigenen Speicherort ermitteln kann, im Verzeichnis eigenen-add-ins finden aktivieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Es ist eine Zugriffsverletzung bei der Pipelineverzeichnisstruktur aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="location" /> ist ein ungültiger <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindAddIns">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt; FindAddIns (Type hostViewOfAddIn, string pipelineRootFolderPath, params string[] addInFolderPaths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.Collection`1&lt;class System.AddIn.Hosting.AddInToken&gt; FindAddIns(class System.Type hostViewOfAddIn, string pipelineRootFolderPath, string[] addInFolderPaths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.FindAddIns(System.Type,System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAddIns (hostViewOfAddIn As Type, pipelineRootFolderPath As String, ParamArray addInFolderPaths As String()) As Collection(Of AddInToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::Collection&lt;System::AddIn::Hosting::AddInToken ^&gt; ^ FindAddIns(Type ^ hostViewOfAddIn, System::String ^ pipelineRootFolderPath, ... cli::array &lt;System::String ^&gt; ^ addInFolderPaths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostViewOfAddIn" Type="System.Type" />
        <Parameter Name="pipelineRootFolderPath" Type="System.String" />
        <Parameter Name="addInFolderPaths" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="hostViewOfAddIn">Der Typ, der die Hostansicht des Add-Ins definiert.</param>
        <param name="pipelineRootFolderPath">Der Pfad zum Stamm der Pipelineverzeichnisstruktur.</param>
        <param name="addInFolderPaths">(Optional) Der Pfad des Verzeichnisses, das ein oder mehrere Unterverzeichnisse von Add-Ins enthält. Da dieser Parameter ein Zeichenfolgenarray akzeptiert, können Sie mehrere Pfade angeben.  
  
 Dieser Parameter ist nicht erforderlich, wenn sich die Add-Ins in der Pipelineverzeichnisstruktur im Ordner AddIns befinden.</param>
        <summary>Sucht alle Add-Ins für eine angegebene Hostansicht des Add-Ins in einem angegebenen Stammverzeichnis.</summary>
        <returns>Eine Auflistung von Token, die die gefundenen Add-Ins darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft die Speicherdateien zwischengespeicherte-add-Ins und -Segment Pipelineinformationen alle add-ins gefunden, ein angegebenes `hostAddInView` Typ. Anschließend können Sie eines der Token in der zurückgegebenen <xref:System.AddIn.Hosting.AddInToken> Auflistung so aktivieren Sie ein bestimmtes Add-in durch Aufrufen der <xref:System.AddIn.Hosting.AddInToken.Activate%2A> Methode der <xref:System.AddIn.Hosting.AddInToken> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Es ist eine Zugriffsverletzung bei der Pipelineverzeichnisstruktur aufgetreten.</exception>
        <altmember cref="M:System.AddIn.Hosting.AddInStore.FindAddIn(System.Type,System.String,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Rebuild">
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt den Pipelinesegmentcache neu und schließt neue Segmente ein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rebuild">
      <MemberSignature Language="C#" Value="public static string[] Rebuild (System.AddIn.Hosting.PipelineStoreLocation location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Rebuild(valuetype System.AddIn.Hosting.PipelineStoreLocation location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.Rebuild(System.AddIn.Hosting.PipelineStoreLocation)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rebuild (location As PipelineStoreLocation) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Rebuild(System::AddIn::Hosting::PipelineStoreLocation location);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.AddIn.Hosting.PipelineStoreLocation" />
      </Parameters>
      <Docs>
        <param name="location">Einer der Enumerationswerte.  
  
 Derzeit ist der einzige Wert in dieser Enumeration das von der <see cref="P:System.AppDomainSetup.ApplicationBase" />-Eigenschaft angegebene Verzeichnis, mit dem die Anwendungsdomäne des Hosts eingerichtet wurde.</param>
        <summary>Erstellt den Pipelinesegmentcache neu und schließt neue Segmente am von einem <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" />-Wert angegebenen Speicherort ein.</summary>
        <returns>Eine Auflistung von Zeichenfolgen, die Warnungen während der Überprüfung der Pipelinesegmente beschreiben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um einem teilweise vertrauenswürdigen Host, die nicht über die Berechtigung, einen eigenen Speicherort ermitteln kann, um-add-ins im Verzeichnis eigenen zu ermitteln aktivieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">In der Pipelineverzeichnisstruktur fehlt ein Segmentverzeichnis.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Es ist eine Zugriffsverletzung bei der Pipelineverzeichnisstruktur aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="location" /> ist ein ungültiger <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Rebuild">
      <MemberSignature Language="C#" Value="public static string[] Rebuild (string pipelineRootFolderPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Rebuild(string pipelineRootFolderPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.Rebuild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rebuild (pipelineRootFolderPath As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Rebuild(System::String ^ pipelineRootFolderPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pipelineRootFolderPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pipelineRootFolderPath">Der Pfad zum Stamm der Pipelineverzeichnisstruktur.</param>
        <summary>Erstellt den Pipelinesegmentcache neu und schließt neue Segmente aus einem angegebenen Stammverzeichnis ein.</summary>
        <returns>Eine Auflistung von Zeichenfolgen, die Warnungen während der Überprüfung der Pipelinesegmente beschreiben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt die Cache-Add-ins neu, wenn die Add-ins in der Pipelineverzeichnisstruktur befinden.  
  
 Verwenden Sie diese Methode nur, wenn es möglicherweise liegt ein Problem mit dem Cache und neu erstellt werden müssen. Verwenden Sie die Leistung zu verbessern, die <xref:System.AddIn.Hosting.AddInStore.Update%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">In der Pipelineverzeichnisstruktur fehlt ein Segmentverzeichnis.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Es ist eine Zugriffsverletzung bei der Pipelineverzeichnisstruktur aufgetreten.</exception>
        <altmember cref="M:System.AddIn.Hosting.AddInStore.Update(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RebuildAddIns">
      <MemberSignature Language="C#" Value="public static string[] RebuildAddIns (string addInsFolderPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] RebuildAddIns(string addInsFolderPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.RebuildAddIns(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RebuildAddIns (addInsFolderPath As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ RebuildAddIns(System::String ^ addInsFolderPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addInsFolderPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="addInsFolderPath">Der Pfad des Verzeichnisses, das ein oder mehrere Unterverzeichnisse von Add-Ins enthält.</param>
        <summary>Erstellt den Add-In-Cache neu und schließt neue Add-Ins aus einem angegebenen Stammverzeichnis ein.</summary>
        <returns>Eine Auflistung von Zeichenfolgen, die Warnungen während der Überprüfung der Pipelinesegmente beschreiben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode, wenn Ihre Add-Ins außerhalb der Pipelineverzeichnisstruktur enthalten sind.  
  
 Verwenden Sie diese Methode nur, wenn es möglicherweise liegt ein Problem mit dem Cache und neu erstellt werden müssen. Verwenden Sie die Leistung zu verbessern, die <xref:System.AddIn.Hosting.AddInStore.UpdateAddIns%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">In der Pipelineverzeichnisstruktur fehlt ein Segmentverzeichnis.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Es ist eine Zugriffsverletzung bei der Pipelineverzeichnisstruktur aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addInsFolderPath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Aufrufer verfügt nicht über Lese- und Schreibzugriffsberechtigungen für den Speicherort, der von <paramref name="addInsFolderPath" /> angegeben wird.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Fähigkeit zum Lesen und aktualisieren die Add-In-Ordners. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="M:System.AddIn.Hosting.AddInStore.UpdateAddIns(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Update">
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualisiert den Pipelinesegmentcache mit neuen Segmenten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public static string[] Update (System.AddIn.Hosting.PipelineStoreLocation location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Update(valuetype System.AddIn.Hosting.PipelineStoreLocation location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.Update(System.AddIn.Hosting.PipelineStoreLocation)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Update (location As PipelineStoreLocation) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Update(System::AddIn::Hosting::PipelineStoreLocation location);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.AddIn.Hosting.PipelineStoreLocation" />
      </Parameters>
      <Docs>
        <param name="location">Einer der Enumerationswerte.  
  
 Derzeit ist der einzige Wert in dieser Enumeration das von der <see cref="P:System.AppDomainSetup.ApplicationBase" />-Eigenschaft angegebene Verzeichnis, mit dem die Anwendungsdomäne des Hosts eingerichtet wurde.</param>
        <summary>Aktualisiert den Pipelinesegmentcache mit neuen Segmenten am von einem <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" />-Wert angegebenen Speicherort.</summary>
        <returns>Eine Auflistung von Zeichenfolgen, die Warnungen während der Überprüfung der Pipelinesegmente beschreiben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um einem teilweise vertrauenswürdigen Host, die nicht über die Berechtigung, einen eigenen Speicherort ermitteln kann, um-add-ins im Verzeichnis eigenen zu ermitteln aktivieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">In der Pipelineverzeichnisstruktur fehlt ein Segmentverzeichnis.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Es ist eine Zugriffsverletzung bei der Pipelineverzeichnisstruktur aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="location" /> ist ein ungültiger <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public static string[] Update (string pipelineRootFolderPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Update(string pipelineRootFolderPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.Update(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Update (pipelineRootFolderPath As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Update(System::String ^ pipelineRootFolderPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pipelineRootFolderPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pipelineRootFolderPath">Der Pfad zum Stamm der Pipelineverzeichnisstruktur.</param>
        <summary>Aktualisiert den Pipelinesegmentcache mit neuen Segmenten aus einem angegebenen Stammverzeichnis.</summary>
        <returns>Eine Auflistung von Zeichenfolgen, die Warnungen während der Überprüfung der Pipelinesegmente beschreiben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird den Cache-Add-ins auch aktualisiert, wenn die Add-ins in der Pipelineverzeichnisstruktur befinden.  
  
 Wenn keine neuen Pipelinesegmente oder -add-ins sind, überprüft diese Methode nur den Cache.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die Cache-Dateien zu aktualisieren. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.AddIn.Hosting.AddInStore> Klasse.  
  
 [!code-csharp[AddInP3Host#3](~/samples/snippets/csharp/VS_Snippets_CLR/addinP3Host/cs/P3Host.cs#3)]
 [!code-vb[AddInP3Host#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/addinP3Host/vb/p3host.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">In der Pipelineverzeichnisstruktur fehlt ein Segmentverzeichnis.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Es ist eine Zugriffsverletzung bei der Pipelineverzeichnisstruktur aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="UpdateAddIns">
      <MemberSignature Language="C#" Value="public static string[] UpdateAddIns (string addInsFolderPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] UpdateAddIns(string addInsFolderPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.UpdateAddIns(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UpdateAddIns (addInsFolderPath As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ UpdateAddIns(System::String ^ addInsFolderPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addInsFolderPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="addInsFolderPath">Der Pfad des Verzeichnisses, das ein oder mehrere Unterverzeichnisse von Add-Ins enthält.</param>
        <summary>Aktualisiert den Add-In-Cache und schließt neue Add-Ins an einem angegebenen Speicherort ein.</summary>
        <returns>Eine Auflistung von Zeichenfolgen, die Warnungen während der Überprüfung der Pipelinesegmente beschreiben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode, wenn Ihre Add-Ins außerhalb der Pipelineverzeichnisstruktur enthalten sind.  
  
 Wenn keine neuen Add-Ins installiert sind, überprüft diese Methode nur den Cache.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">In der Pipelineverzeichnisstruktur fehlt ein Segmentverzeichnis.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Es ist eine Zugriffsverletzung bei der Pipelineverzeichnisstruktur aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addInsFolderPath" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Aufrufer verfügt nicht über Lese- und Schreibzugriffsberechtigungen für den Speicherort, der von <paramref name="addInsFolderPath" /> angegeben wird.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Fähigkeit zum Lesen und aktualisieren die Add-In-Ordners. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />. Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>