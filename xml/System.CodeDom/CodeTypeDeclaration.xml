<Type Name="CodeTypeDeclaration" FullName="System.CodeDom.CodeTypeDeclaration">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eb8a78b4c2231ab22f16c02446d7a7d4328a6f05" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69340973" /></Metadata><TypeSignature Language="C#" Value="public class CodeTypeDeclaration : System.CodeDom.CodeTypeMember" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit CodeTypeDeclaration extends System.CodeDom.CodeTypeMember" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.CodeTypeDeclaration" />
  <TypeSignature Language="VB.NET" Value="Public Class CodeTypeDeclaration&#xA;Inherits CodeTypeMember" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeTypeDeclaration : System::CodeDom::CodeTypeMember" />
  <TypeSignature Language="F#" Value="type CodeTypeDeclaration = class&#xA;    inherit CodeTypeMember" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.CodeDom.CodeTypeMember</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Typdeklaration für eine Klasse, Struktur, Schnittstelle oder Enumeration dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.CodeTypeDeclaration>kann verwendet werden, um Code darzustellen, der eine Klasse, eine Struktur, eine Schnittstelle oder eine Enumeration deklariert. <xref:System.CodeDom.CodeTypeDeclaration>kann verwendet werden, um einen Typ zu deklarieren, der in einem anderen Typ geschachtelt ist.  
  
 Die <xref:System.CodeDom.CodeTypeDeclaration.BaseTypes%2A> -Eigenschaft gibt den Basistyp oder die Basis Typen des deklarierten Typs an. Die <xref:System.CodeDom.CodeTypeDeclaration.Members%2A> -Eigenschaft enthält die Typmember, die Methoden, Felder, Eigenschaften, Kommentare und andere Typen einschließen können. Die <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> -Eigenschaft gibt <xref:System.Reflection.TypeAttributes> die Werte für die Typdeklaration an, die die Typkategorie des Typs angeben. Die <xref:System.CodeDom.CodeTypeDeclaration.IsClass%2A>Methoden <xref:System.CodeDom.CodeTypeDeclaration.IsStruct%2A>, ,<xref:System.CodeDom.CodeTypeDeclaration.IsEnum%2A> und<xref:System.CodeDom.CodeTypeDeclaration.IsInterface%2A> geben an, ob der Typ eine Klasse, Struktur, Enumeration bzw. Schnittstellentyp ist.  
  
> [!NOTE]
>  Einige Programmiersprachen unterstützen nur die Deklaration von Verweis Typen oder-Klassen. Um einen sprachspezifischen CodeDOM-Code-Generator für die Unterstützung zum Deklarieren von Schnittstellen, Enumerationen oder Werttypen zu überprüfen, <xref:System.CodeDom.Compiler.GeneratorSupport> müssen Sie die <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> -Methode zum Testen der entsprechenden Flags aufzurufen. <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareInterfaces>Gibt die Unterstützung für <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareEnums> Schnittstellen an, gibt die Unterstützung <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareValueTypes> für Enumerationen an und gibt Unterstützung für Werttypen wie Strukturen an.  
  
 Sie können eine Klasse oder eine Struktur Implementierung in einer kompletten Deklaration erstellen oder die Implementierung auf mehrere Deklarationen verteilen. Die <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> -Eigenschaft gibt an, ob die Typdeklaration vollständig oder teilweise ist. Nicht alle Code-Generatoren unterstützen partielle Typdeklarationen. Daher sollten Sie die <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> -Methode mit dem-Flag <xref:System.CodeDom.Compiler.GeneratorSupport.PartialTypes>aufrufen, um diese Unterstützung zu testen.  
  
   
  
## Examples  
 <xref:System.CodeDom.CodeTypeDeclaration> In diesem Beispiel wird die Verwendung von zum Deklarieren eines Typs veranschaulicht.  
  
 [!code-cpp[CodeTypeDeclarationExample#2](~/samples/snippets/cpp/VS_Snippets_CLR/CodeTypeDeclarationExample/CPP/codetypedeclarationexample.cpp#2)]
 [!code-csharp[CodeTypeDeclarationExample#2](~/samples/snippets/csharp/VS_Snippets_CLR/CodeTypeDeclarationExample/CS/codetypedeclarationexample.cs#2)]
 [!code-vb[CodeTypeDeclarationExample#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeTypeDeclarationExample/VB/codetypedeclarationexample.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.CodeDom.CodeTypeDeclarationCollection" />
    <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.CodeDom.CodeTypeDeclaration" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CodeTypeDeclaration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.CodeTypeDeclaration.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CodeTypeDeclaration();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.CodeDom.CodeTypeDeclaration" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CodeTypeDeclaration (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.CodeTypeDeclaration.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CodeTypeDeclaration(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.CodeDom.CodeTypeDeclaration : string -&gt; System.CodeDom.CodeTypeDeclaration" Usage="new System.CodeDom.CodeTypeDeclaration name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name für den neuen Typ.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.CodeDom.CodeTypeDeclaration" />-Klasse mit dem angegebenen Namen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseTypes">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeReferenceCollection BaseTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeReferenceCollection BaseTypes" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.BaseTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseTypes As CodeTypeReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeReferenceCollection ^ BaseTypes { System::CodeDom::CodeTypeReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseTypes : System.CodeDom.CodeTypeReferenceCollection" Usage="System.CodeDom.CodeTypeDeclaration.BaseTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Basistypen des Typs ab.</summary>
        <value>Ein <see cref="T:System.CodeDom.CodeTypeReferenceCollection" />-Objekt, das die Basistypen des Typs angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie eine Klasse in Visual Basic generieren möchten, die nicht von einem Basistyp erbt, aber eine oder mehrere Schnittstellen implementiert, müssen <xref:System.Object> Sie als erstes Element in die <xref:System.CodeDom.CodeTypeDeclaration.BaseTypes%2A> Auflistung einschließen.  
  
> [!NOTE]
>  In der .NET Framework Version 2,0 benötigen <xref:System.CodeDom.CodeTypeReference> <xref:System.Object> Sie nicht, wenn die Schnittstelle, die Sie implementieren, bereits vorhanden ist und Sie Sie durch den Typ verweisen. Wenn Sie z. b. die <xref:System.Collections.ICollection> -Schnittstelle implementieren und Sie der-Auflistung mit dieser `ctd.BaseTypes.Add(New CodeTypeReference(typeof(ICollection)))`Anweisung hinzufügen, benötigen Sie die vorangehende `ctd.BaseTypes.Add(New CodeTypeReference(GetType(Object)))` -Anweisung nicht.  
  
 Der folgende Code veranschaulicht das Hinzufügen einer <xref:System.CodeDom.CodeTypeReference> zu der-Auflistung, auf <xref:System.Object>die verweist.  
  
```vb  
Dim ctd As New CodeTypeDeclaration("Class1")  
ctd.IsClass = True  
ctd.BaseTypes.Add(New CodeTypeReference(GetType(Object)))  
ctd.BaseTypes.Add(New CodeTypeReference("Interface1"))  
```  
  
```csharp  
CodeTypeDeclaration ctd = new CodeTypeDeclaration("Class1");  
ctd.IsClass = true;  
ctd.BaseTypes.Add(new CodeTypeReference(typeof(Object)));  
ctd.BaseTypes.Add(new CodeTypeReference("Interface1"));  
```  
  
 Der vorangehende Code generiert das Äquivalent der folgenden Visual Basic-Codes.  
  
```vb  
Public Class Class1  
Implements Interface1  
```  
  
 Der Visual Basic Code, der tatsächlich generiert wird, ist jedoch die folgende.  
  
```vb  
Public Class Class1  
Inherits Object  
Implements Interface1  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeTypeReferenceCollection" />
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob es sich bei dem Typ um eine Klasse oder einen Verweistyp handelt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der Typ eine Klasse oder ein Verweistyp ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public bool IsEnum { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnum { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ eine Enumeration ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der Typ eine Enumeration ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ eine Schnittstelle ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der Typ eine Schnittstelle ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPartial">
      <MemberSignature Language="C#" Value="public bool IsPartial { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPartial" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsPartial" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPartial As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPartial { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPartial : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsPartial" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Typdeklaration vollständig oder partiell ist, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn die Klassen- oder Strukturdeklaration eine partielle Repräsentation der Implementierung darstellt, und <see langword="false" />, wenn die Deklaration eine vollständige Implementierung der Klasse oder der Struktur ist. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können eine Klassen-oder Struktur Implementierung in einer kompletten Deklaration erstellen oder die Implementierung auf mehrere Deklarationen verteilen. Implementierungen werden häufig in einer umfassenden Typdeklaration bereitgestellt. Legen Sie in diesem Fall die Eigenschaft <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> Typdeklaration `false`auf fest. Dies bedeutet, dass die Typdeklaration alle Details für die Implementierung der Klasse oder Struktur darstellt.  
  
 Eine partielle Typdeklaration vereinfacht das Erstellen unterschiedlicher Teile einer Klassen-oder Struktur Implementierung in verschiedenen Modulen Ihrer Anwendung. Die partiellen Typdeklarationen können in einer Quelldatei gespeichert oder auf mehrere Quelldateien verteilt werden, die schließlich zusammen kompiliert werden, um die kombinierte Typimplementierung zu bilden.  
  
 Die C# Sprache unterstützt partielle Typdeklarationen von Klassen und `partial` Strukturen über das-Schlüsselwort. Visual Basic unterstützt partielle Typdeklarationen von Klassen und `Partial` Strukturen mit dem-Schlüsselwort. Nicht alle Code-Generatoren unterstützen partielle Typdeklarationen. Daher sollten Sie die <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> -Methode mit dem-Flag <xref:System.CodeDom.Compiler.GeneratorSupport.PartialTypes>aufrufen, um diese Unterstützung zu testen.  
  
> [!NOTE]
>  Partielle Typdeklarationen werden für Klassen und Strukturen unterstützt. Wenn Sie eine partielle Typdeklaration für eine Enumeration oder Schnittstelle angeben, erzeugt der generierte Code Compilerfehler.  
  
 Wenn Sie eine Klassen-oder Struktur Implementierung über mehrere Deklarationen hinweg <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> bereitstellen `true` , legen Sie die-Eigenschaft für die erste Deklaration und alle ergänzenden Deklarationen auf fest. Die ursprüngliche Deklaration muss die Typsignatur vollständig angeben, einschließlich der Zugriffsmodifizierer, geerbte Typen und implementierter Schnittstellen Die ergänzenden Deklarationen müssen die Typsignatur nicht erneut angeben. Ein Compilerfehler ergibt sich in der Regel, wenn Sie die Typsignatur in einer ergänzenden Deklaration neu definieren.  
  
 Visual Studio 2005 verwendet partielle Typen, um vom benutzergenerierten Code aus dem Designer Code zu trennen. In Visual Basic Windows-Anwendungsprojekten wird der Benutzercode in einer partiellen Klasse platziert, die nicht durch das `Partial` -Schlüsselwort qualifiziert ist. der vom Designer bereitgestellte Code wird in der `Partial` partiellen Klasse mit dem-Schlüsselwort angezeigt. In C#werden der Benutzercode und der Designer Code in partiellen Klassen angezeigt, die `partial` durch das-Schlüsselwort identifiziert werden.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht <xref:System.CodeDom.CodeTypeDeclaration> die Verwendung von, um eine Klassen Implementierung über mehrere Deklarationen hinweg bereitzustellen. Im Beispiel wird die anfängliche Klassen Deklarations Anweisung erstellt und <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> die- `true`Eigenschaft auf festgelegt.  
  
 [!code-cpp[CodeDomPartialTypeExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomPartialTypeExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomPartialTypeExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomPartialTypeExample/CS/source.cs#3)]
 [!code-vb[CodeDomPartialTypeExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomPartialTypeExample/VB/source.vb#3)]  
  
 Eine andere Methode im Beispiel erweitert die-Klassen Implementierung. Diese Methode erstellt eine neue typdeklarations Anweisung für die vorhandene Klasse und legt <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> die- `true`Eigenschaft auf fest. Der Compiler kombiniert die beiden partiellen Typdeklarationen zusammen für die vollständige Klassen Implementierung.  
  
 [!code-cpp[CodeDomPartialTypeExample#7](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomPartialTypeExample/CPP/source.cpp#7)]
 [!code-csharp[CodeDomPartialTypeExample#7](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomPartialTypeExample/CS/source.cs#7)]
 [!code-vb[CodeDomPartialTypeExample#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomPartialTypeExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.CodeDom.Compiler.GeneratorSupport.PartialTypes" />
      </Docs>
    </Member>
    <Member MemberName="IsStruct">
      <MemberSignature Language="C#" Value="public bool IsStruct { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStruct" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsStruct" />
      <MemberSignature Language="VB.NET" Value="Public Property IsStruct As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStruct { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsStruct : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsStruct" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob es sich bei dem Typ um einen Werttyp (Struktur) handelt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der Typ ein Werttyp ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Members">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeMemberCollection Members { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeMemberCollection Members" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.Members" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Members As CodeTypeMemberCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeMemberCollection ^ Members { System::CodeDom::CodeTypeMemberCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Members : System.CodeDom.CodeTypeMemberCollection" Usage="System.CodeDom.CodeTypeDeclaration.Members" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeMemberCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der Klassenmember für den dargestellten Typ ab.</summary>
        <value>Ein <see cref="T:System.CodeDom.CodeTypeMemberCollection" />-Objekt, das die Klassenmember angibt.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.CodeDom.CodeTypeMemberCollection" />
      </Docs>
    </Member>
    <Member MemberName="PopulateBaseTypes">
      <MemberSignature Language="C#" Value="public event EventHandler PopulateBaseTypes;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PopulateBaseTypes" />
      <MemberSignature Language="DocId" Value="E:System.CodeDom.CodeTypeDeclaration.PopulateBaseTypes" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PopulateBaseTypes As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PopulateBaseTypes;" />
      <MemberSignature Language="F#" Value="member this.PopulateBaseTypes : EventHandler " Usage="member this.PopulateBaseTypes : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Erfolgt beim erstmaligen Zugriff auf die <see cref="P:System.CodeDom.CodeTypeDeclaration.BaseTypes" />-Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopulateMembers">
      <MemberSignature Language="C#" Value="public event EventHandler PopulateMembers;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PopulateMembers" />
      <MemberSignature Language="DocId" Value="E:System.CodeDom.CodeTypeDeclaration.PopulateMembers" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PopulateMembers As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PopulateMembers;" />
      <MemberSignature Language="F#" Value="member this.PopulateMembers : EventHandler " Usage="member this.PopulateMembers : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Erfolgt beim erstmaligen Zugriff auf die <see cref="P:System.CodeDom.CodeTypeDeclaration.Members" />-Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAttributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes TypeAttributes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes TypeAttributes" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.TypeAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Property TypeAttributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes TypeAttributes { System::Reflection::TypeAttributes get(); void set(System::Reflection::TypeAttributes value); };" />
      <MemberSignature Language="F#" Value="member this.TypeAttributes : System.Reflection.TypeAttributes with get, set" Usage="System.CodeDom.CodeTypeDeclaration.TypeAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Attribute des Typs ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attribute des Typs angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.TypeAttributes> -Eigenschaft enthält den gleichen Typ von Werten, <xref:System.Reflection> die von verwendet werden, wenn ein Typ zur Laufzeit untersucht wird. Viele dieser Flags entsprechen nicht der typdeklarations Syntax für einige Sprachen. Folglich sind nur die folgenden Flags von <xref:System.CodeDom.CodeTypeDeclaration> Bedeutung: <xref:System.Reflection.TypeAttributes.Public> <xref:System.Reflection.TypeAttributes.Abstract> <xref:System.Reflection.TypeAttributes.Class>, <xref:System.Reflection.TypeAttributes.Interface>,, <xref:System.Reflection.TypeAttributes.Sealed>,, <xref:System.Reflection.TypeAttributes.NotPublic>, <xref:System.Reflection.TypeAttributes.NestedPublic>und. <xref:System.Reflection.TypeAttributes.NestedPrivate>  
  
> [!NOTE]
>  Einige der Flags, <xref:System.Reflection.TypeAttributes.Abstract> z. b. überlappen sich mit der Bedeutung von Flags in der <xref:System.CodeDom.CodeTypeMember.Attributes%2A> -Eigenschaft <xref:System.CodeDom.CodeTypeMember>von <xref:System.CodeDom.CodeTypeDeclaration> , die von geerbt wird. Die <xref:System.CodeDom.CodeTypeMember.Attributes%2A> -Eigenschaft ist ein Nebeneffekt <xref:System.CodeDom.CodeTypeDeclaration> der-Klasse, die <xref:System.CodeDom.CodeTypeMember> von erbt, sodass Klassen eingefügt werden können. Die Flags in der <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> -Eigenschaft sollten anstelle der-Flags in der <xref:System.CodeDom.CodeTypeMember.Attributes%2A> -Eigenschaft verwendet werden.  
  
> [!NOTE]
>  Das Muster für das Festlegen der Sichtbarkeits Kennzeichen (Flags, `Public` die `Nested`die Wörter oder enthalten) besteht darin, <xref:System.Reflection.TypeAttributes.VisibilityMask> alle Sichtbarkeits Kennzeichen mithilfe von zu maskieren und dann das gewünschte Sichtbarkeits Kennzeichen festzulegen. Beispielsweise ist C# <xref:System.CodeDom.CodeTypeDeclaration> `cd` dieCodeAnweisung,umden(mitdemNamen)alsinterneKlasse`cd.TypeAttributes = (cd.TypeAttributes & ~TypeAttributes.VisibilityMask) | TypeAttributes.NotPublic;`zu identifizieren,.  Der Code zum Festlegen desselben Werts in Visual Basic ist `cd.TypeAttributes = (cd.TypeAttributes And (TypeAttributes.VisibilityMask Xor -1)) Or TypeAttributes.NotPublic`. Wenn Sie <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> die-Eigenschaft direkt auf ein Sichtbarkeits Flag (`cd.TypeAttributes = TypeAttributes.NotPublic;`) festlegen, werden alle anderen Flags, die festgelegt werden können, gelöscht.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="TypeParameters">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeParameterCollection TypeParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeParameterCollection TypeParameters" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.TypeParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeParameters As CodeTypeParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeParameterCollection ^ TypeParameters { System::CodeDom::CodeTypeParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeParameters : System.CodeDom.CodeTypeParameterCollection" Usage="System.CodeDom.CodeTypeDeclaration.TypeParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Typparameter für die Typdeklaration ab.</summary>
        <value>Eine <see cref="T:System.CodeDom.CodeTypeParameterCollection" />-Klasse, die die Typparameter für die Typdeklaration enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine generische Typdeklaration enthält einen oder mehrere nicht angegebene Typen, die als Typparameter bezeichnet werden. Ein Typparameter Name steht für den Typ im Text der generischen Deklaration. Die generische Deklaration <xref:System.Collections.Generic.List%601> der-Klasse enthält z. b. den `T`Typparameter.  
  
 Weitere Informationen zu Generika finden Sie unter [Generika in der .NET Framework-Klassenbibliothek](~/docs/csharp/programming-guide/generics/generics-in-the-net-framework-class-library.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeTypeParameterCollection" />
        <altmember cref="T:System.CodeDom.CodeTypeParameter" />
      </Docs>
    </Member>
  </Members>
</Type>
