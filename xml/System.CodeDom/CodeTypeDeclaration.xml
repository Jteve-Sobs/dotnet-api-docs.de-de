<Type Name="CodeTypeDeclaration" FullName="System.CodeDom.CodeTypeDeclaration">
  <Metadata><Meta Name="ms.openlocfilehash" Value="42248b06ac1fa179439385ec22e10bd4ab4b5a36" /><Meta Name="ms.sourcegitcommit" Value="1bb00d2f4343e73ae8d58668f02297a3cf10a4c1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="06/15/2019" /><Meta Name="ms.locfileid" Value="63910090" /></Metadata><TypeSignature Language="C#" Value="public class CodeTypeDeclaration : System.CodeDom.CodeTypeMember" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit CodeTypeDeclaration extends System.CodeDom.CodeTypeMember" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.CodeTypeDeclaration" />
  <TypeSignature Language="VB.NET" Value="Public Class CodeTypeDeclaration&#xA;Inherits CodeTypeMember" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeTypeDeclaration : System::CodeDom::CodeTypeMember" />
  <TypeSignature Language="F#" Value="type CodeTypeDeclaration = class&#xA;    inherit CodeTypeMember" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.CodeDom.CodeTypeMember</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Typdeklaration für eine Klasse, Struktur, Schnittstelle oder Enumeration dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.CodeTypeDeclaration> kann verwendet werden, Code dargestellt, die eine Klasse, Struktur, Schnittstelle oder Enumeration deklariert. <xref:System.CodeDom.CodeTypeDeclaration> kann verwendet werden, um einen Typ zu deklarieren, der in einem anderen Typ geschachtelt ist.  
  
 Die <xref:System.CodeDom.CodeTypeDeclaration.BaseTypes%2A> -Eigenschaft gibt den Basistyp oder die Basistypen des Typs deklariert werden. Die <xref:System.CodeDom.CodeTypeDeclaration.Members%2A> Eigenschaft enthält die Typmember, die Methoden, Felder, Eigenschaften, Kommentare und andere Typen enthalten können. Die <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> Eigenschaft gibt an, die <xref:System.Reflection.TypeAttributes> Werte für die Typdeklaration, die Kategorie der des Typs anzugeben. Die <xref:System.CodeDom.CodeTypeDeclaration.IsClass%2A>, <xref:System.CodeDom.CodeTypeDeclaration.IsStruct%2A>, <xref:System.CodeDom.CodeTypeDeclaration.IsEnum%2A>, und <xref:System.CodeDom.CodeTypeDeclaration.IsInterface%2A> Methoden angeben, ob der Typ eine Klasse, Struktur, Enumeration oder Schnittstellentyp ist.  
  
> [!NOTE]
>  Einige Programmiersprachen unterstützen nur die Deklaration von Verweistypen oder Klassen. Um einen sprachspezifischen CodeDOM-Codegenerator für die Unterstützung für das Deklarieren von Schnittstellen, Enumerationen oder Werttypen zu überprüfen, rufen Sie die <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> -Methode für die entsprechende Prüfung auf <xref:System.CodeDom.Compiler.GeneratorSupport> Flags. <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareInterfaces> Gibt die Unterstützung für Schnittstellen, <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareEnums> gibt Unterstützung für Enumerationen und <xref:System.CodeDom.Compiler.GeneratorSupport.DeclareValueTypes> gibt Unterstützung für Werttypen wie Strukturen.  
  
 Sie können eine Klasse oder einer Struktur-Implementierung in eine vollständige Deklaration zu erstellen, oder Sie können die Implementierung auf mehrere Deklarationen verteilt. Die <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> Eigenschaft gibt an, ob die Typdeklaration vollständig oder partiell ist. Nicht alle Code-Generatoren unterstützen partielle Typdeklarationen, damit Sie für diese Unterstützung durch den Aufruf testen sollten die <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> Methode mit dem Flag <xref:System.CodeDom.Compiler.GeneratorSupport.PartialTypes>.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung einer <xref:System.CodeDom.CodeTypeDeclaration> auf einen Typ zu deklarieren.  
  
 [!code-cpp[CodeTypeDeclarationExample#2](~/samples/snippets/cpp/VS_Snippets_CLR/CodeTypeDeclarationExample/CPP/codetypedeclarationexample.cpp#2)]
 [!code-csharp[CodeTypeDeclarationExample#2](~/samples/snippets/csharp/VS_Snippets_CLR/CodeTypeDeclarationExample/CS/codetypedeclarationexample.cs#2)]
 [!code-vb[CodeTypeDeclarationExample#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeTypeDeclarationExample/VB/codetypedeclarationexample.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.CodeDom.CodeTypeDeclarationCollection" />
    <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.CodeDom.CodeTypeDeclaration" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CodeTypeDeclaration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.CodeTypeDeclaration.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CodeTypeDeclaration();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.CodeDom.CodeTypeDeclaration" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CodeTypeDeclaration (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.CodeTypeDeclaration.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CodeTypeDeclaration(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.CodeDom.CodeTypeDeclaration : string -&gt; System.CodeDom.CodeTypeDeclaration" Usage="new System.CodeDom.CodeTypeDeclaration name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name für den neuen Typ.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.CodeDom.CodeTypeDeclaration" />-Klasse mit dem angegebenen Namen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseTypes">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeReferenceCollection BaseTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeReferenceCollection BaseTypes" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.BaseTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseTypes As CodeTypeReferenceCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeReferenceCollection ^ BaseTypes { System::CodeDom::CodeTypeReferenceCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseTypes : System.CodeDom.CodeTypeReferenceCollection" Usage="System.CodeDom.CodeTypeDeclaration.BaseTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeReferenceCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Basistypen des Typs ab.</summary>
        <value>Ein <see cref="T:System.CodeDom.CodeTypeReferenceCollection" />-Objekt, das die Basistypen des Typs angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Generieren einer Klasse in Visual Basic, die nicht von einem Basistyp erbt, aber, eine oder mehrere Schnittstellen implementiert, müssen Sie enthalten <xref:System.Object> als das erste Element in der <xref:System.CodeDom.CodeTypeDeclaration.BaseTypes%2A> Auflistung.  
  
> [!NOTE]
>  In .NET Framework, Version 2.0, Sie nicht müssen, die <xref:System.CodeDom.CodeTypeReference> für <xref:System.Object> , wenn die Schnittstelle, die Sie bereits implementieren vorhanden ist, und Sie auf die sie nach Typ verweisen. Angenommen, Sie implementieren die <xref:System.Collections.ICollection> Schnittstelle, und fügen Sie es der Auflistung mit den vorliegenden Bestimmungen `ctd.BaseTypes.Add(New CodeTypeReference(typeof(ICollection)))`, Sie benötigen keine der vorherigen `ctd.BaseTypes.Add(New CodeTypeReference(GetType(Object)))` Anweisung.  
  
 Das folgende Codebeispiel veranschaulicht das Hinzufügen einer <xref:System.CodeDom.CodeTypeReference> der Auflistung, die auf verweist <xref:System.Object>.  
  
```vb  
Dim ctd As New CodeTypeDeclaration("Class1")  
ctd.IsClass = True  
ctd.BaseTypes.Add(New CodeTypeReference(GetType(Object)))  
ctd.BaseTypes.Add(New CodeTypeReference("Interface1"))  
```  
  
```csharp  
CodeTypeDeclaration ctd = new CodeTypeDeclaration("Class1");  
ctd.IsClass = true;  
ctd.BaseTypes.Add(new CodeTypeReference(typeof(Object)));  
ctd.BaseTypes.Add(new CodeTypeReference("Interface1"));  
```  
  
 Der vorhergehende Code erzeugt die Entsprechung der folgenden Visual Basic-Code.  
  
```vb  
Public Class Class1  
Implements Interface1  
```  
  
 Der tatsächlich generierte Visual Basic-Code ist jedoch Folgendes.  
  
```vb  
Public Class Class1  
Inherits Object  
Implements Interface1  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeTypeReferenceCollection" />
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob es sich bei dem Typ um eine Klasse oder einen Verweistyp handelt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der Typ eine Klasse oder ein Verweistyp ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public bool IsEnum { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnum { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ eine Enumeration ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der Typ eine Enumeration ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ eine Schnittstelle ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der Typ eine Schnittstelle ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPartial">
      <MemberSignature Language="C#" Value="public bool IsPartial { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPartial" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsPartial" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPartial As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPartial { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPartial : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsPartial" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Typdeklaration vollständig oder partiell ist, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn die Klassen- oder Strukturdeklaration eine partielle Repräsentation der Implementierung darstellt, und <see langword="false" />, wenn die Deklaration eine vollständige Implementierung der Klasse oder der Struktur ist. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können eine Klasse oder Struktur-Implementierung in eine vollständige Deklaration erstellen, oder Sie können die Implementierung auf mehrere Deklarationen verteilt. Implementierungen werden häufig in der Deklaration einer vollständigen Typs bereitgestellt werden. In diesem Fall legen Sie die Typdeklaration <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> Eigenschaft `false`, was bedeutet, dass die Deklaration des Typs alle Details für die Klasse oder Struktur Implementierung darstellt.  
  
 Eine Deklaration der partiellen Typ erleichtert es, um verschiedene Teile einer Klasse oder Struktur-Implementierung in verschiedenen Module Ihrer Anwendung zu erstellen. Der partielle Typdeklarationen können in einer Quelldatei gespeichert oder über mehrere Quelldateien, die kombinierte typimplementierung bilden schließlich zusammen kompiliert werden verteilt werden.  
  
 Die C#-Sprache unterstützt partielle Typdeklarationen von Klassen und Strukturen über die `partial` Schlüsselwort. Visual Basic unterstützt partielle Typdeklarationen von Klassen und Strukturen, die mit der `Partial` Schlüsselwort. Nicht alle Code-Generatoren unterstützen partielle Typdeklarationen, damit Sie für diese Unterstützung durch den Aufruf testen sollten die <xref:System.CodeDom.Compiler.ICodeGenerator.Supports%2A> Methode mit dem Flag <xref:System.CodeDom.Compiler.GeneratorSupport.PartialTypes>.  
  
> [!NOTE]
>  Für Klassen und Strukturen werden partielle Typdeklarationen unterstützt. Wenn Sie eine partielle Typdeklaration für eine Enumeration oder eine Schnittstelle angeben, führt der generierte Code Compilerfehler zu beheben.  
  
 Wenn Sie eine Klasse oder Struktur Implementierung über mehrere Deklarationen angeben, legen Sie die <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> Eigenschaft `true` für die erste Deklaration und alle zusätzlichen Deklarationen. Die ursprüngliche Deklaration muss vollständig Geben Sie die Signatur der Zugriffsmodifizierer, einschließlich Typen geerbt und implementierten Schnittstellen. Die zusätzlichen Deklarationen müssen nicht erneut an die Typsignatur. Ein Compilerfehler führt in der Regel auf, wenn Sie die Typsignatur in eine zusätzliche Deklaration neu definieren.  
  
 Visual Studio 2005 verwendet partielle Typen, um vom Benutzer generierte Code von Designer-Code zu trennen. In Projekten auf Visual Basic-Windows-Anwendung, befindet sich der Benutzercode in einer partiellen Klasse, die durch nicht qualifiziert ist die `Partial` -Schlüsselwort, die vom Designer bereitgestellte Code angezeigt wird, in der partiellen Klasse, die die `Partial` Schlüsselwort. In c# sowohl der Benutzercode als auch die Designercode in partiellen Klassen, die identifizierte angezeigt werden die `partial` Schlüsselwort.  
  
   
  
## Examples  
 Dieses Beispiel veranschaulicht die Verwendung einer <xref:System.CodeDom.CodeTypeDeclaration> Implementierung einer Klasse in mehreren Deklarationen angeben. Im Beispiel wird die erste Klasse deklarationsanweisung erstellt und legt die <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> Eigenschaft `true`.  
  
 [!code-cpp[CodeDomPartialTypeExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomPartialTypeExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomPartialTypeExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomPartialTypeExample/CS/source.cs#3)]
 [!code-vb[CodeDomPartialTypeExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomPartialTypeExample/VB/source.vb#3)]  
  
 Eine andere Methode im Beispiel wird die Implementierung der Klasse erweitert. Diese Methode erstellt eine neue Type-Anweisung für die Deklaration für die vorhandene Klasse und legt die <xref:System.CodeDom.CodeTypeDeclaration.IsPartial%2A> Eigenschaft `true`. Der Compiler kombiniert die beiden Deklarationen der partiellen Typ für die vollständige Implementierung.  
  
 [!code-cpp[CodeDomPartialTypeExample#7](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomPartialTypeExample/CPP/source.cpp#7)]
 [!code-csharp[CodeDomPartialTypeExample#7](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomPartialTypeExample/CS/source.cs#7)]
 [!code-vb[CodeDomPartialTypeExample#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomPartialTypeExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.CodeDom.Compiler.GeneratorSupport.PartialTypes" />
      </Docs>
    </Member>
    <Member MemberName="IsStruct">
      <MemberSignature Language="C#" Value="public bool IsStruct { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStruct" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.IsStruct" />
      <MemberSignature Language="VB.NET" Value="Public Property IsStruct As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStruct { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsStruct : bool with get, set" Usage="System.CodeDom.CodeTypeDeclaration.IsStruct" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob es sich bei dem Typ um einen Werttyp (Struktur) handelt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der Typ ein Werttyp ist, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Members">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeMemberCollection Members { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeMemberCollection Members" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.Members" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Members As CodeTypeMemberCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeMemberCollection ^ Members { System::CodeDom::CodeTypeMemberCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Members : System.CodeDom.CodeTypeMemberCollection" Usage="System.CodeDom.CodeTypeDeclaration.Members" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeMemberCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der Klassenmember für den dargestellten Typ ab.</summary>
        <value>Ein <see cref="T:System.CodeDom.CodeTypeMemberCollection" />-Objekt, das die Klassenmember angibt.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.CodeDom.CodeTypeMemberCollection" />
      </Docs>
    </Member>
    <Member MemberName="PopulateBaseTypes">
      <MemberSignature Language="C#" Value="public event EventHandler PopulateBaseTypes;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PopulateBaseTypes" />
      <MemberSignature Language="DocId" Value="E:System.CodeDom.CodeTypeDeclaration.PopulateBaseTypes" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PopulateBaseTypes As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PopulateBaseTypes;" />
      <MemberSignature Language="F#" Value="member this.PopulateBaseTypes : EventHandler " Usage="member this.PopulateBaseTypes : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Erfolgt beim erstmaligen Zugriff auf die <see cref="P:System.CodeDom.CodeTypeDeclaration.BaseTypes" />-Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopulateMembers">
      <MemberSignature Language="C#" Value="public event EventHandler PopulateMembers;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PopulateMembers" />
      <MemberSignature Language="DocId" Value="E:System.CodeDom.CodeTypeDeclaration.PopulateMembers" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PopulateMembers As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PopulateMembers;" />
      <MemberSignature Language="F#" Value="member this.PopulateMembers : EventHandler " Usage="member this.PopulateMembers : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Erfolgt beim erstmaligen Zugriff auf die <see cref="P:System.CodeDom.CodeTypeDeclaration.Members" />-Auflistung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeAttributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes TypeAttributes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes TypeAttributes" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.TypeAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Property TypeAttributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes TypeAttributes { System::Reflection::TypeAttributes get(); void set(System::Reflection::TypeAttributes value); };" />
      <MemberSignature Language="F#" Value="member this.TypeAttributes : System.Reflection.TypeAttributes with get, set" Usage="System.CodeDom.CodeTypeDeclaration.TypeAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Attribute des Typs ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attribute des Typs angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Reflection.TypeAttributes> Eigenschaft enthält die gleiche Art von Werten von <xref:System.Reflection> beim Untersuchen eines Typs zur Laufzeit. Viele dieser Flags entsprechen nicht um die Syntax zum Deklarieren von Type für einige Sprachen. Daher werden nur die folgenden Flags relevant für die <xref:System.CodeDom.CodeTypeDeclaration> : <xref:System.Reflection.TypeAttributes.Class>, <xref:System.Reflection.TypeAttributes.Interface>, <xref:System.Reflection.TypeAttributes.Abstract>, <xref:System.Reflection.TypeAttributes.Sealed>, <xref:System.Reflection.TypeAttributes.Public>, <xref:System.Reflection.TypeAttributes.NotPublic>, <xref:System.Reflection.TypeAttributes.NestedPublic>, und <xref:System.Reflection.TypeAttributes.NestedPrivate>.  
  
> [!NOTE]
>  Einige der Flags, z. B. <xref:System.Reflection.TypeAttributes.Abstract> überschneiden sich mit der Bedeutung der Flags in der <xref:System.CodeDom.CodeTypeMember.Attributes%2A> Eigenschaft <xref:System.CodeDom.CodeTypeDeclaration> geerbt von <xref:System.CodeDom.CodeTypeMember>. Die <xref:System.CodeDom.CodeTypeMember.Attributes%2A> -Eigenschaft ist ein Nebeneffekt der <xref:System.CodeDom.CodeTypeDeclaration> Klasse erbt von <xref:System.CodeDom.CodeTypeMember> , damit Klassen geschachtelt werden können. Die Flags in der <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> -Eigenschaft sollte verwendet werden, anstatt die Flags in der <xref:System.CodeDom.CodeTypeMember.Attributes%2A> Eigenschaft.  
  
> [!NOTE]
>  Das Muster für das Festlegen von Sichtbarkeitsflags für die (Flags, die die Wörter `Public` oder `Nested`) besteht darin, Maske zunächst alle flags mithilfe der <xref:System.Reflection.TypeAttributes.VisibilityMask> und legen Sie dann das gewünschte Sichtbarkeitsflag. Z. B. die C#-codeanweisung zum Identifizieren der <xref:System.CodeDom.CodeTypeDeclaration> (mit dem Namen `cd`) wie eine interne Klasse `cd.TypeAttributes = (cd.TypeAttributes & ~TypeAttributes.VisibilityMask) | TypeAttributes.NotPublic;`.  Der Code aus, um den gleichen Wert in Visual Basic ist `cd.TypeAttributes = (cd.TypeAttributes And (TypeAttributes.VisibilityMask Xor -1)) Or TypeAttributes.NotPublic`. Festlegen der <xref:System.CodeDom.CodeTypeDeclaration.TypeAttributes%2A> Eigenschaft direkt auf einem Sichtbarkeitsflag (`cd.TypeAttributes = TypeAttributes.NotPublic;`) Löscht alle anderen Flags, die festgelegt werden können.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="TypeParameters">
      <MemberSignature Language="C#" Value="public System.CodeDom.CodeTypeParameterCollection TypeParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.CodeTypeParameterCollection TypeParameters" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.CodeTypeDeclaration.TypeParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeParameters As CodeTypeParameterCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::CodeDom::CodeTypeParameterCollection ^ TypeParameters { System::CodeDom::CodeTypeParameterCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeParameters : System.CodeDom.CodeTypeParameterCollection" Usage="System.CodeDom.CodeTypeDeclaration.TypeParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeTypeParameterCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Typparameter für die Typdeklaration ab.</summary>
        <value>Eine <see cref="T:System.CodeDom.CodeTypeParameterCollection" />-Klasse, die die Typparameter für die Typdeklaration enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deklaration eines generischen Typs enthält ein oder nicht angegebenen Typ, der als Typparameter bezeichnet. Ein Typname für den Parameter steht für den Typ innerhalb des Texts der generischen Deklaration. Z. B. die generische Deklaration für die <xref:System.Collections.Generic.List%601> -Klasse enthält den Typparameter `T`.  
  
 Weitere Informationen zu Generika finden Sie unter [Generika in .NET Framework-Klassenbibliothek](~/docs/csharp/programming-guide/generics/generics-in-the-net-framework-class-library.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeTypeParameterCollection" />
        <altmember cref="T:System.CodeDom.CodeTypeParameter" />
      </Docs>
    </Member>
  </Members>
</Type>