<Type Name="SerialPort" FullName="System.IO.Ports.SerialPort">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f6d8266f03573692bf77677549ef515b6acb8cc0" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83965011" /></Metadata><TypeSignature Language="C#" Value="public class SerialPort : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SerialPort extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.IO.Ports.SerialPort" />
  <TypeSignature Language="VB.NET" Value="Public Class SerialPort&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class SerialPort : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type SerialPort = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.Ports</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("SerialPortDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen seriellen Anschluss (als entsprechende Ressource) dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Klasse, um eine Datei Ressource des seriellen Anschlusses zu steuern. Diese Klasse bietet synchrone und ereignisgesteuerte e/a-Vorgänge, Zugriff auf PIN-und Break-Zustände sowie Zugriff auf die Eigenschaften von seriellen Treibern. Außerdem kann die Funktionalität dieser Klasse in einem internen <xref:System.IO.Stream> Objekt umschlossen werden, auf das über die <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft zugegriffen werden kann und die an Klassen, die Streams umschließen oder verwenden, übermittelt werden.  
  
 Die <xref:System.IO.Ports.SerialPort>-Klasse unterstützt die folgenden Codierungen: <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF32Encoding>und jede in "mscorlib. dll" definierte Codierung, bei der die Codepage kleiner als 50000 oder die Codepage 54936 ist.  Sie können alternative Codierungen verwenden, aber Sie müssen die <xref:System.IO.Ports.SerialPort.ReadByte%2A> oder <xref:System.IO.Ports.SerialPort.Write%2A>-Methode verwenden und die Codierung selbst ausführen.  
  
 Verwenden Sie die <xref:System.IO.Ports.SerialPort.GetPortNames%2A>-Methode, um die gültigen Ports für den aktuellen Computer abzurufen.  
  
 Wenn ein <xref:System.IO.Ports.SerialPort> Objekt während eines Lesevorgangs blockiert wird, sollten Sie den Thread nicht abbrechen. Schließen Sie stattdessen den Basisstream, oder löschen Sie das <xref:System.IO.Ports.SerialPort>-Objekt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Beide Computer müssen das Programm ausführen, um die vollständige Funktionalität dieses Beispiels zu erzielen.  
  
 [!code-cpp[System.IO.Ports.SerialPort#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#10)]
 [!code-csharp[System.IO.Ports.SerialPort#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#10)]
 [!code-vb[System.IO.Ports.SerialPort#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#10)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor verwendet Standardeigenschaftswerte, wenn keine Werte angegeben werden. Beispielsweise ist die <xref:System.IO.Ports.SerialPort.DataBits%2A>-Eigenschaft standardmäßig auf 8 eingestellt, die <xref:System.IO.Ports.SerialPort.Parity%2A>-Eigenschaft standardmäßig auf den `None`-Enumerationswert, die <xref:System.IO.Ports.SerialPort.StopBits%2A>-Eigenschaft standardmäßig auf 1 und den standardportnamen COM1.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::ComponentModel::IContainer ^ container);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : System.ComponentModel.IContainer -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort container" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Eine Schnittstelle zu einem Container.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Ports.SerialPort" />-Klasse mit dem angegebenen <see cref="T:System.ComponentModel.IContainer" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor verwendet Standardeigenschaftswerte, wenn keine Werte angegeben werden. Beispielsweise ist die <xref:System.IO.Ports.SerialPort.DataBits%2A>-Eigenschaft standardmäßig auf 8 eingestellt, die <xref:System.IO.Ports.SerialPort.Parity%2A>-Eigenschaft standardmäßig auf den `None`-Enumerationswert, die <xref:System.IO.Ports.SerialPort.StopBits%2A>-Eigenschaft standardmäßig auf 1 und den standardportnamen COM1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der angegebene Anschluss wurde nicht gefunden oder konnte nicht geöffnet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort portName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="portName">Der zu verwendende Anschluss (z. B. COM1).</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Ports.SerialPort" />-Klasse unter Verwendung des angegebenen Anschlussnamens.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, um eine neue Instanz der <xref:System.IO.Ports.SerialPort>-Klasse zu erstellen, wenn Sie den Portnamen angeben möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der angegebene Anschluss wurde nicht gefunden oder konnte nicht geöffnet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String, baudRate As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Der zu verwendende Anschluss (z. B. COM1).</param>
        <param name="baudRate">Die Baudrate.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Ports.SerialPort" />-Klasse unter Verwendung des angegebenen Anschlussnamens und der Baudrate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, um eine neue Instanz der <xref:System.IO.Ports.SerialPort>-Klasse zu erstellen, wenn Sie den Portnamen und die Baudrate angeben möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der angegebene Anschluss wurde nicht gefunden oder konnte nicht geöffnet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String, baudRate As Integer, parity As Parity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
      </Parameters>
      <Docs>
        <param name="portName">Der zu verwendende Anschluss (z. B. COM1).</param>
        <param name="baudRate">Die Baudrate.</param>
        <param name="parity">Einer der <see cref="P:System.IO.Ports.SerialPort.Parity" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Ports.SerialPort" />-Klasse mit dem angegebenen Anschlussnamen, der Baudrate und dem Paritätsbit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, um eine neue Instanz der <xref:System.IO.Ports.SerialPort>-Klasse zu erstellen, wenn Sie den Portnamen, die Baudrate und das Paritäts Bit angeben möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der angegebene Anschluss wurde nicht gefunden oder konnte nicht geöffnet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String, baudRate As Integer, parity As Parity, dataBits As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Der zu verwendende Anschluss (z. B. COM1).</param>
        <param name="baudRate">Die Baudrate.</param>
        <param name="parity">Einer der <see cref="P:System.IO.Ports.SerialPort.Parity" />-Werte.</param>
        <param name="dataBits">Der Datenbitwert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Ports.SerialPort" />-Klasse mit dem angegebenen Anschlussnamen, der Baudrate, dem Paritätsbit und Datenbits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, um eine neue Instanz der <xref:System.IO.Ports.SerialPort>-Klasse zu erstellen, wenn Sie den Portnamen, die Baudrate, das Paritäts Bit und die Datenbits angeben möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der angegebene Anschluss wurde nicht gefunden oder konnte nicht geöffnet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits, System.IO.Ports.StopBits stopBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits, valuetype System.IO.Ports.StopBits stopBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32,System.IO.Ports.StopBits)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String, baudRate As Integer, parity As Parity, dataBits As Integer, stopBits As StopBits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits, System::IO::Ports::StopBits stopBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int * System.IO.Ports.StopBits -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits, stopBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
        <Parameter Name="stopBits" Type="System.IO.Ports.StopBits" />
      </Parameters>
      <Docs>
        <param name="portName">Der zu verwendende Anschluss (z. B. COM1).</param>
        <param name="baudRate">Die Baudrate.</param>
        <param name="parity">Einer der <see cref="P:System.IO.Ports.SerialPort.Parity" />-Werte.</param>
        <param name="dataBits">Der Datenbitwert.</param>
        <param name="stopBits">Einer der <see cref="P:System.IO.Ports.SerialPort.StopBits" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Ports.SerialPort" />-Klasse mit dem angegebenen Anschlussnamen, der Baudrate, dem Paritätsbit, den Datenbits und Stoppbits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, um eine neue Instanz der <xref:System.IO.Ports.SerialPort>-Klasse zu erstellen, wenn Sie den Portnamen, die Baudrate, das Paritäts Bit, die Datenbits und das Stoppbit angeben möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der angegebene Anschluss wurde nicht gefunden oder konnte nicht geöffnet werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.Ports.SerialPort.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das zugrunde liegende <see cref="T:System.IO.Stream" />-Objekt für ein <see cref="T:System.IO.Ports.SerialPort" />-Objekt ab.</summary>
        <value>Ein <see cref="T:System.IO.Stream" /> -Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft für explizite asynchrone e/a-Vorgänge oder, um das <xref:System.IO.Ports.SerialPort> Objekt an eine <xref:System.IO.Stream> Wrapper Klasse wie <xref:System.IO.StreamWriter>zu übergeben.  
  
 Die <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft eines geöffneten seriellen Ports gibt ein Objekt zurück, das von der abstrakten <xref:System.IO.Stream> Klasse abgeleitet ist, und implementiert Lese-und Schreib Methoden mithilfe der von der <xref:System.IO.Stream>-Klasse geerbten Prototypen: <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.BeginWrite%2A>, <xref:System.IO.Stream.Read%2A>, <xref:System.IO.Stream.ReadByte%2A>, <xref:System.IO.Stream.Write%2A>und <xref:System.IO.Stream.WriteByte%2A>. Diese Methoden können nützlich sein, wenn Sie eine umschließende serielle Ressource an eine <xref:System.IO.Stream> Wrapper Klasse übergeben.  
  
 Aufgrund der nicht zugreif barkeit des umschließenden Datei Handles werden die Eigenschaften <xref:System.IO.Stream.Length%2A> und <xref:System.IO.Stream.Position%2A> nicht unterstützt, und die Methoden <xref:System.IO.Stream.Seek%2A> und <xref:System.IO.Stream.SetLength%2A> werden nicht unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Stream ist geschlossen. Dies kann dadurch verursacht werden, dass die <see cref="M:System.IO.Ports.SerialPort.Open" />-Methode nicht aufgerufen bzw. die <see cref="M:System.IO.Ports.SerialPort.Close" />-Methode aufgerufen wurde.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream befindet sich in einer .NET Compact Framework-Anwendung, und es wurde eine der folgenden Methoden aufgerufen: 
 <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.EndRead(System.IAsyncResult)" /><see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />  
  
.NET Compact Framework unterstützt das asynchrone Modell mit Basisstreams nicht.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaudRate">
      <MemberSignature Language="C#" Value="public int BaudRate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BaudRate" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaudRate" />
      <MemberSignature Language="VB.NET" Value="Public Property BaudRate As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BaudRate { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BaudRate : int with get, set" Usage="System.IO.Ports.SerialPort.BaudRate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(9600)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("BaudRate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die serielle Baudrate ab oder legt diese fest.</summary>
        <value>Die Baudrate.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Baudrate muss vom seriellen Treiber des Benutzers unterstützt werden. Der Standardwert ist 9600 Bits pro Sekunde (Bit/s).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.IO.Ports.SerialPort.BaudRate%2A>-Eigenschaft auf `9600`festgelegt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat zwischen zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die angegebene Baudrate ist kleiner oder gleich 0 oder größer als die maximal für das Gerät zulässige Baudrate.</exception>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="BreakState">
      <MemberSignature Language="C#" Value="public bool BreakState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BreakState" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BreakState" />
      <MemberSignature Language="VB.NET" Value="Public Property BreakState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BreakState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BreakState : bool with get, set" Usage="System.IO.Ports.SerialPort.BreakState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zustand bei einer Signalunterbrechung ab oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der Anschluss unterbrochen ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Status des Break-Signals tritt auf, wenn eine Übertragung angehalten und die Linie in den Umbruch Zustand versetzt wird (alle niedrig, kein Stoppbit), bis die Freigabe aufgehoben wird. Legen Sie diese Eigenschaft auf `true`fest, um den Break-Status einzugeben. Wenn sich der Port bereits im Umbruch Zustand befindet, führt das erneute Festlegen dieser Eigenschaft auf `true` nicht zu einer Ausnahme. Es ist nicht möglich, in das <xref:System.IO.Ports.SerialPort> Objekt zu schreiben, während <xref:System.IO.Ports.SerialPort.BreakState%2A> `true`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream ist geschlossen. Dies kann dadurch verursacht werden, dass die <see cref="M:System.IO.Ports.SerialPort.Open" />-Methode nicht aufgerufen bzw. die <see cref="M:System.IO.Ports.SerialPort.Close" />-Methode aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToRead">
      <MemberSignature Language="C#" Value="public int BytesToRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToRead As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToRead { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToRead : int" Usage="System.IO.Ports.SerialPort.BytesToRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Datenbytes im Empfangspuffer ab.</summary>
        <value>Die Anzahl von Datenbytes im Empfangspuffer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Empfangs Puffer enthält den Empfangs Puffer des seriellen Treibers sowie interne Pufferung im <xref:System.IO.Ports.SerialPort> Objekt selbst.  
  
 Da die <xref:System.IO.Ports.SerialPort.BytesToRead%2A>-Eigenschaft sowohl den <xref:System.IO.Ports.SerialPort> Puffer als auch den von Windows erstellten Puffer darstellt, kann Sie einen höheren Wert als die <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>-Eigenschaft zurückgeben, die nur den von Windows erstellten Puffer darstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Anschluss ist nicht geöffnet.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToWrite">
      <MemberSignature Language="C#" Value="public int BytesToWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToWrite As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToWrite { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToWrite : int" Usage="System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Datenbytes im Sendepuffer ab.</summary>
        <value>Die Anzahl von Datenbytes im Sendepuffer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Sendepuffer enthält den Sendepuffer des seriellen Treibers sowie interne Pufferung im <xref:System.IO.Ports.SerialPort> Objekt selbst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream ist geschlossen. Dies kann dadurch verursacht werden, dass die <see cref="M:System.IO.Ports.SerialPort.Open" />-Methode nicht aufgerufen bzw. die <see cref="M:System.IO.Ports.SerialPort.Close" />-Methode aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="CDHolding">
      <MemberSignature Language="C#" Value="public bool CDHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CDHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CDHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CDHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CDHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CDHolding : bool" Usage="System.IO.Ports.SerialPort.CDHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zustand der Zeile für die Erkennung des Trägers für den Anschluss ab.</summary>
        <value><see langword="true" />, wenn der Träger erkannt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft kann verwendet werden, um den Status der Netzbetreiber Erkennungs Linie für einen Port zu überwachen. Kein Netzbetreiber gibt normalerweise an, dass der Empfänger nicht reagiert hat und der Netzbetreiber gelöscht wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream ist geschlossen. Dies kann dadurch verursacht werden, dass die <see cref="M:System.IO.Ports.SerialPort.Open" />-Methode nicht aufgerufen bzw. die <see cref="M:System.IO.Ports.SerialPort.Close" />-Methode aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="serialPort.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die Anschlussverbindung, legt die <see cref="P:System.IO.Ports.SerialPort.IsOpen" />-Eigenschaft auf <see langword="false" /> fest und löscht das interne <see cref="T:System.IO.Stream" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Aufrufen dieser Methode wird das <xref:System.IO.Ports.SerialPort> Objekt geschlossen und sowohl der Empfangs-als auch der Übertragungs Puffer gelöscht. Diese Methode ruft die <xref:System.ComponentModel.Component.Dispose?displayProperty=nameWithType>-Methode auf, die die geschützte <xref:System.IO.Ports.SerialPort.Dispose%28System.Boolean%29?displayProperty=nameWithType>-Methode aufruft, wobei der `disposing`-Parameter auf `true`festgelegt ist.  
  
 Die bewährte Methode für jede Anwendung besteht darin, nach dem Aufrufen der <xref:System.IO.Ports.SerialPort.Close%2A>-Methode eine gewisse Zeit zu warten, bevor versucht wird, die <xref:System.IO.Ports.SerialPort.Open%2A>-Methode aufzurufen, da der Port möglicherweise nicht sofort geschlossen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="CtsHolding">
      <MemberSignature Language="C#" Value="public bool CtsHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CtsHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CtsHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CtsHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CtsHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CtsHolding : bool" Usage="System.IO.Ports.SerialPort.CtsHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zustand der Clear-to-Send-Zeile ab.</summary>
        <value><see langword="true" />, wenn die Clear-to-Send-Zeile erkannt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Zeile Clear-to-Send (CTS) wird in Anforderung zum Senden/löschen von Hardware handlingen (RTS/CTS) verwendet. Die CTS-Zeile wird von einem Port abgefragt, bevor Daten gesendet werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream ist geschlossen. Dies kann dadurch verursacht werden, dass die <see cref="M:System.IO.Ports.SerialPort.Open" />-Methode nicht aufgerufen bzw. die <see cref="M:System.IO.Ports.SerialPort.Close" />-Methode aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataBits">
      <MemberSignature Language="C#" Value="public int DataBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DataBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DataBits" />
      <MemberSignature Language="VB.NET" Value="Public Property DataBits As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DataBits { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DataBits : int with get, set" Usage="System.IO.Ports.SerialPort.DataBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DataBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardlänge der Datenbits pro Byte ab oder legt diese fest.</summary>
        <value>Die Länge der Datenbits.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wertebereich für diese Eigenschaft liegt zwischen 5 und 8. Der Standardwert ist 8.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Datenbitwert ist kleiner als 5 oder höher als 8.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialDataReceivedEventHandler DataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialDataReceivedEventHandler DataReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.DataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataReceived As SerialDataReceivedEventHandler " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialDataReceivedEventHandler ^ DataReceived;" />
      <MemberSignature Language="F#" Value="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " Usage="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event DataReceived As SerialDataReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialDataReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialDataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass Daten über einen Port empfangen wurden, der durch das <see cref="T:System.IO.Ports.SerialPort" />-Objekt dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Daten Ereignisse können von einem der Elemente in der <xref:System.IO.Ports.SerialData>-Enumeration verursacht werden. Da das Betriebssystem bestimmt, ob dieses Ereignis oder nicht, werden möglicherweise nicht alle Paritätsfehler gemeldet.  
  
 Das <xref:System.IO.Ports.SerialPort.DataReceived>-Ereignis wird auch ausgelöst, wenn ein EOF-Zeichen empfangen wird, unabhängig von der Anzahl von Bytes im internen Eingabepuffer und dem Wert der <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A>-Eigenschaft.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>-, <xref:System.IO.Ports.SerialPort.DataReceived>-und <xref:System.IO.Ports.SerialPort.ErrorReceived>-Ereignisse können in falscher Reihenfolge aufgerufen werden, und es kann zu einer geringfügigen Verzögerung zwischen dem Zeitpunkt, zu dem der zugrunde liegende Stream den Fehler meldet, und dem Zeitpunkt der Ausführung des Ereignis Handlers Es kann jeweils nur ein Ereignishandler ausgeführt werden.  
  
 Es ist nicht garantiert, dass das <xref:System.IO.Ports.SerialPort.DataReceived>-Ereignis für jedes empfangene Byte ausgelöst wird. Verwenden Sie die <xref:System.IO.Ports.SerialPort.BytesToRead%2A>-Eigenschaft, um zu bestimmen, wie viele Daten im Puffer gelesen werden sollen.  
  
 Das <xref:System.IO.Ports.SerialPort.DataReceived>-Ereignis wird für einen sekundären Thread ausgelöst, wenn Daten vom <xref:System.IO.Ports.SerialPort>-Objekt empfangen werden. Da dieses Ereignis auf einem sekundären Thread ausgelöst wird, nicht auf dem Haupt Thread, könnte der Versuch, einige Elemente im Haupt Thread zu ändern, wie z. b. Benutzeroberflächen Elemente, eine Threading Ausnahme auslöst. Wenn es erforderlich ist, Elemente in der Haupt <xref:System.Windows.Forms.Form> oder <xref:System.Windows.Forms.Control>zu ändern, müssen Sie die Änderungsanforderungen mithilfe <xref:System.Windows.Forms.Control.Invoke%2A>zurückstellen, wodurch die Arbeit im richtigen Thread erfolgt.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](/dotnet/standard/events/).  
  
   
  
## Examples  
 In diesem Beispiel wird <xref:System.IO.Ports.SerialPort.DataReceived> ein <xref:System.IO.Ports.SerialDataReceivedEventHandler> hinzugefügt, um alle verfügbaren Daten zu lesen, die auf dem COM1-Port empfangen wurden. Beachten Sie, dass zum Testen dieses Codes Hardware an COM1 angefügt werden muss, die Daten sendet.  
  
 [!code-cpp[System.IO.Ports.SerialPort#06](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#06)]
 [!code-csharp[System.IO.Ports.SerialPort#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#06)]
 [!code-vb[System.IO.Ports.SerialPort#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#06)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardInBuffer">
      <MemberSignature Language="C#" Value="public void DiscardInBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardInBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardInBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardInBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardInBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardInBuffer : unit -&gt; unit" Usage="serialPort.DiscardInBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verwirft Daten aus dem Empfangspuffer des seriellen Treibers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der folgenden Visual Basic Code: `MSComm1.InBufferCount = 0`. Er löscht den Empfangs Puffer, wirkt sich jedoch nicht auf den Übertragungs Puffer aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream ist geschlossen. Dies kann dadurch verursacht werden, dass die <see cref="M:System.IO.Ports.SerialPort.Open" />-Methode nicht aufgerufen bzw. die <see cref="M:System.IO.Ports.SerialPort.Close" />-Methode aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardNull">
      <MemberSignature Language="C#" Value="public bool DiscardNull { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DiscardNull" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DiscardNull" />
      <MemberSignature Language="VB.NET" Value="Public Property DiscardNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DiscardNull { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DiscardNull : bool with get, set" Usage="System.IO.Ports.SerialPort.DiscardNull" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DiscardNull")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob NULL-Bytes bei der Übertragung zwischen dem Anschluss und dem Empfangspuffer ignoriert werden, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn NULL-Werte ignoriert werden, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert sollte normalerweise auf `false`festgelegt werden, insbesondere bei binären Übertragungen.  Wenn diese Eigenschaft auf `true` festgelegt wird, kann dies zu unerwarteten Ergebnissen für UTF32-und UTF16-codierte Bytes führen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream ist geschlossen. Dies kann dadurch verursacht werden, dass die <see cref="M:System.IO.Ports.SerialPort.Open" />-Methode nicht aufgerufen bzw. die <see cref="M:System.IO.Ports.SerialPort.Close" />-Methode aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardOutBuffer">
      <MemberSignature Language="C#" Value="public void DiscardOutBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardOutBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardOutBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardOutBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardOutBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardOutBuffer : unit -&gt; unit" Usage="serialPort.DiscardOutBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verwirft Daten aus dem Übertragungspuffer des seriellen Treibers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der folgenden Visual Basic Code: `MSComm1.OutBufferCount = 0`. Er löscht den Übertragungs Puffer, wirkt sich jedoch nicht auf den Empfangs Puffer aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream ist geschlossen. Dies kann dadurch verursacht werden, dass die <see cref="M:System.IO.Ports.SerialPort.Open" />-Methode nicht aufgerufen bzw. die <see cref="M:System.IO.Ports.SerialPort.Close" />-Methode aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serialPort.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.IO.Ports.SerialPort" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen <xref:System.ComponentModel.Component.Dispose%2A>-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen. <xref:System.ComponentModel.Component.Dispose%2A> Ruft die geschützte <xref:System.IO.Ports.SerialPort.Dispose%2A> Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist. <xref:System.Object.Finalize%2A> ruft <xref:System.IO.Ports.SerialPort.Dispose%2A> auf, bei dem `disposing` auf `false`festgelegt ist.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.IO.Ports.SerialPort> verweist. Diese Methode ruft die <xref:System.ComponentModel.Component.Dispose%2A>-Methode jedes referenzierten Objekts auf.  
  
 Diese Methode leert und schließt das Stream-Objekt in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see cref="M:System.ComponentModel.Component.Dispose" /> freigegeben wurden. Weitere Informationen zum Implementieren von <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />finden Sie unter [Implementieren einer](/dotnet/standard/garbage-collection/implementing-dispose)verwerfen-Methode.  
  
Weitere Informationen zu <see cref="M:System.ComponentModel.Component.Dispose" /> und <see cref="M:System.Object.Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DsrHolding">
      <MemberSignature Language="C#" Value="public bool DsrHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DsrHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DsrHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DsrHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DsrHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DsrHolding : bool" Usage="System.IO.Ports.SerialPort.DsrHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zustand des DSR (Data Set Ready)-Signals ab.</summary>
        <value><see langword="true" />, wenn ein Data Set Ready-Signal zum Anschluss gesendet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird im DSR/DTR-Handshake (Data Set Ready/Data Terminal Ready) verwendet. Das DSR-Signal (Data Set Ready) wird normalerweise von einem Modem an einen Port gesendet, um anzugeben, dass es für die Datenübertragung oder den Datenempfang bereit ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream ist geschlossen. Dies kann dadurch verursacht werden, dass die <see cref="M:System.IO.Ports.SerialPort.Open" />-Methode nicht aufgerufen bzw. die <see cref="M:System.IO.Ports.SerialPort.Close" />-Methode aufgerufen wurde.</exception>
      </Docs>
    </Member>
    <Member MemberName="DtrEnable">
      <MemberSignature Language="C#" Value="public bool DtrEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtrEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DtrEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property DtrEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtrEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DtrEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.DtrEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DtrEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der das Data Terminal Ready (DTR)-Signal während einer seriellen Kommunikation aktiviert, oder legt diesen fest.</summary>
        <value><see langword="true" />, um Data Terminal Ready (DTR) zu aktivieren, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Data Terminal Ready (DTR) wird in der Regel während eines XON/XOFF-Software Handlers und Anforderung zum Senden/löschen von Hardware handlingen (RTS/CTS) und Modem Kommunikation aktiviert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding with get, set" Usage="System.IO.Ports.SerialPort.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Encoding")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Bytecodierung für die Konvertierung von Text vor und nach der Übertragung ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.Text.Encoding" />-Objekt. Der Standardwert lautet <see cref="T:System.Text.ASCIIEncoding" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.IO.Ports.SerialPort.Encoding" />-Eigenschaft wurde auf <see langword="null" /> festgelegt.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.IO.Ports.SerialPort.Encoding" />-Eigenschaft wurde auf eine Codierung festgelegt, bei der es sich nicht um <see cref="T:System.Text.ASCIIEncoding" />, <see cref="T:System.Text.UTF8Encoding" />, <see cref="T:System.Text.UTF32Encoding" />, <see cref="T:System.Text.UnicodeEncoding" />, eine der Einzelbytecodierungen von Windows oder eine der Doppelbytecodierungen von Windows handelt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ErrorReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.ErrorReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorReceived As SerialErrorReceivedEventHandler " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialErrorReceivedEventHandler ^ ErrorReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " Usage="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event ErrorReceived As SerialErrorReceivedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialErrorReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialErrorReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass ein Fehler bei einem Port aufgetreten ist, der durch ein <see cref="T:System.IO.Ports.SerialPort" />-Objekt dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fehlerereignisse können durch eines der Elemente in der <xref:System.IO.Ports.SerialError>-Enumeration verursacht werden. Da das Betriebssystem bestimmt, ob dieses Ereignis oder nicht, werden möglicherweise nicht alle Paritätsfehler gemeldet.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>-, <xref:System.IO.Ports.SerialPort.DataReceived>-und <xref:System.IO.Ports.SerialPort.ErrorReceived>-Ereignisse können in falscher Reihenfolge aufgerufen werden, und es kann zu einer geringfügigen Verzögerung zwischen dem Zeitpunkt, zu dem der zugrunde liegende Stream den Fehler meldet, und dem Zeitpunkt, zu dem der Ereignishandler ausgeführt werden kann Es kann jeweils nur ein Ereignishandler ausgeführt werden.  
  
 Wenn für das nachfolgende Byte eines Streams ein Paritätsfehler auftritt, wird dem Eingabepuffer ein zusätzliches Byte mit dem Wert 126 hinzugefügt.  
  
 Das <xref:System.IO.Ports.SerialPort.ErrorReceived>-Ereignis wird für einen sekundären Thread ausgelöst, wenn ein Fehler vom <xref:System.IO.Ports.SerialPort>-Objekt empfangen wird. Da dieses Ereignis auf einem sekundären Thread ausgelöst wird, nicht auf dem Haupt Thread, könnte der Versuch, einige Elemente im Haupt Thread zu ändern, wie z. b. Benutzeroberflächen Elemente, eine Threading Ausnahme auslöst. Wenn es erforderlich ist, Elemente in der Haupt <xref:System.Windows.Forms.Form> oder <xref:System.Windows.Forms.Control>zu ändern, müssen Sie die Änderungsanforderungen mithilfe <xref:System.Windows.Forms.Control.Invoke%2A>zurückstellen, wodurch die Arbeit im richtigen Thread erfolgt.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](/dotnet/standard/events/).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPortNames">
      <MemberSignature Language="C#" Value="public static string[] GetPortNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetPortNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.GetPortNames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPortNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetPortNames();" />
      <MemberSignature Language="F#" Value="static member GetPortNames : unit -&gt; string[]" Usage="System.IO.Ports.SerialPort.GetPortNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array der seriellen Anschlussnamen für den aktuellen Computer ab.</summary>
        <returns>Ein Array der seriellen Anschlussnamen für den aktuellen Computer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der von <xref:System.IO.Ports.SerialPort.GetPortNames%2A> zurückgegebenen Port Namen ist nicht angegeben.  
  
 Verwenden Sie die <xref:System.IO.Ports.SerialPort.GetPortNames%2A>-Methode zum Abfragen des aktuellen Computers, um eine Liste der gültigen seriellen Anschluss Namen zu suchen. Mit dieser Methode können Sie beispielsweise bestimmen, ob COM1 und COM2 gültige serielle Anschlüsse für den aktuellen Computer sind.  
  
 Die Portnamen werden aus der Systemregistrierung abgerufen (z. b. HKEY_LOCAL_MACHINE \hardware\devicemap\serialcomm). Wenn die Registrierung veraltete oder anderweitig falsche Daten enthält, gibt die <xref:System.IO.Ports.SerialPort.GetPortNames%2A> Methode falsche Daten zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.IO.Ports.SerialPort.GetPortNames%2A>-Methode verwendet, um die Namen von seriellen Ports der Konsole anzuzeigen.  
  
 [!code-cpp[IO.Ports.GetPortNames#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Ports.GetPortNames/cpp/example.cpp#1)]
 [!code-csharp[IO.Ports.GetPortNames#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Ports.GetPortNames/CS/example.cs#1)]
 [!code-vb[IO.Ports.GetPortNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Ports.GetPortNames/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Die seriellen Anschlussnamen konnten nicht abgefragt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handshake">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Handshake Handshake { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Handshake Handshake" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Handshake" />
      <MemberSignature Language="VB.NET" Value="Public Property Handshake As Handshake" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Handshake Handshake { System::IO::Ports::Handshake get(); void set(System::IO::Ports::Handshake value); };" />
      <MemberSignature Language="F#" Value="member this.Handshake : System.IO.Ports.Handshake with get, set" Usage="System.IO.Ports.SerialPort.Handshake" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handshake")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Handshake</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Handshakeprotokoll für die Datenübertragung an seriellen Anschlüssen anhand eines Werts von <see cref="T:System.IO.Ports.Handshake" /> ab oder legt dieses fest.</summary>
        <value>Einer der <see cref="T:System.IO.Ports.Handshake" />-Werte. Der Standardwert lautet <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Verwendung von Handshake wird das Gerät, das mit dem <xref:System.IO.Ports.SerialPort> Objekt verbunden ist, angewiesen, das Senden von Daten zu beenden, wenn mindestens (<xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>-1024) Bytes im Puffer vorhanden sind. Das Gerät wird angewiesen, erneut mit dem Senden von Daten zu beginnen, wenn der Puffer 1024 oder weniger Bytes enthält. Wenn das Gerät Daten in Blöcken sendet, die größer als 1024 Bytes sind, kann dies dazu führen, dass der Puffer überläuft.  
  
 Wenn die <xref:System.IO.Ports.SerialPort.Handshake%2A>-Eigenschaft auf <xref:System.IO.Ports.Handshake.RequestToSendXOnXOff> festgelegt ist und <xref:System.IO.Ports.SerialPort.CtsHolding%2A> auf `false`festgelegt ist, wird das XOff-Zeichen nicht gesendet. Wenn <xref:System.IO.Ports.SerialPort.CtsHolding%2A> dann auf `true`festgelegt wird, müssen mehr Daten gesendet werden, bevor das XOff-Zeichen gesendet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Wert ist kein gültiger Wert in der <see cref="T:System.IO.Ports.Handshake" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public const int InfiniteTimeout = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 InfiniteTimeout = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const InfiniteTimeout As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int InfiniteTimeout = -1;" />
      <MemberSignature Language="F#" Value="val mutable InfiniteTimeout : int" Usage="System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>Gibt an, dass kein Timeout erfolgen soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird mit den Eigenschaften <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> und <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> verwendet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOpen">
      <MemberSignature Language="C#" Value="public bool IsOpen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOpen" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.IsOpen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOpen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOpen : bool" Usage="System.IO.Ports.SerialPort.IsOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der den offenen oder geschlossenen Status des <see cref="T:System.IO.Ports.SerialPort" />-Objekts angibt.</summary>
        <value><see langword="true" />, wenn der serielle Anschluss geöffnet ist, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.IO.Ports.SerialPort.IsOpen%2A>-Eigenschaft wird nachverfolgt, ob der Port für die Verwendung durch den Aufrufer geöffnet ist, nicht, ob der Port von einer beliebigen Anwendung auf dem Computer geöffnet ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der übergebene <see cref="P:System.IO.Ports.SerialPort.IsOpen" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der als leere Zeichenfolge ("") übergebene <see cref="P:System.IO.Ports.SerialPort.IsOpen" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public string NewLine { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ NewLine { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string with get, set" Usage="System.IO.Ports.SerialPort.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("\n")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("NewLine")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert ab, mit dem das Ende eines Aufrufs der <see cref="M:System.IO.Ports.SerialPort.ReadLine" />-Methode und der <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" />-Methode interpretiert wird, oder legt diesen fest.</summary>
        <value>Ein Wert, der das Ende einer Zeile darstellt. Der Standardwert ist ein Zeilenvorschub ("\n C# " in oder <see cref="F:Microsoft.VisualBasic.Constants.vbLf" /> in Visual Basic).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bestimmt, welcher Wert (Byte) das Ende einer Zeile für die <xref:System.IO.Ports.SerialPort.ReadLine%2A>-und <xref:System.IO.Ports.SerialPort.WriteLine%2A> Methoden definiert. Standardmäßig ist der zeilenendewert ein Zeilenvorschub Zeichen (`\n` in C#, <xref:Microsoft.VisualBasic.Constants.vbLf?displayProperty=nameWithType> in Visual Basic). Ändern Sie dies in einen anderen Wert, wenn das jeweilige serielle Gerät, mit dem Sie arbeiten, einen anderen Wert für denselben Zweck verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Eigenschaftswert ist leer.</exception>
        <exception cref="T:System.ArgumentNullException">Der Eigenschaftswert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Open" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Open();" />
      <MemberSignature Language="F#" Value="member this.Open : unit -&gt; unit" Usage="serialPort.Open " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Öffnet eine neue serielle Anschlussverbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pro <xref:System.IO.Ports.SerialPort> Objekt kann nur eine geöffnete Verbindung vorhanden sein.  
  
 Die bewährte Methode für jede Anwendung besteht darin, nach dem Aufrufen der <xref:System.IO.Ports.SerialPort.Close%2A>-Methode eine gewisse Zeit zu warten, bevor versucht wird, die <xref:System.IO.Ports.SerialPort.Open%2A>-Methode aufzurufen, da der Port möglicherweise nicht sofort geschlossen wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Der Zugriff auf den Anschluss wird verweigert.  
  
Oder 
Der aktuelle Prozess, oder ein anderer Prozess auf dem System, lässt bereits den angegebenen COM-Port entweder durch eine <see cref="T:System.IO.Ports.SerialPort" />-Instanz oder in nicht verwaltetem Code öffnen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Eine oder mehrere Eigenschaften für diese Instanz sind ungültig. Beispielsweise hat die <see cref="P:System.IO.Ports.SerialPort.Parity" />-Eigenschaft, die <see cref="P:System.IO.Ports.SerialPort.DataBits" />-Eigenschaft oder die <see cref="P:System.IO.Ports.SerialPort.Handshake" />-Eigenschaft keinen gültigen Wert, die <see cref="P:System.IO.Ports.SerialPort.BaudRate" /> ist kleiner oder gleich 0, die <see cref="P:System.IO.Ports.SerialPort.ReadTimeout" />-Eigenschaft oder die <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" />-Eigenschaft ist kleiner als  0 und nicht <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ArgumentException">Der Anschlussname fängt nicht mit "COM" an.  
  
Oder
  
 Der Dateityp des Anschlusses wird nicht unterstützt.</exception>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der angegebene Port auf der aktuellen Instanz vom <see cref="T:System.IO.Ports.SerialPort" /> ist bereits geöffnet.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parity">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Parity Parity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Parity Parity" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Parity" />
      <MemberSignature Language="VB.NET" Value="Public Property Parity As Parity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Parity Parity { System::IO::Ports::Parity get(); void set(System::IO::Ports::Parity value); };" />
      <MemberSignature Language="F#" Value="member this.Parity : System.IO.Ports.Parity with get, set" Usage="System.IO.Ports.SerialPort.Parity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Parity")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Parity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Paritätsprüfungsprotokoll ab oder legt dieses fest.</summary>
        <value>Einer der Enumerationswerte, der das Paritätsprüfungsprotokoll darstellt. Der Standardwert lautet <see cref="F:System.IO.Ports.Parity.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parität ist eine Fehler Überprüfungs Prozedur, bei der die Anzahl von 1S für jede Gruppe von Bits, die ohne Fehler übertragen wird, immer gleich sein muss. Bei der Kommunikation zwischen Modem und Modem ist die Parität häufig einer der Parameter, die vereinbart werden müssen, indem Parteien und Empfänger Parteien gesendet werden, bevor die Übertragung stattfinden kann.  
  
 Wenn für das nachfolgende Byte eines Streams ein Paritätsfehler auftritt, wird dem Eingabepuffer ein zusätzliches Byte mit dem Wert 126 hinzugefügt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene <see cref="P:System.IO.Ports.SerialPort.Parity" />-Wert ist kein gültiger Wert in der <see cref="T:System.IO.Ports.Parity" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="ParityReplace">
      <MemberSignature Language="C#" Value="public byte ParityReplace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8 ParityReplace" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ParityReplace" />
      <MemberSignature Language="VB.NET" Value="Public Property ParityReplace As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte ParityReplace { System::Byte get(); void set(System::Byte value); };" />
      <MemberSignature Language="F#" Value="member this.ParityReplace : byte with get, set" Usage="System.IO.Ports.SerialPort.ParityReplace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(63)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ParityReplace")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Byte ab, das ungültige Bytes in einem Datenstream ersetzt, wenn ein Paritätsfehler auftritt, oder legt dieses fest.</summary>
        <value>Ein Byte, das ungültige Bytes ersetzt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert auf das NULL-Zeichen festgelegt ist, ist die Paritäts Ersetzung deaktiviert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="PinChanged">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialPinChangedEventHandler PinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialPinChangedEventHandler PinChanged" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.PinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PinChanged As SerialPinChangedEventHandler " FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialPinChangedEventHandler ^ PinChanged;" />
      <MemberSignature Language="F#" Value="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " Usage="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " />
      <MemberSignature Language="VB.NET" Value="Public Event PinChanged As SerialPinChangedEventHandler " FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialPinChanged")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialPinChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass ein Nicht-Datensignalereignis an dem Port aufgetreten ist, der durch das <see cref="T:System.IO.Ports.SerialPort" />-Objekt dargestellt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Geänderte Ereignisse der seriellen PIN können von einem der Elemente in der <xref:System.IO.Ports.SerialPinChange> Enumeration verursacht werden. Da das Betriebssystem bestimmt, ob dieses Ereignis oder nicht, werden möglicherweise nicht alle Paritätsfehler gemeldet. Im Rahmen des Ereignisses wird der neue Wert der PIN festgelegt.  
  
 Das <xref:System.IO.Ports.SerialPort.PinChanged>-Ereignis wird ausgelöst, wenn ein <xref:System.IO.Ports.SerialPort>-Objekt in den <xref:System.IO.Ports.SerialPort.BreakState%2A>eintritt, jedoch nicht, wenn der Anschluss den <xref:System.IO.Ports.SerialPort.BreakState%2A>verlässt. Dieses Verhalten gilt nicht für andere Werte in der <xref:System.IO.Ports.SerialPinChange>-Enumeration.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>-, <xref:System.IO.Ports.SerialPort.DataReceived>-und <xref:System.IO.Ports.SerialPort.ErrorReceived>-Ereignisse können in falscher Reihenfolge aufgerufen werden, und es kann zu einer geringfügigen Verzögerung zwischen dem Zeitpunkt, zu dem der zugrunde liegende Stream den Fehler meldet, und dem Zeitpunkt der Ausführung des Ereignis Handlers Es kann jeweils nur ein Ereignishandler ausgeführt werden.  
  
 Das <xref:System.IO.Ports.SerialPort.PinChanged>-Ereignis wird für einen sekundären Thread ausgelöst. Da dieses Ereignis auf einem sekundären Thread ausgelöst wird, nicht auf dem Haupt Thread, könnte der Versuch, einige Elemente im Haupt Thread zu ändern, wie z. b. Benutzeroberflächen Elemente, eine Threading Ausnahme auslöst. Wenn es erforderlich ist, Elemente in der Haupt <xref:System.Windows.Forms.Form> oder <xref:System.Windows.Forms.Control>zu ändern, müssen Sie die Änderungsanforderungen mithilfe <xref:System.Windows.Forms.Control.Invoke%2A>zurückstellen, wodurch die Arbeit im richtigen Thread erfolgt.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](/dotnet/standard/events/).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PortName">
      <MemberSignature Language="C#" Value="public string PortName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PortName" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.PortName" />
      <MemberSignature Language="VB.NET" Value="Public Property PortName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PortName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PortName : string with get, set" Usage="System.IO.Ports.SerialPort.PortName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("COM1")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PortName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Anschluss für die Kommunikation ab oder legt diesen fest, einschließlich aller verfügbaren COM-Anschlüsse, aber nicht beschränkt auf diese.</summary>
        <value>Der Kommunikationsport. Die Standardeinstellung lautet COM1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste gültiger Portnamen kann mithilfe der <xref:System.IO.Ports.SerialPort.GetPortNames%2A>-Methode abgerufen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.IO.Ports.SerialPort.PortName" />-Eigenschaft wurde auf einen Wert mit einer Länge von 0 festgelegt.  
  
Oder 
Die <see cref="P:System.IO.Ports.SerialPort.PortName" />-Eigenschaft wurde auf einen Wert festgelegt, der mit „\\\\“ beginnt.  
  
Oder 
Der Anschlussname war nicht gültig.</exception>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.IO.Ports.SerialPort.PortName" />-Eigenschaft wurde auf <see langword="null" /> festgelegt.</exception>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist offen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest aus dem <see cref="T:System.IO.Ports.SerialPort" />-Eingabepuffer.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : byte[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Bytearray, in das die Eingabe geschrieben werden soll.</param>
        <param name="offset">Der Offset im <paramref name="buffer" />, mit dem die Bytes geschrieben werden.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Bytes. Es werden weniger Bytes gelesen, wenn <paramref name="count" /> größer ist als die Anzahl der Bytes im Eingabepuffer.</param>
        <summary>Liest eine Anzahl von Bytes aus dem <see cref="T:System.IO.Ports.SerialPort" />-Eingabepuffer und schreibt diese Bytes am angegebenen Offset in ein Bytearray.</summary>
        <returns>Die Anzahl der gelesenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn zwischen dem Lesen von Text und dem Lesen von Binärdaten aus dem Stream gewechselt werden muss, wählen Sie ein Protokoll aus, das die Begrenzung zwischen Text-und Binärdaten sorgfältig definiert, z. b. das manuelle Lesen von Bytes und das Decodieren der Daten.  
  
 Da die <xref:System.IO.Ports.SerialPort>-Klasse Daten puffert, und der in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltene Datenstrom nicht, können die beiden Konflikte mit der Anzahl der zu lesenden Bytes in Konflikt stehen.  Die <xref:System.IO.Ports.SerialPort.BytesToRead%2A>-Eigenschaft kann anzeigen, dass Bytes zu lesen sind. diese Bytes sind jedoch möglicherweise nicht für den in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltenen Stream verfügbar, da Sie für die <xref:System.IO.Ports.SerialPort>-Klasse gepuffert wurden.  
  
 Die <xref:System.IO.Ports.SerialPort.Read%2A>-Methode blockiert keine anderen Vorgänge, wenn die Anzahl der gelesenen Bytes gleich ist `count` es sind aber noch nicht gelesene Bytes am seriellen Anschluss verfügbar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der übergebene Puffer ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist nicht offen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter oder der <paramref name="count" />-Parameter liegt außerhalb eines gültigen Bereichs des übergebenen <paramref name="buffer" />. Entweder <paramref name="offset" /> oder <paramref name="count" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.TimeoutException">Es waren keine Bytes zum Lesen verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Char(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : char[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Zeichenarray, in das die Eingabe geschrieben werden soll.</param>
        <param name="offset">Der Offset im <paramref name="buffer" />, mit dem die Zeichen geschrieben werden.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Zeichen. Es werden weniger Zeichen gelesen, wenn <paramref name="count" /> größer ist als die Anzahl der Zeichen im Eingabepuffer.</param>
        <summary>Liest eine Anzahl von Zeichen aus dem <see cref="T:System.IO.Ports.SerialPort" />-Eingabepuffer und schreibt diese am angegebenen Offset in ein Zeichenarray.</summary>
        <returns>Die Anzahl gelesener Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Lesen von Zeichen aus dem seriellen Anschluss.  
  
 Wenn zwischen dem Lesen von Text und dem Lesen von Binärdaten aus dem Stream gewechselt werden muss, wählen Sie ein Protokoll aus, das die Begrenzung zwischen Text-und Binärdaten sorgfältig definiert, z. b. das manuelle Lesen von Bytes und das Decodieren der Daten.  
  
 Da die <xref:System.IO.Ports.SerialPort>-Klasse Daten puffert und der in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltene Stream nicht ist, können die beiden Konflikte mit der Anzahl der zu lesenden Zeichen in Konflikt stehen.  Die <xref:System.IO.Ports.SerialPort.BytesToRead%2A>-Eigenschaft kann anzeigen, dass Zeichen zum Lesen vorhanden sind. diese Zeichen sind jedoch möglicherweise nicht für den in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltenen Stream verfügbar, da Sie für die <xref:System.IO.Ports.SerialPort>-Klasse gepuffert wurden.  
  
 Die <xref:System.IO.Ports.SerialPort.Read%2A>-Methode blockiert keine anderen Vorgänge, wenn die Anzahl der gelesenen Bytes gleich ist `count` es sind aber noch nicht gelesene Bytes am seriellen Anschluss verfügbar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Länge des Puffers.  
  
Oder 
 <paramref name="count" /> ist 1, und es befindet sich ein Ersatzzeichenzeichen im Puffer.</exception>
        <exception cref="T:System.ArgumentNullException">Der übergebene <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter oder der <paramref name="count" />-Parameter liegt außerhalb eines gültigen Bereichs des übergebenen <paramref name="buffer" />. Entweder <paramref name="offset" /> oder <paramref name="count" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist nicht offen.</exception>
        <exception cref="T:System.TimeoutException">Es waren keine Zeichen zum Lesen verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBufferSize">
      <MemberSignature Language="C#" Value="public int ReadBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(4096)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des <see cref="T:System.IO.Ports.SerialPort" />-Eingabepuffers ab oder legt diese fest.</summary>
        <value>Die Puffergröße in Byte. Der Standardwert ist 4096. Der maximale Wert ist der einer positiven ganzen Zahl oder 2147483647.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>-Eigenschaft ignoriert jeden Wert, der kleiner als 4096 ist.  
  
 Da die <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>-Eigenschaft nur den von Windows erstellten Puffer darstellt, kann Sie einen kleineren Wert zurückgeben als die <xref:System.IO.Ports.SerialPort.BytesToRead%2A>-Eigenschaft, die sowohl den <xref:System.IO.Ports.SerialPort> Puffer als auch den von Windows erstellten Puffer darstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der festgelegte <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" />-Wert ist kleiner oder gleich 0.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" />-Eigenschaft wurde festgelegt, während der Stream offen war.</exception>
        <exception cref="T:System.IO.IOException">Die <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" />-Eigenschaft wurde auf einen ungeraden ganzzahligen Wert festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadByte();" />
      <MemberSignature Language="F#" Value="member this.ReadByte : unit -&gt; int" Usage="serialPort.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest synchron ein Byte aus dem <see cref="T:System.IO.Ports.SerialPort" />-Eingabepuffer.</summary>
        <returns>Das Byte, das in <see cref="T:System.Int32" /> umgewandelt wurde, oder -1, wenn das Ende des Streams gelesen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest ein Byte.  
  
 Seien Sie vorsichtig, wenn Sie <xref:System.IO.Ports.SerialPort.ReadByte%2A> und <xref:System.IO.Ports.SerialPort.ReadChar%2A> verwenden. Das Wechseln zwischen Lese-und Lesezeichen kann dazu führen, dass zusätzliche Daten gelesen werden und/oder ein anderes unbeabsichtigtes Verhalten hat. Wenn zwischen dem Lesen von Text und dem Lesen von Binärdaten aus dem Stream gewechselt werden muss, wählen Sie ein Protokoll aus, das die Begrenzung zwischen Text-und Binärdaten sorgfältig definiert, z. b. das manuelle Lesen von Bytes und das Decodieren der Daten.  
  
> [!NOTE]
>  Da die <xref:System.IO.Ports.SerialPort>-Klasse Daten puffert, und der in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltene Datenstrom nicht, können die beiden Konflikte mit der Anzahl der zu lesenden Bytes in Konflikt stehen.  Die <xref:System.IO.Ports.SerialPort.BytesToRead%2A>-Eigenschaft kann anzeigen, dass Bytes zu lesen sind. diese Bytes sind jedoch möglicherweise nicht für den in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltenen Stream verfügbar, da Sie für die <xref:System.IO.Ports.SerialPort>-Klasse gepuffert wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist nicht offen.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Der Vorgang konnte nicht vor Ablauf des Timeouts abgeschlossen werden.  
  
Oder
  
 Es wurde kein Byte gelesen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadChar">
      <MemberSignature Language="C#" Value="public int ReadChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadChar" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChar () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChar();" />
      <MemberSignature Language="F#" Value="member this.ReadChar : unit -&gt; int" Usage="serialPort.ReadChar " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest synchron ein Zeichen aus dem <see cref="T:System.IO.Ports.SerialPort" />-Eingabepuffer.</summary>
        <returns>Das Zeichen, das gelesen wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest ein Zeichen auf der Grundlage der Codierung.  
  
 Seien Sie vorsichtig, wenn Sie <xref:System.IO.Ports.SerialPort.ReadByte%2A> und <xref:System.IO.Ports.SerialPort.ReadChar%2A> verwenden. Das Wechseln zwischen Lese-und Lesezeichen kann dazu führen, dass zusätzliche Daten gelesen werden und/oder ein anderes unbeabsichtigtes Verhalten hat. Wenn zwischen dem Lesen von Text und dem Lesen von Binärdaten aus dem Stream gewechselt werden muss, wählen Sie ein Protokoll aus, das die Begrenzung zwischen Text-und Binärdaten sorgfältig definiert, z. b. das manuelle Lesen von Bytes und das Decodieren der Daten.  
  
> [!NOTE]
>  Da die <xref:System.IO.Ports.SerialPort>-Klasse Daten puffert, und der in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltene Datenstrom nicht, können die beiden Konflikte mit der Anzahl der zu lesenden Bytes in Konflikt stehen.  Die <xref:System.IO.Ports.SerialPort.BytesToRead%2A>-Eigenschaft kann anzeigen, dass Bytes zu lesen sind. diese Bytes sind jedoch möglicherweise nicht für den in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltenen Stream verfügbar, da Sie für die <xref:System.IO.Ports.SerialPort>-Klasse gepuffert wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist nicht offen.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Der Vorgang konnte nicht vor Ablauf des Timeouts abgeschlossen werden.  
  
Oder
  
 Im zugewiesenen Timeoutzeitraum war kein Zeichen verfügbar.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadExisting">
      <MemberSignature Language="C#" Value="public string ReadExisting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadExisting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadExisting" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadExisting () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadExisting();" />
      <MemberSignature Language="F#" Value="member this.ReadExisting : unit -&gt; string" Usage="serialPort.ReadExisting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest alle sofort verfügbaren Bytes auf Grundlage der Codierung sowohl im Stream als auch im Eingabepuffer des <see cref="T:System.IO.Ports.SerialPort" />-Objekts.</summary>
        <returns>Der Inhalt des Streams und des Eingabepuffers des <see cref="T:System.IO.Ports.SerialPort" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Inhalt des Streams und den internen Puffer des <xref:System.IO.Ports.SerialPort> Objekts als Zeichenfolge zurück. Diese Methode verwendet kein Timeout. Beachten Sie, dass diese Methode nachfolgende führende Bytes im internen Puffer belassen kann, wodurch der <xref:System.IO.Ports.SerialPort.BytesToRead%2A> Wert größer als 0 (null) ist.  
  
 Wenn zwischen dem Lesen von Text und dem Lesen von Binärdaten aus dem Stream gewechselt werden muss, wählen Sie ein Protokoll aus, das die Begrenzung zwischen Text-und Binärdaten sorgfältig definiert, z. b. das manuelle Lesen von Bytes und das Decodieren der Daten.  
  
> [!NOTE]
>  Die <xref:System.IO.Ports.SerialPort>-Klasse puffert Daten, das in der <xref:System.IO.Ports.SerialPort.BaseStream%2A?displayProperty=nameWithType>-Eigenschaft enthaltene Stream-Objekt jedoch nicht. Daher können sich die <xref:System.IO.Ports.SerialPort>-Objekt und das Stream-Objekt je nach Anzahl der zu lesenden Bytes unterscheiden. Wenn Bytes für das <xref:System.IO.Ports.SerialPort> Objekt gepuffert werden, enthält die <xref:System.IO.Ports.SerialPort.BytesToRead%2A>-Eigenschaft diese Bytes in ihren Wert. Diese Bytes sind jedoch möglicherweise nicht für den Stream verfügbar, der in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthalten ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist nicht offen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="member this.ReadLine : unit -&gt; string" Usage="serialPort.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest bis zum <see cref="P:System.IO.Ports.SerialPort.NewLine" />-Wert im Eingabepuffer.</summary>
        <returns>Der Inhalt des Eingabepuffers bis zum ersten Vorkommen eines <see cref="P:System.IO.Ports.SerialPort.NewLine" />-Werts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass diese Methode zwar nicht den <xref:System.IO.Ports.SerialPort.NewLine%2A> Wert zurückgibt, der <xref:System.IO.Ports.SerialPort.NewLine%2A> Wert jedoch aus dem Eingabepuffer entfernt wird.  
  
 Standardmäßig wird die <xref:System.IO.Ports.SerialPort.ReadLine%2A>-Methode blockiert, bis eine Zeile empfangen wird. Wenn dieses Verhalten nicht erwünscht ist, legen Sie die <xref:System.IO.Ports.SerialPort.ReadTimeout%2A>-Eigenschaft auf einen Wert ungleich 0 (null) fest, um zu erzwingen, dass die <xref:System.IO.Ports.SerialPort.ReadLine%2A> Methode eine <xref:System.TimeoutException> auslöst, wenn keine Zeile auf dem Port verfügbar ist.  
  
 Wenn zwischen dem Lesen von Text und dem Lesen von Binärdaten aus dem Stream gewechselt werden muss, wählen Sie ein Protokoll aus, das die Begrenzung zwischen Text-und Binärdaten sorgfältig definiert, z. b. das manuelle Lesen von Bytes und das Decodieren der Daten.  
  
> [!NOTE]
>  Da die <xref:System.IO.Ports.SerialPort>-Klasse Daten puffert, und der in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltene Datenstrom nicht, können die beiden Konflikte mit der Anzahl der zu lesenden Bytes in Konflikt stehen.  Die <xref:System.IO.Ports.SerialPort.BytesToRead%2A>-Eigenschaft kann anzeigen, dass Bytes zu lesen sind. diese Bytes sind jedoch möglicherweise nicht für den in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltenen Stream verfügbar, da Sie für die <xref:System.IO.Ports.SerialPort>-Klasse gepuffert wurden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist nicht offen.</exception>
        <exception cref="T:System.TimeoutException">Der Vorgang konnte nicht vor Ablauf des Timeouts abgeschlossen werden.  
  
Oder
  
 Es wurden keine Bytes gelesen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Millisekunden ab, bevor ein Timeout auftritt, wenn ein Lesevorgang nicht beendet wird, oder legt diese fest.</summary>
        <value>Die Anzahl der Millisekunden, bevor ein Timeout auftritt, wenn ein Lesevorgang nicht beendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert für "Read Timeout" wurde ursprünglich in der Win32-Kommunikations-API auf 500 Millisekunden festgelegt. Diese Eigenschaft ermöglicht es Ihnen, diesen Wert festzulegen. Der Timeout Wert kann auf einen beliebigen Wert größer als 0 (null) festgelegt oder auf <xref:System.IO.Ports.SerialPort.InfiniteTimeout>festgelegt werden. in diesem Fall tritt kein Timeout auf. <xref:System.IO.Ports.SerialPort.InfiniteTimeout> ist die Standardeinstellung.  
  
> [!NOTE]
>  Benutzer der nicht verwalteten `COMMTIMEOUTS`-Struktur erwarten möglicherweise, dass der Timeout Wert auf 0 (null) festgelegt wird, um Timeouts zu unterdrücken. Um Timeouts mit der <xref:System.IO.Ports.SerialPort.ReadTimeout%2A>-Eigenschaft zu unterdrücken, müssen Sie jedoch <xref:System.IO.Ports.SerialPort.InfiniteTimeout>angeben.  
  
 Diese Eigenschaft hat keine Auswirkung auf die <xref:System.IO.Stream.BeginRead%2A> Methode des Streams, der von der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Timeoutwert für Lesevorgänge ist kleiner als 0 (null) und ungleich <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTo">
      <MemberSignature Language="C#" Value="public string ReadTo (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadTo(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadTo (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadTo(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.ReadTo : string -&gt; string" Usage="serialPort.ReadTo value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Ein Wert, der angibt, wo der Lesevorgang anhält.</param>
        <summary>Liest eine Zeichenfolge bis zum angegebenen <paramref name="value" /> im Eingabepuffer.</summary>
        <returns>Der Inhalt des Eingabepuffers bis zum angegebenen <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest eine Zeichenfolge bis zum angegebenen `value`. Obwohl die zurückgegebene Zeichenfolge die `value`nicht enthält, wird die `value` aus dem Eingabepuffer entfernt.  
  
 Wenn zwischen dem Lesen von Text und dem Lesen von Binärdaten aus dem Stream gewechselt werden muss, wählen Sie ein Protokoll aus, das die Begrenzung zwischen Text-und Binärdaten sorgfältig definiert, z. b. das manuelle Lesen von Bytes und das Decodieren der Daten.  
  
> [!NOTE]
>  Da die <xref:System.IO.Ports.SerialPort>-Klasse Daten puffert, und der in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltene Datenstrom nicht, können die beiden Konflikte mit der Anzahl der zu lesenden Bytes in Konflikt stehen.  Die <xref:System.IO.Ports.SerialPort.BytesToRead%2A>-Eigenschaft kann anzeigen, dass Bytes zu lesen sind. diese Bytes sind jedoch möglicherweise nicht für den in der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft enthaltenen Stream verfügbar, da Sie für die <xref:System.IO.Ports.SerialPort>-Klasse gepuffert wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Länge des <paramref name="value" />-Parameters ist 0 (null).</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist nicht offen.</exception>
        <exception cref="T:System.TimeoutException">Der Vorgang konnte nicht vor Ablauf des Timeouts abgeschlossen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceivedBytesThreshold">
      <MemberSignature Language="C#" Value="public int ReceivedBytesThreshold { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceivedBytesThreshold" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceivedBytesThreshold As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceivedBytesThreshold { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceivedBytesThreshold : int with get, set" Usage="System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReceivedBytesThreshold")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Bytes im internen Eingabepuffer ab, bevor ein <see cref="E:System.IO.Ports.SerialPort.DataReceived" />-Ereignis auftritt, oder legt diese fest.</summary>
        <value>Die Anzahl von Bytes im internen Eingabepuffer, bevor ein <see cref="E:System.IO.Ports.SerialPort.DataReceived" />-Ereignis ausgelöst wird. Der Standardwert ist 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.IO.Ports.SerialPort.DataReceived>-Ereignis wird auch ausgelöst, wenn ein <xref:System.IO.Ports.SerialData.Eof> Zeichen empfangen wird, unabhängig von der Anzahl von Bytes im internen Eingabepuffer und dem Wert der <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A>-Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <see cref="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" />-Wert ist kleiner oder gleich 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="RtsEnable">
      <MemberSignature Language="C#" Value="public bool RtsEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RtsEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.RtsEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property RtsEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RtsEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RtsEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.RtsEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("RtsEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Request to Send (RTS)-Signal während der seriellen Kommunikation aktiviert ist, oder legt diesen fest.</summary>
        <value><see langword="true" />, um Request to Transmit (RTS) zu aktivieren, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das RTS-Signal (Request to überträgt) wird in der Regel in Anforderung zum Senden/löschen von Hardware handlingen (RTS/CTS) verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert der <see cref="P:System.IO.Ports.SerialPort.RtsEnable" />-Eigenschaft wurde festgelegt oder abgerufen, während die <see cref="P:System.IO.Ports.SerialPort.Handshake" />-Eigenschaft auf den <see cref="F:System.IO.Ports.Handshake.RequestToSend" />-Wert oder den <see cref="F:System.IO.Ports.Handshake.RequestToSendXOnXOff" />-Wert festgelegt ist.</exception>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="StopBits">
      <MemberSignature Language="C#" Value="public System.IO.Ports.StopBits StopBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.StopBits StopBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.StopBits" />
      <MemberSignature Language="VB.NET" Value="Public Property StopBits As StopBits" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::StopBits StopBits { System::IO::Ports::StopBits get(); void set(System::IO::Ports::StopBits value); };" />
      <MemberSignature Language="F#" Value="member this.StopBits : System.IO.Ports.StopBits with get, set" Usage="System.IO.Ports.SerialPort.StopBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("StopBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.StopBits</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Standardanzahl von Stoppbits pro Byte ab oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.IO.Ports.StopBits" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für <xref:System.IO.Ports.SerialPort.StopBits%2A> ist <xref:System.IO.Ports.StopBits.One>.  
  
 Der <xref:System.IO.Ports.StopBits.None?displayProperty=nameWithType>-Wert wird nicht unterstützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.IO.Ports.SerialPort.StopBits%2A>-Eigenschaft auf `One`festgelegt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat zwischen zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <see cref="P:System.IO.Ports.SerialPort.StopBits" />-Wert ist <see cref="F:System.IO.Ports.StopBits.None" />.</exception>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Daten in den Ausgabepuffer des seriellen Anschlusses.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="serialPort.Write text" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public void Write (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="serialPort.Write str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Die Zeichenfolge für die Ausgabe.</param>
        <param name="str">To be added.</param>
        <summary>Schreibt die angegebene Zeichenfolge in den seriellen Anschluss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, wenn Sie eine Zeichenfolge als Ausgabe an einen seriellen Anschluss schreiben möchten.  
  
 Wenn im Ausgabepuffer zu viele Bytes vorhanden sind und <xref:System.IO.Ports.SerialPort.Handshake%2A> auf <xref:System.IO.Ports.Handshake.XOnXOff> festgelegt ist, kann das <xref:System.IO.Ports.SerialPort> Objekt eine <xref:System.ServiceProcess.TimeoutException> ausgeben, während darauf gewartet wird, dass das Gerät für die Annahme von weiteren Daten bereit ist.  
  
 Standardmäßig verwendet <xref:System.IO.Ports.SerialPort> <xref:System.Text.ASCIIEncoding>, um die Zeichen zu codieren. <xref:System.Text.ASCIIEncoding> codiert alle Zeichen, die größer als 127 als (Char) 63 oder "?" sind. Um zusätzliche Zeichen in diesem Bereich zu unterstützen, legen Sie <xref:System.IO.Ports.SerialPort.Encoding%2A> auf <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>oder <xref:System.Text.UnicodeEncoding>fest.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist nicht offen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="text" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Der Vorgang konnte nicht vor Ablauf des Timeouts abgeschlossen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : byte[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Bytearray mit den Daten, die an den Anschluss geschrieben werden sollen.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="buffer" />-Parameter, ab dem Bytes in den Anschluss kopiert werden.</param>
        <param name="count">Die Anzahl der zu schreibenden Bytes.</param>
        <summary>Schreibt eine angegebene Anzahl von Bytes unter Verwendung von Daten aus einem Puffer in den seriellen Anschluss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, wenn Sie in einen Byte Puffer schreiben möchten, um die Ausgabe eines seriellen Ports zu erstellen.  
  
 Wenn im Ausgabepuffer zu viele Bytes vorhanden sind und <xref:System.IO.Ports.SerialPort.Handshake%2A> auf <xref:System.IO.Ports.Handshake.XOnXOff> festgelegt ist, kann das <xref:System.IO.Ports.SerialPort> Objekt eine <xref:System.ServiceProcess.TimeoutException> ausgeben, während darauf gewartet wird, dass das Gerät für die Annahme von weiteren Daten bereit ist.  
  
 Standardmäßig verwendet <xref:System.IO.Ports.SerialPort> <xref:System.Text.ASCIIEncoding>, um die Zeichen zu codieren. <xref:System.Text.ASCIIEncoding> codiert alle Zeichen, die größer als 127 als (Char) 63 oder "?" sind. Um zusätzliche Zeichen in diesem Bereich zu unterstützen, legen Sie <xref:System.IO.Ports.SerialPort.Encoding%2A> auf <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>oder <xref:System.Text.UnicodeEncoding>fest.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der übergebene <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist nicht offen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter oder der <paramref name="count" />-Parameter liegt außerhalb eines gültigen Bereichs des übergebenen <paramref name="buffer" />. Entweder <paramref name="offset" /> oder <paramref name="count" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Der Vorgang konnte nicht vor Ablauf des Timeouts abgeschlossen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Zeichenarray mit den Daten, die an den Anschluss geschrieben werden sollen.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="buffer" />-Parameter, ab dem Bytes in den Anschluss kopiert werden.</param>
        <param name="count">Die Anzahl der zu schreibenden Zeichen.</param>
        <summary>Schreibt eine angegebene Anzahl von Zeichen unter Verwendung von Daten aus einem Puffer in den seriellen Anschluss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, wenn Sie in einen Zeichen Puffer schreiben möchten, um die Ausgabe eines seriellen Ports zu erstellen.  
  
 Wenn im Ausgabepuffer zu viele Bytes vorhanden sind und <xref:System.IO.Ports.SerialPort.Handshake%2A> auf <xref:System.IO.Ports.Handshake.XOnXOff> festgelegt ist, kann das <xref:System.IO.Ports.SerialPort> Objekt eine <xref:System.ServiceProcess.TimeoutException> ausgeben, während darauf gewartet wird, dass das Gerät für die Annahme von weiteren Daten bereit ist.  
  
 Standardmäßig verwendet <xref:System.IO.Ports.SerialPort> <xref:System.Text.ASCIIEncoding>, um die Zeichen zu codieren. <xref:System.Text.ASCIIEncoding> codiert alle Zeichen, die größer als 127 als (Char) 63 oder "?" sind. Um zusätzliche Zeichen in diesem Bereich zu unterstützen, legen Sie <xref:System.IO.Ports.SerialPort.Encoding%2A> auf <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>oder <xref:System.Text.UnicodeEncoding>fest.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der übergebene <paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist nicht offen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter oder der <paramref name="count" />-Parameter liegt außerhalb eines gültigen Bereichs des übergebenen <paramref name="buffer" />. Entweder <paramref name="offset" /> oder <paramref name="count" /> ist kleiner als 0 (null).</exception>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">Der Vorgang konnte nicht vor Ablauf des Timeouts abgeschlossen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBufferSize">
      <MemberSignature Language="C#" Value="public int WriteBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2048)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Größe des Ausgabepuffers des seriellen Anschlusses ab oder legt diese fest.</summary>
        <value>Die Größe des Ausgabepuffers. Der Standard ist 2048.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Ports.SerialPort.WriteBufferSize%2A>-Eigenschaft ignoriert jeden Wert, der kleiner als 2048 ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" />-Wert ist kleiner oder gleich 0.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" />-Eigenschaft wurde festgelegt, während der Stream offen war.</exception>
        <exception cref="T:System.IO.IOException">Die <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" />-Eigenschaft wurde auf einen ungeraden ganzzahligen Wert festgelegt.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public void WriteLine (string text);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string text) cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (text As String)" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ text);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.WriteLine : string -&gt; unit" Usage="serialPort.WriteLine text" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public void WriteLine (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.WriteLine : string -&gt; unit" Usage="serialPort.WriteLine str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Die Zeichenfolge, die in den Ausgabepuffer geschrieben werden soll.</param>
        <param name="str">To be added.</param>
        <summary>Schreibt die angegebene Zeichenfolge und den <see cref="P:System.IO.Ports.SerialPort.NewLine" />-Wert in den Ausgabepuffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn im Eingabepuffer zu viele Bytes vorhanden sind und <xref:System.IO.Ports.SerialPort.Handshake%2A> auf <xref:System.IO.Ports.Handshake.XOnXOff> festgelegt ist, kann das <xref:System.IO.Ports.SerialPort> Objekt eine <xref:System.ServiceProcess.TimeoutException> hervorrufen, während darauf gewartet wird, dass das Gerät für die Annahme von mehr Daten bereit ist.  
  
 Die geschriebene Ausgabe enthält die <xref:System.IO.Ports.SerialPort.NewLine%2A> Zeichenfolge.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="text" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der angegebene Anschluss ist nicht offen.</exception>
        <exception cref="T:System.TimeoutException">Die <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" />-Methode konnte nicht in den Stream schreiben.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Millisekunden ab, bevor ein Timeout auftritt, wenn ein Schreibvorgang nicht beendet wird, oder legt diese fest.</summary>
        <value>Die Anzahl von Millisekunden, bevor ein Timeout auftritt. Der Standardwert lautet <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Timeout Wert für den Schreibvorgang wurde ursprünglich in der Win32-Kommunikations-API auf 500 Millisekunden festgelegt. Diese Eigenschaft ermöglicht es Ihnen, diesen Wert festzulegen. Der Timeout Wert kann auf einen beliebigen Wert größer als 0 (null) festgelegt oder auf <xref:System.IO.Ports.SerialPort.InfiniteTimeout>festgelegt werden. in diesem Fall tritt kein Timeout auf. <xref:System.IO.Ports.SerialPort.InfiniteTimeout> ist die Standardeinstellung.  
  
> [!NOTE]
>  Benutzer der nicht verwalteten `COMMTIMEOUTS`-Struktur erwarten möglicherweise, dass der Timeout Wert auf 0 (null) festgelegt wird, um Timeouts zu unterdrücken. Um Timeouts mit der <xref:System.IO.Ports.SerialPort.WriteTimeout%2A>-Eigenschaft zu unterdrücken, müssen Sie jedoch <xref:System.IO.Ports.SerialPort.InfiniteTimeout>angeben.  
  
 Diese Eigenschaft hat keine Auswirkung auf die <xref:System.IO.Stream.BeginWrite%2A> Methode des Streams, der von der <xref:System.IO.Ports.SerialPort.BaseStream%2A>-Eigenschaft zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.IO.Ports.SerialPort>-Klasse verwendet wird, um zwei Benutzern den Chat von zwei separaten Computern zu gestatten, die durch ein NULL-Modemkabel verbunden sind. In diesem Beispiel werden die Benutzer vor dem Chatten aufgefordert, die Port Einstellungen und einen Benutzernamen einzugeben. Dieses Codebeispiel ist Teil eines größeren Code Beispiels, das für die <xref:System.IO.Ports.SerialPort>-Klasse bereitgestellt wird.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Der Anschluss befindet sich in einem ungültigen Zustand.  
  
Oder 
Fehler beim Versuch, den Zustand des zugrunde liegenden Anschlusses festzulegen. Beispielsweise waren die von diesem <see cref="T:System.IO.Ports.SerialPort" />-Objekt übergebenen Parameter ungültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" />-Wert ist kleiner als 0 (null) und ungleich <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
