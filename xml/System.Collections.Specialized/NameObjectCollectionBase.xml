<Type Name="NameObjectCollectionBase" FullName="System.Collections.Specialized.NameObjectCollectionBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="02c591641f2b36962036a70b257878224f76e008" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51320517" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class NameObjectCollectionBase : System.Collections.ICollection, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit NameObjectCollectionBase extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Specialized.NameObjectCollectionBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class NameObjectCollectionBase&#xA;Implements ICollection, IDeserializationCallback, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class NameObjectCollectionBase abstract : System::Collections::ICollection, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type NameObjectCollectionBase = class&#xA;    interface ICollection&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Specialized</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt die <see langword="abstract" />-Basisklasse für eine Auflistung zugeordneter <see cref="T:System.String" />-Schlüssel und <see cref="T:System.Object" />-Werte bereit, auf die entweder über den Schlüssel oder über den Index zugegriffen werden kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zugrunde liegende Struktur für diese Klasse ist eine Hashtabelle.  
  
 Jedes Element ist ein Schlüssel/Wert-Paar.  
  
 Die Kapazität einer <xref:System.Collections.Specialized.NameObjectCollectionBase> ist die Anzahl der Elemente der <xref:System.Collections.Specialized.NameObjectCollectionBase> enthalten kann. Elemente hinzugefügt werden eine <xref:System.Collections.Specialized.NameObjectCollectionBase>, die Kapazität wird automatisch erhöht, über die neuzuordnung erforderlich.  
  
 Die Hashcodeanbieter Hashcodes für Schlüssel in der <xref:System.Collections.Specialized.NameObjectCollectionBase> Instanz. Der Hashcode-Standardanbieter ist die <xref:System.Collections.CaseInsensitiveHashCodeProvider>.  
  
 Der Vergleich wird bestimmt, ob zwei Schlüssel gleich sind. Der Standardcomparer ist die <xref:System.Collections.CaseInsensitiveComparer>.  
  
 In .NET Framework, Version 1.0 verwendet diese Klasse kulturabhängige Zeichenfolgenvergleiche. In .NET Framework, Version 1.1 und höher, verwendet diese Klasse jedoch <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> beim Vergleichen von Zeichenfolgen. Weitere Informationen zu den Auswirkungen der Kultur auf Vergleiche und Sortiervorgänge finden Sie unter [Performing Culture-Insensitive String Operations](~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md).  
  
 `null` ist als Schlüssel oder als Wert zulässig.  
  
> [!CAUTION]
>  Die <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseGet%2A> Methode unterscheidet nicht zwischen `null` der Fehler wird zurückgegeben, da der angegebene Schlüssel nicht gefunden wird und `null` der Fehler wird zurückgegeben, da der Wert, der dem Schlüssel zugeordnet ist `null`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie implementiert und verwendet die <xref:System.Collections.Specialized.NameObjectCollectionBase> Klasse.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase/CPP/nameobjectcollectionbase.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase/CS/nameobjectcollectionbase.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase/VB/nameobjectcollectionbase.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Diese Implementierung bietet keinen synchronisierten (threadsicheren) Wrapper für eine <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />, abgeleitete Klassen können jedoch erstellen ihre eigenen synchronisierten Versionen der der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" /> mithilfe der <see cref="P:System.Collections.ICollection.SyncRoot" /> Eigenschaft.  
  
Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.</threadsafe>
    <altmember cref="T:System.Collections.Hashtable" />
    <altmember cref="T:System.Collections.Specialized.NameValueCollection" />
    <altmember cref="T:System.String" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected NameObjectCollectionBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; NameObjectCollectionBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Specialized.NameObjectCollectionBase> ist die Anzahl der Elemente, die die <xref:System.Collections.Specialized.NameObjectCollectionBase> enthalten kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Specialized.NameObjectCollectionBase>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben müssen nicht mehr eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen, die zum Ausführen der <xref:System.Collections.Specialized.NameObjectCollectionBase>.  
  
 Die Hashcodeanbieter Hashcodes für Schlüssel in der <xref:System.Collections.Specialized.NameObjectCollectionBase> Instanz. Der Hashcode-Standardanbieter ist die <xref:System.Collections.CaseInsensitiveHashCodeProvider>.  
  
 Der Vergleich wird bestimmt, ob zwei Schlüssel gleich sind. Der Standardcomparer ist die <xref:System.Collections.CaseInsensitiveComparer>.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.CaseInsensitiveHashCodeProvider" />
        <altmember cref="T:System.Collections.CaseInsensitiveComparer" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected NameObjectCollectionBase (System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.#ctor(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; NameObjectCollectionBase(System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Specialized.NameObjectCollectionBase : System.Collections.IEqualityComparer -&gt; System.Collections.Specialized.NameObjectCollectionBase" Usage="new System.Collections.Specialized.NameObjectCollectionBase equalityComparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="equalityComparer">Das <see cref="T:System.Collections.IEqualityComparer" />-Objekt wird verwendet, um zu ermitteln, ob zwei Schlüssel gleich sind, und um Hashcodes für die in der Auflistung befindlichen Schlüssel zu generieren.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Klasse mit der anfänglichen Standardkapazität und dem angegebenen <see cref="T:System.Collections.IEqualityComparer" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Specialized.NameObjectCollectionBase> Objekt ist die Anzahl der Elemente, die die <xref:System.Collections.Specialized.NameObjectCollectionBase> enthalten kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Specialized.NameObjectCollectionBase>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben müssen nicht mehr eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen, die zum Ausführen der <xref:System.Collections.Specialized.NameObjectCollectionBase>.  
  
 Die <xref:System.Collections.IEqualityComparer> -Objekt kombiniert die Vergleichsfunktion und der Hashcode-Standardanbieters.  Die Hashcodeanbieter Hashcodes für Schlüssel in der <xref:System.Collections.Specialized.NameObjectCollectionBase>.  Der Vergleich wird bestimmt, ob zwei Schlüssel gleich sind.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEqualityComparer" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected NameObjectCollectionBase (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; NameObjectCollectionBase(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Specialized.NameObjectCollectionBase : int -&gt; System.Collections.Specialized.NameObjectCollectionBase" Usage="new System.Collections.Specialized.NameObjectCollectionBase capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die ungefähre Anzahl von Einträgen, die die <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz anfänglich enthalten kann.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Klasse mit der angegebenen Anfangskapazität, wobei der Hashcode-Standardanbieter und Standardcomparer verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Specialized.NameObjectCollectionBase> ist die Anzahl der Elemente, die die <xref:System.Collections.Specialized.NameObjectCollectionBase> enthalten kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Specialized.NameObjectCollectionBase>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben müssen nicht mehr eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen, die zum Ausführen der <xref:System.Collections.Specialized.NameObjectCollectionBase>.  
  
 Die Hashcodeanbieter Hashcodes für Schlüssel in der <xref:System.Collections.Specialized.NameObjectCollectionBase> Instanz. Der Hashcode-Standardanbieter ist die <xref:System.Collections.CaseInsensitiveHashCodeProvider>.  
  
 Der Vergleich wird bestimmt, ob zwei Schlüssel gleich sind. Der Standardcomparer ist die <xref:System.Collections.CaseInsensitiveComparer>.  
  
 Dieser Konstruktor ist eine O (`n`)-Vorgang, in denen `n` ist `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Collections.CaseInsensitiveHashCodeProvider" />
        <altmember cref="T:System.Collections.CaseInsensitiveComparer" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected NameObjectCollectionBase (System.Collections.IHashCodeProvider hashProvider, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.IHashCodeProvider hashProvider, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (hashProvider As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; NameObjectCollectionBase(System::Collections::IHashCodeProvider ^ hashProvider, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Specialized.NameObjectCollectionBase : System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Specialized.NameObjectCollectionBase" Usage="new System.Collections.Specialized.NameObjectCollectionBase (hashProvider, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use NameObjectCollectionBase(IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="hashProvider" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="hashProvider">Der <see cref="T:System.Collections.IHashCodeProvider" />, der die Hashcodes für sämtliche Schlüssel in der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz bereitstellt.</param>
        <param name="comparer">Der <see cref="T:System.Collections.IComparer" />, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Klasse mit der anfänglichen Standardkapazität, wobei der angegebene Hashcodeanbieter und der angegebene Comparer verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Specialized.NameObjectCollectionBase> ist die Anzahl der Elemente, die die <xref:System.Collections.Specialized.NameObjectCollectionBase> enthalten kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Specialized.NameObjectCollectionBase>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben müssen nicht mehr eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen, die zum Ausführen der <xref:System.Collections.Specialized.NameObjectCollectionBase>.  
  
 Die Hashcodeanbieter Hashcodes für Schlüssel in der <xref:System.Collections.Specialized.NameObjectCollectionBase> Instanz. Der Hashcode-Standardanbieter ist die <xref:System.Collections.CaseInsensitiveHashCodeProvider>.  
  
 Der Vergleich wird bestimmt, ob zwei Schlüssel gleich sind. Der Standardcomparer ist die <xref:System.Collections.CaseInsensitiveComparer>.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.Collections.CaseInsensitiveHashCodeProvider" />
        <altmember cref="T:System.Collections.CaseInsensitiveComparer" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected NameObjectCollectionBase (int capacity, System.Collections.IEqualityComparer equalityComparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IEqualityComparer equalityComparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.#ctor(System.Int32,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (capacity As Integer, equalityComparer As IEqualityComparer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; NameObjectCollectionBase(int capacity, System::Collections::IEqualityComparer ^ equalityComparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Specialized.NameObjectCollectionBase : int * System.Collections.IEqualityComparer -&gt; System.Collections.Specialized.NameObjectCollectionBase" Usage="new System.Collections.Specialized.NameObjectCollectionBase (capacity, equalityComparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="equalityComparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Die ungefähre Anzahl von Einträgen, die das <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Objekt anfänglich enthalten kann.</param>
        <param name="equalityComparer">Das <see cref="T:System.Collections.IEqualityComparer" />-Objekt wird verwendet, um zu ermitteln, ob zwei Schlüssel gleich sind, und um Hashcodes für die in der Auflistung befindlichen Schlüssel zu generieren.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Klasse mit der angegebenen Anfangskapazität und dem angegebenen <see cref="T:System.Collections.IEqualityComparer" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Specialized.NameObjectCollectionBase> Objekt ist die Anzahl der Elemente, die die <xref:System.Collections.Specialized.NameObjectCollectionBase> enthalten kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Specialized.NameObjectCollectionBase>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben müssen nicht mehr eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen, die zum Ausführen der <xref:System.Collections.Specialized.NameObjectCollectionBase>.  
  
 Die <xref:System.Collections.IEqualityComparer> -Objekt kombiniert die Vergleichsfunktion und der Hashcode-Standardanbieters.  Die Hashcodeanbieter Hashcodes für Schlüssel in der <xref:System.Collections.Specialized.NameObjectCollectionBase>.  Der Vergleich wird bestimmt, ob zwei Schlüssel gleich sind.  
  
 Dieser Konstruktor ist eine O (`n`)-Vorgang, in denen `n` ist die `capacity` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Collections.IEqualityComparer" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected NameObjectCollectionBase (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; NameObjectCollectionBase(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Specialized.NameObjectCollectionBase : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Specialized.NameObjectCollectionBase" Usage="new System.Collections.Specialized.NameObjectCollectionBase (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren der neuen <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz erforderlichen Informationen.</param>
        <param name="context">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt mit der Quelle und dem Ziel des serialisierten Streams, der der neuen <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz zugeordnet ist.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Klasse, die serialisierbar ist und die angegebene <see cref="T:System.Runtime.Serialization.SerializationInfo" /> und den angegebenen <see cref="T:System.Runtime.Serialization.StreamingContext" /> verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected NameObjectCollectionBase (int capacity, System.Collections.IHashCodeProvider hashProvider, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.IHashCodeProvider hashProvider, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (capacity As Integer, hashProvider As IHashCodeProvider, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; NameObjectCollectionBase(int capacity, System::Collections::IHashCodeProvider ^ hashProvider, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Specialized.NameObjectCollectionBase : int * System.Collections.IHashCodeProvider * System.Collections.IComparer -&gt; System.Collections.Specialized.NameObjectCollectionBase" Usage="new System.Collections.Specialized.NameObjectCollectionBase (capacity, hashProvider, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Please use NameObjectCollectionBase(Int32, IEqualityComparer) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="hashProvider" Type="System.Collections.IHashCodeProvider" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="capacity">Die ungefähre Anzahl von Einträgen, die die <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz anfänglich enthalten kann.</param>
        <param name="hashProvider">Der <see cref="T:System.Collections.IHashCodeProvider" />, der die Hashcodes für sämtliche Schlüssel in der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz bereitstellt.</param>
        <param name="comparer">Der <see cref="T:System.Collections.IComparer" />, mit dem ermittelt wird, ob zwei Schlüssel gleich sind.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Klasse mit der angegebenen Anfangskapazität, wobei der angegebene Hashcodeanbieter und Comparer verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Specialized.NameObjectCollectionBase> ist die Anzahl der Elemente, die die <xref:System.Collections.Specialized.NameObjectCollectionBase> enthalten kann. Wenn Elemente hinzugefügt werden eine <xref:System.Collections.Specialized.NameObjectCollectionBase>, die Kapazität wird automatisch erhöht Neuzuordnen des internen Arrays wie erforderlich.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, die anfängliche Kapazität angeben müssen nicht mehr eine Reihe von größenänderungsvorgänge beim Hinzufügen von Elementen, die zum Ausführen der <xref:System.Collections.Specialized.NameObjectCollectionBase>.  
  
 Die Hashcodeanbieter Hashcodes für Schlüssel in der <xref:System.Collections.Specialized.NameObjectCollectionBase> Instanz. Der Hashcode-Standardanbieter ist die <xref:System.Collections.CaseInsensitiveHashCodeProvider>.  
  
 Der Vergleich wird bestimmt, ob zwei Schlüssel gleich sind. Der Standardcomparer ist die <xref:System.Collections.CaseInsensitiveComparer>.  
  
 Dieser Konstruktor ist eine O (`n`)-Vorgang, in denen `n` ist `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> ist kleiner als Null.</exception>
        <altmember cref="T:System.Collections.IHashCodeProvider" />
        <altmember cref="T:System.Collections.CaseInsensitiveHashCodeProvider" />
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.Collections.CaseInsensitiveComparer" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
      </Docs>
    </Member>
    <Member MemberName="BaseAdd">
      <MemberSignature Language="C#" Value="protected void BaseAdd (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BaseAdd(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseAdd(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BaseAdd (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BaseAdd(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.BaseAdd : string * obj -&gt; unit" Usage="nameObjectCollectionBase.BaseAdd (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der <see cref="T:System.String" />-Schlüssel des hinzuzufügenden Eintrags. Der Schlüssel kann <see langword="null" /> sein.</param>
        <param name="value">Der <see cref="T:System.Object" />-Wert des hinzuzufügenden Eintrags. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Fügt einen Eintrag mit dem angegebenen Schlüssel und Wert der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A> bereits die Kapazität, die Kapazität entspricht der <xref:System.Collections.Specialized.NameObjectCollectionBase> wird erhöht, die automatisch erneut zugewiesen werden, das interne Array, und die vorhandenen Elemente in das neue Array kopiert werden, bevor das neue Element hinzugefügt wird.  
  
 Wenn <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A> ist kleiner als die Kapazität, diese Methode ist ein o(1)-Vorgang. Wenn die Kapazität für das neue Element erhöht werden muss, wird diese Methode eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseAdd%2A> zum Erstellen eines neuen <xref:System.Collections.Specialized.NameObjectCollectionBase> mit Elementen aus einer <xref:System.Collections.IDictionary>.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseAdd#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseAdd/CPP/nocb_baseadd.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseAdd#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseAdd/CS/nocb_baseadd.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseAdd#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseAdd/VB/nocb_baseadd.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Auflistung ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseClear">
      <MemberSignature Language="C#" Value="protected void BaseClear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BaseClear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseClear" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BaseClear ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BaseClear();" />
      <MemberSignature Language="F#" Value="member this.BaseClear : unit -&gt; unit" Usage="nameObjectCollectionBase.BaseClear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Einträge aus der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A> wird auf NULL festgelegt, und Verweise auf andere Objekte von Elementen in der Auflistung werden ebenfalls freigegeben.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseClear%2A> So entfernen Sie alle Elemente aus einer <xref:System.Collections.Specialized.NameObjectCollectionBase>.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseClear#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseClear/CPP/nocb_baseclear.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseClear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseClear/CS/nocb_baseclear.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseClear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseClear/VB/nocb_baseclear.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Auflistung ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BaseGet">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert des angegebenen Eintrags aus der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BaseGet">
      <MemberSignature Language="C#" Value="protected object BaseGet (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object BaseGet(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseGet(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Function BaseGet (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ BaseGet(int index);" />
      <MemberSignature Language="F#" Value="member this.BaseGet : int -&gt; obj" Usage="nameObjectCollectionBase.BaseGet index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des abzurufenden Werts.</param>
        <summary>Ruft den Wert des Eintrags am angegebenen Index der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz ab.</summary>
        <returns>Ein <see cref="T:System.Object" />, das den Wert des Eintrags am angegebenen Index darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseGetKey%2A> und <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseGet%2A> zum Abrufen von bestimmten Schlüsseln und Werten.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseGet#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGet/CPP/nocb_baseget.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseGet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGet/CS/nocb_baseget.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseGet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGet/VB/nocb_baseget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des gültigen Bereichs von Indizes für die Auflistung.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseGet">
      <MemberSignature Language="C#" Value="protected object BaseGet (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object BaseGet(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseGet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function BaseGet (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ BaseGet(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.BaseGet : string -&gt; obj" Usage="nameObjectCollectionBase.BaseGet name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der <see cref="T:System.String" />-Schlüssel des Eintrags, der abgerufen werden soll. Der Schlüssel kann <see langword="null" /> sein.</param>
        <summary>Ruft den Wert des ersten Eintrags mit dem angegebenen Schlüssel aus der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz ab.</summary>
        <returns>Ein <see cref="T:System.Object" />, das den Wert des ersten Eintrags mit dem angegebenen Schlüssel darstellt, sofern ein solcher Eintrag gefunden wird; andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Auflistung mehrerer Einträge mit dem angegebenen Schlüssel enthält, gibt diese Methode nur den ersten Eintrag zurück. Verwenden Sie den Enumerator zum Durchlaufen der Auflistung und die Schlüssel zu vergleichen, rufen Sie die Werte der folgenden Einträge mit demselben Schlüssel.  
  
> [!CAUTION]
>  Diese Methode gibt `null` in den folgenden Fällen: 1) Wenn der angegebene Schlüssel nicht gefunden wird; und 2) Wenn der angegebene Schlüssel gefunden wird, und der zugehörige Wert wird `null`. Diese Methode unterscheidet nicht zwischen den beiden Fällen.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseGetKey%2A> und <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseGet%2A> zum Abrufen von bestimmten Schlüsseln und Werten.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseGet#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGet/CPP/nocb_baseget.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseGet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGet/CS/nocb_baseget.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseGet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGet/VB/nocb_baseget.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Specialized.NameObjectCollectionBase.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="BaseGetAllKeys">
      <MemberSignature Language="C#" Value="protected string[] BaseGetAllKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance string[] BaseGetAllKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseGetAllKeys" />
      <MemberSignature Language="VB.NET" Value="Protected Function BaseGetAllKeys () As String()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; cli::array &lt;System::String ^&gt; ^ BaseGetAllKeys();" />
      <MemberSignature Language="F#" Value="member this.BaseGetAllKeys : unit -&gt; string[]" Usage="nameObjectCollectionBase.BaseGetAllKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.String" />-Array zurück, das alle Schlüssel der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz enthält.</summary>
        <returns>Ein <see cref="T:System.String" />-Array, das alle Schlüssel der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseGetAllKeys%2A> und <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseGetAllValues%2A> um ein Array der Schlüssel oder ein Array mit den Werten zu erhalten.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseGetAll#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGetAll/CPP/nocb_basegetall.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseGetAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGetAll/CS/nocb_basegetall.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseGetAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGetAll/VB/nocb_basegetall.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BaseGetAllValues">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein Array zurück, das alle Werte der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BaseGetAllValues">
      <MemberSignature Language="C#" Value="protected object[] BaseGetAllValues ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object[] BaseGetAllValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseGetAllValues" />
      <MemberSignature Language="VB.NET" Value="Protected Function BaseGetAllValues () As Object()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; cli::array &lt;System::Object ^&gt; ^ BaseGetAllValues();" />
      <MemberSignature Language="F#" Value="member this.BaseGetAllValues : unit -&gt; obj[]" Usage="nameObjectCollectionBase.BaseGetAllValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Object" />-Array zurück, das alle Werte der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz enthält.</summary>
        <returns>Ein <see cref="T:System.Object" />-Array, das alle Werte der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseGetAllKeys%2A> und <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseGetAllValues%2A> um ein Array der Schlüssel oder ein Array mit den Werten zu erhalten.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseGetAll#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGetAll/CPP/nocb_basegetall.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseGetAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGetAll/CS/nocb_basegetall.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseGetAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGetAll/VB/nocb_basegetall.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseGetAllValues">
      <MemberSignature Language="C#" Value="protected object[] BaseGetAllValues (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object[] BaseGetAllValues(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseGetAllValues(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; cli::array &lt;System::Object ^&gt; ^ BaseGetAllValues(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.BaseGetAllValues : Type -&gt; obj[]" Usage="nameObjectCollectionBase.BaseGetAllValues type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" />, der den Typ des zurückzugebenden Arrays darstellt.</param>
        <summary>Gibt ein Array des angegebenen Typs zurück, das alle Werte der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz enthält.</summary>
        <returns>Ein Array des angegebenen Typs, das alle Werte der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ist kein gültiger <see cref="T:System.Type" />.</exception>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="BaseGetKey">
      <MemberSignature Language="C#" Value="protected string BaseGetKey (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance string BaseGetKey(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseGetKey(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Function BaseGetKey (index As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::String ^ BaseGetKey(int index);" />
      <MemberSignature Language="F#" Value="member this.BaseGetKey : int -&gt; string" Usage="nameObjectCollectionBase.BaseGetKey index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des abzurufenden Schlüssels.</param>
        <summary>Ruft den Schlüssel des Eintrags am angegebenen Index der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz ab.</summary>
        <returns>Ein <see cref="T:System.String" />, der den Schlüssel des Eintrags am angegebenen Index darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseGetKey%2A> und <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseGet%2A> zum Abrufen von bestimmten Schlüsseln und Werten.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseGet#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGet/CPP/nocb_baseget.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseGet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGet/CS/nocb_baseget.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseGet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseGet/VB/nocb_baseget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des gültigen Bereichs von Indizes für die Auflistung.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseHasKeys">
      <MemberSignature Language="C#" Value="protected bool BaseHasKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool BaseHasKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseHasKeys" />
      <MemberSignature Language="VB.NET" Value="Protected Function BaseHasKeys () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool BaseHasKeys();" />
      <MemberSignature Language="F#" Value="member this.BaseHasKeys : unit -&gt; bool" Usage="nameObjectCollectionBase.BaseHasKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz Einträge enthält, deren Schlüssel nicht <see langword="null" /> sind.</summary>
        <returns>
          <see langword="true" />, wenn die <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz Einträge enthält, deren Schlüssel nicht <see langword="null" /> sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseHasKeys%2A> zu bestimmen, ob die Auflistung ein Schlüssel enthält, die nicht `null`.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseHasKeys#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseHasKeys/CPP/nocb_basehaskeys.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseHasKeys#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseHasKeys/CS/nocb_basehaskeys.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseHasKeys#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseHasKeys/VB/nocb_basehaskeys.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseRemove">
      <MemberSignature Language="C#" Value="protected void BaseRemove (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BaseRemove(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BaseRemove (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BaseRemove(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.BaseRemove : string -&gt; unit" Usage="nameObjectCollectionBase.BaseRemove name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der <see cref="T:System.String" />-Schlüssel der zu entfernenden Einträge. Der Schlüssel kann <see langword="null" /> sein.</param>
        <summary>Entfernt die Einträge mit dem angegebenen Schlüssel aus der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Collections.Specialized.NameObjectCollectionBase> enthält kein Element mit dem angegebenen Schlüssel, der <xref:System.Collections.Specialized.NameObjectCollectionBase> bleibt unverändert. Es werden keine Ausnahmen ausgelöst.  
  
 In Auflistungen mit zusammenhängenden Elementen, beispielsweise Listen, wird die nach dem Entfernen eines Elements entstandene Lücke durch Verschieben aller nachfolgenden Elemente gefüllt. Wenn die Auflistung indiziert ist, werden auch die Indizes der verschobenen Elemente aktualisiert. Dies gilt nicht für Auflistungen, in denen die Elemente konzeptionell in Buckets gruppiert sind, beispielsweise Hashtabellen.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseRemove%2A> und <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseRemoveAt%2A> zum Entfernen von Elementen aus einem <xref:System.Collections.Specialized.NameObjectCollectionBase>.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseRemove#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseRemove/CPP/nocb_baseremove.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseRemove#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseRemove/CS/nocb_baseremove.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseRemove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseRemove/VB/nocb_baseremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Auflistung ist schreibgeschützt.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
      </Docs>
    </Member>
    <Member MemberName="BaseRemoveAt">
      <MemberSignature Language="C#" Value="protected void BaseRemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BaseRemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseRemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BaseRemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BaseRemoveAt(int index);" />
      <MemberSignature Language="F#" Value="member this.BaseRemoveAt : int -&gt; unit" Usage="nameObjectCollectionBase.BaseRemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Eintrags, der entfernt werden soll.</param>
        <summary>Entfernt den Eintrag am angegebenen Index der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Auflistungen mit zusammenhängenden Elementen, beispielsweise Listen, wird die nach dem Entfernen eines Elements entstandene Lücke durch Verschieben aller nachfolgenden Elemente gefüllt. Wenn die Auflistung indiziert ist, werden auch die Indizes der verschobenen Elemente aktualisiert. Dies gilt nicht für Auflistungen, in denen die Elemente konzeptionell in Buckets gruppiert sind, beispielsweise Hashtabellen.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseRemove%2A> und <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseRemoveAt%2A> zum Entfernen von Elementen aus einem <xref:System.Collections.Specialized.NameObjectCollectionBase>.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseRemove#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseRemove/CPP/nocb_baseremove.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseRemove#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseRemove/CS/nocb_baseremove.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseRemove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseRemove/VB/nocb_baseremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des gültigen Bereichs von Indizes für die Auflistung.</exception>
        <exception cref="T:System.NotSupportedException">Die Auflistung ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BaseSet">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt den Wert eines Eintrags in der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BaseSet">
      <MemberSignature Language="C#" Value="protected void BaseSet (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BaseSet(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseSet(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BaseSet (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BaseSet(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.BaseSet : int * obj -&gt; unit" Usage="nameObjectCollectionBase.BaseSet (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Eintrags, der festgelegt werden soll.</param>
        <param name="value">Das <see cref="T:System.Object" />, das den neuen Wert des Eintrags darstellt, der festgelegt werden soll. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Legt den Wert des Eintrags am angegebenen Index der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseSet%2A> zum Festlegen des Werts eines bestimmten Elements.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseSet#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseSet/CPP/nocb_baseset.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseSet/CS/nocb_baseset.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseSet/VB/nocb_baseset.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Auflistung ist schreibgeschützt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> liegt außerhalb des gültigen Bereichs von Indizes für die Auflistung.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
      </Docs>
    </Member>
    <Member MemberName="BaseSet">
      <MemberSignature Language="C#" Value="protected void BaseSet (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BaseSet(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.BaseSet(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BaseSet (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BaseSet(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.BaseSet : string * obj -&gt; unit" Usage="nameObjectCollectionBase.BaseSet (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der <see cref="T:System.String" />-Schlüssel des Eintrags, der festgelegt werden soll. Der Schlüssel kann <see langword="null" /> sein.</param>
        <param name="value">Das <see cref="T:System.Object" />, das den neuen Wert des Eintrags darstellt, der festgelegt werden soll. Der Wert kann <see langword="null" /> sein.</param>
        <summary>Legt den Wert des ersten Eintrags mit dem angegebenen Schlüssel in der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz fest. Wenn der Schlüssel nicht vorhanden ist, wird der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz ein Eintrag mit dem angegebenen Wert und Schlüssel hinzugefügt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Auflistung mehrerer Einträge mit dem angegebenen Schlüssel enthält, legt diese Methode nur den ersten Eintrag. Um die Werte der folgenden Einträge mit demselben Schlüssel festzulegen, verwenden Sie den Enumerator zum Durchlaufen der Auflistung und die Schlüssel zu vergleichen.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Collections.Specialized.NameObjectCollectionBase.BaseSet%2A> zum Festlegen des Werts eines bestimmten Elements.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.BaseSet#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseSet/CPP/nocb_baseset.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.BaseSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseSet/CS/nocb_baseset.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.BaseSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.BaseSet/VB/nocb_baseset.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Auflistung ist schreibgeschützt.</exception>
        <altmember cref="M:System.Collections.Specialized.NameObjectCollectionBase.GetEnumerator" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.NameObjectCollectionBase.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Specialized.NameObjectCollectionBase.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Schlüssel-Wert-Paaren in der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz ab.</summary>
        <value>Die Anzahl von Schlüssel-Wert-Paaren in der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität ist die Anzahl der Elemente, die die <xref:System.Collections.Specialized.NameObjectCollectionBase> speichern können. <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A> ist die Anzahl der Elemente, die in der <xref:System.Collections.Specialized.NameObjectCollectionBase>.  
  
 Die Kapazität ist immer größer als oder gleich <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A>. Wenn <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A> überschreitet die Kapazität beim Hinzufügen von Elementen, die Kapazität wird automatisch durch das interne Array erneut zugewiesen werden, vor dem Kopieren der alten und die neuen Elemente hinzugefügt.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="nameObjectCollectionBase.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" /> durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" /> für die <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Enumerator gibt die Schlüssel der Auflistung als Zeichenfolgen zurück.  
  
 Die `foreach`-Anweisung der Programmiersprache C# (`for each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.  Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung. Daher ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="nameObjectCollectionBase.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz erforderlichen Informationen.</param>
        <param name="context">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt, das die Quelle und das Ziel des serialisierten Streams enthält, der der neuen <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz zugeordnet ist.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und gibt die zum Serialisieren der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz erforderlichen Daten zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Serialisierungsdiensten. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="protected bool IsReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.NameObjectCollectionBase.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool with get, set" Usage="System.Collections.Specialized.NameObjectCollectionBase.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz schreibgeschützt ist, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn die <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz schreibgeschützt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der verhindert, dass die Auflistung zu ändern; Wenn die zugrunde liegende Auflistung Änderungen vorgenommen werden, spiegelt die schreibgeschützte Auflistung aus diesem Grund diese Änderungen wider.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine schreibgeschützte Auflistung.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase.IsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.IsReadOnly/CPP/nocb_isreadonly.cpp#1)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase.IsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.IsReadOnly/CS/nocb_isreadonly.cs#1)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase.IsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase.IsReadOnly/VB/nocb_isreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Specialized.NameObjectCollectionBase.KeysCollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameObjectCollectionBase/KeysCollection Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.NameObjectCollectionBase.Keys" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Keys As NameObjectCollectionBase.KeysCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Specialized::NameObjectCollectionBase::KeysCollection ^ Keys { System::Collections::Specialized::NameObjectCollectionBase::KeysCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Specialized.NameObjectCollectionBase.KeysCollection" Usage="System.Collections.Specialized.NameObjectCollectionBase.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameObjectCollectionBase+KeysCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.Specialized.NameObjectCollectionBase.KeysCollection" />-Instanz ab, die alle Schlüssel der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz enthält.</summary>
        <value>Eine <see cref="T:System.Collections.Specialized.NameObjectCollectionBase.KeysCollection" />-Instanz, die alle Schlüssel der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="nameObjectCollectionBase.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Die Quelle des Deserialisierungsereignisses.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und löst das Deserialisierungsereignis aus, sobald die Deserialisierung abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Während der <xref:System.Collections.Specialized.NameObjectCollectionBase.OnDeserialization%2A> Methode ist nicht sichtbar für COM-Clients standardmäßig erben die <xref:System.Collections.Specialized.NameObjectCollectionBase> -Klasse können sie verfügbar machen und können dazu führen, dass unerwünschte Verhalten bei COM-Clients.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Das der aktuellen <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Instanz zugeordnete <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Objekt ist ungültig.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="M:System.Collections.Specialized.NameObjectCollectionBase.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Specialized.NameObjectCollectionBase.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <c>array</c>, ab dem kopiert wird.</param>
        <summary>Kopiert die gesamte <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Instanz in ein kompatibles eindimensionales <see cref="T:System.Array" />, beginnend am angegebenen Index des Zielarrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das angegebene Array muss von einem kompatiblen Typ sein.  
  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType> die Elemente kopiert.  
  
 Während der <xref:System.Collections.Specialized.NameObjectCollectionBase.System%23Collections%23ICollection%23CopyTo%2A> Methode ist nicht sichtbar für COM-Clients standardmäßig erben die <xref:System.Collections.Specialized.NameObjectCollectionBase> -Klasse können sie verfügbar machen und können dazu führen, dass unerwünschte Verhalten bei COM-Clients.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Specialized.NameObjectCollectionBase.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ist mehrdimensional.  
  
- oder -  
Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Specialized.NameObjectCollectionBase" /> ist größer als der verfügbare Platz vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
        <exception cref="T:System.InvalidCastException">Der Typ der Quell-<see cref="T:System.Collections.Specialized.NameObjectCollectionBase" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.NameObjectCollectionBase.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf das <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Objekt synchronisiert (threadsicher) ist.</summary>
        <value>
          <see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Objekt synchronisiert (threadsicher) ist, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Collections.Specialized.NameObjectCollectionBase> Objekt ist nicht synchronisiert. Abgeleitete Klassen können eine synchronisierte Version des Bereitstellen der <xref:System.Collections.Specialized.NameObjectCollectionBase> mithilfe der <xref:System.Collections.ICollection.SyncRoot%2A> Eigenschaft.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Auflistung mit Sperren der <xref:System.Collections.ICollection.SyncRoot%2A> Eigenschaft während der gesamten Enumeration.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase/CPP/remarks.cpp#2)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase/CS/remarks.cs#2)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase/VB/remarks.vb#2)]  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Specialized.NameObjectCollectionBase.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Specialized</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf das <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Objekt synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf das <see cref="T:System.Collections.Specialized.NameObjectCollectionBase" />-Objekt synchronisiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen können eigene synchronisierte Version des Bereitstellen der <xref:System.Collections.Specialized.NameObjectCollectionBase> -Klasse unter Verwendung der <xref:System.Collections.ICollection.SyncRoot%2A> Eigenschaft. Der Synchronisierungscode dürfen Vorgänge auf den <xref:System.Collections.ICollection.SyncRoot%2A> Eigenschaft der <xref:System.Collections.Specialized.NameObjectCollectionBase> Objekt nicht direkt auf die <xref:System.Collections.Specialized.NameObjectCollectionBase> Objekt. Dies gewährleistet die einwandfreie Funktion von Auflistungen, die von anderen Objekten abgeleitet sind. Insbesondere verwaltet ordnungsgemäße Synchronisierung mit anderen Threads, die möglicherweise gleichzeitig ändern können die <xref:System.Collections.Specialized.NameObjectCollectionBase> Objekt.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Selbst wenn eine Auflistung synchronisiert wird, besteht die Möglichkeit, dass andere Threads sie ändern. Dies führt dazu, dass der Enumerator eine Ausnahme auslöst. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Auflistung mit Sperren der <xref:System.Collections.ICollection.SyncRoot%2A> während der gesamten Enumeration.  
  
 [!code-cpp[System.Collections.Specialized.NameObjectCollectionBase#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase/CPP/remarks.cpp#2)]
 [!code-csharp[System.Collections.Specialized.NameObjectCollectionBase#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase/CS/remarks.cs#2)]
 [!code-vb[System.Collections.Specialized.NameObjectCollectionBase#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Specialized.NameObjectCollectionBase/VB/remarks.vb#2)]  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
  </Members>
</Type>