<Type Name="BinaryPrimitives" FullName="System.Buffers.Binary.BinaryPrimitives">
  <Metadata><Meta Name="ms.openlocfilehash" Value="19acb47cc96e0a5dfa0fa2365375f761ade2befa" /><Meta Name="ms.sourcegitcommit" Value="1617f40ee47f4336ea7edb156fc31f853fadd853" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/13/2020" /><Meta Name="ms.locfileid" Value="88188370" /></Metadata><TypeSignature Language="C#" Value="public static class BinaryPrimitives" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit BinaryPrimitives extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Buffers.Binary.BinaryPrimitives" />
  <TypeSignature Language="VB.NET" Value="Public Class BinaryPrimitives" />
  <TypeSignature Language="C++ CLI" Value="public ref class BinaryPrimitives abstract sealed" />
  <TypeSignature Language="F#" Value="type BinaryPrimitives = class" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Memory" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="a3952-101">Liest Bytes als primitive Werte mit einer bestimmten Bytereihenfolge</span><span class="sxs-lookup"><span data-stu-id="a3952-101">Reads bytes as primitives with specific endianness.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-102">Für Native Formate, memoryextensions. Read {T}; sollte verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="a3952-102">For native formats, MemoryExtensions.Read{T}; should be used.</span></span>
<span data-ttu-id="a3952-103">Verwenden Sie diese Hilfsprogramme, wenn Sie eine bestimmte Einschreibung lesen müssen.</span><span class="sxs-lookup"><span data-stu-id="a3952-103">Use these helpers when you need to read specific endinanness.</span></span>

          ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ReadDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static double ReadDoubleBigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ReadDoubleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadDoubleBigEndian (source As ReadOnlySpan(Of Byte)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ReadDoubleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadDoubleBigEndian : ReadOnlySpan&lt;byte&gt; -&gt; double" Usage="System.Buffers.Binary.BinaryPrimitives.ReadDoubleBigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-104">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-104">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-105">Liest eine <see cref="T:System.Double" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-105">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-106">Der big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-106">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-107">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-107">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-108"><paramref name="source" /> ist zu klein für eine <see cref="T:System.Double" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-108"><paramref name="source" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static double ReadDoubleLittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ReadDoubleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadDoubleLittleEndian (source As ReadOnlySpan(Of Byte)) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double ReadDoubleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadDoubleLittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; double" Usage="System.Buffers.Binary.BinaryPrimitives.ReadDoubleLittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-109">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-109">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-110">Liest eine <see cref="T:System.Double" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-110">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-111">Der Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-111">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-112">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-112">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-113"><paramref name="source" /> ist zu klein für eine <see cref="T:System.Double" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-113"><paramref name="source" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16BigEndian">
      <MemberSignature Language="C#" Value="public static short ReadInt16BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16BigEndian (source As ReadOnlySpan(Of Byte)) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt16BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt16BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-114">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-114">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-115">Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-115">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-116">Der big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-116">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-117">Liest genau 2 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-117">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-118"><paramref name="source" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-118"><paramref name="source" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static short ReadInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt16LittleEndian (source As ReadOnlySpan(Of Byte)) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReadInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt16LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt16LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-119">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-119">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-120">Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-120">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-121">Der Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-121">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-122">Liest genau 2 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-122">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-123"><paramref name="source" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-123"><paramref name="source" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32BigEndian">
      <MemberSignature Language="C#" Value="public static int ReadInt32BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32BigEndian (source As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt32BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt32BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-124">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-124">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-125">Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-125">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-126">Der big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-126">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-127">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-127">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-128"><paramref name="source" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-128"><paramref name="source" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static int ReadInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt32LittleEndian (source As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReadInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt32LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt32LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-129">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-129">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-130">Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-130">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-131">Der Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-131">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-132">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-132">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-133"><paramref name="source" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-133"><paramref name="source" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64BigEndian">
      <MemberSignature Language="C#" Value="public static long ReadInt64BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64BigEndian (source As ReadOnlySpan(Of Byte)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt64BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt64BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-134">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-134">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-135">Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-135">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-136">Der big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-136">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-137">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-137">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-138"><paramref name="source" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-138"><paramref name="source" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static long ReadInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadInt64LittleEndian (source As ReadOnlySpan(Of Byte)) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReadInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadInt64LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadInt64LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-139">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-139">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-140">Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-140">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-141">Der Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-141">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-142">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-142">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-143"><paramref name="source" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-143"><paramref name="source" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSingleBigEndian">
      <MemberSignature Language="C#" Value="public static float ReadSingleBigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ReadSingleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadSingleBigEndian (source As ReadOnlySpan(Of Byte)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ReadSingleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadSingleBigEndian : ReadOnlySpan&lt;byte&gt; -&gt; single" Usage="System.Buffers.Binary.BinaryPrimitives.ReadSingleBigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-144">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-144">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-145">Liest eine <see cref="T:System.Single" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-145">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-146">Der big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-146">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-147">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-147">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-148"><paramref name="source" /> ist zu klein für eine <see cref="T:System.Single" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-148"><paramref name="source" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static float ReadSingleLittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ReadSingleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadSingleLittleEndian (source As ReadOnlySpan(Of Byte)) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ReadSingleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadSingleLittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; single" Usage="System.Buffers.Binary.BinaryPrimitives.ReadSingleLittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-149">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-149">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-150">Liest eine <see cref="T:System.Single" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-150">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-151">Der Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-151">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-152">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-152">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-153"><paramref name="source" /> ist zu klein für eine <see cref="T:System.Single" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-153"><paramref name="source" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static ushort ReadUInt16BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReadUInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt16BigEndian (source As ReadOnlySpan(Of Byte)) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReadUInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt16BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt16BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-154">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-154">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-155">Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-155">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-156">Der big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-156">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-157">Liest genau 2 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-157">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-158"><paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-158"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static ushort ReadUInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReadUInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt16LittleEndian (source As ReadOnlySpan(Of Byte)) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReadUInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt16LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt16LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-159">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-159">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-160">Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-160">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-161">Der Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-161">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-162">Liest genau 2 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-162">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-163"><paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-163"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static uint ReadUInt32BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReadUInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt32BigEndian (source As ReadOnlySpan(Of Byte)) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReadUInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt32BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt32BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-164">Der zu lesende schreibgeschützte Bereich</span><span class="sxs-lookup"><span data-stu-id="a3952-164">The read-only span to read.</span></span></param>
        <summary><span data-ttu-id="a3952-165">Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-165">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-166">Der big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-166">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-167">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-167">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-168"><paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-168"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static uint ReadUInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReadUInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt32LittleEndian (source As ReadOnlySpan(Of Byte)) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReadUInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt32LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt32LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-169">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-169">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="a3952-170">Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-170">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-171">Der Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-171">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-172">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-172">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-173"><paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-173"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static ulong ReadUInt64BigEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReadUInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt64BigEndian (source As ReadOnlySpan(Of Byte)) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReadUInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt64BigEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt64BigEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-174">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-174">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="a3952-175">Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-175">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-176">Der big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-176">The big endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-177">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-177">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-178"><paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-178"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static ulong ReadUInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReadUInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUInt64LittleEndian (source As ReadOnlySpan(Of Byte)) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReadUInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="static member ReadUInt64LittleEndian : ReadOnlySpan&lt;byte&gt; -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReadUInt64LittleEndian source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-179">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-179">The read-only span of bytes to read.</span></span></param>
        <summary><span data-ttu-id="a3952-180">Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-180">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-181">Der Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-181">The little endian value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-182">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-182">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-183"><paramref name="source" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-183"><paramref name="source" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static byte ReverseEndianness (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReverseEndianness(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte ReverseEndianness(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : byte -&gt; byte" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a3952-184">Der umzukehrende Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-184">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="a3952-185">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Byte" />-Werts geändert wird, der nicht für eine <see cref="T:System.Byte" />-Struktur benötigt wird</span><span class="sxs-lookup"><span data-stu-id="a3952-185">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Byte" /> value, which effectively does nothing for a <see cref="T:System.Byte" />.</span></span></summary>
        <returns><span data-ttu-id="a3952-186">Der übergebene Wert in unveränderter Form</span><span class="sxs-lookup"><span data-stu-id="a3952-186">The passed-in value, unmodified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-187">Diese Methode führt praktisch nichts aus und wurde nur aus Gründen der Konsistenz hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="a3952-187">This method effectively does nothing and was added only for consistency.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static short ReverseEndianness (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReverseEndianness(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short ReverseEndianness(short value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int16 -&gt; int16" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a3952-188">Der umzukehrende Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-188">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="a3952-189">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Int16" />-Werts geändert wird</span><span class="sxs-lookup"><span data-stu-id="a3952-189">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int16" /> value.</span></span></summary>
        <returns><span data-ttu-id="a3952-190">Der umgekehrte Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-190">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static int ReverseEndianness (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReverseEndianness(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ReverseEndianness(int value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int -&gt; int" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a3952-191">Der umzukehrende Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-191">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="a3952-192">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Int32" />-Werts geändert wird</span><span class="sxs-lookup"><span data-stu-id="a3952-192">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int32" /> value.</span></span></summary>
        <returns><span data-ttu-id="a3952-193">Der umgekehrte Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-193">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static long ReverseEndianness (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReverseEndianness(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long ReverseEndianness(long value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : int64 -&gt; int64" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a3952-194">Der umzukehrende Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-194">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="a3952-195">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.Int64" />-Werts geändert wird</span><span class="sxs-lookup"><span data-stu-id="a3952-195">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.Int64" /> value.</span></span></summary>
        <returns><span data-ttu-id="a3952-196">Der umgekehrte Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-196">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static sbyte ReverseEndianness (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ReverseEndianness(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte ReverseEndianness(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : sbyte -&gt; sbyte" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a3952-197">Der umzukehrende Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-197">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="a3952-198">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.SByte" />-Werts geändert wird, der nicht für eine <see cref="T:System.SByte" />-Struktur benötigt wird</span><span class="sxs-lookup"><span data-stu-id="a3952-198">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.SByte" /> value, which effectively does nothing for an <see cref="T:System.SByte" />.</span></span></summary>
        <returns><span data-ttu-id="a3952-199">Der übergebene Wert in unveränderter Form</span><span class="sxs-lookup"><span data-stu-id="a3952-199">The passed-in value, unmodified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-200">Diese Methode führt praktisch nichts aus und wurde nur aus Gründen der Konsistenz hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="a3952-200">This method effectively does nothing and was added only for consistency.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static ushort ReverseEndianness (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ReverseEndianness(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 ReverseEndianness(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint16 -&gt; uint16" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a3952-201">Der umzukehrende Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-201">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="a3952-202">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.UInt16" />-Werts geändert wird</span><span class="sxs-lookup"><span data-stu-id="a3952-202">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt16" /> value.</span></span></summary>
        <returns><span data-ttu-id="a3952-203">Der umgekehrte Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-203">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static uint ReverseEndianness (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ReverseEndianness(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 ReverseEndianness(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint32 -&gt; uint32" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a3952-204">Der umzukehrende Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-204">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="a3952-205">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.UInt32" />-Werts geändert wird</span><span class="sxs-lookup"><span data-stu-id="a3952-205">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt32" /> value.</span></span></summary>
        <returns><span data-ttu-id="a3952-206">Der umgekehrte Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-206">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseEndianness">
      <MemberSignature Language="C#" Value="public static ulong ReverseEndianness (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ReverseEndianness(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.ReverseEndianness(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReverseEndianness (value As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 ReverseEndianness(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member ReverseEndianness : uint64 -&gt; uint64" Usage="System.Buffers.Binary.BinaryPrimitives.ReverseEndianness value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a3952-207">Der umzukehrende Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-207">The value to reverse.</span></span></param>
        <summary><span data-ttu-id="a3952-208">Kehrt einen primitiven Wert um, indem die Bytereihenfolge des angegebenen <see cref="T:System.UInt64" />-Werts geändert wird</span><span class="sxs-lookup"><span data-stu-id="a3952-208">Reverses a primitive value by performing an endianness swap of the specified <see cref="T:System.UInt64" /> value.</span></span></summary>
        <returns><span data-ttu-id="a3952-209">Der umgekehrte Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-209">The reversed value.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadDoubleBigEndian (ReadOnlySpan&lt;byte&gt; source, out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadDoubleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian(System.ReadOnlySpan{System.Byte},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadDoubleBigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadDoubleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="static member TryReadDoubleBigEndian : ReadOnlySpan&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadDoubleBigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-210">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-210">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-211">Wenn diese Methode zurückgegeben wird, enthält sie den Wert, der aus dem schreibgeschützten Bytebereich als Big-Endian-Wert gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="a3952-211">When this method returns, contains the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="a3952-212">Liest eine <see cref="T:System.Double" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-212">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-213"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Double" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-213"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-214">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-214">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadDoubleLittleEndian (ReadOnlySpan&lt;byte&gt; source, out double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadDoubleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian(System.ReadOnlySpan{System.Byte},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadDoubleLittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadDoubleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] double % value);" />
      <MemberSignature Language="F#" Value="static member TryReadDoubleLittleEndian : ReadOnlySpan&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadDoubleLittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-215">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-215">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-216">Wenn diese Methode zurückgegeben wird, enthält sie den Wert, der aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="a3952-216">When this method returns, contains the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="a3952-217">Liest eine <see cref="T:System.Double" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-217">Reads a <see cref="T:System.Double" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-218"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Double" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-218"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-219">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-219">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt16BigEndian (ReadOnlySpan&lt;byte&gt; source, out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian(System.ReadOnlySpan{System.Byte},System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt16BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt16BigEndian : ReadOnlySpan&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt16BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-220">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-220">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-221">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-221">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="a3952-222">Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-222">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-223"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-223"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-224">Liest genau 2 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-224">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source, out short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt16LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] short % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt16LittleEndian : ReadOnlySpan&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt16LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-225">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-225">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-226">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-226">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="a3952-227">Liest eine <see cref="T:System.Int16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-227">Reads an <see cref="T:System.Int16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-228"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-228"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-229">Liest genau 2 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-229">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt32BigEndian (ReadOnlySpan&lt;byte&gt; source, out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt32BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt32BigEndian : ReadOnlySpan&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt32BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-230">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-230">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-231">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-231">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="a3952-232">Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-232">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-233"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-233"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-234">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-234">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source, out int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt32LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt32LittleEndian : ReadOnlySpan&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt32LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-235">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-235">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-236">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-236">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="a3952-237">Liest eine <see cref="T:System.Int32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-237">Reads an <see cref="T:System.Int32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-238"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-238"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-239">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-239">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt64BigEndian (ReadOnlySpan&lt;byte&gt; source, out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian(System.ReadOnlySpan{System.Byte},System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt64BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt64BigEndian : ReadOnlySpan&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt64BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-240">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-240">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-241">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-241">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="a3952-242">Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-242">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-243"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-243"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-244">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-244">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source, out long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadInt64LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] long % value);" />
      <MemberSignature Language="F#" Value="static member TryReadInt64LittleEndian : ReadOnlySpan&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadInt64LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-245">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-245">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-246">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-246">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="a3952-247">Liest eine <see cref="T:System.Int64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-247">Reads an <see cref="T:System.Int64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-248"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-248"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-249">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-249">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSingleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadSingleBigEndian (ReadOnlySpan&lt;byte&gt; source, out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadSingleBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian(System.ReadOnlySpan{System.Byte},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadSingleBigEndian (source As ReadOnlySpan(Of Byte), ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadSingleBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="static member TryReadSingleBigEndian : ReadOnlySpan&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadSingleBigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-250">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-250">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-251">Wenn diese Methode zurückgegeben wird, enthält sie den Wert, der aus dem schreibgeschützten Bytebereich als Big-Endian-Wert gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="a3952-251">When this method returns, contains the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="a3952-252">Liest eine <see cref="T:System.Single" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-252">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-253"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Single" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-253"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-254">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-254">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadSingleLittleEndian (ReadOnlySpan&lt;byte&gt; source, out float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadSingleLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] float32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian(System.ReadOnlySpan{System.Byte},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadSingleLittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadSingleLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] float % value);" />
      <MemberSignature Language="F#" Value="static member TryReadSingleLittleEndian : ReadOnlySpan&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadSingleLittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" RefType="out" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-255">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-255">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-256">Wenn diese Methode zurückgegeben wird, enthält sie den Wert, der aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen wird.</span><span class="sxs-lookup"><span data-stu-id="a3952-256">When this method returns, contains the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="a3952-257">Liest eine <see cref="T:System.Single" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-257">Reads a <see cref="T:System.Single" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-258"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Single" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-258"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-259">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-259">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt16BigEndian (ReadOnlySpan&lt;byte&gt; source, out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt16BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt16BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt16BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt16BigEndian : ReadOnlySpan&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt16BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-260">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-260">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-261">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-261">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="a3952-262">Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-262">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-263"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-263"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-264">Liest genau 2 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-264">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt16LittleEndian (ReadOnlySpan&lt;byte&gt; source, out ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt16LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int16&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt16LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt16LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt16 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt16LittleEndian : ReadOnlySpan&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt16LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-265">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-265">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-266">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-266">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="a3952-267">Liest eine <see cref="T:System.UInt16" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-267">Reads a <see cref="T:System.UInt16" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-268"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-268"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-269">Liest genau 2 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-269">Reads exactly 2 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt32BigEndian (ReadOnlySpan&lt;byte&gt; source, out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt32BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt32BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt32BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt32BigEndian : ReadOnlySpan&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt32BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-270">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-270">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-271">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-271">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="a3952-272">Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-272">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-273"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-273"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-274">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-274">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt32LittleEndian (ReadOnlySpan&lt;byte&gt; source, out uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt32LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int32&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt32LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt32LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt32 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt32LittleEndian : ReadOnlySpan&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt32LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-275">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-275">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-276">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-276">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="a3952-277">Liest eine <see cref="T:System.UInt32" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-277">Reads a <see cref="T:System.UInt32" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-278"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-278"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-279">Liest genau 4 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-279">Reads exactly 4 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt64BigEndian (ReadOnlySpan&lt;byte&gt; source, out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt64BigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt64BigEndian (source As ReadOnlySpan(Of Byte), ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt64BigEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt64BigEndian : ReadOnlySpan&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt64BigEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-280">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-280">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-281">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als big-endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-281">When this method returns, the value read out of the read-only span of bytes, as big endian.</span></span></param>
        <summary><span data-ttu-id="a3952-282">Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als big-endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-282">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-283"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-283"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-284">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-284">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryReadUInt64LittleEndian (ReadOnlySpan&lt;byte&gt; source, out ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryReadUInt64LittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] unsigned int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian(System.ReadOnlySpan{System.Byte},System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadUInt64LittleEndian (source As ReadOnlySpan(Of Byte), ByRef value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadUInt64LittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] System::UInt64 % value);" />
      <MemberSignature Language="F#" Value="static member TryReadUInt64LittleEndian : ReadOnlySpan&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryReadUInt64LittleEndian (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="a3952-285">Der schreibgeschützte Bereich der zu lesenden Bytes</span><span class="sxs-lookup"><span data-stu-id="a3952-285">The read-only span of bytes to read.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-286">Wenn diese Methode zurückgegeben wird, wird der Wert aus dem schreibgeschützten Bytebereich als Little-Endian-Wert gelesen.</span><span class="sxs-lookup"><span data-stu-id="a3952-286">When this method returns, the value read out of the read-only span of bytes, as little endian.</span></span></param>
        <summary><span data-ttu-id="a3952-287">Liest eine <see cref="T:System.UInt64" />-Struktur am Anfang eines schreibgeschützten Bytebereichs als Little-Endian-Wert</span><span class="sxs-lookup"><span data-stu-id="a3952-287">Reads a <see cref="T:System.UInt64" /> from the beginning of a read-only span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-288"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-288"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-289">Liest genau 8 Bytes vom Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-289">Reads exactly 8 bytes from the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteDoubleBigEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteDoubleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteDoubleBigEndian (destination As Span(Of Byte), value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteDoubleBigEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member TryWriteDoubleBigEndian : Span&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-290">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-290">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-291">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-291">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-292">Schreibt eine <see cref="T:System.Double" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-292">Writes a <see cref="T:System.Double" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-293"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Double" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-293"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-294">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-294">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteDoubleLittleEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteDoubleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteDoubleLittleEndian (destination As Span(Of Byte), value As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteDoubleLittleEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member TryWriteDoubleLittleEndian : Span&lt;byte&gt; * double -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteDoubleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-295">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-295">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-296">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-296">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-297">Schreibt eine <see cref="T:System.Double" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-297">Writes a <see cref="T:System.Double" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-298"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Double" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-298"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Double" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-299">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-299">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt16BigEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt16BigEndian (destination As Span(Of Byte), value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt16BigEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt16BigEndian : Span&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-300">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-300">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-301">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-301">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-302">Schreibt eine <see cref="T:System.Int16" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-302">Writes an <see cref="T:System.Int16" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-303"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-303"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-304">Schreibt genau 2 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-304">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt16LittleEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt16LittleEndian (destination As Span(Of Byte), value As Short) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt16LittleEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt16LittleEndian : Span&lt;byte&gt; * int16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-305">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-305">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-306">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-306">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-307">Schreibt eine <see cref="T:System.Int16" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-307">Writes an <see cref="T:System.Int16" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-308"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int16" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-308"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-309">Schreibt genau 2 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-309">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt32BigEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt32BigEndian (destination As Span(Of Byte), value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt32BigEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt32BigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-310">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-310">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-311">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-311">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-312">Schreibt eine <see cref="T:System.Int32" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-312">Writes an <see cref="T:System.Int32" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-313"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-313"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-314">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-314">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt32LittleEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt32LittleEndian (destination As Span(Of Byte), value As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt32LittleEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt32LittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-315">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-315">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-316">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-316">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-317">Schreibt eine <see cref="T:System.Int32" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-317">Writes an <see cref="T:System.Int32" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-318"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int32" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-318"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-319">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-319">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt64BigEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt64BigEndian (destination As Span(Of Byte), value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt64BigEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt64BigEndian : Span&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-320">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-320">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-321">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-321">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-322">Schreibt eine <see cref="T:System.Int64" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-322">Writes an <see cref="T:System.Int64" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-323"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-323"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-324">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-324">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteInt64LittleEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteInt64LittleEndian (destination As Span(Of Byte), value As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteInt64LittleEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member TryWriteInt64LittleEndian : Span&lt;byte&gt; * int64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-325">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-325">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-326">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-326">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-327">Schreibt eine <see cref="T:System.Int64" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-327">Writes an <see cref="T:System.Int64" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-328"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Int64" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-328"><see langword="true" /> if the span is large enough to contain an <see cref="T:System.Int64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-329">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-329">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteSingleBigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteSingleBigEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteSingleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteSingleBigEndian (destination As Span(Of Byte), value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteSingleBigEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member TryWriteSingleBigEndian : Span&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteSingleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-330">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-330">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-331">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-331">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-332">Schreibt eine <see cref="T:System.Single" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-332">Writes a <see cref="T:System.Single" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-333"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Single" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-333"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-334">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-334">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteSingleLittleEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteSingleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteSingleLittleEndian (destination As Span(Of Byte), value As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteSingleLittleEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member TryWriteSingleLittleEndian : Span&lt;byte&gt; * single -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteSingleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-335">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-335">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-336">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-336">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-337">Schreibt eine <see cref="T:System.Single" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-337">Writes a <see cref="T:System.Single" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-338"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.Single" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-338"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.Single" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-339">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-339">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt16BigEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt16BigEndian (destination As Span(Of Byte), value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt16BigEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt16BigEndian : Span&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-340">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-340">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-341">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-341">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-342">Schreibt eine <see cref="T:System.UInt16" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-342">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-343"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-343"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-344">Schreibt genau 2 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-344">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt16LittleEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt16LittleEndian (destination As Span(Of Byte), value As UShort) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt16LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt16LittleEndian : Span&lt;byte&gt; * uint16 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-345">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-345">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-346">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-346">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-347">Schreibt eine <see cref="T:System.UInt16" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-347">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-348"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt16" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-348"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt16" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-349">Schreibt genau 2 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-349">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt32BigEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt32BigEndian (destination As Span(Of Byte), value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt32BigEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt32BigEndian : Span&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-350">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-350">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-351">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-351">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-352">Schreibt eine <see cref="T:System.UInt32" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-352">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-353"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-353"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-354">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-354">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt32LittleEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt32LittleEndian (destination As Span(Of Byte), value As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt32LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt32LittleEndian : Span&lt;byte&gt; * uint32 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-355">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-355">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-356">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-356">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-357">Schreibt eine <see cref="T:System.UInt32" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-357">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-358"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt32" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-358"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt32" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-359">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-359">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt64BigEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt64BigEndian (destination As Span(Of Byte), value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt64BigEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt64BigEndian : Span&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-360">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-360">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-361">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-361">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-362">Schreibt eine <see cref="T:System.UInt64" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-362">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as big endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-363"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-363"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-364">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-364">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static bool TryWriteUInt64LittleEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWriteUInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWriteUInt64LittleEndian (destination As Span(Of Byte), value As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWriteUInt64LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member TryWriteUInt64LittleEndian : Span&lt;byte&gt; * uint64 -&gt; bool" Usage="System.Buffers.Binary.BinaryPrimitives.TryWriteUInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-365">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-365">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-366">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-366">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-367">Schreibt eine <see cref="T:System.UInt64" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-367">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as little endian.</span></span></summary>
        <returns><span data-ttu-id="a3952-368"><see langword="true" />, wenn der Bereich groß genug für eine <see cref="T:System.UInt64" />-Struktur ist; andernfalls <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="a3952-368"><see langword="true" /> if the span is large enough to contain a <see cref="T:System.UInt64" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-369">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-369">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteDoubleBigEndian">
      <MemberSignature Language="C#" Value="public static void WriteDoubleBigEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteDoubleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteDoubleBigEndian (destination As Span(Of Byte), value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteDoubleBigEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member WriteDoubleBigEndian : Span&lt;byte&gt; * double -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteDoubleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-370">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-370">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-371">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-371">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-372">Schreibt eine <see cref="T:System.Double" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-372">Writes a <see cref="T:System.Double" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-373">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-373">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-374"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.Double" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-374"><paramref name="destination" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteDoubleLittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteDoubleLittleEndian (Span&lt;byte&gt; destination, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteDoubleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian(System.Span{System.Byte},System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteDoubleLittleEndian (destination As Span(Of Byte), value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteDoubleLittleEndian(Span&lt;System::Byte&gt; destination, double value);" />
      <MemberSignature Language="F#" Value="static member WriteDoubleLittleEndian : Span&lt;byte&gt; * double -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteDoubleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Double" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-375">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-375">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-376">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-376">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-377">Schreibt eine <see cref="T:System.Double" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-377">Writes a <see cref="T:System.Double" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-378">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-378">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-379"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.Double" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-379"><paramref name="destination" /> is too small to contain a <see cref="T:System.Double" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt16BigEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16BigEndian (destination As Span(Of Byte), value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16BigEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member WriteInt16BigEndian : Span&lt;byte&gt; * int16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-380">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-380">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-381">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-381">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-382">Schreibt eine <see cref="T:System.Int16" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-382">Writes an <see cref="T:System.Int16" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-383">Schreibt genau 2 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-383">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-384"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-384"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt16LittleEndian (Span&lt;byte&gt; destination, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian(System.Span{System.Byte},System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt16LittleEndian (destination As Span(Of Byte), value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt16LittleEndian(Span&lt;System::Byte&gt; destination, short value);" />
      <MemberSignature Language="F#" Value="static member WriteInt16LittleEndian : Span&lt;byte&gt; * int16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-385">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-385">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-386">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-386">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-387">Schreibt eine <see cref="T:System.Int16" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-387">Writes an <see cref="T:System.Int16" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-388">Schreibt genau 2 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-388">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-389"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int16" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-389"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt32BigEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32BigEndian (destination As Span(Of Byte), value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32BigEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member WriteInt32BigEndian : Span&lt;byte&gt; * int -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-390">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-390">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-391">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-391">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-392">Schreibt eine <see cref="T:System.Int32" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-392">Writes an <see cref="T:System.Int32" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-393">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-393">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-394"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-394"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt32LittleEndian (Span&lt;byte&gt; destination, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian(System.Span{System.Byte},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt32LittleEndian (destination As Span(Of Byte), value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt32LittleEndian(Span&lt;System::Byte&gt; destination, int value);" />
      <MemberSignature Language="F#" Value="static member WriteInt32LittleEndian : Span&lt;byte&gt; * int -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-395">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-395">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-396">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-396">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-397">Schreibt eine <see cref="T:System.Int32" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-397">Writes an <see cref="T:System.Int32" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-398">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-398">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-399"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int32" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-399"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt64BigEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64BigEndian (destination As Span(Of Byte), value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64BigEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member WriteInt64BigEndian : Span&lt;byte&gt; * int64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-400">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-400">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-401">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-401">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-402">Schreibt eine <see cref="T:System.Int64" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-402">Writes an <see cref="T:System.Int64" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-403">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-403">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-404"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-404"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteInt64LittleEndian (Span&lt;byte&gt; destination, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian(System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteInt64LittleEndian (destination As Span(Of Byte), value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteInt64LittleEndian(Span&lt;System::Byte&gt; destination, long value);" />
      <MemberSignature Language="F#" Value="static member WriteInt64LittleEndian : Span&lt;byte&gt; * int64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-405">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-405">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-406">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-406">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-407">Schreibt eine <see cref="T:System.Int64" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-407">Writes an <see cref="T:System.Int64" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-408">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-408">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-409"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.Int64" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-409"><paramref name="destination" /> is too small to contain an <see cref="T:System.Int64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSingleBigEndian">
      <MemberSignature Language="C#" Value="public static void WriteSingleBigEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteSingleBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteSingleBigEndian (destination As Span(Of Byte), value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteSingleBigEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member WriteSingleBigEndian : Span&lt;byte&gt; * single -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteSingleBigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-410">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-410">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-411">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-411">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-412">Schreibt eine <see cref="T:System.Single" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-412">Writes a <see cref="T:System.Single" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-413">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-413">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-414"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.Single" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-414"><paramref name="destination" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSingleLittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteSingleLittleEndian (Span&lt;byte&gt; destination, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteSingleLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian(System.Span{System.Byte},System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteSingleLittleEndian (destination As Span(Of Byte), value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteSingleLittleEndian(Span&lt;System::Byte&gt; destination, float value);" />
      <MemberSignature Language="F#" Value="static member WriteSingleLittleEndian : Span&lt;byte&gt; * single -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteSingleLittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="value" Type="System.Single" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-415">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-415">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-416">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-416">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-417">Schreibt eine <see cref="T:System.Single" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-417">Writes a <see cref="T:System.Single" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-418">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-418">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-419"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.Single" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-419"><paramref name="destination" /> is too small to contain a <see cref="T:System.Single" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt16BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt16BigEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt16BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt16BigEndian (destination As Span(Of Byte), value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt16BigEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt16BigEndian : Span&lt;byte&gt; * uint16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt16BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-420">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-420">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-421">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-421">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-422">Schreibt eine <see cref="T:System.UInt16" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-422">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-423">Schreibt genau 2 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-423">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-424"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-424"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt16LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt16LittleEndian (Span&lt;byte&gt; destination, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt16LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian(System.Span{System.Byte},System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt16LittleEndian (destination As Span(Of Byte), value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt16LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt16LittleEndian : Span&lt;byte&gt; * uint16 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt16LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-425">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-425">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-426">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-426">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-427">Schreibt eine <see cref="T:System.UInt16" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-427">Writes a <see cref="T:System.UInt16" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-428">Schreibt genau 2 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-428">Writes exactly 2 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-429"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt16" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-429"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt16" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt32BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt32BigEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt32BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt32BigEndian (destination As Span(Of Byte), value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt32BigEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt32BigEndian : Span&lt;byte&gt; * uint32 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt32BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-430">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-430">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-431">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-431">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-432">Schreibt eine <see cref="T:System.UInt32" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-432">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-433">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-433">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-434"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-434"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt32LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt32LittleEndian (Span&lt;byte&gt; destination, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt32LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian(System.Span{System.Byte},System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt32LittleEndian (destination As Span(Of Byte), value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt32LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt32LittleEndian : Span&lt;byte&gt; * uint32 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt32LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-435">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-435">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-436">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-436">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-437">Schreibt eine <see cref="T:System.UInt32" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-437">Writes a <see cref="T:System.UInt32" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-438">Schreibt genau 4 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-438">Writes exactly 4 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-439"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt32" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-439"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt32" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt64BigEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt64BigEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt64BigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt64BigEndian (destination As Span(Of Byte), value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt64BigEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt64BigEndian : Span&lt;byte&gt; * uint64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt64BigEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-440">Der Bytebereich, in den der Wert als big-endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-440">The span of bytes where the value is to be written, as big endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-441">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-441">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-442">Schreibt eine <see cref="T:System.UInt64" />-Struktur als big-endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-442">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as big endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-443">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-443">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-444"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-444"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WriteUInt64LittleEndian">
      <MemberSignature Language="C#" Value="public static void WriteUInt64LittleEndian (Span&lt;byte&gt; destination, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUInt64LittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian(System.Span{System.Byte},System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUInt64LittleEndian (destination As Span(Of Byte), value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteUInt64LittleEndian(Span&lt;System::Byte&gt; destination, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteUInt64LittleEndian : Span&lt;byte&gt; * uint64 -&gt; unit" Usage="System.Buffers.Binary.BinaryPrimitives.WriteUInt64LittleEndian (destination, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="a3952-445">Der Bytebereich, in den der Wert als Little-Endian-Wert geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-445">The span of bytes where the value is to be written, as little endian.</span></span></param>
        <param name="value"><span data-ttu-id="a3952-446">Der Wert, der in den Bytebereich geschrieben werden soll</span><span class="sxs-lookup"><span data-stu-id="a3952-446">The value to write into the span of bytes.</span></span></param>
        <summary><span data-ttu-id="a3952-447">Schreibt eine <see cref="T:System.UInt64" />-Struktur als Little-Endian-Wert in einen Bytebereich</span><span class="sxs-lookup"><span data-stu-id="a3952-447">Writes a <see cref="T:System.UInt64" /> into a span of bytes, as little endian.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a3952-448">Schreibt genau 8 Bytes an den Anfang der Spanne.</span><span class="sxs-lookup"><span data-stu-id="a3952-448">Writes exactly 8 bytes to the beginning of the span.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="a3952-449"><paramref name="destination" /> ist zu klein für eine <see cref="T:System.UInt64" />-Struktur.</span><span class="sxs-lookup"><span data-stu-id="a3952-449"><paramref name="destination" /> is too small to contain a <see cref="T:System.UInt64" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
