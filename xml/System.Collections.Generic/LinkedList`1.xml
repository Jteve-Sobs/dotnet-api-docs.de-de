<Type Name="LinkedList&lt;T&gt;" FullName="System.Collections.Generic.LinkedList&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="49b63e7bf5e8e4dccb0e36a35d4016d11f7db3d3" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52208956" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class LinkedList&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit LinkedList`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.LinkedList`1" />
  <TypeSignature Language="VB.NET" Value="Public Class LinkedList(Of T)&#xA;Implements ICollection, ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class LinkedList : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type LinkedList&lt;'T&gt; = class&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Gibt den Elementtyp der verknüpften Liste an.</typeparam>
    <summary>Stellt eine doppelt verknüpfte Liste dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> ist eine vielfältig einsetzbare verknüpfte Liste. Es unterstützt, Enumeratoren und implementiert die <xref:System.Collections.ICollection> Schnittstelle, die konsistent mit anderen Auflistungsklassen in .NET Framework.  
  
 <xref:System.Collections.Generic.LinkedList%601> stellt separate Knoten vom Typ <xref:System.Collections.Generic.LinkedListNode%601>, sodass Einfüge- und Entfernvorgänge o(1)-Einfüge-Löschvorgänge sind.  
  
 Entfernen Sie Knoten, und wieder einfügen und entweder in derselben Liste oder in einer anderen Liste, sodass keine zusätzliche Objekte im Heap zugeordnet. Da die Liste auch eine interne Anzahl verwaltet werden, Abrufen der <xref:System.Collections.Generic.LinkedList%601.Count%2A> -Eigenschaft ist ein o(1)-Vorgang.  
  
 Jeder Knoten in einem <xref:System.Collections.Generic.LinkedList%601> Objekt weist den Typ <xref:System.Collections.Generic.LinkedListNode%601>. Da die <xref:System.Collections.Generic.LinkedList%601> doppelt verknüpft ist, kann jeder Knoten verweist weiterleiten, die <xref:System.Collections.Generic.LinkedListNode%601.Next%2A> Knoten als auch auf die <xref:System.Collections.Generic.LinkedListNode%601.Previous%2A> Knoten.  
  
 Listen, die Verweistypen enthalten eine bessere Leistung, wenn ein Knoten und dessen Wert zur gleichen Zeit erstellt werden. <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Verweis und lässt doppelte Werte.  
  
 Wenn die <xref:System.Collections.Generic.LinkedList%601> leer ist, die <xref:System.Collections.Generic.LinkedList%601.First%2A> und <xref:System.Collections.Generic.LinkedList%601.Last%2A> Eigenschaften enthalten `null`.  
  
 Die <xref:System.Collections.Generic.LinkedList%601> verketten, aufteilen, Zyklen oder andere Features, die die Liste in einem inkonsistenten Zustand versetzen können-Klasse nicht unterstützt. Die Liste bleibt konsistent auf einem einzelnen Thread. Die von unterstützt nur Multithread-Szenario <xref:System.Collections.Generic.LinkedList%601> ist Multithread-Lesevorgänge.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, viele Funktionen von der <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 [!code-cpp[Generic.LinkedList#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.LinkedList/cpp/source.cpp#1)]
 [!code-csharp[Generic.LinkedList#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.LinkedList/cs/source.cs#1)]
 [!code-vb[Generic.LinkedList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.LinkedList/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist nicht threadsicher. Wenn die <see cref="T:System.Collections.Generic.LinkedList`1" /> von mehreren Threads zugegriffen werden muss Sie ihre eigenen Synchronisierungsmechanismen implementieren müssen.  
  
Ein <see cref="T:System.Collections.Generic.LinkedList`1" /> gleichzeitige Unterstützung für mehrere Reader, solange die Auflistung nicht geändert wird. Trotzdem ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur. In dem seltenen Fall, in denen eine Enumeration mit Schreibzugriffe stellt fest, muss die Auflistung während der gesamten Enumeration gesperrt werden. Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.</threadsafe>
    <altmember cref="T:System.Collections.Generic.LinkedListNode`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.LinkedList`1" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LinkedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LinkedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.LinkedList`1" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Wenn die <xref:System.Collections.Generic.LinkedList%601> leer ist, die <xref:System.Collections.Generic.LinkedList%601.First%2A> und <xref:System.Collections.Generic.LinkedList%601.Last%2A> Eigenschaften enthalten `null`.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt und initialisiert ein <xref:System.Collections.Generic.LinkedList%601> des Typs <xref:System.String>mehrere Knoten hinzugefügt, und klicken Sie dann ihr Inhalt angezeigt.  
  
 [!code-cpp[System.Collections.Generic.LinkedList.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.LinkedList.ctor/CPP/llctor.cpp#1)]
 [!code-csharp[System.Collections.Generic.LinkedList.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.LinkedList.ctor/CS/llctor.cs#1)]
 [!code-vb[System.Collections.Generic.LinkedList.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.LinkedList.ctor/VB/llctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public LinkedList (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; LinkedList(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.LinkedList&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.LinkedList&lt;'T&gt;" Usage="new System.Collections.Generic.LinkedList&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Das <see cref="T:System.Collections.IEnumerable" />, dessen Elemente in das neue <see cref="T:System.Collections.Generic.LinkedList`1" /> kopiert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.LinkedList`1" />-Klasse, die aus der angegebenen <see cref="T:System.Collections.IEnumerable" /> kopierte Elemente enthält und eine ausreichende Kapazität für die Anzahl der kopierten Elemente aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Wenn `collection` verfügt über keine Elemente und klicken Sie dann die neue <xref:System.Collections.Generic.LinkedList%601> leer ist, und die <xref:System.Collections.Generic.LinkedList%601.First%2A> und <xref:System.Collections.Generic.LinkedList%601.Last%2A> Eigenschaften enthalten `null`.  
  
 Dieser Konstruktor ist ein o(n)-Vorgang, wobei `n` ist die Anzahl der Elemente im `collection`.  
  
   
  
## Examples  
 Ein Beispiel, das diesen Konstruktor enthält, finden Sie die <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected LinkedList (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; LinkedList(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.LinkedList&lt;'T&gt; : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Generic.LinkedList&lt;'T&gt;" Usage="new System.Collections.Generic.LinkedList&lt;'T&gt; (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren der <see cref="T:System.Collections.Generic.LinkedList`1" /> erforderlichen Informationen.</param>
        <param name="context">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt mit der Quelle und dem Ziel des entsprechenden serialisierten Streams für <see cref="T:System.Collections.Generic.LinkedList`1" />.</param>
        <summary>Initialisiert eine neue Instanz der serialisierbaren <see cref="T:System.Collections.Generic.LinkedList`1" />-Klasse mit der angegebenen <see cref="T:System.Runtime.Serialization.SerializationInfo" /> und dem angegebenen <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Wenn die <xref:System.Collections.Generic.LinkedList%601> leer ist, die <xref:System.Collections.Generic.LinkedList%601.First%2A> und <xref:System.Collections.Generic.LinkedList%601.Last%2A> Eigenschaften enthalten `null`.  
  
 Dieser Konstruktor ist eine o(n)-Operation.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Runtime.Serialization" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddAfter">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt nach einem vorhandenen Knoten in der <see cref="T:System.Collections.Generic.LinkedList`1" /> einen neuen Knoten oder Wert hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAfter">
      <MemberSignature Language="C#" Value="public void AddAfter (System.Collections.Generic.LinkedListNode&lt;T&gt; node, System.Collections.Generic.LinkedListNode&lt;T&gt; newNode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfter(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node, class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; newNode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddAfter(System.Collections.Generic.LinkedListNode{`0},System.Collections.Generic.LinkedListNode{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfter (node As LinkedListNode(Of T), newNode As LinkedListNode(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfter(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node, System::Collections::Generic::LinkedListNode&lt;T&gt; ^ newNode);" />
      <MemberSignature Language="F#" Value="member this.AddAfter : System.Collections.Generic.LinkedListNode&lt;'T&gt; * System.Collections.Generic.LinkedListNode&lt;'T&gt; -&gt; unit" Usage="linkedList.AddAfter (node, newNode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
        <Parameter Name="newNode" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Collections.Generic.LinkedListNode`1" />, nach dem der <paramref name="newNode" /> eingefügt werden soll.</param>
        <param name="newNode">Der neue <see cref="T:System.Collections.Generic.LinkedListNode`1" />, der der <see cref="T:System.Collections.Generic.LinkedList`1" /> hinzugefügt werden soll.</param>
        <summary>Fügt den angegebenen neuen Knoten nach dem angegebenen vorhandenen Knoten in der <see cref="T:System.Collections.Generic.LinkedList`1" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="newNode" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> befindet sich nicht in der aktuellen <see cref="T:System.Collections.Generic.LinkedList`1" />.  
  
- oder -  
 <paramref name="newNode" /> gehört zu einer anderen <see cref="T:System.Collections.Generic.LinkedList`1" />.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
      </Docs>
    </Member>
    <Member MemberName="AddAfter">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; AddAfter (System.Collections.Generic.LinkedListNode&lt;T&gt; node, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; AddAfter(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node, !T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddAfter(System.Collections.Generic.LinkedListNode{`0},`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddAfter (node As LinkedListNode(Of T), value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ AddAfter(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node, T value);" />
      <MemberSignature Language="F#" Value="member this.AddAfter : System.Collections.Generic.LinkedListNode&lt;'T&gt; * 'T -&gt; System.Collections.Generic.LinkedListNode&lt;'T&gt;" Usage="linkedList.AddAfter (node, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Collections.Generic.LinkedListNode`1" />, nach dem ein neuer <see cref="T:System.Collections.Generic.LinkedListNode`1" /> mit dem <paramref name="value" /> eingefügt werden soll.</param>
        <param name="value">Der der <see cref="T:System.Collections.Generic.LinkedList`1" /> hinzuzufügende Wert.</param>
        <summary>Fügt nach dem angegebenen vorhandenen Knoten in der <see cref="T:System.Collections.Generic.LinkedList`1" /> einen neuen Knoten mit dem angegebenen Wert hinzu.</summary>
        <returns>Der neue <see cref="T:System.Collections.Generic.LinkedListNode`1" /> mit dem <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> befindet sich nicht in der aktuellen <see cref="T:System.Collections.Generic.LinkedList`1" />.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBefore">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt vor einem vorhandenen Knoten in der <see cref="T:System.Collections.Generic.LinkedList`1" /> einen neuen Knoten oder Wert hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBefore">
      <MemberSignature Language="C#" Value="public void AddBefore (System.Collections.Generic.LinkedListNode&lt;T&gt; node, System.Collections.Generic.LinkedListNode&lt;T&gt; newNode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBefore(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node, class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; newNode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddBefore(System.Collections.Generic.LinkedListNode{`0},System.Collections.Generic.LinkedListNode{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBefore (node As LinkedListNode(Of T), newNode As LinkedListNode(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBefore(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node, System::Collections::Generic::LinkedListNode&lt;T&gt; ^ newNode);" />
      <MemberSignature Language="F#" Value="member this.AddBefore : System.Collections.Generic.LinkedListNode&lt;'T&gt; * System.Collections.Generic.LinkedListNode&lt;'T&gt; -&gt; unit" Usage="linkedList.AddBefore (node, newNode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
        <Parameter Name="newNode" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Collections.Generic.LinkedListNode`1" />, vor dem der <paramref name="newNode" /> eingefügt werden soll.</param>
        <param name="newNode">Der neue <see cref="T:System.Collections.Generic.LinkedListNode`1" />, der der <see cref="T:System.Collections.Generic.LinkedList`1" /> hinzugefügt werden soll.</param>
        <summary>Fügt den angegebenen neuen Knoten vor dem angegebenen vorhandenen Knoten in der <see cref="T:System.Collections.Generic.LinkedList`1" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="newNode" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> befindet sich nicht in der aktuellen <see cref="T:System.Collections.Generic.LinkedList`1" />.  
  
- oder -  
 <paramref name="newNode" /> gehört zu einer anderen <see cref="T:System.Collections.Generic.LinkedList`1" />.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
      </Docs>
    </Member>
    <Member MemberName="AddBefore">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; AddBefore (System.Collections.Generic.LinkedListNode&lt;T&gt; node, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; AddBefore(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node, !T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddBefore(System.Collections.Generic.LinkedListNode{`0},`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddBefore (node As LinkedListNode(Of T), value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ AddBefore(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node, T value);" />
      <MemberSignature Language="F#" Value="member this.AddBefore : System.Collections.Generic.LinkedListNode&lt;'T&gt; * 'T -&gt; System.Collections.Generic.LinkedListNode&lt;'T&gt;" Usage="linkedList.AddBefore (node, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Collections.Generic.LinkedListNode`1" />, vor dem ein neuer <see cref="T:System.Collections.Generic.LinkedListNode`1" /> mit dem <paramref name="value" /> eingefügt werden soll.</param>
        <param name="value">Der der <see cref="T:System.Collections.Generic.LinkedList`1" /> hinzuzufügende Wert.</param>
        <summary>Fügt vor dem angegebenen vorhandenen Knoten in der <see cref="T:System.Collections.Generic.LinkedList`1" /> einen neuen Knoten mit dem angegebenen Wert hinzu.</summary>
        <returns>Der neue <see cref="T:System.Collections.Generic.LinkedListNode`1" /> mit dem <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> befindet sich nicht in der aktuellen <see cref="T:System.Collections.Generic.LinkedList`1" />.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFirst">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt am Anfang der <see cref="T:System.Collections.Generic.LinkedList`1" /> einen neuen Knoten oder Wert hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFirst">
      <MemberSignature Language="C#" Value="public void AddFirst (System.Collections.Generic.LinkedListNode&lt;T&gt; node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFirst(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddFirst(System.Collections.Generic.LinkedListNode{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFirst (node As LinkedListNode(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFirst(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node);" />
      <MemberSignature Language="F#" Value="member this.AddFirst : System.Collections.Generic.LinkedListNode&lt;'T&gt; -&gt; unit" Usage="linkedList.AddFirst node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="node">Der neue <see cref="T:System.Collections.Generic.LinkedListNode`1" />, der am Anfang der <see cref="T:System.Collections.Generic.LinkedList`1" /> hinzugefügt werden soll.</param>
        <summary>Fügt am Anfang der <see cref="T:System.Collections.Generic.LinkedList`1" /> den angegebenen neuen Knoten hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Wenn die <xref:System.Collections.Generic.LinkedList%601> ist leer, der neue Knoten wird die <xref:System.Collections.Generic.LinkedList%601.First%2A> und die <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> gehört zu einer anderen <see cref="T:System.Collections.Generic.LinkedList`1" />.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="AddFirst">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; AddFirst (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; AddFirst(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddFirst(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddFirst (value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ AddFirst(T value);" />
      <MemberSignature Language="F#" Value="member this.AddFirst : 'T -&gt; System.Collections.Generic.LinkedListNode&lt;'T&gt;" Usage="linkedList.AddFirst value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der am Anfang der <see cref="T:System.Collections.Generic.LinkedList`1" /> hinzugefügt werden soll.</param>
        <summary>Fügt am Anfang der <see cref="T:System.Collections.Generic.LinkedList`1" /> einen neuen Knoten mit dem angegebenen Wert hinzu.</summary>
        <returns>Der neue <see cref="T:System.Collections.Generic.LinkedListNode`1" /> mit dem <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Wenn die <xref:System.Collections.Generic.LinkedList%601> ist leer, der neue Knoten wird die <xref:System.Collections.Generic.LinkedList%601.First%2A> und die <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLast">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt am Ende der <see cref="T:System.Collections.Generic.LinkedList`1" /> einen neuen Knoten oder Wert hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLast">
      <MemberSignature Language="C#" Value="public void AddLast (System.Collections.Generic.LinkedListNode&lt;T&gt; node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLast(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddLast(System.Collections.Generic.LinkedListNode{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLast (node As LinkedListNode(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLast(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node);" />
      <MemberSignature Language="F#" Value="member this.AddLast : System.Collections.Generic.LinkedListNode&lt;'T&gt; -&gt; unit" Usage="linkedList.AddLast node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="node">Der neue <see cref="T:System.Collections.Generic.LinkedListNode`1" />, der am Ende der <see cref="T:System.Collections.Generic.LinkedList`1" /> hinzugefügt werden soll.</param>
        <summary>Fügt am Ende der <see cref="T:System.Collections.Generic.LinkedList`1" /> den angegebenen neuen Knoten hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Wenn die <xref:System.Collections.Generic.LinkedList%601> ist leer, der neue Knoten wird die <xref:System.Collections.Generic.LinkedList%601.First%2A> und die <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> gehört zu einer anderen <see cref="T:System.Collections.Generic.LinkedList`1" />.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
      </Docs>
    </Member>
    <Member MemberName="AddLast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; AddLast (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; AddLast(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.AddLast(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddLast (value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ AddLast(T value);" />
      <MemberSignature Language="F#" Value="member this.AddLast : 'T -&gt; System.Collections.Generic.LinkedListNode&lt;'T&gt;" Usage="linkedList.AddLast value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der am Ende der <see cref="T:System.Collections.Generic.LinkedList`1" /> hinzugefügt werden soll.</param>
        <summary>Fügt am Ende der <see cref="T:System.Collections.Generic.LinkedList`1" /> einen neuen Knoten mit dem angegebenen Wert hinzu.</summary>
        <returns>Der neue <see cref="T:System.Collections.Generic.LinkedListNode`1" /> mit dem <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Wenn die <xref:System.Collections.Generic.LinkedList%601> ist leer, der neue Knoten wird die <xref:System.Collections.Generic.LinkedList%601.First%2A> und die <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="linkedList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Knoten aus der <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601.Count%2A> wird auf NULL festgelegt, und Verweise auf andere Objekte von Elementen in der Auflistung werden ebenfalls freigegeben.  <xref:System.Collections.Generic.LinkedList%601.First%2A> und <xref:System.Collections.Generic.LinkedList%601.Last%2A> festgelegt `null`.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T value);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="linkedList.Contains value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Der im <see cref="T:System.Collections.Generic.LinkedList`1" /> zu suchende Wert. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Bestimmt, ob sich ein Wert in der <see cref="T:System.Collections.Generic.LinkedList`1" /> befindet.</summary>
        <returns>
          <see langword="true" />, wenn das <paramref name="value" /> in der <see cref="T:System.Collections.Generic.LinkedList`1" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Find(`0)" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.FindLast(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="linkedList.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.LinkedList`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die gesamte <see cref="T:System.Collections.Generic.LinkedList`1" />-Instanz in ein kompatibles eindimensionales <see cref="T:System.Array" />, beginnend am angegebenen Index des Zielarrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente kopiert werden, auf die <xref:System.Array> in der gleichen Reihenfolge, in dem sich der Enumerator durchläuft, die <xref:System.Collections.Generic.LinkedList%601>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.LinkedList`1" /> ist größer als der verfügbare Platz vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.LinkedList&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Knoten ab, die tatsächlich in der <see cref="T:System.Collections.Generic.LinkedList`1" /> enthalten sind.</summary>
        <value>Die Anzahl der Knoten, die tatsächlich in der <see cref="T:System.Collections.Generic.LinkedList`1" /> enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel, das diese Eigenschaft enthält, finden Sie die <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; Find (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; Find(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.Find(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ Find(T value);" />
      <MemberSignature Language="F#" Value="member this.Find : 'T -&gt; System.Collections.Generic.LinkedListNode&lt;'T&gt;" Usage="linkedList.Find value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Der im <see cref="T:System.Collections.Generic.LinkedList`1" /> zu suchende Wert.</param>
        <summary>Sucht den ersten Knoten, der den angegebenen Wert enthält.</summary>
        <returns>Der erste <see cref="T:System.Collections.Generic.LinkedListNode`1" />, der den angegebenen Wert enthält, sofern er gefunden wird, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.LinkedList%601> Rollforward ab durchsucht <xref:System.Collections.Generic.LinkedList%601.First%2A> und endet um <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.FindLast(`0)" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; FindLast (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; FindLast(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.FindLast(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (value As T) As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedListNode&lt;T&gt; ^ FindLast(T value);" />
      <MemberSignature Language="F#" Value="member this.FindLast : 'T -&gt; System.Collections.Generic.LinkedListNode&lt;'T&gt;" Usage="linkedList.FindLast value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Der im <see cref="T:System.Collections.Generic.LinkedList`1" /> zu suchende Wert.</param>
        <summary>Sucht den letzten Knoten, der den angegebenen Wert enthält.</summary>
        <returns>Der letzte <see cref="T:System.Collections.Generic.LinkedListNode`1" />, der den angegebenen Wert enthält, sofern er gefunden wird, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.LinkedList%601> wird rückwärts gesuchten beginnt am <xref:System.Collections.Generic.LinkedList%601.Last%2A> und endet um <xref:System.Collections.Generic.LinkedList%601.First%2A>.  
  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Find(`0)" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="First">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; First { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; First" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.First" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property First As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::LinkedListNode&lt;T&gt; ^ First { System::Collections::Generic::LinkedListNode&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.First : System.Collections.Generic.LinkedListNode&lt;'T&gt;" Usage="System.Collections.Generic.LinkedList&lt;'T&gt;.First" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den ersten Knoten der <see cref="T:System.Collections.Generic.LinkedList`1" /> ab.</summary>
        <value>Der erste <see cref="T:System.Collections.Generic.LinkedListNode`1" /> der <see cref="T:System.Collections.Generic.LinkedList`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Wenn die <xref:System.Collections.Generic.LinkedList%601> leer ist, die <xref:System.Collections.Generic.LinkedList%601.First%2A> und <xref:System.Collections.Generic.LinkedList%601.Last%2A> Eigenschaften enthalten `null`.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel, das diese Eigenschaft enthält, finden Sie die <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedList&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.LinkedList`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As LinkedList(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::LinkedList&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.LinkedList&lt;'T&gt;.Enumerator" Usage="linkedList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedList&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die <see cref="T:System.Collections.Generic.LinkedList`1" /> durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.LinkedList`1.Enumerator" /> für das <see cref="T:System.Collections.Generic.LinkedList`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der c#-Sprache (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> legt <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.LinkedList%601.Enumerator.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn der Auflistung, z. B. das Hinzufügen Änderungen, ändern oder Löschen von Elementen, wenn der Enumerator unwiederbringlich ist ungültig, und der nächste Aufruf von <xref:System.Collections.Generic.LinkedList%601.Enumerator.MoveNext%2A> oder <xref:System.Collections.Generic.LinkedList%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.LinkedList`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="linkedList.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren der <see cref="T:System.Collections.Generic.LinkedList`1" />-Instanz erforderlichen Informationen.</param>
        <param name="context">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt, das die Quelle und das Ziel des serialisierten Streams enthält, der der neuen <see cref="T:System.Collections.Generic.LinkedList`1" />-Instanz zugeordnet ist.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und gibt die zum Serialisieren der <see cref="T:System.Collections.Generic.LinkedList`1" />-Instanz erforderlichen Daten zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Serialisierungsdiensten. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Last">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.LinkedListNode&lt;T&gt; Last { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; Last" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.Last" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Last As LinkedListNode(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::LinkedListNode&lt;T&gt; ^ Last { System::Collections::Generic::LinkedListNode&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Last : System.Collections.Generic.LinkedListNode&lt;'T&gt;" Usage="System.Collections.Generic.LinkedList&lt;'T&gt;.Last" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.LinkedListNode&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den letzten Knoten der <see cref="T:System.Collections.Generic.LinkedList`1" /> ab.</summary>
        <value>Der letzte <see cref="T:System.Collections.Generic.LinkedListNode`1" /> der <see cref="T:System.Collections.Generic.LinkedList`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Wenn die <xref:System.Collections.Generic.LinkedList%601> leer ist, die <xref:System.Collections.Generic.LinkedList%601.First%2A> und <xref:System.Collections.Generic.LinkedList%601.Last%2A> Eigenschaften enthalten `null`.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel, das diese Eigenschaft enthält, finden Sie die <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="linkedList.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Die Quelle des Deserialisierungsereignisses.</param>
        <summary>Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und löst das Deserialisierungsereignis aus, sobald die Deserialisierung abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Das der aktuellen <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Instanz zugeordnete <see cref="T:System.Collections.Generic.LinkedList`1" />-Objekt ist ungültig.</exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt das erste Vorkommen eines Knotens oder Werts aus der <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Collections.Generic.LinkedListNode&lt;T&gt; node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Collections.Generic.LinkedListNode`1&lt;!T&gt; node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.Remove(System.Collections.Generic.LinkedListNode{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (node As LinkedListNode(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Collections::Generic::LinkedListNode&lt;T&gt; ^ node);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Collections.Generic.LinkedListNode&lt;'T&gt; -&gt; unit" Usage="linkedList.Remove node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Collections.Generic.LinkedListNode&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Collections.Generic.LinkedListNode`1" />, der aus der <see cref="T:System.Collections.Generic.LinkedList`1" /> entfernt werden soll.</param>
        <summary>Entfernt den angegebenen Knoten aus der <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="node" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="node" /> befindet sich nicht in der aktuellen <see cref="T:System.Collections.Generic.LinkedList`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Clear" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T value);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="linkedList.Remove value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Die Wert, der aus der <see cref="T:System.Collections.Generic.LinkedList`1" /> entfernt werden soll.</param>
        <summary>Entfernt das erste Vorkommen des angegebenen Werts aus der <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <returns>
          <see langword="true" />, wenn das Element, das den <paramref name="value" /> enthält, erfolgreich entfernt wurde, andernfalls <see langword="false" />.  Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="value" /> nicht im ursprünglichen <see cref="T:System.Collections.Generic.LinkedList`1" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode führt eine lineare Suche. Diese Methode ist daher eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Clear" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddBefore" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddAfter" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
      </Docs>
    </Member>
    <Member MemberName="RemoveFirst">
      <MemberSignature Language="C#" Value="public void RemoveFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFirst ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFirst();" />
      <MemberSignature Language="F#" Value="member this.RemoveFirst : unit -&gt; unit" Usage="linkedList.RemoveFirst " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt den Knoten am Anfang der <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Generic.LinkedList`1" /> ist leer.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Clear" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddFirst" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLast">
      <MemberSignature Language="C#" Value="public void RemoveLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.RemoveLast" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveLast ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveLast();" />
      <MemberSignature Language="F#" Value="member this.RemoveLast : unit -&gt; unit" Usage="linkedList.RemoveLast " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt den Knoten am Ende der <see cref="T:System.Collections.Generic.LinkedList`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Generic.LinkedList`1" /> ist leer.</exception>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.Remove" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.RemoveFirst" />
        <altmember cref="M:System.Collections.Generic.LinkedList`1.Clear" />
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (value As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T value) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der am Ende der <see cref="T:System.Collections.Generic.ICollection`1" /> hinzugefügt werden soll.</param>
        <summary>Fügt am Ende der <see cref="T:System.Collections.Generic.ICollection`1" /> ein Element hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.LinkedList%601> akzeptiert `null` als gültiger <xref:System.Collections.Generic.LinkedListNode%601.Value%2A> für Referenztypen und doppelte Werte lässt.  
  
 Wenn die <xref:System.Collections.Generic.LinkedList%601> ist leer, der neue Knoten wird die <xref:System.Collections.Generic.LinkedList%601.First%2A> und die <xref:System.Collections.Generic.LinkedList%601.Last%2A>.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Ein Beispiel für die diese Methode enthält, finden Sie unter den <xref:System.Collections.Generic.LinkedList%601> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Collections.Generic.LinkedList`1.AddLast" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist.</summary>
        <value>
          <see langword="true" />, wenn das <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.LinkedList`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der verhindert, dass die Auflistung zu ändern; Wenn die zugrunde liegende Auflistung Änderungen vorgenommen werden, spiegelt die schreibgeschützte Auflistung aus diesem Grund diese Änderungen wider.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerator`1" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der c#-Sprache (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.Generic.IEnumerator%601.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.Generic.IEnumerator%601.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn der Auflistung, z. B. das Hinzufügen Änderungen, ändern oder Löschen von Elementen, wenn der Enumerator unwiederbringlich ist ungültig, und der nächste Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.ICollection" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.ICollection" /> in ein <see cref="T:System.Array" />, beginnend bei einem bestimmten <see cref="T:System.Array" />-Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ der Quelle <xref:System.Collections.ICollection> kann nicht automatisch in den Typ des Ziels umgewandelt werden `array`, die nicht generische Implementierungen der <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> auslösen <xref:System.InvalidCastException>, während die Implementierungen die generischen auslösen <xref:System.ArgumentException>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.LinkedList%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ist mehrdimensional.  
  
- oder -  
 <paramref name="array" /> verwendet keine nullbasierte Indizierung.  
  
- oder -  
Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.ICollection" /> ist größer als der verfügbare Platz vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.  
  
- oder -  
Der Typ der Quell-<see cref="T:System.Collections.ICollection" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value>
          <see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.LinkedList`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt zu sperren, bevor Sie den Zugriff auf die Auflistung.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.LinkedList`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.  In der Standardimplementierung der <see cref="T:System.Collections.Generic.LinkedList`1" /> gibt diese Eigenschaft immer die aktuelle Instanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt zu sperren, bevor Sie den Zugriff auf die Auflistung. Der folgende Code zeigt die Verwendung der <xref:System.Collections.ICollection.SyncRoot%2A> -Eigenschaft für c#, C++ und Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.LinkedList`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die verknüpfte Liste als Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der die verknüpfte Liste als Auflistung durchlaufen kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach` -Anweisung der c#-Sprache (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn der Auflistung, z. B. das Hinzufügen Änderungen, ändern oder Löschen von Elementen, wenn der Enumerator unwiederbringlich ist ungültig, und der nächste Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> sind nicht synchronisiert.  
  
 Diese Methode ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.LinkedList`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
  </Members>
</Type>