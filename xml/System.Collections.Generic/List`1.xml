<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fea48e6ac3d6a3ec880818cc879f8df6c21d6ff6" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78718320" /></Metadata><TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface IList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IList" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.IList" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::IList" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Collections" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Der Typ der Elemente in der Liste</typeparam>
    <summary>Stellt eine stark typisierte Liste mit Objekten dar, auf die über einen Index zugegriffen werden kann. Stellt Methoden zum Durchsuchen, Sortieren und Bearbeiten von Listen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601>-Klasse ist die generische Entsprechung der <xref:System.Collections.ArrayList>-Klasse. Es implementiert die generische Schnittstelle <xref:System.Collections.Generic.IList%601> mithilfe eines Arrays, dessen Größe je nach Bedarf dynamisch erweitert wird.  
  
 Sie können einer <xref:System.Collections.Generic.List%601> Elemente hinzufügen, indem Sie die <xref:System.Collections.Generic.List%601.Add%2A>-Methode oder die <xref:System.Collections.Generic.List%601.AddRange%2A>-Methode verwenden.  
  
 Die <xref:System.Collections.Generic.List%601>-Klasse verwendet einen Gleichheits Vergleich und einen Reihenfolge Vergleich.  
  
-   Methoden wie <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>und <xref:System.Collections.Generic.Dictionary%602.Remove%2A> verwenden einen Gleichheits Vergleich für die Listenelemente. Der Standard Gleichheits Vergleich für den Typ `T` wird wie folgt bestimmt. Wenn Type `T` die <xref:System.IEquatable%601> generische Schnittstelle implementiert, dann ist der Gleichheits Vergleich die <xref:System.IEquatable%601.Equals%28%600%29>-Methode dieser Schnittstelle. Andernfalls ist der Standard Gleichheits Vergleich <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   Methoden wie <xref:System.Collections.Generic.List%601.BinarySearch%2A> und <xref:System.Collections.Generic.List%601.Sort%2A> verwenden einen Reihenfolge Vergleich für die Listenelemente. Der Standardcomparer für den `T` Typ wird wie folgt bestimmt.  Wenn Type `T` die <xref:System.IComparable%601> generische Schnittstelle implementiert, dann ist der Standardcomparer die <xref:System.IComparable%601.CompareTo%28%600%29>-Methode dieser Schnittstelle. Andernfalls ist der Standardcomparer die <xref:System.IComparable.CompareTo%28System.Object%29>-Methode der Schnittstelle, wenn der Typ `T` die nicht generische <xref:System.IComparable> Schnittstelle implementiert. Wenn Type `T` keine Schnittstelle implementiert, gibt es keinen Standardcomparer, und ein Vergleichs-oder Vergleichs Delegat muss explizit bereitgestellt werden.  
  
 Es ist nicht garantiert, dass die <xref:System.Collections.Generic.List%601> sortiert wird.  Sie müssen die <xref:System.Collections.Generic.List%601> sortieren, bevor Sie Vorgänge ausführen (z. b. <xref:System.Collections.Generic.List%601.BinarySearch%2A>), für die die <xref:System.Collections.Generic.List%601> sortiert werden muss.  
  
 Auf Elemente in dieser Auflistung kann mit einem ganzzahligen Index zugegriffen werden.  Indizes in dieser Sammlung sind NULL basiert.  
  
 **Nur .NET Framework:** Bei sehr großen <xref:System.Collections.Generic.List%601> Objekten können Sie die maximale Kapazität auf 2 Milliarden Elemente in einem 64-Bit-System erhöhen, indem Sie das `enabled`-Attribut des [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) Configuration-Elements auf `true` in der Laufzeitumgebung festlegen.  
  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
 Eine unveränderliche Version der <xref:System.Collections.Generic.List%601>-Klasse finden Sie unter <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Wenn Sie entscheiden, ob Sie die <xref:System.Collections.Generic.List%601> oder <xref:System.Collections.ArrayList> Klasse verwenden möchten, die beide über eine ähnliche Funktionalität verfügen, denken Sie daran, dass die <xref:System.Collections.Generic.List%601> Klasse in den meisten Fällen besser funktioniert und typsicher ist. Wenn ein Verweistyp für den Typ `T` der <xref:System.Collections.Generic.List%601>-Klasse verwendet wird, ist das Verhalten der beiden Klassen identisch. Wenn jedoch ein Werttyp für den `T`Typ verwendet wird, müssen Sie Implementierungs-und boxingprobleme in Erwägung gezogen.  
  
 Wenn ein Werttyp für den `T`Typ verwendet wird, generiert der Compiler eine Implementierung der <xref:System.Collections.Generic.List%601> Klasse speziell für diesen Werttyp. Dies bedeutet, dass ein Listenelement eines <xref:System.Collections.Generic.List%601> Objekts nicht gekapselt werden muss, bevor das-Element verwendet werden kann. nach dem Erstellen von ungefähr 500 List-Elementen ist der Arbeitsspeicher, der nicht Boxing-Listenelemente speichert, größer als der Arbeitsspeicher, der zum Generieren der Klassen Implementierung verwendet wird.  
  
 Stellen Sie sicher, dass der Werttyp, der für den Typ verwendet wird `T` die <xref:System.IEquatable%601> generische Schnittstelle Wenn dies nicht der Wert ist, müssen Methoden wie <xref:System.Collections.Generic.List%601.Contains%2A> die <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>-Methode aufzurufen, die das betroffene Listenelement einstellt. Wenn der Werttyp die <xref:System.IComparable>-Schnittstelle implementiert und Sie der Besitzer des Quellcodes sind, implementieren Sie auch die <xref:System.IComparable%601> generische-Schnittstelle, um zu verhindern, dass die <xref:System.Collections.Generic.List%601.BinarySearch%2A>-und <xref:System.Collections.Generic.List%601.Sort%2A>-Methoden aus Boxing Wenn Sie nicht der Besitzer des Quellcodes sind, übergeben Sie ein <xref:System.Collections.Generic.IComparer%601> Objekt an die Methoden <xref:System.Collections.Generic.List%601.BinarySearch%2A> und <xref:System.Collections.Generic.List%601.Sort%2A>.  
  
 Es ist von Vorteil, die typspezifische Implementierung der <xref:System.Collections.Generic.List%601>-Klasse zu verwenden, anstatt die <xref:System.Collections.ArrayList>-Klasse zu verwenden oder eine stark typisierte Wrapper Auflistung selbst zu schreiben. Der Grund hierfür ist, dass Ihre Implementierung bereits Aktionen ausführen muss, die das .NET Framework bereits durchführt, und die Common Language Runtime können den Microsoft Intermediate Language-Code und die Metadaten gemeinsam nutzen, die ihre Implementierung nicht unterstützt.  
  
## <a name="f-considerations"></a>F#Überlegungen  
 Die <xref:System.Collections.Generic.List%601>-Klasse wird nur selten im F# Code verwendet. Stattdessen werden in der Regel [Listen](~/docs/fsharp/language-reference/lists.md), die unveränderlich, einzeln verknüpfte Listen sind, bevorzugt. Eine F# Liste stellt eine geordnete, unveränderliche Reihe von Werten bereit und wird für die Verwendung bei der funktionalen Entwicklung unterstützt. Bei Verwendung von F#wird in der Regel von [resizearray\<'t >](https://msdn.microsoft.com/library/ee353447.aspx) typabkürzung auf die <xref:System.Collections.Generic.List%601> Klasse verwiesen, um Namenskonflikte mit F# Listen zu vermeiden.  
  
   
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>hinzugefügt, entfernt und eingefügt wird.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Im folgenden Beispiel werden mehrere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen Klasse des Typs String veranschaulicht. (Ein Beispiel für eine <xref:System.Collections.Generic.List%601> komplexer Typen finden Sie unter der <xref:System.Collections.Generic.List%601.Contains%2A>-Methode.)  
  
 Der Parameter lose Konstruktor wird verwendet, um eine Liste von Zeichen folgen mit der Standardkapazität zu erstellen. Die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft wird angezeigt, und dann wird die <xref:System.Collections.Generic.List%601.Add%2A>-Methode verwendet, um mehrere Elemente hinzuzufügen. Die Elemente werden aufgelistet, und die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft wird wieder zusammen mit der <xref:System.Collections.Generic.List%601.Count%2A>-Eigenschaft angezeigt, um anzuzeigen, dass die Kapazität nach Bedarf erweitert wurde.  
  
 Die <xref:System.Collections.Generic.List%601.Contains%2A>-Methode wird verwendet, um zu testen, ob ein Element in der Liste vorhanden ist, die <xref:System.Collections.Generic.List%601.Insert%2A>-Methode wird verwendet, um ein neues Element in der Mitte der Liste einzufügen, und der Inhalt der Liste wird erneut angezeigt.  
  
 Die Standard <xref:System.Collections.Generic.List%601.Item%2A>-Eigenschaft (der Indexer C#in) wird verwendet, um ein Element abzurufen. die <xref:System.Collections.Generic.List%601.Remove%2A>-Methode wird verwendet, um die erste Instanz des zuvor hinzugefügten doppelten Elements zu entfernen, und der Inhalt wird erneut angezeigt. Die <xref:System.Collections.Generic.List%601.Remove%2A>-Methode entfernt immer die erste Instanz, auf die Sie trifft.  
  
 Die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode wird verwendet, um die Kapazität so zu verringern, dass Sie der Anzahl entspricht, und die Eigenschaften <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> werden angezeigt. Wenn die nicht genutzte Kapazität weniger als 10 Prozent der Gesamtkapazität war, wurde die Größe der Liste nicht geändert.  
  
 Schließlich wird die <xref:System.Collections.Generic.List%601.Clear%2A>-Methode verwendet, um alle Elemente aus der Liste zu entfernen, und die Eigenschaften <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> werden angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Es ist sicher, mehrere Lesevorgänge für eine <see cref="T:System.Collections.Generic.List`1" />auszuführen, aber es können Probleme auftreten, wenn die Auflistung beim Lesen geändert wird. Um die Thread Sicherheit sicherzustellen, Sperren Sie die Sammlung während eines Lese-oder Schreibvorgangs. Damit eine Auflistung von mehreren Threads zum Lesen und schreiben aufgerufen werden kann, müssen Sie eine eigene Synchronisierung implementieren. Informationen zu Auflistungen mit integrierter Synchronisierung finden Sie unter den Klassen im <see cref="N:System.Collections.Concurrent" />-Namespace. Informationen zu einer naturgemäß Thread sicheren Alternative finden Sie in der <see cref="T:System.Collections.Immutable.ImmutableList`1" />-Klasse.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Iteratoren (C# und Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Collections.Generic.List`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die die Standardanfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.List%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.List%601> aufnehmen kann. Wenn Elemente zu einem <xref:System.Collections.Generic.List%601>hinzugefügt werden, wird die Kapazität nach Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, ist es bei der Verwendung des <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29>-Konstruktors und der Angabe der anfänglichen Kapazität nicht mehr erforderlich, beim Hinzufügen von Elementen zum <xref:System.Collections.Generic.List%601>eine Reihe von Größen der Größenänderung auszuführen.  
  
 Die Kapazität kann verringert werden, indem Sie die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode aufrufen oder die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft explizit festlegen. Wenn Sie die Kapazität verringern, wird Arbeitsspeicher neu zugewiesen, und alle Elemente in der <xref:System.Collections.Generic.List%601>werden kopiert.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  

 Das folgende Beispiel veranschaulicht den Parameter losen Konstruktor der <xref:System.Collections.Generic.List%601> generischen-Klasse. Der Parameter lose Konstruktor erstellt eine Liste mit der Standardkapazität, wie in Anzeigen der <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft gezeigt.  
  
 Im Beispiel werden Elemente hinzugefügt, eingefügt und entfernt, und es wird gezeigt, wie sich die Kapazität ändert, wenn diese Methoden verwendet werden.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, deren Elemente in die neue Liste kopiert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die aus der angegebenen Auflistung kopierte Elemente enthält und eine ausreichende Kapazität für die Anzahl der kopierten Elemente aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden in der Reihenfolge, in der Sie vom Enumerator der Auflistung gelesen werden, auf die <xref:System.Collections.Generic.List%601> kopiert.  
  
 Dieser Konstruktor ist ein O (*n*)-Vorgang, wobei *n* die Anzahl der Elemente in `collection`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden der <xref:System.Collections.Generic.List%601.%23ctor%2A>-Konstruktor und verschiedene Methoden der <xref:System.Collections.Generic.List%601>-Klasse veranschaulicht, die auf Bereiche reagieren. Ein Array von Zeichen folgen wird erstellt und an den Konstruktor übergeben, wobei die Liste mit den Elementen des Arrays aufgefüllt wird. Daraufhin wird die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft angezeigt, um anzuzeigen, dass die anfängliche Kapazität genau dem entspricht, was zum Speichern der Eingabeelemente erforderlich ist.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die Anzahl von Elementen, die anfänglich in der neuen Liste gespeichert werden können.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die die angegebene Anfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.List%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.List%601> aufnehmen kann. Wenn Elemente zu einem <xref:System.Collections.Generic.List%601>hinzugefügt werden, wird die Kapazität nach Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Generic.List%601>eine Reihe von Größen der Größenänderung auszuführen.  
  
 Die Kapazität kann verringert werden, indem Sie die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode aufrufen oder die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft explizit festlegen. Wenn Sie die Kapazität verringern, wird Arbeitsspeicher neu zugewiesen, und alle Elemente in der <xref:System.Collections.Generic.List%601>werden kopiert.  
  
 Dieser Konstruktor ist ein O (*n*)-Vorgang, bei dem *n* `capacity`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29>-Konstruktor veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen mit einer Kapazität von 4 wird erstellt, da die endgültige Größe der Liste bekanntermaßen genau 4 ist. Die Liste wird mit vier Zeichen folgen aufgefüllt, und mit der <xref:System.Collections.Generic.List%601.AsReadOnly%2A>-Methode wird eine schreibgeschützte Kopie erstellt.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das Objekt, das am Ende der <see cref="T:System.Collections.Generic.List`1" /> hinzugefügt werden soll. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt ein Objekt am Ende von <see cref="T:System.Collections.Generic.List`1" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> bereits <xref:System.Collections.Generic.List%601.Capacity%2A>entspricht, erhöht sich die Kapazität des <xref:System.Collections.Generic.List%601> durch automatisches Neuzuordnen des internen Arrays, und die vorhandenen Elemente werden in das neue Array kopiert, bevor das neue Element hinzugefügt wird.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> kleiner als <xref:System.Collections.Generic.List%601.Capacity%2A>ist, ist diese Methode ein O (1)-Vorgang. Wenn die Kapazität für das neue Element erweitert werden muss, wird diese Methode zu einem O (*n*)-Vorgang, wobei *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>hinzugefügt, entfernt und eingefügt wird.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Im folgenden Beispiel werden mehrere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.List%601.Add%2A>-Methode. Der Parameter lose Konstruktor wird verwendet, um eine Liste von Zeichen folgen mit einer Kapazität von 0 (null) zu erstellen. Die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft wird angezeigt, und dann wird die <xref:System.Collections.Generic.List%601.Add%2A>-Methode verwendet, um mehrere Elemente hinzuzufügen. Die Elemente werden aufgelistet, und die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft wird wieder zusammen mit der <xref:System.Collections.Generic.List%601.Count%2A>-Eigenschaft angezeigt, um anzuzeigen, dass die Kapazität nach Bedarf erweitert wurde.  
  
 Andere Eigenschaften und Methoden werden verwendet, um Elemente in der Liste zu suchen, einzufügen und zu entfernen und schließlich die Liste zu löschen.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, deren Elemente am Ende der <see cref="T:System.Collections.Generic.List`1" /> hinzugefügt werden sollen. Die Auflistung an sich kann nicht <see langword="null" /> sein, sie kann jedoch Elemente enthalten, die <see langword="null" /> sind, wenn Typ <paramref name="T" /> einen Referenztyp darstellt.</param>
        <summary>Fügt die Elemente der angegebenen Auflistung am Ende von <see cref="T:System.Collections.Generic.List`1" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Elemente in der Auflistung wird im <xref:System.Collections.Generic.List%601>beibehalten.  
  
 Wenn die neue <xref:System.Collections.Generic.List%601.Count%2A> (die aktuelle <xref:System.Collections.Generic.List%601.Count%2A> zuzüglich der Größe der Auflistung) größer als <xref:System.Collections.Generic.List%601.Capacity%2A>ist, wird die Kapazität der <xref:System.Collections.Generic.List%601> erhöht, indem das interne Array automatisch neu zugewiesen wird, um die neuen Elemente zu berücksichtigen, und die vorhandenen Elemente werden in das neue Array kopiert, bevor die neuen Elemente hinzugefügt werden.  
  
 Wenn die <xref:System.Collections.Generic.List%601> die neuen Elemente aufnehmen kann, ohne die <xref:System.Collections.Generic.List%601.Capacity%2A>zu erhöhen, ist diese Methode ein O (*n*)-Vorgang, wobei *n* die Anzahl der hinzu zufügenden Elemente ist. Wenn die Kapazität erhöht werden muss, um die neuen Elemente zu unterstützen, wird diese Methode zu einem O (*n* + *m*)-Vorgang, wobei *n* die Anzahl der hinzu zufügenden Elemente und *m* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.AddRange%2A>-Methode und verschiedene andere Methoden der <xref:System.Collections.Generic.List%601>-Klasse veranschaulicht, die auf Bereiche reagieren. Ein Array von Zeichen folgen wird erstellt und an den Konstruktor übergeben, wobei die Liste mit den Elementen des Arrays aufgefüllt wird. Die <xref:System.Collections.Generic.List%601.AddRange%2A>-Methode wird aufgerufen, wobei die Liste als Argument angezeigt wird. Das Ergebnis ist, dass die aktuellen Elemente der Liste am Ende der Liste hinzugefügt werden, wobei alle Elemente duplizieren.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen schreibgeschützten <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper für die aktuelle Auflistung zurück.</summary>
        <returns>Ein Objekt, das als schreibgeschützter Wrapper des aktuellen <see cref="T:System.Collections.Generic.List`1" />-Objekts fungiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um Änderungen am <xref:System.Collections.Generic.List%601> Objekt zu verhindern, machen Sie es nur über diesen Wrapper verfügbar. Ein <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>-Objekt macht keine Methoden verfügbar, mit denen die Auflistung geändert wird. Wenn jedoch Änderungen am zugrunde liegenden <xref:System.Collections.Generic.List%601> Objekt vorgenommen werden, reflektiert die schreibgeschützte Auflistung diese Änderungen.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.AsReadOnly%2A> Methode. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen mit einer Kapazität von 4 wird erstellt, da die endgültige Größe der Liste bekanntermaßen genau 4 ist. Die Liste wird mit vier Zeichen folgen gefüllt, und die <xref:System.Collections.Generic.List%601.AsReadOnly%2A>-Methode wird verwendet, um eine schreibgeschützte <xref:System.Collections.Generic.IList%601> generische Schnittstellen Implementierung zu erhalten, die die ursprüngliche Liste umschließt.  
  
 Ein Element der ursprünglichen Liste wird mithilfe der <xref:System.Collections.Generic.List%601.Item%2A>-Eigenschaft (Indexer in C#) auf "Coelophysis" festgelegt, und der Inhalt der schreibgeschützten Liste wird erneut angezeigt, um zu veranschaulichen, dass es sich nur um einen Wrapper für die ursprüngliche Liste handelt.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verwendet einen binären Suchalgorithmus für die Suche nach einem bestimmten Element bzw. einen Teil dieses Elements in der sortierten <see cref="T:System.Collections.Generic.List`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Durchsucht mithilfe des Standardcomparers die gesamte sortierte <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet den Standardcomparer-<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> für den Typ `T`, um die Reihenfolge der Listenelemente zu bestimmen. Die <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>-Eigenschaft überprüft, ob der Typ `T` die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Andernfalls <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` die <xref:System.IComparable>-Schnittstelle implementiert.  Wenn Type `T` keine Schnittstelle implementiert, löst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> eine <xref:System.InvalidOperationException>aus.  
  
 Der <xref:System.Collections.Generic.List%601> muss bereits entsprechend der Vergleich-Implementierung sortiert werden. Andernfalls ist das Ergebnis falsch.  
  
 Das Vergleichen von `null` mit einem beliebigen Verweistyp ist zulässig und generiert bei Verwendung der <xref:System.IComparable%601> generischen-Schnittstelle keine Ausnahme. Beim Sortieren wird `null` als kleiner als ein beliebiges anderes Objekt betrachtet.  
  
 Wenn der <xref:System.Collections.Generic.List%601> mehr als ein Element mit dem gleichen Wert enthält, gibt die Methode nur eine der Vorkommen zurück und gibt möglicherweise eine der Vorkommen zurück, nicht notwendigerweise die erste.  
  
 Wenn das <xref:System.Collections.Generic.List%601> den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können die bitweise Komplement Operation (~) auf diese negative Ganzzahl anwenden, um den Index des ersten Elements, das größer als der Suchwert ist, zu erhalten. Wenn Sie den Wert in die <xref:System.Collections.Generic.List%601>einfügen, sollte dieser Index als Einfügemarke zum Beibehalten der Sortierreihenfolge verwendet werden.  
  
 Bei dieser Methode handelt es sich um einen O (log *n*)-Vorgang, wobei *n* die Anzahl der Elemente im Bereich ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Sort>-Methoden Überladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>-Methoden Überladung veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste wird angezeigt, sortiert und erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>-Methoden Überladung wird dann verwendet, um nach zwei Zeichen folgen zu suchen, die nicht in der Liste enthalten sind, und die <xref:System.Collections.Generic.List%601.Insert%2A>-Methode wird verwendet, um Sie einzufügen. Der Rückgabewert der <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>-Methode ist in jedem Fall negativ, da die Zeichen folgen nicht in der Liste enthalten sind. Das bitweise Komplement (der ~-Operator in C# und Visual C++, `Xor`-1 in Visual Basic) dieser negativen Zahl erzeugt den Index des ersten Elements in der Liste, das größer als die Such Zeichenfolge ist, und das Einfügen an dieser Stelle behält die Sortierreihenfolge bei. Die zweite Such Zeichenfolge ist größer als jedes Element in der Liste, sodass sich die Einfügeposition am Ende der Liste befindet.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
Oder 
 <see langword="null" /> zur Verwendung des Standardcomparers <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Durchsucht mithilfe des angegebenen Comparers die gesamte sortierte <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer> Instanz als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` bereitgestellt wird, werden die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung mit dem angegebenen Wert verglichen.  
  
 Wenn `comparer` `null`ist, überprüft der Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, ob der Typ `T` die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Andernfalls <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` die <xref:System.IComparable>-Schnittstelle implementiert.  Wenn Type `T` keine Schnittstelle implementiert, löst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> <xref:System.InvalidOperationException>aus.  
  
 Der <xref:System.Collections.Generic.List%601> muss bereits entsprechend der Vergleich-Implementierung sortiert werden. Andernfalls ist das Ergebnis falsch.  
  
 Das Vergleichen von `null` mit einem beliebigen Verweistyp ist zulässig und generiert bei Verwendung der <xref:System.IComparable%601> generischen-Schnittstelle keine Ausnahme. Beim Sortieren wird `null` als kleiner als ein beliebiges anderes Objekt betrachtet.  
  
 Wenn der <xref:System.Collections.Generic.List%601> mehr als ein Element mit dem gleichen Wert enthält, gibt die Methode nur eine der Vorkommen zurück und gibt möglicherweise eine der Vorkommen zurück, nicht notwendigerweise die erste.  
  
 Wenn das <xref:System.Collections.Generic.List%601> den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können die bitweise Komplement Operation (~) auf diese negative Ganzzahl anwenden, um den Index des ersten Elements, das größer als der Suchwert ist, zu erhalten. Wenn Sie den Wert in die <xref:System.Collections.Generic.List%601>einfügen, sollte dieser Index als Einfügemarke zum Beibehalten der Sortierreihenfolge verwendet werden.  
  
 Bei dieser Methode handelt es sich um einen O (log *n*)-Vorgang, wobei *n* die Anzahl der Elemente im Bereich ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung veranschaulicht.  
  
 Im Beispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen DinoCompare definiert, der den `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` C++in Visual) generischen Schnittstelle implementiert. Der Vergleich funktioniert wie folgt: zuerst werden die Vergleiche auf `null`getestet, und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste wird angezeigt, mit dem alternativen Vergleich sortiert und erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung wird dann verwendet, um nach mehreren Zeichen folgen zu suchen, die nicht in der Liste enthalten sind, wobei der Alternative Vergleich verwendet wird. Die <xref:System.Collections.Generic.List%601.Insert%2A>-Methode wird zum Einfügen der Zeichen folgen verwendet. Diese beiden Methoden befinden sich in der Funktion mit dem Namen `SearchAndInsert`, zusammen mit dem Code, um das bitweise Komplement (der C# ~- C++Operator in und Visual, `Xor`-1 in Visual Basic) der von <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> zurückgegebenen negativen Zahl zu verwenden und Sie als Index für das Einfügen der neuen Zeichenfolge zu verwenden.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu durchsuchenden Bereichs.</param>
        <param name="count">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Durchsucht mithilfe des angegebenen Vergleichs einen Bereich von Elementen in der sortierten <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie eine <xref:System.Collections.CaseInsensitiveComparer> Instanz als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` bereitgestellt wird, werden die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der angegebenen <xref:System.Collections.Generic.IComparer%601> Implementierung mit dem angegebenen Wert verglichen.  
  
 Wenn `comparer` `null`ist, überprüft der Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, ob der Typ `T` die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Andernfalls <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` die <xref:System.IComparable>-Schnittstelle implementiert.  Wenn Type `T` keine Schnittstelle implementiert, löst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> <xref:System.InvalidOperationException>aus.  
  
 Der <xref:System.Collections.Generic.List%601> muss bereits entsprechend der Vergleich-Implementierung sortiert werden. Andernfalls ist das Ergebnis falsch.  
  
 Das Vergleichen von `null` mit einem beliebigen Verweistyp ist zulässig und generiert bei Verwendung der <xref:System.IComparable%601> generischen-Schnittstelle keine Ausnahme. Beim Sortieren wird `null` als kleiner als ein beliebiges anderes Objekt betrachtet.  
  
 Wenn der <xref:System.Collections.Generic.List%601> mehr als ein Element mit dem gleichen Wert enthält, gibt die Methode nur eine der Vorkommen zurück und gibt möglicherweise eine der Vorkommen zurück, nicht notwendigerweise die erste.  
  
 Wenn das <xref:System.Collections.Generic.List%601> den angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können die bitweise Komplement Operation (~) auf diese negative Ganzzahl anwenden, um den Index des ersten Elements, das größer als der Suchwert ist, zu erhalten. Wenn Sie den Wert in die <xref:System.Collections.Generic.List%601>einfügen, sollte dieser Index als Einfügemarke zum Beibehalten der Sortierreihenfolge verwendet werden.  
  
 Bei dieser Methode handelt es sich um einen O (log *n*)-Vorgang, wobei *n* die Anzahl der Elemente im Bereich ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung veranschaulicht.  
  
 Im Beispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen DinoCompare definiert, der den `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` C++in Visual) generischen Schnittstelle implementiert. Der Vergleich funktioniert wie folgt: zuerst werden die Vergleiche auf `null`getestet, und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit den Namen von fünf herbialous-dinosaern und drei karnevaliösen dinosaern aufgefüllt. Innerhalb der beiden Gruppen befinden sich die Namen nicht in einer bestimmten Sortierreihenfolge. Die Liste wird angezeigt, der Bereich der HERBIVORES wird mit dem alternativen Comparer sortiert, und die Liste wird erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung wird dann verwendet, um nur den Bereich von HERBIVORES für "Brachiosaurus" zu durchsuchen. Die Zeichenfolge wurde nicht gefunden, und das bitweise Komplement (der ~- C# Operator in C++und Visual, `Xor`-1 in Visual Basic) der negativen Zahl, die von der <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methode zurückgegeben wird, wird als Index zum Einfügen der neuen Zeichenfolge verwendet.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
Oder 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl der Elemente ab, die die interne Datenstruktur ohne Änderung der Größe aufnehmen kann, oder legt diese Anzahl fest.</summary>
        <value>Die Anzahl der Elemente, die <see cref="T:System.Collections.Generic.List`1" /> enthalten kann, bevor eine Größenanpassung erforderlich ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> ist die Anzahl der Elemente, die der <xref:System.Collections.Generic.List%601> speichern kann, bevor die Größe geändert wird, während <xref:System.Collections.Generic.List%601.Count%2A> die Anzahl der Elemente ist, die sich tatsächlich in der <xref:System.Collections.Generic.List%601>befinden.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> ist immer größer oder gleich <xref:System.Collections.Generic.List%601.Count%2A>. Wenn <xref:System.Collections.Generic.List%601.Count%2A> beim Hinzufügen von Elementen <xref:System.Collections.Generic.List%601.Capacity%2A> überschreitet, wird die Kapazität erhöht, indem das interne Array automatisch neu zugewiesen wird, bevor die alten Elemente kopiert und die neuen Elemente hinzugefügt werden.  
  
 Wenn die Kapazität deutlich größer als die Anzahl ist und Sie den vom <xref:System.Collections.Generic.List%601>genutzten Arbeitsspeicher verringern möchten, können Sie die Kapazität verringern, indem Sie die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode aufrufen oder die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft explizit auf einen niedrigeren Wert festlegen. Wenn der Wert von <xref:System.Collections.Generic.List%601.Capacity%2A> explizit festgelegt wird, wird das interne Array ebenfalls neu zugeordnet, um der angegebenen Kapazität Rechnung zu tragen, und alle Elemente werden kopiert.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O (1)-Vorgang. das Festlegen der-Eigenschaft ist ein O (*n*)-Vorgang, wobei *n* die neue Kapazität ist.  
  
   
   
## Examples  
 
 Im folgenden Beispiel wird veranschaulicht, wie die Kapazität und die Anzahl einer <xref:System.Collections.Generic.List%601> überprüft werden, die ein einfaches Geschäftsobjekt enthält, und es wird veranschaulicht, wie die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode verwendet wird, um zusätzliche Kapazität zu entfernen.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft an mehreren Punkten in der Lebensdauer einer Liste gezeigt. Der Parameter lose Konstruktor wird verwendet, um eine Liste von Zeichen folgen mit einer Kapazität von 0 (null) zu erstellen, und die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft wird angezeigt, um dies zu veranschaulichen. Nachdem die <xref:System.Collections.Generic.List%601.Add%2A>-Methode zum Hinzufügen mehrerer Elemente verwendet wurde, werden die Elemente aufgelistet, und dann wird die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft zusammen mit der <xref:System.Collections.Generic.List%601.Count%2A>-Eigenschaft erneut angezeigt, um anzuzeigen, dass die Kapazität nach Bedarf erweitert wurde.  
  
 Die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft wird erneut angezeigt, nachdem die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode verwendet wurde, um die Kapazität auf die Anzahl abzugleichen. Schließlich wird die <xref:System.Collections.Generic.List%601.Clear%2A>-Methode verwendet, um alle Elemente aus der Liste zu entfernen, und die Eigenschaften <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> werden erneut angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.Generic.List`1.Capacity" /> ist auf einen Wert festgelegt, der kleiner als <see cref="P:System.Collections.Generic.List`1.Count" /> ist.</exception>
        <exception cref="T:System.OutOfMemoryException">Im System ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> ist auf 0 festgelegt, und Verweise auf andere Objekte von Elementen der Auflistung werden ebenfalls freigegeben.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> bleibt unverändert. Um die Kapazität des <xref:System.Collections.Generic.List%601>zurückzusetzen, müssen Sie die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode aufzurufen oder die <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft direkt festlegen. Wenn Sie die Kapazität verringern, wird Arbeitsspeicher neu zugewiesen, und alle Elemente in der <xref:System.Collections.Generic.List%601>werden kopiert. Wenn Sie ein leeres <xref:System.Collections.Generic.List%601> kürzen, wird die Kapazität des <xref:System.Collections.Generic.List%601> auf die Standardkapazität festgelegt.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  

 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Clear%2A>-Methode und verschiedene andere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen Klasse veranschaulicht. Die <xref:System.Collections.Generic.List%601.Clear%2A>-Methode wird am Ende des Programms verwendet, um alle Elemente aus der Liste zu entfernen, und die Eigenschaften <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> werden dann angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das in <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Bestimmt, ob sich ein Element in <see cref="T:System.Collections.Generic.List`1" /> befindet.</summary>
        <returns><see langword="true" />, wenn das <paramref name="item" /> in der <see cref="T:System.Collections.Generic.List`1" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt Gleichheit mithilfe des Standard Gleichheits Vergleichs, wie durch die-Implementierung <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> des-Objekts für `T` definiert (der Typ der Werte in der Liste).  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Methoden <xref:System.Collections.Generic.List%601.Contains%2A> und <xref:System.Collections.Generic.List%601.Exists%2A> auf einem <xref:System.Collections.Generic.List%601> veranschaulicht, das ein einfaches Geschäftsobjekt enthält, das <xref:System.IEquatable%601.Equals%2A>implementiert.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Das folgende Beispiel enthält eine Liste komplexer Objekte des Typs `Cube`. Die `Cube`-Klasse implementiert die <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType>-Methode, sodass zwei Cubes als gleich betrachtet werden, wenn ihre Dimensionen gleich sind. In diesem Beispiel gibt die <xref:System.Collections.Generic.List%601.Contains%2A>-Methode `true`zurück, weil ein Cube mit den angegebenen Dimensionen bereits in der Auflistung vorhanden ist.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Der Typ der Elemente des Zielarrays.</typeparam>
        <param name="converter">Ein <see cref="T:System.Converter`2" />-Delegat, der jedes Element von einem Typ in einen anderen Typ konvertiert.</param>
        <summary>Konvertiert die Elemente in der aktuellen <see cref="T:System.Collections.Generic.List`1" /> in einen anderen Typ und gibt eine Liste der konvertierten Elemente zurück.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.List`1" /> des Zieltyps, die die konvertierten Elemente aus der aktuellen <see cref="T:System.Collections.Generic.List`1" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Converter%602> ist ein Delegat einer Methode, die ein Objekt in den Zieltyp konvertiert.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Converter%602> Delegaten und die konvertierten Elemente in der neuen <xref:System.Collections.Generic.List%601>gespeichert.  
  
 Der aktuelle <xref:System.Collections.Generic.List%601> bleibt unverändert.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Methode mit dem Namen `PointFToPoint` definiert, die eine <xref:System.Drawing.PointF>-Struktur in eine <xref:System.Drawing.Point> Struktur konvertiert. Im Beispiel wird dann eine <xref:System.Collections.Generic.List%601> <xref:System.Drawing.PointF> Strukturen erstellt, ein `Converter\<PointF, Point>` Delegat (`Converter(Of PointF, Point)` in Visual Basic) erstellt, um die `PointFToPoint`-Methode darzustellen, und der-Delegat wird an die <xref:System.Collections.Generic.List%601.ConvertAll%2A>-Methode weitergeleitet. Die <xref:System.Collections.Generic.List%601.ConvertAll%2A>-Methode übergibt jedes Element der Eingabeliste an die `PointFToPoint`-Methode und fügt die konvertierten Elemente in eine neue Liste von <xref:System.Drawing.Point> Strukturen ein. Beide Listen werden angezeigt.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="converter" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert <see cref="T:System.Collections.Generic.List`1" /> oder einen Teil davon in ein Array.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente darstellt. Das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung aufweisen.</param>
        <summary>Kopiert die gesamte <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, wobei am Anfang des Zielarrays begonnen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType>, um die Elemente zu kopieren.  
  
 Die Elemente werden in der gleichen Reihenfolge in die <xref:System.Array> kopiert, in der der Enumerator die <xref:System.Collections.Generic.List%601>durchläuft.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der <xref:System.Collections.Generic.List%601.CopyTo%2A>-Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit 5 Zeichen folgen aufgefüllt. Ein leeres Zeichen folgen Array mit 15 Elementen wird erstellt, und die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29>-Methoden Überladung wird verwendet, um alle Elemente der Liste in das Array zu kopieren, beginnend beim ersten Element des Arrays. Die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um alle Elemente der Liste in das Array zu kopieren, beginnend am Array Index 6 (wobei Index 5 leer bleibt). Schließlich wird die <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um 3 Elemente aus der Liste, beginnend mit Index 2, in das Array zu kopieren, beginnend am Array Index 12 (wobei Index 11 leer bleibt). Daraufhin wird der Inhalt des Arrays angezeigt.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als die Anzahl von Elementen, die das Ziel-<paramref name="array" /> enthalten kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente darstellt. Das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung aufweisen.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die gesamte <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, beginnend am angegebenen Index des Zielarrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType>, um die Elemente zu kopieren.  
  
 Die Elemente werden in der gleichen Reihenfolge in die <xref:System.Array> kopiert, in der der Enumerator die <xref:System.Collections.Generic.List%601>durchläuft.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der <xref:System.Collections.Generic.List%601.CopyTo%2A>-Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit 5 Zeichen folgen aufgefüllt. Ein leeres Zeichen folgen Array mit 15 Elementen wird erstellt, und die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29>-Methoden Überladung wird verwendet, um alle Elemente der Liste in das Array zu kopieren, beginnend beim ersten Element des Arrays. Die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um alle Elemente der Liste in das Array zu kopieren, beginnend am Array Index 6 (wobei Index 5 leer bleibt). Schließlich wird die <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um 3 Elemente aus der Liste, beginnend mit Index 2, in das Array zu kopieren, beginnend am Array Index 12 (wobei Index 11 leer bleibt). Daraufhin wird der Inhalt des Arrays angezeigt.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index in der Quell-<see cref="T:System.Collections.Generic.List`1" />, ab dem mit dem Kopieren begonnen wird.</param>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente darstellt. Das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung aufweisen.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <param name="count">Die Anzahl der zu kopierenden Elemente.</param>
        <summary>Kopiert einen Bereich von Elementen aus der <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, beginnend ab dem angegebenen Index im Zielarray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType>, um die Elemente zu kopieren.  
  
 Die Elemente werden in der gleichen Reihenfolge in die <xref:System.Array> kopiert, in der der Enumerator die <xref:System.Collections.Generic.List%601>durchläuft.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* `count`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der <xref:System.Collections.Generic.List%601.CopyTo%2A>-Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit 5 Zeichen folgen aufgefüllt. Ein leeres Zeichen folgen Array mit 15 Elementen wird erstellt, und die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29>-Methoden Überladung wird verwendet, um alle Elemente der Liste in das Array zu kopieren, beginnend beim ersten Element des Arrays. Die <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um alle Elemente der Liste in das Array zu kopieren, beginnend am Array Index 6 (wobei Index 5 leer bleibt). Schließlich wird die <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um 3 Elemente aus der Liste, beginnend mit Index 2, in das Array zu kopieren, beginnend am Array Index 12 (wobei Index 11 leer bleibt). Daraufhin wird der Inhalt des Arrays angezeigt.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
Oder 
 <paramref name="arrayIndex" /> ist kleiner als 0.  
  
Oder 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> ist gleich oder größer als die <see cref="P:System.Collections.Generic.List`1.Count" /> der Quell-<see cref="T:System.Collections.Generic.List`1" />.  
  
Oder 
Die Anzahl der Elemente vom <paramref name="index" /> bis zum Ende der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Collections.Generic.List`1" /> enthalten sind.</summary>
        <value>Die Anzahl der in <see cref="T:System.Collections.Generic.List`1" /> enthaltenen Elemente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> ist die Anzahl der Elemente, die der <xref:System.Collections.Generic.List%601> speichern kann, bevor die Größe geändert werden muss. <xref:System.Collections.Generic.List%601.Count%2A> ist die Anzahl der Elemente, die sich tatsächlich in der <xref:System.Collections.Generic.List%601>befinden.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> ist immer größer oder gleich <xref:System.Collections.Generic.List%601.Count%2A>. Wenn <xref:System.Collections.Generic.List%601.Count%2A> beim Hinzufügen von Elementen <xref:System.Collections.Generic.List%601.Capacity%2A> überschreitet, wird die Kapazität erhöht, indem das interne Array automatisch neu zugewiesen wird, bevor die alten Elemente kopiert und die neuen Elemente hinzugefügt werden.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie die Kapazität und die Anzahl einer <xref:System.Collections.Generic.List%601> überprüft werden, die ein einfaches Geschäftsobjekt enthält, und es wird veranschaulicht, wie die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode verwendet wird, um zusätzliche Kapazität zu entfernen.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Das folgende Beispiel zeigt den Wert der <xref:System.Collections.Generic.List%601.Count%2A>-Eigenschaft an verschiedenen Punkten in der Lebensdauer einer Liste. Nachdem die Liste erstellt und aufgefüllt und die zugehörigen Elemente angezeigt wurden, werden die Eigenschaften <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> angezeigt. Diese Eigenschaften werden erneut angezeigt, nachdem die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode aufgerufen wurde, und auch nachdem der Inhalt der Liste gelöscht wurde.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Bestimmt, ob die <see cref="T:System.Collections.Generic.List`1" /> Elemente enthält, die mit den vom angegebenen Prädikat definierten Bedingungen übereinstimmen.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Collections.Generic.List`1" /> ein oder mehr Elemente enthält, die die durch das angegebene Prädikat definierten Bedingungen erfüllen; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten, und die Verarbeitung wird beendet, wenn eine Entsprechung gefunden wird.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Methoden <xref:System.Collections.Generic.List%601.Contains%2A> und <xref:System.Collections.Generic.List%601.Exists%2A> auf einem <xref:System.Collections.Generic.List%601> veranschaulicht, das ein einfaches Geschäftsobjekt enthält, das <xref:System.IEquatable%601.Equals%2A>implementiert.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Exists%2A>-Methode und verschiedene andere Methoden veranschaulicht, die den <xref:System.Predicate%601> generischen Delegaten verwenden.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, die acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Beispiel definiert auch eine Such Prädikat Methode mit dem Namen `EndsWithSaurus`, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die Methoden <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>und <xref:System.Collections.Generic.List%601.FindAll%2A> werden verwendet, um die Liste mit der Such Prädikat Methode zu durchsuchen, und anschließend wird die <xref:System.Collections.Generic.List%601.RemoveAll%2A>-Methode verwendet, um alle Einträge zu entfernen, die mit "saurus" enden.  
  
 Zum Schluss wird die <xref:System.Collections.Generic.List%601.Exists%2A>-Methode aufgerufen. Sie durchläuft die Liste von Anfang an, wobei jedes Element wiederum an die `EndsWithSaurus`-Methode übergeben wird. Die Suche wird beendet, und die Methode gibt `true` zurück, wenn die `EndsWithSaurus` Methode `true` für ein beliebiges Element zurückgibt. Die <xref:System.Collections.Generic.List%601.Exists%2A>-Methode gibt `false` zurück, da alle diese Elemente entfernt wurden.  
  
> [!NOTE]
>  In C# und Visual Basic muss der `Predicate<string>` Delegat (`Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das erste Vorkommen im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Das erste Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten weitergegeben. dabei wird der <xref:System.Collections.Generic.List%601>fortgeführt, beginnend mit dem ersten Element und endet mit dem letzten Element.  Die Verarbeitung wird beendet, wenn eine Entsprechung gefunden wird.  
  
> [!IMPORTANT]
>  Stellen Sie beim Durchsuchen einer Liste, die Werttypen enthält, sicher, dass der Standardwert für den Typ nicht das Such Prädikat erfüllt. Andernfalls gibt es keine Möglichkeit, zwischen einem Standardwert zu unterscheiden, der angibt, dass keine Entsprechung gefunden wurde, und einem List-Element, das den Standardwert für den Typ hat. Wenn der Standardwert das Such Prädikat erfüllt, verwenden Sie stattdessen die <xref:System.Collections.Generic.List%601.FindIndex%2A>-Methode.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Collections.Generic.List%601.Find%2A>-Methode für ein <xref:System.Collections.Generic.List%601> veranschaulicht, das ein einfaches komplexes Objekt enthält.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb" id="Snippet1":::
  
 Im folgenden Beispiel werden die Find-Methoden für die <xref:System.Collections.Generic.List%601>-Klasse veranschaulicht. Das Beispiel für die <xref:System.Collections.Generic.List%601>-Klasse enthält `book` Objekte der Klasse `Book`unter Verwendung der Daten aus der [XML-Beispieldatei: Books (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList`-Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , um die Werte aus der XML-Datei mit den Eigenschafts Werten der `book`-Objekte zu analysieren.  
  
 In der folgenden Tabelle werden die Beispiele für die Find-Methoden beschrieben.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht ein Buch mit einer ID mithilfe des `IDToFind` Prädikat Delegaten.<br /><br /> C#Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen aller Bücher, deren `Genre`-Eigenschaft "Computer" ist, mithilfe des `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, das über ein Veröffentlichungsdatum vor 2001 ist, unter Verwendung des `PubBefore2001` Prädikat Delegaten.<br /><br /> C#Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs mithilfe des `FindComputer`-Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs mithilfe des `FindComputer`-Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs in der zweiten Hälfte der Sammlung mithilfe des `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs in der zweiten Hälfte der Sammlung mithilfe des `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Ruft alle Elemente ab, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.List`1" /> mit allen Elementen, die ggf. die durch das angegebene Prädikat definierten Bedingungen erfüllen, andernfalls eine leere <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten, und die Elemente, die den Bedingungen entsprechen, werden im zurückgegebenen <xref:System.Collections.Generic.List%601>gespeichert.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Find-Methoden für die <xref:System.Collections.Generic.List%601>-Klasse veranschaulicht. Das Beispiel für die <xref:System.Collections.Generic.List%601>-Klasse enthält `book` Objekte der Klasse `Book`unter Verwendung der Daten aus der [XML-Beispieldatei: Books (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList`-Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , um die Werte aus der XML-Datei mit den Eigenschafts Werten der `book`-Objekte zu analysieren.  
  
 In der folgenden Tabelle werden die Beispiele für die Find-Methoden beschrieben.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht ein Buch mit einer ID mithilfe des `IDToFind` Prädikat Delegaten.<br /><br /> C#Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen aller Bücher, deren `Genre`-Eigenschaft "Computer" ist, mithilfe des `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, das über ein Veröffentlichungsdatum vor 2001 ist, unter Verwendung des `PubBefore2001` Prädikat Delegaten.<br /><br /> C#Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs mithilfe des `FindComputer`-Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs mithilfe des `FindComputer`-Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs in der zweiten Hälfte der Sammlung mithilfe des `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs in der zweiten Hälfte der Sammlung mithilfe des `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch ein angegebenes Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens in der <see cref="T:System.Collections.Generic.List`1" /> oder einem Teil davon zurück. Diese Methode gibt -1 zurück, wenn kein Element gefunden wird, das den Bedingungen entspricht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> wird nach vorne durchsucht, beginnend beim ersten Element und endet beim letzten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten übermittelt. Der Delegat hat die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine `Employee`-Klasse mit zwei Feldern definiert, `Name` und `Id`. Außerdem wird eine `EmployeeSearch`-Klasse mit einer einzelnen Methode definiert, `StartsWith`, die angibt, ob das `Employee.Name` Feld mit einer angegebenen Teil Zeichenfolge beginnt, die an den `EmployeeSearch`-Klassenkonstruktor übergeben wird. Beachten Sie die Signatur dieser Methode.  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 entspricht der Signatur des Delegaten, der an die <xref:System.Collections.Generic.List%601.FindIndex%2A>-Methode übermittelt werden kann. Im Beispiel wird ein `List<Employee>` Objekt instanziiert, eine Reihe von `Employee`-Objekten hinzugefügt und dann die <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>-Methode zweimal aufgerufen, um die gesamte Auflistung zu durchsuchen, das erste Mal für das erste `Employee` Objekt, dessen `Name` Feld mit "J" beginnt, und das zweite Mal für das erste `Employee` Objekt, dessen `Name` Feld mit "Ju" beginnt.  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der vom angegebenen Index bis zum letzten Element reicht.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird nach `startIndex` durchsucht und endet beim letzten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten übermittelt. Der Delegat hat die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* die Anzahl der Elemente von `startIndex` bis zum Ende der <xref:System.Collections.Generic.List%601>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine `Employee`-Klasse mit zwei Feldern definiert, `Name` und `Id`. Außerdem wird eine `EmployeeSearch`-Klasse mit einer einzelnen Methode definiert, `StartsWith`, die angibt, ob das `Employee.Name` Feld mit einer angegebenen Teil Zeichenfolge beginnt, die an den `EmployeeSearch`-Klassenkonstruktor übergeben wird. Beachten Sie die Signatur dieser Methode.  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 entspricht der Signatur des Delegaten, der an die <xref:System.Collections.Generic.List%601.FindIndex%2A>-Methode übermittelt werden kann. Im Beispiel wird ein `List<Employee>` Objekt instanziiert, eine Reihe von `Employee`-Objekten hinzugefügt und dann die <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>-Methode zweimal aufgerufen, um die Auflistung beginnend mit ihrem fünften Member (d. h. dem Element bei Index 4) zu durchsuchen. Beim ersten Mal sucht Sie nach dem ersten `Employee` Objekt, dessen `Name` Feld mit "J" beginnt. beim zweiten Mal sucht der Dienst nach dem ersten `Employee` Objekt, dessen `Name` Feld mit "Ju" beginnt.  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen umfasst.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> wird nach vorne durchsucht, beginnend bei `startIndex` und endet bei `startIndex` Plus `count` minus 1, wenn `count` größer als 0 (null) ist.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten übermittelt. Der Delegat hat die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* `count`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine `Employee`-Klasse mit zwei Feldern definiert, `Name` und `Id`. Außerdem wird eine `EmployeeSearch`-Klasse mit einer einzelnen Methode definiert, `StartsWith`, die angibt, ob das `Employee.Name` Feld mit einer angegebenen Teil Zeichenfolge beginnt, die an den `EmployeeSearch`-Klassenkonstruktor übergeben wird. Beachten Sie die Signatur dieser Methode.  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 entspricht der Signatur des Delegaten, der an die <xref:System.Collections.Generic.List%601.FindIndex%2A>-Methode übermittelt werden kann. Im Beispiel wird ein `List<Employee>` Objekt instanziiert, eine Reihe von `Employee`-Objekten hinzugefügt und dann die <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>-Methode zweimal aufgerufen, um die gesamte Auflistung (d. h. die Elemente von Index 0 bis Index <xref:System.Collections.Generic.List%601.Count%2A>-1) zu durchsuchen. Beim ersten Mal sucht Sie nach dem ersten `Employee` Objekt, dessen `Name` Feld mit "J" beginnt. beim zweiten Mal sucht der Dienst nach dem ersten `Employee` Objekt, dessen `Name` Feld mit "Ju" beginnt.  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
Oder 
 <paramref name="count" /> ist kleiner als 0.  
  
Oder 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das letzte Vorkommen im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Das letzte Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten weitergegeben. dabei wird der <xref:System.Collections.Generic.List%601>nach hinten verschoben, beginnend mit dem letzten Element und endet mit dem ersten Element.  Die Verarbeitung wird beendet, wenn eine Entsprechung gefunden wird.  
  
> [!IMPORTANT]
>  Stellen Sie beim Durchsuchen einer Liste, die Werttypen enthält, sicher, dass der Standardwert für den Typ nicht das Such Prädikat erfüllt. Andernfalls gibt es keine Möglichkeit, zwischen einem Standardwert zu unterscheiden, der angibt, dass keine Entsprechung gefunden wurde, und einem List-Element, das den Standardwert für den Typ hat. Wenn der Standardwert das Such Prädikat erfüllt, verwenden Sie stattdessen die <xref:System.Collections.Generic.List%601.FindLastIndex%2A>-Methode.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Find-Methoden für die <xref:System.Collections.Generic.List%601>-Klasse veranschaulicht. Das Beispiel für die <xref:System.Collections.Generic.List%601>-Klasse enthält `book` Objekte der Klasse `Book`unter Verwendung der Daten aus der [XML-Beispieldatei: Books (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList`-Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , um die Werte aus der XML-Datei mit den Eigenschafts Werten der `book`-Objekte zu analysieren.  
  
 In der folgenden Tabelle werden die Beispiele für die Find-Methoden beschrieben.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht ein Buch mit einer ID mithilfe des `IDToFind` Prädikat Delegaten.<br /><br /> C#Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen aller Bücher, deren `Genre`-Eigenschaft "Computer" ist, mithilfe des `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, das über ein Veröffentlichungsdatum vor 2001 ist, unter Verwendung des `PubBefore2001` Prädikat Delegaten.<br /><br /> C#Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs mithilfe des `FindComputer`-Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs mithilfe des `FindComputer`-Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs in der zweiten Hälfte der Sammlung mithilfe des `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs in der zweiten Hälfte der Sammlung mithilfe des `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch ein angegebenes Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens in der <see cref="T:System.Collections.Generic.List`1" /> oder einem Teil davon zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird rückwärts durchsucht, beginnend beim letzten Element und endet beim ersten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten übermittelt.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Find-Methoden für die <xref:System.Collections.Generic.List%601>-Klasse veranschaulicht. Das Beispiel für die <xref:System.Collections.Generic.List%601>-Klasse enthält `book` Objekte der Klasse `Book`unter Verwendung der Daten aus der [XML-Beispieldatei: Books (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList`-Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , um die Werte aus der XML-Datei mit den Eigenschafts Werten der `book`-Objekte zu analysieren.  
  
 In der folgenden Tabelle werden die Beispiele für die Find-Methoden beschrieben.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht ein Buch mit einer ID mithilfe des `IDToFind` Prädikat Delegaten.<br /><br /> C#Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen aller Bücher, deren `Genre`-Eigenschaft "Computer" ist, mithilfe des `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, das über ein Veröffentlichungsdatum vor 2001 ist, unter Verwendung des `PubBefore2001` Prädikat Delegaten.<br /><br /> C#Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs mithilfe des `FindComputer`-Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs mithilfe des `FindComputer`-Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs in der zweiten Hälfte der Sammlung mithilfe des `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs in der zweiten Hälfte der Sammlung mithilfe des `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der vom ersten Element bis zum angegeben Index reicht.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird rückwärts durchsucht, beginnend bei `startIndex` und endet beim ersten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten übermittelt.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* die Anzahl der Elemente vom Anfang des <xref:System.Collections.Generic.List%601> bis `startIndex`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der die angegebene Anzahl von Elementen umfasst und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird rückwärts nach `startIndex` durchsucht und endet bei `startIndex` minus `count` Plus 1, wenn `count` größer als 0 (null) ist.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten übermittelt.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* `count`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Find-Methoden für die <xref:System.Collections.Generic.List%601>-Klasse veranschaulicht. Das Beispiel für die <xref:System.Collections.Generic.List%601>-Klasse enthält `book` Objekte der Klasse `Book`unter Verwendung der Daten aus der [XML-Beispieldatei: Books (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die `FillList`-Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , um die Werte aus der XML-Datei mit den Eigenschafts Werten der `book`-Objekte zu analysieren.  
  
 In der folgenden Tabelle werden die Beispiele für die Find-Methoden beschrieben.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht ein Buch mit einer ID mithilfe des `IDToFind` Prädikat Delegaten.<br /><br /> C#Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen aller Bücher, deren `Genre`-Eigenschaft "Computer" ist, mithilfe des `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung, das über ein Veröffentlichungsdatum vor 2001 ist, unter Verwendung des `PubBefore2001` Prädikat Delegaten.<br /><br /> C#Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs mithilfe des `FindComputer`-Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs mithilfe des `FindComputer`-Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs in der zweiten Hälfte der Sammlung mithilfe des `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs in der zweiten Hälfte der Sammlung mithilfe des `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
Oder 
 <paramref name="count" /> ist kleiner als 0.  
  
Oder 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Der <see cref="T:System.Action`1" />-Delegat, der für jedes Element von <see cref="T:System.Collections.Generic.List`1" /> ausgeführt werden soll.</param>
        <summary>Führt die angegebene Aktion für jedes Element der <see cref="T:System.Collections.Generic.List`1" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Action%601> ist ein Delegat für eine Methode, die eine Aktion für das an ihn weiter gegebene Objekt ausführt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Action%601> Delegaten übermittelt.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
 Das Ändern der zugrunde liegenden Auflistung im Hauptteil des <xref:System.Action%601> Delegaten wird nicht unterstützt und verursacht ein nicht definiertes Verhalten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung des <xref:System.Action%601> Delegaten zum Drucken des Inhalts eines <xref:System.Collections.Generic.List%601> Objekts veranschaulicht. In diesem Beispiel wird die `Print`-Methode verwendet, um den Inhalt der Liste in der Konsole anzuzeigen.  
  
> [!NOTE]
>  Zusätzlich zum Anzeigen der Inhalte mithilfe der `Print`-Methode veranschaulicht das C# Beispiel die Verwendung [anonymer Methoden](~/docs/csharp/programming-guide/statements-expressions-operators/anonymous-methods.md) , um die Ergebnisse in der Konsole anzuzeigen.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">Ein Element in der Auflistung wurde geändert.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der das <see cref="T:System.Collections.Generic.List`1" />-Objekt durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.List`1.Enumerator" /> für die <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach`-Anweisung der C# Sprache (`for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist die <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>-Eigenschaft nicht definiert. Daher müssen Sie die <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>-Methode aufzurufen, um den Enumerator auf das erste Element der Auflistung zu setzen, bevor Sie den Wert von <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>lesen.  
  
 Die <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>-Eigenschaft gibt dasselbe Objekt zurück, bis <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> legt <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert bleibt. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste aufrufungs <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> oder <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> löst eine <xref:System.InvalidOperationException>aus.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte <see cref="T:System.Collections.Generic.List`1" />-Index, an dem der Bereich beginnt.</param>
        <param name="count">Die Anzahl der Elemente im Bereich.</param>
        <summary>Erstellt eine flache Kopie eines Bereichs von Elementen in der Quell-<see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Eine flache Kopie eines Bereichs von Elementen in der Quell-<see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine flache Kopie einer Auflistung von Verweis Typen oder eine Teilmenge dieser Auflistung enthält nur die Verweise auf die Elemente der Auflistung. Die Objekte selbst werden nicht kopiert. Die Verweise in der neuen Liste zeigen auf die gleichen Objekte wie die Verweise in der ursprünglichen Liste.  
  
 Eine flache Kopie einer Auflistung von Werttypen oder eine Teilmenge dieser Auflistung enthält die Elemente der Auflistung. Wenn die Elemente der Auflistung jedoch Verweise auf andere Objekte enthalten, werden diese Objekte nicht kopiert. Die Verweise in den Elementen der neuen Auflistung zeigen auf die gleichen Objekte wie die Verweise in den Elementen der ursprünglichen Auflistung.  
  
 Im Gegensatz dazu kopiert eine tiefe Kopie einer Auflistung die Elemente und alle Elemente, die direkt oder indirekt von den Elementen referenziert werden.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* `count`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.GetRange%2A>-Methode und andere Methoden der <xref:System.Collections.Generic.List%601>-Klasse veranschaulicht, die für Bereiche fungieren. Am Ende des Beispiels wird die <xref:System.Collections.Generic.List%601.GetRange%2A>-Methode verwendet, um drei Elemente aus der Liste zu erhalten, beginnend mit Indexposition 2. Die <xref:System.Collections.Generic.List%601.ToArray%2A>-Methode wird für die resultierende <xref:System.Collections.Generic.List%601>aufgerufen und erstellt ein Array aus drei Elementen. Die Elemente des Arrays werden angezeigt.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
Oder 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den nullbasierten Index des ersten Vorkommens eines Werts in der <see cref="T:System.Collections.Generic.List`1" /> bzw. in einem Abschnitt davon zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das in <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb der gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des ggf. ersten Vorkommens von <paramref name="item" /> in der gesamten <see cref="T:System.Collections.Generic.List`1" />, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> wird nach vorne durchsucht, beginnend beim ersten Element und endet beim letzten Element.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der <xref:System.Collections.Generic.List%601.IndexOf%2A>-Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%29>-Methoden Überladung durchsucht die Liste von Anfang an und findet das erste Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um die Liste zu durchsuchen, beginnend mit Index Speicherort 3 und bis zum Ende der Liste, und findet das zweite Vorkommen der Zeichenfolge. Zum Schluss wird die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von zwei Einträgen zu durchsuchen, beginnend bei Indexposition 2. Sie gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das in <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Suche. 0 (null) ist in einer leeren Liste gültig.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der sich vom angegebenen Index bis zum letzten Element erstreckt.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in <see cref="T:System.Collections.Generic.List`1" />, der sich von <paramref name="index" /> bis zum letzten Element erstreckt, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird nach `index` durchsucht und endet beim letzten Element.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* die Anzahl der Elemente von `index` bis zum Ende der <xref:System.Collections.Generic.List%601>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der <xref:System.Collections.Generic.List%601.IndexOf%2A>-Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%29>-Methoden Überladung durchsucht die Liste von Anfang an und findet das erste Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um die Liste zu durchsuchen, beginnend mit Index Speicherort 3 und bis zum Ende der Liste, und findet das zweite Vorkommen der Zeichenfolge. Zum Schluss wird die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von zwei Einträgen zu durchsuchen, beginnend bei Indexposition 2. Sie gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das in <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Suche. 0 (null) ist in einer leeren Liste gültig.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen enthält.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in <see cref="T:System.Collections.Generic.List`1" />, der am <paramref name="index" /> beginnt und eine Anzahl von Elementen <paramref name="count" /> enthält, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.List%601> wird nach vorne durchsucht, beginnend bei `index` und endet bei `index` Plus `count` minus 1, wenn `count` größer als 0 (null) ist.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* `count`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der <xref:System.Collections.Generic.List%601.IndexOf%2A>-Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%29>-Methoden Überladung durchsucht die Liste von Anfang an und findet das erste Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um die Liste zu durchsuchen, beginnend mit Index Speicherort 3 und bis zum Ende der Liste, und findet das zweite Vorkommen der Zeichenfolge. Zum Schluss wird die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von zwei Einträgen zu durchsuchen, beginnend bei Indexposition 2. Sie gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
Oder 
 <paramref name="count" /> ist kleiner als 0.  
  
Oder 
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <paramref name="item" /> eingefügt werden soll.</param>
        <param name="item">Das einzufügende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt ein Element am angegebenen Index in die <see cref="T:System.Collections.Generic.List`1" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> bereits <xref:System.Collections.Generic.List%601.Capacity%2A>entspricht, erhöht sich die Kapazität des <xref:System.Collections.Generic.List%601> durch automatisches Neuzuordnen des internen Arrays, und die vorhandenen Elemente werden in das neue Array kopiert, bevor das neue Element hinzugefügt wird.  
  
 Wenn `index` gleich <xref:System.Collections.Generic.List%601.Count%2A>ist, wird `item` am Ende <xref:System.Collections.Generic.List%601>hinzugefügt.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>hinzugefügt, entfernt und eingefügt wird.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Im folgenden Beispiel wird die <xref:System.Collections.Generic.List%601.Insert%2A>-Methode zusammen mit verschiedenen anderen Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen Klasse veranschaulicht. Nachdem die Liste erstellt wurde, werden Elemente hinzugefügt. Die <xref:System.Collections.Generic.List%601.Insert%2A>-Methode wird verwendet, um ein Element in die Mitte der Liste einzufügen. Das eingefügte Element ist ein Duplikat, das später mithilfe der <xref:System.Collections.Generic.List%601.Remove%2A>-Methode entfernt wird.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
Oder 
 <paramref name="index" /> ist größer als <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem die neuen Elemente eingefügt werden sollen.</param>
        <param name="collection">Die Sammlung, deren Elemente in die <see cref="T:System.Collections.Generic.List`1" /> eingefügt werden sollen. Die Auflistung an sich kann nicht <see langword="null" /> sein, sie kann jedoch Elemente enthalten, die <see langword="null" /> sind, wenn Typ <paramref name="T" /> einen Referenztyp darstellt.</param>
        <summary>Fügt die Elemente einer Auflistung am angegebenen Index in die <see cref="T:System.Collections.Generic.List`1" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
 Wenn die neue <xref:System.Collections.Generic.List%601.Count%2A> (die aktuelle <xref:System.Collections.Generic.List%601.Count%2A> zuzüglich der Größe der Auflistung) größer als <xref:System.Collections.Generic.List%601.Capacity%2A>ist, wird die Kapazität der <xref:System.Collections.Generic.List%601> erhöht, indem das interne Array automatisch neu zugewiesen wird, um die neuen Elemente zu berücksichtigen, und die vorhandenen Elemente werden in das neue Array kopiert, bevor die neuen Elemente hinzugefügt werden.  
  
 Wenn `index` gleich <xref:System.Collections.Generic.List%601.Count%2A>ist, werden die Elemente am Ende der <xref:System.Collections.Generic.List%601>hinzugefügt.  
  
 Die Reihenfolge der Elemente in der Auflistung wird im <xref:System.Collections.Generic.List%601>beibehalten.  
  
 Diese Methode ist ein O (*n* * *m*)-Vorgang, wobei *n* die Anzahl der hinzu zufügenden Elemente und *m* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden <xref:System.Collections.Generic.List%601.InsertRange%2A>-Methode und verschiedene andere Methoden der <xref:System.Collections.Generic.List%601>-Klasse veranschaulicht, die auf Bereiche reagieren. Nachdem die Liste erstellt und mit den Namen mehrerer, friedlicher, Pflanzen fressender Dinosaurier aufgefüllt wurde, wird die <xref:System.Collections.Generic.List%601.InsertRange%2A>-Methode verwendet, um in der Liste ein Array von drei wilden, in der Liste enthaltenen Dinosaurier in die Liste einzufügen, beginnend bei Indexposition 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
Oder 
 <paramref name="index" /> ist größer als <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Elements, das abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt es fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
 Über diese Eigenschaft können Sie mithilfe der folgenden Syntax auf ein bestimmtes Element der Auflistung zugreifen: `myCollection[index]`.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O (1)-Vorgang. das Festlegen der-Eigenschaft ist ebenfalls ein O (1)-Vorgang.  
  
   
  
## Examples  
 Das Beispiel in diesem Abschnitt veranschaulicht die <xref:System.Collections.Generic.List%601.Item%2A>-Eigenschaft (Indexer in C#) und verschiedene andere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen Klasse. Nachdem die Liste mit der <xref:System.Collections.Generic.List%601.Add%2A>-Methode erstellt und aufgefüllt wurde, wird ein Element mithilfe der <xref:System.Collections.Generic.List%601.Item%2A>-Eigenschaft abgerufen und angezeigt. (Ein Beispiel, in dem die <xref:System.Collections.Generic.List%601.Item%2A>-Eigenschaft verwendet wird, um den Wert eines List-Elements festzulegen, finden Sie unter <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, C#und verfügen C++ über eine Syntax für den Zugriff auf die <xref:System.Collections.Generic.List%601.Item%2A>-Eigenschaft, ohne ihren Namen zu verwenden. Stattdessen wird die Variable, die die <xref:System.Collections.Generic.List%601> enthält, so verwendet, als ob es sich um ein Array handelt.  
  
 Die C# Sprache verwendet das [`this`](~/docs/csharp/language-reference/keywords/this.md) -Schlüsselwort, um die Indexer zu definieren, anstatt die <xref:System.Collections.Generic.List%601.Item%2A>-Eigenschaft zu implementieren. Visual Basic implementiert <xref:System.Collections.Generic.List%601.Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
Oder 
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den nullbasierten Index des letzten Vorkommens eines Werts in der <see cref="T:System.Collections.Generic.List`1" /> bzw. in einem Abschnitt davon zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das in <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb der gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="item" /> in der gesamten <see cref="T:System.Collections.Generic.List`1" />; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird rückwärts durchsucht, beginnend beim letzten Element und endet beim ersten Element.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der <xref:System.Collections.Generic.List%601.LastIndexOf%2A>-Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29>-Methoden Überladung durchsucht die gesamte Liste vom Ende und findet das zweite Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um die Liste rückwärts zu durchsuchen, beginnend mit Index Speicherort 3 und bis zum Anfang der Liste, sodass das erste Vorkommen der Zeichenfolge in der Liste gefunden wird. Schließlich wird die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von vier Einträgen zu durchsuchen, beginnend bei Indexposition 4 und rückwärts, d. h., Sie durchsucht die Elemente an den Positionen 4, 3, 2 und 1. Diese Suche gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das in <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der sich vom angegebenen Index bis zum letzten Element erstreckt.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" />, der sich vom ersten Element bis <paramref name="index" /> erstreckt, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird rückwärts durchsucht, beginnend bei `index` und endet beim ersten Element.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* die Anzahl der Elemente vom Anfang des <xref:System.Collections.Generic.List%601> bis `index`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der <xref:System.Collections.Generic.List%601.LastIndexOf%2A>-Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29>-Methoden Überladung durchsucht die gesamte Liste vom Ende und findet das zweite Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um die Liste rückwärts zu durchsuchen, beginnend mit Index Speicherort 3 und bis zum Anfang der Liste, sodass das erste Vorkommen der Zeichenfolge in der Liste gefunden wird. Schließlich wird die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von vier Einträgen zu durchsuchen, beginnend bei Indexposition 4 und rückwärts, d. h., Sie durchsucht die Elemente an den Positionen 4, 3, 2 und 1. Diese Suche gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das in <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" />, der <paramref name="count" /> Anzahl von Elementen enthält und am <paramref name="index" /> endet, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird rückwärts nach `index` durchsucht und endet bei `index` minus `count` Plus 1, wenn `count` größer als 0 (null) ist.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* `count`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der <xref:System.Collections.Generic.List%601.LastIndexOf%2A>-Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, wobei ein Eintrag zweimal an Indexposition 0 und Index Speicherort 5 angezeigt wird. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29>-Methoden Überladung durchsucht die gesamte Liste vom Ende und findet das zweite Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29>-Methoden Überladung wird verwendet, um die Liste rückwärts zu durchsuchen, beginnend mit Index Speicherort 3 und bis zum Anfang der Liste, sodass das erste Vorkommen der Zeichenfolge in der Liste gefunden wird. Zum Schluss wird die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um einen Bereich von vier Einträgen zu durchsuchen, beginnend bei Indexposition 4 und rückwärts, d. h., Sie durchsucht die Elemente an den Positionen 4, 3, 2 und 1. Diese Suche gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
Oder 
 <paramref name="count" /> ist kleiner als 0.  
  
Oder 
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das aus der <see cref="T:System.Collections.Generic.List`1" /> zu entfernende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Entfernt das erste Vorkommen eines bestimmten Objekts aus <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns><see langword="true" />, wenn <paramref name="item" /> erfolgreich entfernt wurde, andernfalls <see langword="false" />.  Diese Methode gibt auch dann <see langword="false" /> zurück, wenn das <paramref name="item" /> nicht in der <see cref="T:System.Collections.Generic.List`1" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Type `T` die <xref:System.IEquatable%601> generische Schnittstelle implementiert, ist der Gleichheits Vergleich die <xref:System.IEquatable%601.Equals%2A>-Methode dieser Schnittstelle. Andernfalls ist der Standard Gleichheits Vergleich <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>hinzugefügt, entfernt und eingefügt wird.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Im folgenden Beispiel wird <xref:System.Collections.Generic.List%601.Remove%2A>-Methode veranschaulicht. Mehrere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen Klasse werden verwendet, um die Liste hinzuzufügen, einzufügen und zu durchsuchen. Nach diesen Vorgängen enthält die Liste ein Duplikat. Die <xref:System.Collections.Generic.List%601.Remove%2A>-Methode wird verwendet, um die erste Instanz des doppelten Elements zu entfernen, und der Inhalt wird angezeigt. Die <xref:System.Collections.Generic.List%601.Remove%2A>-Methode entfernt immer die erste Instanz, auf die Sie trifft.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, die entfernt werden sollen.</param>
        <summary>Entfernt alle Elemente, die mit den Bedingungen übereinstimmen, die durch das angegebene Prädikat definiert werden.</summary>
        <returns>Die Anzahl der aus der <see cref="T:System.Collections.Generic.List`1" />-Klasse entfernten Elemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten übergebenen, und die Elemente, die den Bedingungen entsprechen, werden aus dem <xref:System.Collections.Generic.List%601>entfernt.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.RemoveAll%2A>-Methode und verschiedene andere Methoden veranschaulicht, die den <xref:System.Predicate%601> generischen Delegaten verwenden.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, die acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Beispiel definiert auch eine Such Prädikat Methode mit dem Namen `EndsWithSaurus`, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die Methoden <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>und <xref:System.Collections.Generic.List%601.FindAll%2A> werden verwendet, um die Liste mit der Such Prädikat Methode zu durchsuchen.  
  
 Die <xref:System.Collections.Generic.List%601.RemoveAll%2A>-Methode wird verwendet, um alle Einträge zu entfernen, die mit "saurus" enden. Sie durchläuft die Liste von Anfang an, wobei jedes Element wiederum an die `EndsWithSaurus`-Methode übergeben wird. Das-Element wird entfernt, wenn die `EndsWithSaurus`-Methode `true`zurückgibt.  
  
> [!NOTE]
>  In C# und Visual Basic muss der `Predicate<string>` Delegat (`Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Zum Schluss überprüft die <xref:System.Collections.Generic.List%601.Exists%2A>-Methode, dass keine Zeichen folgen in der Liste vorhanden sind, die mit "saurus" enden.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des zu entfernenden Elements.</param>
        <summary>Entfernt das Element am angegebenen Index aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie <xref:System.Collections.Generic.List%601.RemoveAt%2A> zum Entfernen eines Elements aufzurufen, werden die restlichen Elemente in der Liste neu umbenannt, um das entfernte Element zu ersetzen. Wenn Sie z. b. das Element am Index 3 entfernen, wird das Element bei Index 4 an die 3-Position verschoben. Außerdem wird die Anzahl der Elemente in der Liste (wie durch die <xref:System.Collections.Generic.List%601.Count%2A>-Eigenschaft dargestellt) um 1 reduziert.  
  
 Diese Methode ist ein O (*n*)-Vorgang, wobei *n* (<xref:System.Collections.Generic.List%601.Count%2A> - `index`) ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein einfaches Geschäftsobjekt in einem <xref:System.Collections.Generic.List%601>hinzugefügt, entfernt und eingefügt wird.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
Oder 
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu entfernenden Bereichs von Elementen.</param>
        <param name="count">Die Anzahl der zu entfernenden Elemente.</param>
        <summary>Entfernt einen Bereich von Elementen aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden entfernt, und alle Elemente, die in der <xref:System.Collections.Generic.List%601> folgen, werden durch `count`reduziert.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.RemoveRange%2A>-Methode und verschiedene andere Methoden der <xref:System.Collections.Generic.List%601>-Klasse veranschaulicht, die auf Bereiche reagieren. Nachdem die Liste erstellt und geändert wurde, wird die <xref:System.Collections.Generic.List%601.RemoveRange%2A>-Methode verwendet, um zwei Elemente aus der Liste zu entfernen, beginnend bei Indexposition 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
Oder 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kehrt die Reihenfolge der Elemente in der <see cref="T:System.Collections.Generic.List`1" /> bzw. in einem Teil davon um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kehrt die Reihenfolge der Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Reverse%2A?displayProperty=nameWithType>, um die Reihenfolge der Elemente umzukehren.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden beide über Ladungen der <xref:System.Collections.Generic.List%601.Reverse%2A>-Methode veranschaulicht. Im Beispiel wird eine <xref:System.Collections.Generic.List%601> von Zeichen folgen erstellt und sechs Zeichen folgen hinzugefügt. Die <xref:System.Collections.Generic.List%601.Reverse>-Methoden Überladung wird verwendet, um die Liste umzukehren, und dann wird die <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um die Mitte der Liste umzukehren, beginnend mit Element 1 und umfasst vier Elemente.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des Bereichs, in dem die Reihenfolge umgekehrt werden soll.</param>
        <param name="count">Die Anzahl der Elemente im Bereich, in dem die Reihenfolge umgekehrt werden soll.</param>
        <summary>Kehrt die Reihenfolge der Elemente im angegebenen Bereich um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Reverse%2A?displayProperty=nameWithType>, um die Reihenfolge der Elemente umzukehren.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden beide über Ladungen der <xref:System.Collections.Generic.List%601.Reverse%2A>-Methode veranschaulicht. Im Beispiel wird eine <xref:System.Collections.Generic.List%601> von Zeichen folgen erstellt und sechs Zeichen folgen hinzugefügt. Die <xref:System.Collections.Generic.List%601.Reverse>-Methoden Überladung wird verwendet, um die Liste umzukehren, und dann wird die <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29>-Methoden Überladung verwendet, um die Mitte der Liste umzukehren, beginnend mit Element 1 und umfasst vier Elemente.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
Oder 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente oder einen Teil der Elemente in <see cref="T:System.Collections.Generic.List`1" />, entweder über die angegebene oder eine Standardimplementierung von <see cref="T:System.Collections.Generic.IComparer`1" /> oder über einen bereitgestellten <see cref="T:System.Comparison`1" />-Delegat zum Vergleichen von Listenelementen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des Standardcomparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet den Standardcomparer-<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> für den Typ `T`, um die Reihenfolge der Listenelemente zu bestimmen. Die <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>-Eigenschaft überprüft, ob der Typ `T` die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Andernfalls <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` die <xref:System.IComparable>-Schnittstelle implementiert.  Wenn Type `T` keine Schnittstelle implementiert, löst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> eine <xref:System.InvalidOperationException>aus.  
  
 Diese Methode verwendet die <xref:System.Array.Sort%2A?displayProperty=nameWithType>-Methode, die die Introspektion wie folgt anwendet:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein Einfügungs Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 Protokoll *n*überschreitet, wobei *n* der Bereich des Eingabe Arrays ist, wird ein Heapsort-Algorithmus verwendet.  
  
-   Andernfalls wird ein QuickSort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Im Durchschnitt ist diese Methode ein O (*n* log *n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist. im schlimmsten Fall ist dies ein O (*n*<sup>2</sup>)-Vorgang.  
  
   
  
## Examples  

 Im folgenden Beispiel werden einige Namen zu einem `List<String>` Objekt hinzugefügt. die Liste wird in der unsortierten Reihenfolge angezeigt, die <xref:System.Collections.Generic.List%601.Sort%2A>-Methode wird aufgerufen, und anschließend wird die sortierte Liste angezeigt.  
  
 [!code-csharp-interactive[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 Der folgende Code veranschaulicht die <xref:System.Collections.Generic.List%601.Sort>-und <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>-Methoden Überladungen für ein einfaches Geschäftsobjekt. Wenn Sie die <xref:System.Collections.Generic.List%601.Sort>-Methode aufrufen, wird der Standardcomparer für den Teiltyp verwendet, und die <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>-Methode wird mit einer anonymen Methode implementiert.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Sort>-Methoden Überladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>-Methoden Überladung veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste wird angezeigt, sortiert und erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29>-Methoden Überladung wird dann verwendet, um nach zwei Zeichen folgen zu suchen, die nicht in der Liste enthalten sind, und die <xref:System.Collections.Generic.List%601.Insert%2A>-Methode wird verwendet, um Sie einzufügen. Der Rückgabewert der <xref:System.Collections.Generic.List%601.BinarySearch%2A>-Methode ist in jedem Fall negativ, da die Zeichen folgen nicht in der Liste enthalten sind. Das bitweise Komplement (der ~-Operator in C# und Visual C++, `Xor`-1 in Visual Basic) dieser negativen Zahl erzeugt den Index des ersten Elements in der Liste, das größer als die Such Zeichenfolge ist, und das Einfügen an dieser Stelle behält die Sortierreihenfolge bei. Die zweite Such Zeichenfolge ist größer als jedes Element in der Liste, sodass sich die Einfügeposition am Ende der Liste befindet.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen Comparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` bereitgestellt wird, werden die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der angegebenen <xref:System.Collections.Generic.IComparer%601>-Implementierung sortiert.  
  
 Wenn `comparer` `null`ist, überprüft der Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, ob der Typ `T` die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Andernfalls <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` die <xref:System.IComparable>-Schnittstelle implementiert.  Wenn Type `T` keine Schnittstelle implementiert, löst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> eine <xref:System.InvalidOperationException>aus.  
  
 Diese Methode verwendet die <xref:System.Array.Sort%2A?displayProperty=nameWithType>-Methode, die die Introspektion wie folgt anwendet:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein Einfügungs Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 Protokoll *n*überschreitet, wobei *n* der Bereich des Eingabe Arrays ist, wird ein Heapsort-Algorithmus verwendet.  
  
-   Andernfalls wird ein QuickSort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Im Durchschnitt ist diese Methode ein O (*n* log *n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist. im schlimmsten Fall ist dies ein O (*n*<sup>2</sup>)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung veranschaulicht.  
  
 Im Beispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen DinoCompare definiert, der den `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` C++in Visual) generischen Schnittstelle implementiert. Der Vergleich funktioniert wie folgt: zuerst werden die Vergleiche auf `null`getestet, und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste wird angezeigt, mit dem alternativen Vergleich sortiert und erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung wird dann verwendet, um nach mehreren Zeichen folgen zu suchen, die nicht in der Liste enthalten sind, wobei der Alternative Vergleich verwendet wird. Die <xref:System.Collections.Generic.List%601.Insert%2A>-Methode wird zum Einfügen der Zeichen folgen verwendet. Diese beiden Methoden befinden sich in der Funktion mit dem Namen `SearchAndInsert`, zusammen mit dem Code, um das bitweise Komplement (der C# ~- C++Operator in und Visual, `Xor`-1 in Visual Basic) der von <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> zurückgegebenen negativen Zahl zu verwenden und Sie als Index für das Einfügen der neuen Zeichenfolge zu verwenden.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> nicht finden.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">Die <see cref="T:System.Comparison`1" />, die beim Vergleich von Elementen verwendet werden soll.</param>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparison` bereitgestellt wird, werden die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der Methode sortiert, die durch den-Delegaten dargestellt wird.  
  
 Wenn `comparison` `null`ist, wird ein <xref:System.ArgumentNullException> ausgelöst.  
  
 Diese Methode verwendet <xref:System.Array.Sort%2A?displayProperty=nameWithType>, das die Introspektion wie folgt anwendet:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein Einfügungs Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 Protokoll *n*überschreitet, wobei *n* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein QuickSort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Im Durchschnitt ist diese Methode ein O (*n* log *n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist. im schlimmsten Fall ist dies ein O (*n*<sup>2</sup>)-Vorgang.  
  
   
  
## Examples  
 Der folgende Code veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%2A>-und <xref:System.Collections.Generic.List%601.Sort%2A>-Methoden Überladungen für ein einfaches Geschäftsobjekt. Wenn Sie die <xref:System.Collections.Generic.List%601.Sort%2A>-Methode aufrufen, wird der Standardcomparer für den Teiltyp verwendet, und die <xref:System.Collections.Generic.List%601.Sort%2A>-Methode wird mit einer anonymen Methode implementiert.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>-Methoden Überladung veranschaulicht.  
  
 Das Beispiel definiert eine Alternative Vergleichsmethode für Zeichen folgen mit dem Namen `CompareDinosByLength`. Diese Methode funktioniert wie folgt: zuerst werden die Vergleiche auf `null`getestet, und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste enthält auch eine leere Zeichenfolge und einen NULL-Verweis. Die Liste wird angezeigt, mithilfe eines <xref:System.Comparison%601> generischen Delegaten sortiert, der die `CompareDinosByLength`-Methode darstellt, und wird erneut angezeigt.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparison" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparison" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparison" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu sortierenden Bereichs.</param>
        <param name="count">Die Länge des zu sortierenden Bereichs.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen Vergleichs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` bereitgestellt wird, werden die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der angegebenen <xref:System.Collections.Generic.IComparer%601>-Implementierung sortiert.  
  
 Wenn `comparer` `null`ist, überprüft der Standardcomparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, ob der Typ `T` die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Andernfalls <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob der Typ `T` die <xref:System.IComparable>-Schnittstelle implementiert.  Wenn Type `T` keine Schnittstelle implementiert, löst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> eine <xref:System.InvalidOperationException>aus.  
  
 Diese Methode verwendet <xref:System.Array.Sort%2A?displayProperty=nameWithType>, das die Introspektion wie folgt anwendet:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein Einfügungs Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 Protokoll *n*überschreitet, wobei *n* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein QuickSort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Im Durchschnitt ist diese Methode ein O (*n* log *n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist. im schlimmsten Fall ist dies ein O (*n*<sup>2</sup>)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung und die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung veranschaulicht.  
  
 Im Beispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen DinoCompare definiert, der den `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` C++in Visual) generischen Schnittstelle implementiert. Der Vergleich funktioniert wie folgt: zuerst werden die Vergleiche auf `null`getestet, und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit den Namen von fünf herbialous-dinosaern und drei karnevaliösen dinosaern aufgefüllt. Innerhalb der beiden Gruppen befinden sich die Namen nicht in einer bestimmten Sortierreihenfolge. Die Liste wird angezeigt, der Bereich der HERBIVORES wird mit dem alternativen Comparer sortiert, und die Liste wird erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methoden Überladung wird dann verwendet, um nur den Bereich von HERBIVORES für "Brachiosaurus" zu durchsuchen. Die Zeichenfolge wurde nicht gefunden, und das bitweise Komplement (der ~- C# Operator in C++und Visual, `Xor`-1 in Visual Basic) der negativen Zahl, die von der <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29>-Methode zurückgegeben wird, wird als Index zum Einfügen der neuen Zeichenfolge verwendet.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
Oder 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in der <see cref="T:System.Collections.Generic.List`1" /> an.  
  
Oder 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> nicht finden.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly : bool" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist.</summary>
        <value>Ist <see langword="true" />, wenn die <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der das Ändern der Auflistung verhindert. Wenn also Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, reflektiert die schreibgeschützte Auflistung diese Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;&#xA;override this.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;" Usage="list.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerator`1" />, mit dem die Auflistung durchlaufen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach`-Anweisung der C# Sprache (`for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist die <xref:System.Collections.Generic.IEnumerator%601.Current%2A>-Eigenschaft nicht definiert. Daher müssen Sie die <xref:System.Collections.IEnumerator.MoveNext%2A>-Methode aufzurufen, um den Enumerator auf das erste Element der Auflistung zu setzen, bevor Sie den Wert von <xref:System.Collections.Generic.IEnumerator%601.Current%2A>lesen.  
  
 Die <xref:System.Collections.Generic.IEnumerator%601.Current%2A>-Eigenschaft gibt dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.Generic.IEnumerator%601.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert bleibt. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste aufrufungs <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>aus.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As Array, arrayIndex As Integer) Implements ICollection.CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.ICollection.CopyTo : Array * int -&gt; unit&#xA;override this.System.Collections.ICollection.CopyTo : Array * int -&gt; unit" Usage="list.System.Collections.ICollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.ICollection" /> kopierten Elemente darstellt. Das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung aufweisen.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.ICollection" /> in ein <see cref="T:System.Array" />, beginnend bei einem bestimmten <see cref="T:System.Array" />-Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ des Quell <xref:System.Collections.ICollection> nicht automatisch in den Typ des Ziel `array`umgewandelt werden kann, lösen die nicht generischen Implementierungen von <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> <xref:System.InvalidCastException>aus, wohingegen die generischen Implementierungen <xref:System.ArgumentException>auslösen.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
Oder 
 <paramref name="array" /> verwendet keine nullbasierte Indizierung.  
  
Oder 
Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.ICollection" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />.  
  
Oder 
Der Typ der <see cref="T:System.Collections.ICollection" /> der Quelle kann nicht automatisch in den Typ des <paramref name="array" /> des Ziels umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.IsSynchronized : bool" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value><see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  In den seltenen Fällen, in denen enumerationskonflikte mit Schreibzugriffen auftreten, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Die Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt Sperren, bevor Sie auf die Auflistung zugreifen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.SyncRoot : obj" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.  In der Standardimplementierung der <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer die aktuelle Instanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Die Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt Sperren, bevor Sie auf die Auflistung zugreifen. Der folgende Code zeigt die Verwendung der <xref:System.Collections.ICollection.SyncRoot%2A>-Eigenschaft für C#, C++und Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="list.System.Collections.IEnumerable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, mit dem die Auflistung durchlaufen werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach`-Anweisung der C# Sprache (`for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist die <xref:System.Collections.IEnumerator.Current%2A>-Eigenschaft nicht definiert. Daher müssen Sie die <xref:System.Collections.IEnumerator.MoveNext%2A>-Methode aufzurufen, um den Enumerator auf das erste Element der Auflistung zu setzen, bevor Sie den Wert von <xref:System.Collections.IEnumerator.Current%2A>lesen.  
  
 Die <xref:System.Collections.IEnumerator.Current%2A>-Eigenschaft gibt dasselbe Objekt zurück, bis entweder <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert bleibt. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste aufrufungs <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>aus.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Add : obj -&gt; int&#xA;override this.System.Collections.IList.Add : obj -&gt; int" Usage="list.System.Collections.IList.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das <see cref="T:System.Object" />-Objekt, das dem <see cref="T:System.Collections.IList" />-Objekt hinzugefügt werden soll.</param>
        <summary>Fügt <see cref="T:System.Collections.IList" /> ein Element hinzu.</summary>
        <returns>Die Position, an der das neue Element eingefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> kleiner als <xref:System.Collections.Generic.List%601.Capacity%2A>ist, ist diese Methode ein O (1)-Vorgang. Wenn die Kapazität für das neue Element erweitert werden muss, wird diese Methode zu einem O (*n*)-Vorgang, wobei *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Contains : obj -&gt; bool&#xA;override this.System.Collections.IList.Contains : obj -&gt; bool" Usage="list.System.Collections.IList.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Die in <see cref="T:System.Object" /> zu suchende <see cref="T:System.Collections.IList" />.</param>
        <summary>Bestimmt, ob <see cref="T:System.Collections.IList" /> einen bestimmten Wert enthält.</summary>
        <returns><see langword="true" />, wenn das <paramref name="item" /> in der <see cref="T:System.Collections.IList" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.IndexOf : obj -&gt; int&#xA;override this.System.Collections.IList.IndexOf : obj -&gt; int" Usage="list.System.Collections.IList.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das in <see cref="T:System.Collections.IList" /> zu suchende Objekt.</param>
        <summary>Bestimmt den Index eines bestimmten Elements in <see cref="T:System.Collections.IList" />.</summary>
        <returns>Der Index von <paramref name="item" />, wenn das Element in der Liste gefunden wird, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Insert : int * obj -&gt; unit&#xA;override this.System.Collections.IList.Insert : int * obj -&gt; unit" Usage="list.System.Collections.IList.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <paramref name="item" /> eingefügt werden soll.</param>
        <param name="item">Das in die <see cref="T:System.Collections.IList" /> einzufügende Objekt.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.IList" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `index` gleich der Anzahl der Elemente in <xref:System.Collections.IList> ist, wird `item` am Ende angefügt.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.IsFixedSize : bool" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Collections.IList" /> eine feste Größe aufweist.</summary>
        <value>Ist <see langword="true" />, wenn die <see cref="T:System.Collections.IList" /> eine feste Größe aufweist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Auflistung mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem Erstellen der Auflistung nicht zu. Vorhandene Elemente können jedoch geändert werden.  
  
 Eine Auflistung mit fester Größe ist einfach eine Sammlung mit einem Wrapper, der das Hinzufügen und Entfernen von Elementen verhindert. Wenn Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, einschließlich hinzufügen oder Entfernen von Elementen, reflektiert die Auflistung mit fester Größe diese Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.IsReadOnly : bool" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Collections.IList" /> schreibgeschützt ist.</summary>
        <value>Ist <see langword="true" />, wenn die <see cref="T:System.Collections.IList" /> schreibgeschützt ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der das Ändern der Auflistung verhindert. Wenn also Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, reflektiert die schreibgeschützte Auflistung diese Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.Item(int) : obj with get, set" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Elements, das abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt es fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die C# Sprache verwendet das [this](~/docs/csharp/language-reference/keywords/this.md) -Schlüsselwort zum Definieren der Indexer, anstatt die <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A>-Eigenschaft zu implementieren. Visual Basic implementiert <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O (1)-Vorgang. das Festlegen der-Eigenschaft ist ebenfalls ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">Die Eigenschaft wird festgelegt, und der <paramref name="value" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Remove : obj -&gt; unit&#xA;override this.System.Collections.IList.Remove : obj -&gt; unit" Usage="list.System.Collections.IList.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das aus der <see cref="T:System.Collections.IList" /> zu entfernende Objekt.</param>
        <summary>Entfernt das erste Vorkommen eines bestimmten Objekts aus <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.Generic.List`1" /> in ein neues Array.</summary>
        <returns>Ein Array, das Kopien der Elemente aus <see cref="T:System.Collections.Generic.List`1" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden mithilfe von <xref:System.Array.Copy%2A?displayProperty=nameWithType>kopiert. dabei handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.ToArray%2A>-Methode und andere Methoden der <xref:System.Collections.Generic.List%601>-Klasse veranschaulicht, die für Bereiche fungieren. Am Ende des Beispiels wird die <xref:System.Collections.Generic.List%601.GetRange%2A>-Methode verwendet, um drei Elemente aus der Liste zu erhalten, beginnend mit Indexposition 2. Die <xref:System.Collections.Generic.List%601.ToArray%2A>-Methode wird für die resultierende <xref:System.Collections.Generic.List%601>aufgerufen und erstellt ein Array aus drei Elementen. Die Elemente des Arrays werden angezeigt.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die Kapazität auf die Anzahl der tatsächlich in der <see cref="T:System.Collections.Generic.List`1" /> befindlichen Elemente fest, sofern diese Anzahl unter dem Schwellenwert liegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Arbeitsspeicher Aufwand einer Sammlung zu minimieren, wenn der Auflistung keine neuen Elemente hinzugefügt werden. Die Kosten für das erneute zuordnen und Kopieren einer großen <xref:System.Collections.Generic.List%601> können jedoch beträchtlich sein, sodass die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode nichts bewirkt, wenn die Liste mehr als 90 Prozent der Kapazität hat. Dadurch wird vermieden, dass für einen relativ kleinen Gewinn keine großen Kosten für die erneute Zuordnung anfallen.  
  
> [!NOTE]
>  Der aktuelle Schwellenwert von 90 Prozent kann sich in zukünftigen Versionen ändern.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
 Um einen <xref:System.Collections.Generic.List%601> auf seinen ursprünglichen Zustand zurückzusetzen, rufen Sie die <xref:System.Collections.Generic.List%601.Clear%2A>-Methode auf, bevor Sie die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode aufrufen. Wenn Sie ein leeres <xref:System.Collections.Generic.List%601> kürzen, wird die Kapazität des <xref:System.Collections.Generic.List%601> auf die Standardkapazität festgelegt.  
  
 Die Kapazität kann auch mit der <xref:System.Collections.Generic.List%601.Capacity%2A>-Eigenschaft festgelegt werden.  
  
   
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie die Kapazität und die Anzahl einer <xref:System.Collections.Generic.List%601> überprüft werden, die ein einfaches Geschäftsobjekt enthält, und es wird veranschaulicht, wie die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode verwendet wird, um zusätzliche Kapazität zu entfernen.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode. Mehrere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601>-Klasse werden zum Hinzufügen, einfügen und Entfernen von Elementen aus einer Liste von Zeichen folgen verwendet. Anschließend wird die <xref:System.Collections.Generic.List%601.TrimExcess%2A>-Methode verwendet, um die Kapazität so zu reduzieren, dass Sie der Anzahl entspricht, und die Eigenschaften <xref:System.Collections.Generic.List%601.Capacity%2A> und <xref:System.Collections.Generic.List%601.Count%2A> werden angezeigt. Wenn die nicht genutzte Kapazität weniger als 10 Prozent der Gesamtkapazität war, wurde die Größe der Liste nicht geändert. Schließlich wird der Inhalt der Liste gelöscht.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen definiert, auf die die Elemente geprüft werden sollen.</param>
        <summary>Bestimmt, ob jedes Element in der <see cref="T:System.Collections.Generic.List`1" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt.</summary>
        <returns><see langword="true" />, wenn jedes Element in der <see cref="T:System.Collections.Generic.List`1" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt; andernfalls <see langword="false" />. Wenn die Liste über keine Elemente verfügt, ist der Rückgabewert <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die `true` zurückgibt, wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den <xref:System.Predicate%601> Delegaten und die Verarbeitung angehalten, wenn der Delegat `false` für ein beliebiges Element zurückgibt. Die Elemente werden in der Reihenfolge verarbeitet, und alle Aufrufe werden in einem einzelnen Thread durchgeführt.  
  
 Bei dieser Methode handelt es sich um einen O (*n*)-Vorgang, bei dem *n* <xref:System.Collections.Generic.List%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.TrueForAll%2A>-Methode und verschiedene andere Methoden veranschaulicht, die <xref:System.Predicate%601> generischen Delegaten verwenden.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, die acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Beispiel definiert auch eine Such Prädikat Methode mit dem Namen `EndsWithSaurus`, die einen Zeichen folgen Parameter annimmt und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Collections.Generic.List%601.TrueForAll%2A>-Methode durchläuft die Liste von Anfang an, wobei jedes Element wiederum an die `EndsWithSaurus`-Methode übergeben wird. Die Suche wird beendet, wenn die `EndsWithSaurus`-Methode `false`zurückgibt.  
  
> [!NOTE]
>  In C# und Visual Basic muss der `Predicate<string>` Delegat (`Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
