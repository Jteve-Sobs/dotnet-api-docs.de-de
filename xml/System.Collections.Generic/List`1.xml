<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="10d0572f1274167c8d00f2c69c8266e74de47638" /><Meta Name="ms.sourcegitcommit" Value="ff93f301301180af9a0213650c5b4edb28570fd0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/18/2020" /><Meta Name="ms.locfileid" Value="88557193" /></Metadata><TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface IList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IList" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.IList" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::IList" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Collections" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Collections" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("Count = {Count}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("Count = {Count}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Der Typ der Elemente in der Liste</typeparam>
    <summary>Stellt eine stark typisierte Liste von Objekten dar, auf die über einen Index zugegriffen werden kann. Stellt Methoden zum Durchsuchen, Sortieren und Bearbeiten von Listen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Collections.Generic.List%601> Klasse ist das generische Äquivalent der- <xref:System.Collections.ArrayList> Klasse. Es implementiert die <xref:System.Collections.Generic.IList%601> generische-Schnittstelle mithilfe eines Arrays, dessen Größe je nach Bedarf dynamisch erweitert wird.  
  
 Sie können einem <xref:System.Collections.Generic.List%601> mithilfe der-Methode oder der-Methode Elemente hinzufügen <xref:System.Collections.Generic.List%601.Add%2A> <xref:System.Collections.Generic.List%601.AddRange%2A> .  
  
 Die <xref:System.Collections.Generic.List%601> -Klasse verwendet sowohl einen Gleichheits Vergleich als auch einen Reihenfolge Vergleich.  
  
-   Methoden wie <xref:System.Collections.Generic.List%601.Contains%2A> , <xref:System.Collections.Generic.List%601.IndexOf%2A> , <xref:System.Collections.Generic.List%601.LastIndexOf%2A> und <xref:System.Collections.Generic.Dictionary%602.Remove%2A> verwenden einen Gleichheits Vergleich für die Listenelemente. Der Standard Gleichheits Vergleich für den Typ `T` wird wie folgt bestimmt. Wenn `T` der Typ die <xref:System.IEquatable%601> generische Schnittstelle implementiert, dann ist der Gleichheits Vergleich die- <xref:System.IEquatable%601.Equals%28%600%29> Methode dieser Schnittstelle; andernfalls ist der Standard Gleichheits Vergleich <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> .  
  
-   Methoden wie <xref:System.Collections.Generic.List%601.BinarySearch%2A> und <xref:System.Collections.Generic.List%601.Sort%2A> verwenden einen Reihenfolge Vergleich für die Listenelemente. Der Standardcomparer für den Typ `T` wird wie folgt bestimmt.  Wenn Type `T` die <xref:System.IComparable%601> generische Schnittstelle implementiert, dann ist der Standard Vergleich die- <xref:System.IComparable%601.CompareTo%28%600%29> Methode dieser Schnittstelle; andernfalls, wenn `T` der Typ die nicht generische- <xref:System.IComparable> Schnittstelle implementiert, dann ist der Standard Vergleich die- <xref:System.IComparable.CompareTo%28System.Object%29> Methode dieser Schnittstelle. Wenn der Typ `T` keine Schnittstelle implementiert, gibt es keinen Standardcomparer, und ein Vergleichs-oder Vergleichs Delegat muss explizit bereitgestellt werden.  
  
 Die <xref:System.Collections.Generic.List%601> Sortierung der ist nicht garantiert.  Sie müssen die <xref:System.Collections.Generic.List%601> vor dem Ausführen von Vorgängen sortieren (z <xref:System.Collections.Generic.List%601.BinarySearch%2A> . b.), für die eine Sortierung erforderlich ist <xref:System.Collections.Generic.List%601> .  
  
 Auf Elemente in dieser Auflistung kann mit einem ganzzahligen Index zugegriffen werden.  Indizes in dieser Sammlung sind NULL basiert.  
  
 **Nur .NET Framework:** Bei sehr großen <xref:System.Collections.Generic.List%601> Objekten können Sie die maximale Kapazität auf 2 Milliarden Elemente in einem 64-Bit-System erhöhen, indem Sie das- `enabled` Attribut des- [`<gcAllowVeryLargeObjects>`](/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element) Konfigurations Elements `true` in der Laufzeitumgebung auf festlegen.  
  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
 Eine unveränderliche Version der- <xref:System.Collections.Generic.List%601> Klasse finden Sie unter <xref:System.Collections.Immutable.ImmutableList%601> .  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Wenn Sie entscheiden, ob Sie die-Klasse oder die-Klasse verwenden möchten, die beide über eine <xref:System.Collections.Generic.List%601> <xref:System.Collections.ArrayList> ähnliche Funktionalität verfügen, denken Sie daran, dass die <xref:System.Collections.Generic.List%601> -Klasse in den meisten Fällen bessere Leistung erzielt und Wenn ein Verweistyp für `T` den Typ der Klasse verwendet wird <xref:System.Collections.Generic.List%601> , ist das Verhalten der beiden Klassen identisch. Wenn jedoch ein Werttyp für den Typ verwendet wird `T` , müssen Sie Implementierungs-und boxingprobleme in Erwägung gezogen.  
  
 Wenn ein Werttyp für den-Typ verwendet wird `T` , generiert der Compiler eine Implementierung der- <xref:System.Collections.Generic.List%601> Klasse speziell für diesen Werttyp. Dies bedeutet, dass ein Listenelement eines- <xref:System.Collections.Generic.List%601> Objekts nicht gekapselt werden muss, bevor das-Element verwendet werden kann. nach dem Erstellen von ungefähr 500 List-Elementen ist der Arbeitsspeicher, der nicht Boxing-Listenelemente speichert, größer als der Arbeitsspeicher, der zum Generieren der Klassen Implementierung verwendet wird.  
  
 Stellen Sie sicher, dass der für Typ verwendete Werttyp `T` die <xref:System.IEquatable%601> generische Schnittstelle implementiert. Wenn dies nicht der Wert ist, müssen Methoden wie <xref:System.Collections.Generic.List%601.Contains%2A> die- <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> Methode, die das betroffene Listenelement einstellt, aufruft. Wenn der Werttyp die- <xref:System.IComparable> Schnittstelle implementiert und Sie Besitzer des Quellcodes sind, implementieren Sie außerdem die <xref:System.IComparable%601> generische-Schnittstelle, um zu verhindern, dass die <xref:System.Collections.Generic.List%601.BinarySearch%2A> -Methode und die- <xref:System.Collections.Generic.List%601.Sort%2A> Methode Wenn Sie nicht über den Quellcode verfügen, übergeben Sie ein <xref:System.Collections.Generic.IComparer%601> -Objekt an die <xref:System.Collections.Generic.List%601.BinarySearch%2A> -Methode und die- <xref:System.Collections.Generic.List%601.Sort%2A> Methode.  
  
 Es ist von Vorteil, die typspezifische Implementierung der-Klasse zu verwenden, <xref:System.Collections.Generic.List%601> anstatt die-Klasse zu verwenden <xref:System.Collections.ArrayList> oder eine stark typisierte Wrapper Auflistung selbst zu schreiben. Der Grund hierfür ist, dass Ihre Implementierung bereits Aktionen ausführen muss, die das .NET Framework bereits durchführt, und die Common Language Runtime können den Microsoft Intermediate Language-Code und die Metadaten gemeinsam nutzen, die ihre Implementierung nicht unterstützt.  
  
## <a name="f-considerations"></a>Überlegungen zu F #  
 Die- <xref:System.Collections.Generic.List%601> Klasse wird nur selten in F #-Code verwendet. Stattdessen werden in der Regel [Listen](/dotnet/fsharp/language-reference/lists), die unveränderlich, einzeln verknüpfte Listen sind, bevorzugt. Eine F #-Liste stellt eine geordnete, unveränderliche Reihe von Werten bereit und wird für die Verwendung bei der funktionalen Entwicklung unterstützt. Bei Verwendung in f # wird in der <xref:System.Collections.Generic.List%601> Regel von der [ \<'T> resizearray](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-resizearray-1.html) -typabkürzung auf die-Klasse verwiesen, um Namenskonflikte mit F #-Listen zu vermeiden.
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie ein einfaches Geschäftsobjekt in einem hinzugefügt, entfernt und eingefügt wird <xref:System.Collections.Generic.List%601> .  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs" interactive="try-dotnet" id="snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb" id="snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs" id="snippet1":::
  
 Im folgenden Beispiel werden mehrere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen-Klasse vom Typ String veranschaulicht. (Ein Beispiel für <xref:System.Collections.Generic.List%601> komplexe Typen finden Sie unter der- <xref:System.Collections.Generic.List%601.Contains%2A> Methode.)  
  
 Der Parameter lose Konstruktor wird verwendet, um eine Liste von Zeichen folgen mit der Standardkapazität zu erstellen. Die <xref:System.Collections.Generic.List%601.Capacity%2A> -Eigenschaft wird angezeigt, und dann wird die- <xref:System.Collections.Generic.List%601.Add%2A> Methode verwendet, um mehrere Elemente hinzuzufügen. Die Elemente werden aufgelistet, und die- <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird wieder zusammen mit der- <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaft angezeigt, um anzuzeigen, dass die Kapazität nach Bedarf erweitert wurde.  
  
 Die- <xref:System.Collections.Generic.List%601.Contains%2A> Methode wird verwendet, um zu testen, ob ein Element in der Liste vorhanden ist <xref:System.Collections.Generic.List%601.Insert%2A> . die-Methode wird verwendet, um ein neues Element in der Mitte der Liste einzufügen, und der Inhalt der Liste wird erneut angezeigt.  
  
 Die Standard <xref:System.Collections.Generic.List%601.Item%2A> Eigenschaft (Indexer in c#) wird verwendet, um ein Element abzurufen. die- <xref:System.Collections.Generic.List%601.Remove%2A> Methode wird verwendet, um die erste Instanz des zuvor hinzugefügten doppelten Elements zu entfernen, und der Inhalt wird erneut angezeigt. Die- <xref:System.Collections.Generic.List%601.Remove%2A> Methode entfernt immer die erste Instanz, die Sie trifft.  
  
 Die <xref:System.Collections.Generic.List%601.TrimExcess%2A> -Methode wird verwendet, um die Kapazität so zu reduzieren, dass Sie der Anzahl entspricht, und die <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften und werden angezeigt. Wenn die nicht genutzte Kapazität weniger als 10 Prozent der Gesamtkapazität war, wurde die Größe der Liste nicht geändert.  
  
 Schließlich wird die <xref:System.Collections.Generic.List%601.Clear%2A> -Methode verwendet, um alle Elemente aus der Liste zu entfernen, und die <xref:System.Collections.Generic.List%601.Capacity%2A> -Eigenschaft und die-Eigenschaft <xref:System.Collections.Generic.List%601.Count%2A> werden angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische ( <see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Es ist sicher, mehrere Lesevorgänge auf einem auszuführen <see cref="T:System.Collections.Generic.List`1" /> , aber es können Probleme auftreten, wenn die Auflistung beim Lesen geändert wird. Um die Thread Sicherheit sicherzustellen, Sperren Sie die Sammlung während eines Lese-oder Schreibvorgangs. Damit eine Auflistung von mehreren Threads zum Lesen und schreiben aufgerufen werden kann, müssen Sie eine eigene Synchronisierung implementieren. Informationen zu Auflistungen mit integrierter Synchronisierung finden Sie unter den Klassen im- <see cref="N:System.Collections.Concurrent" /> Namespace. Informationen zu einer naturgemäß Thread sicheren Alternative finden Sie unter der- <see cref="T:System.Collections.Immutable.ImmutableList`1" /> Klasse.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Iteratoren (C# und Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die die Standardanfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität eines <xref:System.Collections.Generic.List%601> ist die Anzahl der Elemente, die der <xref:System.Collections.Generic.List%601> enthalten kann. Wenn Elemente zu einem hinzugefügt werden <xref:System.Collections.Generic.List%601> , wird die Kapazität bei Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt bei der Verwendung des <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> -Konstruktors und der Angabe der anfänglichen Kapazität, dass beim Hinzufügen von Elementen zur eine Reihe von Größen für die Größenänderung durchgeführt werden müssen <xref:System.Collections.Generic.List%601> .  
  
 Die Kapazität kann verringert werden, indem die- <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode aufgerufen oder die-Eigenschaft explizit festgelegt wird <xref:System.Collections.Generic.List%601.Capacity%2A> . Durch das Verringern der Kapazität wird der Arbeitsspeicher neu zugewiesen und alle Elemente in kopiert <xref:System.Collections.Generic.List%601> .  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.
  
## Examples  

 Im folgenden Beispiel wird der Parameter lose Konstruktor der <xref:System.Collections.Generic.List%601> generischen-Klasse veranschaulicht. Der Parameter lose Konstruktor erstellt eine Liste mit der Standardkapazität, wie in der Anzeige der- <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft gezeigt.  
  
 Im Beispiel werden Elemente hinzugefügt, eingefügt und entfernt, und es wird gezeigt, wie sich die Kapazität ändert, wenn diese Methoden verwendet werden.  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, deren Elemente in die neue Liste kopiert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die aus der angegebenen Auflistung kopierte Elemente enthält und eine ausreichende Kapazität für die Anzahl der kopierten Elemente aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden <xref:System.Collections.Generic.List%601> in derselben Reihenfolge auf die kopiert, in der Sie vom Enumerator der Auflistung gelesen werden.  
  
 Dieser Konstruktor ist ein O (*n*)-Vorgang, wobei *n* die Anzahl der Elemente in ist `collection` .
  
## Examples  
 Das folgende Beispiel veranschaulicht den <xref:System.Collections.Generic.List%601.%23ctor%2A> Konstruktor und verschiedene Methoden der- <xref:System.Collections.Generic.List%601> Klasse, die auf Bereiche reagieren. Ein Array von Zeichen folgen wird erstellt und an den Konstruktor übergeben, wobei die Liste mit den Elementen des Arrays aufgefüllt wird. Daraufhin wird die- <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft angezeigt, um anzuzeigen, dass die anfängliche Kapazität genau dem entspricht, was zum Speichern der Eingabeelemente erforderlich ist.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die Anzahl von Elementen, die anfänglich in der neuen Liste gespeichert werden können.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.List`1" />-Klasse, die die angegebene Anfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität eines <xref:System.Collections.Generic.List%601> ist die Anzahl der Elemente, die der <xref:System.Collections.Generic.List%601> enthalten kann. Wenn Elemente zu einem hinzugefügt werden <xref:System.Collections.Generic.List%601> , wird die Kapazität bei Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität das Ausführen einer Reihe von Größenänderung beim Hinzufügen von Elementen zum <xref:System.Collections.Generic.List%601> .  
  
 Die Kapazität kann verringert werden, indem die- <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode aufgerufen oder die-Eigenschaft explizit festgelegt wird <xref:System.Collections.Generic.List%601.Capacity%2A> . Durch das Verringern der Kapazität wird der Arbeitsspeicher neu zugewiesen und alle Elemente in kopiert <xref:System.Collections.Generic.List%601> .  
  
 Dieser Konstruktor ist ein O (*n*)-Vorgang, wobei *n* gleich ist `capacity` .
  
## Examples  
 Im folgenden Beispiel wird der- <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> Konstruktor veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen mit einer Kapazität von 4 wird erstellt, da die endgültige Größe der Liste bekanntermaßen genau 4 ist. Die Liste wird mit vier Zeichen folgen aufgefüllt, und mit der-Methode wird eine schreibgeschützte Kopie erstellt <xref:System.Collections.Generic.List%601.AsReadOnly%2A> .  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das Objekt, das am Ende der <see cref="T:System.Collections.Generic.List`1" /> hinzugefügt werden soll. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt ein Objekt am Ende von <see cref="T:System.Collections.Generic.List`1" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> bereits entspricht <xref:System.Collections.Generic.List%601.Capacity%2A> , wird die Kapazität des <xref:System.Collections.Generic.List%601> erhöht, indem das interne Array automatisch neu zugewiesen wird und die vorhandenen Elemente in das neue Array kopiert werden, bevor das neue Element hinzugefügt wird.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> kleiner als ist <xref:System.Collections.Generic.List%601.Capacity%2A> , ist diese Methode ein O (1)-Vorgang. Wenn die Kapazität für das neue Element erweitert werden muss, wird diese Methode zu einem O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie ein einfaches Geschäftsobjekt in einem hinzugefügt, entfernt und eingefügt wird <xref:System.Collections.Generic.List%601> .  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs" id="Snippet1":::
  
 Im folgenden Beispiel werden verschiedene Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen-Klasse, einschließlich der-Methode, veranschaulicht <xref:System.Collections.Generic.List%601.Add%2A> . Der Parameter lose Konstruktor wird verwendet, um eine Liste von Zeichen folgen mit einer Kapazität von 0 (null) zu erstellen. Die <xref:System.Collections.Generic.List%601.Capacity%2A> -Eigenschaft wird angezeigt, und dann <xref:System.Collections.Generic.List%601.Add%2A> wird die-Methode verwendet, um mehrere Elemente hinzuzufügen. Die Elemente werden aufgelistet, und die- <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird wieder zusammen mit der- <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaft angezeigt, um anzuzeigen, dass die Kapazität nach Bedarf erweitert wurde.  
  
 Andere Eigenschaften und Methoden werden verwendet, um Elemente in der Liste zu suchen, einzufügen und zu entfernen und schließlich die Liste zu löschen.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, deren Elemente am Ende der <see cref="T:System.Collections.Generic.List`1" /> hinzugefügt werden sollen. Die Auflistung an sich kann nicht <see langword="null" /> sein, sie kann jedoch Elemente enthalten, die <see langword="null" /> sind, wenn Typ <paramref name="T" /> einen Referenztyp darstellt.</param>
        <summary>Fügt die Elemente der angegebenen Auflistung am Ende von <see cref="T:System.Collections.Generic.List`1" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Elemente in der Auflistung wird im beibehalten <xref:System.Collections.Generic.List%601> .  
  
 Wenn das neue <xref:System.Collections.Generic.List%601.Count%2A> (das aktuelle <xref:System.Collections.Generic.List%601.Count%2A> plus die Größe der Auflistung) größer als ist <xref:System.Collections.Generic.List%601.Capacity%2A> , wird die Kapazität des erhöht, <xref:System.Collections.Generic.List%601> indem das interne Array automatisch neu zugewiesen wird, um die neuen Elemente zu berücksichtigen, und die vorhandenen Elemente werden in das neue Array kopiert, bevor die neuen Elemente hinzugefügt werden.  
  
 Wenn der <xref:System.Collections.Generic.List%601> die neuen Elemente aufnehmen kann, ohne den <xref:System.Collections.Generic.List%601.Capacity%2A> zu erhöhen, ist diese Methode ein O (*n*)-Vorgang, wobei *n* die Anzahl der hinzu zufügenden Elemente ist. Wenn die Kapazität erhöht werden muss, damit Sie die neuen Elemente aufnehmen kann, wird diese Methode zu einem O (*n*  +  *m*)-Vorgang, wobei *n* die Anzahl der hinzu zufügenden Elemente und *m* ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.AddRange%2A> -Methode und verschiedene andere Methoden der- <xref:System.Collections.Generic.List%601> Klasse veranschaulicht, die auf Bereiche reagieren. Ein Array von Zeichen folgen wird erstellt und an den Konstruktor übergeben, wobei die Liste mit den Elementen des Arrays aufgefüllt wird. Die- <xref:System.Collections.Generic.List%601.AddRange%2A> Methode wird aufgerufen, wobei die Liste als Argument angezeigt wird. Das Ergebnis ist, dass die aktuellen Elemente der Liste am Ende der Liste hinzugefügt werden, wobei alle Elemente duplizieren.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen schreibgeschützten <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />-Wrapper für die aktuelle Auflistung zurück.</summary>
        <returns>Ein Objekt, das als schreibgeschützter Wrapper des aktuellen <see cref="T:System.Collections.Generic.List`1" />-Objekts fungiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um Änderungen am-Objekt zu verhindern <xref:System.Collections.Generic.List%601> , machen Sie es nur über diesen Wrapper verfügbar. Ein-  <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> Objekt macht keine Methoden verfügbar, mit denen die Auflistung geändert wird. Wenn jedoch Änderungen am zugrunde liegenden Objekt vorgenommen werden <xref:System.Collections.Generic.List%601> , reflektiert die schreibgeschützte Auflistung diese Änderungen.  
  
 Diese Methode ist ein O (1)-Vorgang.
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.AsReadOnly%2A> Methode. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen mit einer Kapazität von 4 wird erstellt, da die endgültige Größe der Liste bekanntermaßen genau 4 ist. Die Liste wird mit vier Zeichen folgen gefüllt, und die- <xref:System.Collections.Generic.List%601.AsReadOnly%2A> Methode wird verwendet, um eine schreibgeschützte <xref:System.Collections.Generic.IList%601> generische Schnittstellen Implementierung zu erhalten, die die ursprüngliche Liste umschließt.  
  
 Ein Element der ursprünglichen Liste wird mithilfe der- <xref:System.Collections.Generic.List%601.Item%2A> Eigenschaft (Indexer in c#) auf "Coelophysis" festgelegt, und der Inhalt der schreibgeschützten Liste wird erneut angezeigt, um zu veranschaulichen, dass es sich nur um einen Wrapper für die ursprüngliche Liste handelt.  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verwendet einen binären Suchalgorithmus für die Suche nach einem bestimmten Element bzw. einen Teil dieses Elements in der sortierten <see cref="T:System.Collections.Generic.List`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Durchsucht mithilfe des Standardcomparers die gesamte sortierte <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet den Standard Vergleich für den- <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Typ `T` , um die Reihenfolge der Listenelemente zu bestimmen. Die <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> -Eigenschaft überprüft `T` , ob der Typ die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Wenn nicht, wird <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob `T` der Typ die- <xref:System.IComparable> Schnittstelle implementiert.  Wenn der Typ `T` eine der beiden Schnittstellen nicht implementiert, löst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> eine aus <xref:System.InvalidOperationException> .  
  
 Der <xref:System.Collections.Generic.List%601> muss bereits entsprechend der Vergleichs Implementierung sortiert werden, andernfalls ist das Ergebnis falsch.  
  
 `null`Der Vergleich mit einem beliebigen Verweistyp ist zulässig und generiert bei Verwendung der <xref:System.IComparable%601> generischen-Schnittstelle keine Ausnahme. Beim Sortieren `null` wird als kleiner als ein beliebiges anderes Objekt betrachtet.  
  
 Wenn <xref:System.Collections.Generic.List%601> mehr als ein Element mit dem gleichen Wert enthält, gibt die Methode nur eine der Vorkommen zurück, und Sie gibt möglicherweise eine der Vorkommen zurück, nicht notwendigerweise die erste.  
  
 Wenn das den <xref:System.Collections.Generic.List%601> angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können die bitweise Komplement Operation (~) auf diese negative Ganzzahl anwenden, um den Index des ersten Elements, das größer als der Suchwert ist, zu erhalten. Wenn Sie den Wert in das Einfügen <xref:System.Collections.Generic.List%601> , sollte dieser Index als Einfügemarke zum Beibehalten der Sortierreihenfolge verwendet werden.  
  
 Bei dieser Methode handelt es sich um einen O (log *n*)-Vorgang, wobei *n* die Anzahl der Elemente im Bereich ist.
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort> -Methoden Überladung und die- <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Methoden Überladung. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste wird angezeigt, sortiert und erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> -Methoden Überladung wird dann verwendet, um nach zwei Zeichen folgen zu suchen, die nicht in der Liste enthalten sind, und die- <xref:System.Collections.Generic.List%601.Insert%2A> Methode wird verwendet, um Sie einzufügen. Der Rückgabewert der- <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Methode ist in jedem Fall negativ, da die Zeichen folgen nicht in der Liste enthalten sind. Das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) dieser negativen Zahl erzeugt den Index des ersten Elements in der Liste, das größer als die Such Zeichenfolge ist, und das Einfügen an dieser Stelle behält die Sortierreihenfolge bei. Die zweite Such Zeichenfolge ist größer als jedes Element in der Liste, sodass sich die Einfügeposition am Ende der Liste befindet.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleich von Elementen verwendet werden soll.  
  
Oder 
 <see langword="null" /> zur Verwendung des Standardcomparers <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Durchsucht mithilfe des angegebenen Comparers die gesamte sortierte <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie eine- <xref:System.Collections.CaseInsensitiveComparer> Instanz als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` angegeben wird, werden die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der angegebenen-Implementierung mit dem angegebenen Wert verglichen <xref:System.Collections.Generic.IComparer%601> .  
  
 Wenn `comparer` `null` den Wert hat, überprüft der Standardcomparer, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> ob `T` der Typ die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Wenn nicht, wird <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob `T` der Typ die- <xref:System.IComparable> Schnittstelle implementiert.  Wenn der Typ eine der `T` beiden Schnittstellen nicht implementiert, wird ausgelöst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> <xref:System.InvalidOperationException> .  
  
 Der <xref:System.Collections.Generic.List%601> muss bereits entsprechend der Vergleichs Implementierung sortiert werden, andernfalls ist das Ergebnis falsch.  
  
 `null`Der Vergleich mit einem beliebigen Verweistyp ist zulässig und generiert bei Verwendung der <xref:System.IComparable%601> generischen-Schnittstelle keine Ausnahme. Beim Sortieren `null` wird als kleiner als ein beliebiges anderes Objekt betrachtet.  
  
 Wenn <xref:System.Collections.Generic.List%601> mehr als ein Element mit dem gleichen Wert enthält, gibt die Methode nur eine der Vorkommen zurück, und Sie gibt möglicherweise eine der Vorkommen zurück, nicht notwendigerweise die erste.  
  
 Wenn das den <xref:System.Collections.Generic.List%601> angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können die bitweise Komplement Operation (~) auf diese negative Ganzzahl anwenden, um den Index des ersten Elements, das größer als der Suchwert ist, zu erhalten. Wenn Sie den Wert in das Einfügen <xref:System.Collections.Generic.List%601> , sollte dieser Index als Einfügemarke zum Beibehalten der Sortierreihenfolge verwendet werden.  
  
 Bei dieser Methode handelt es sich um einen O (log *n*)-Vorgang, wobei *n* die Anzahl der Elemente im Bereich ist.
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> -Methoden Überladung und die- <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methoden Überladung.  
  
 Im Beispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen DinoCompare definiert, der die `IComparer<string>` `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich funktioniert wie folgt: zuerst werden die Vergleiche für getestet `null` , und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste wird angezeigt, mit dem alternativen Vergleich sortiert und erneut angezeigt.  
  
 Die- <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methoden Überladung wird dann verwendet, um nach mehreren Zeichen folgen zu suchen, die nicht in der Liste enthalten sind, wobei der Alternative Vergleich verwendet wird. Die- <xref:System.Collections.Generic.List%601.Insert%2A> Methode wird zum Einfügen der Zeichen folgen verwendet. Diese beiden Methoden befinden sich in der-Funktion `SearchAndInsert` mit dem Namen, zusammen mit dem Code, um das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) der negativen Zahl zu verwenden, die von zurückgegeben wird, <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> und verwenden es als Index zum Einfügen der neuen Zeichenfolge.  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu durchsuchenden Bereichs.</param>
        <param name="count">Die Länge des zu durchsuchenden Bereichs.</param>
        <param name="item">Das zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Durchsucht mithilfe des angegebenen Vergleichs einen Bereich von Elementen in der sortierten <see cref="T:System.Collections.Generic.List`1" /> nach einem Element und gibt den nullbasierten Index des Elements zurück.</summary>
        <returns>Der nullbasierte Index von <paramref name="item" /> in der sortierten <see cref="T:System.Collections.Generic.List`1" />, sofern <paramref name="item" /> gefunden wird, andernfalls eine negative Zahl, die das bitweise Komplement des Indexes des nächsten Elements darstellt, das größer als <paramref name="item" /> ist, oder, wenn kein größeres Element vorhanden ist, das bitweise Komplement von <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Vergleich passt an, wie die Elemente verglichen werden. Beispielsweise können Sie eine- <xref:System.Collections.CaseInsensitiveComparer> Instanz als Vergleichs Operator verwenden, um Zeichen folgen suchen ohne Berücksichtigung der Groß-/Kleinschreibung auszuführen.  
  
 Wenn `comparer` angegeben wird, werden die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der angegebenen-Implementierung mit dem angegebenen Wert verglichen <xref:System.Collections.Generic.IComparer%601> .  
  
 Wenn `comparer` `null` den Wert hat, überprüft der Standardcomparer, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> ob `T` der Typ die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Wenn nicht, wird <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob `T` der Typ die- <xref:System.IComparable> Schnittstelle implementiert.  Wenn der Typ eine der `T` beiden Schnittstellen nicht implementiert, wird ausgelöst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> <xref:System.InvalidOperationException> .  
  
 Der <xref:System.Collections.Generic.List%601> muss bereits entsprechend der Vergleichs Implementierung sortiert werden, andernfalls ist das Ergebnis falsch.  
  
 `null`Der Vergleich mit einem beliebigen Verweistyp ist zulässig und generiert bei Verwendung der <xref:System.IComparable%601> generischen-Schnittstelle keine Ausnahme. Beim Sortieren `null` wird als kleiner als ein beliebiges anderes Objekt betrachtet.  
  
 Wenn <xref:System.Collections.Generic.List%601> mehr als ein Element mit dem gleichen Wert enthält, gibt die Methode nur eine der Vorkommen zurück, und Sie gibt möglicherweise eine der Vorkommen zurück, nicht notwendigerweise die erste.  
  
 Wenn das den <xref:System.Collections.Generic.List%601> angegebenen Wert nicht enthält, gibt die Methode eine negative Ganzzahl zurück. Sie können die bitweise Komplement Operation (~) auf diese negative Ganzzahl anwenden, um den Index des ersten Elements, das größer als der Suchwert ist, zu erhalten. Wenn Sie den Wert in das Einfügen <xref:System.Collections.Generic.List%601> , sollte dieser Index als Einfügemarke zum Beibehalten der Sortierreihenfolge verwendet werden.  
  
 Bei dieser Methode handelt es sich um einen O (log *n*)-Vorgang, wobei *n* die Anzahl der Elemente im Bereich ist.
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> -Methoden Überladung und die- <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methoden Überladung.  
  
 Im Beispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen DinoCompare definiert, der die `IComparer<string>` `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich funktioniert wie folgt: zuerst werden die Vergleiche für getestet `null` , und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit den Namen von fünf herbialous-dinosaern und drei karnevaliösen dinosaern aufgefüllt. Innerhalb der beiden Gruppen befinden sich die Namen nicht in einer bestimmten Sortierreihenfolge. Die Liste wird angezeigt, der Bereich der HERBIVORES wird mit dem alternativen Comparer sortiert, und die Liste wird erneut angezeigt.  
  
 Die- <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methoden Überladung wird dann verwendet, um nur den Bereich von HERBIVORES für "Brachiosaurus" zu durchsuchen. Die Zeichenfolge wurde nicht gefunden, und das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) der negativen Zahl, die von der-Methode zurückgegeben <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> wird, wird als Index zum Einfügen der neuen Zeichenfolge verwendet.  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtzahl der Elemente ab, die die interne Datenstruktur ohne Änderung der Größe aufnehmen kann, oder legt diese Anzahl fest.</summary>
        <value>Die Anzahl der Elemente, die <see cref="T:System.Collections.Generic.List`1" /> enthalten kann, bevor eine Größenanpassung erforderlich ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> die Anzahl der Elemente, die von der <xref:System.Collections.Generic.List%601> gespeichert werden können, bevor die Größe geändert wird, während <xref:System.Collections.Generic.List%601.Count%2A> die Anzahl der Elemente ist, die tatsächlich in der sind <xref:System.Collections.Generic.List%601> .  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> ist immer größer als oder gleich <xref:System.Collections.Generic.List%601.Count%2A> . Wenn <xref:System.Collections.Generic.List%601.Count%2A> <xref:System.Collections.Generic.List%601.Capacity%2A> beim Hinzufügen von Elementen überschreitet, wird die Kapazität erhöht, indem das interne Array automatisch neu zugewiesen wird, bevor die alten Elemente kopiert und die neuen Elemente hinzugefügt werden.  
  
 Wenn die Kapazität deutlich größer als die Anzahl ist und Sie den von genutzten Arbeitsspeicher verringern möchten <xref:System.Collections.Generic.List%601> , können Sie die Kapazität verringern, indem Sie die- <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode aufrufen oder die- <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft explizit auf einen niedrigeren Wert festlegen. Wenn der Wert von <xref:System.Collections.Generic.List%601.Capacity%2A> explizit festgelegt wird, wird das interne Array ebenfalls neu zugeordnet, um der angegebenen Kapazität Rechnung zu tragen, und alle Elemente werden kopiert.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O (1)-Vorgang. das Festlegen der-Eigenschaft ist ein O (*n*)-Vorgang, wobei *n* die neue Kapazität ist.
   
## Examples  
 
 Im folgenden Beispiel wird veranschaulicht, wie die Kapazität und die Anzahl von einem- <xref:System.Collections.Generic.List%601> Objekt überprüft werden, das ein einfaches Geschäftsobjekt enthält, und die Verwendung der-Methode veranschaulicht, <xref:System.Collections.Generic.List%601.TrimExcess%2A> um zusätzliche Kapazität zu entfernen.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb" id="Snippet1":::
  
 Im folgenden Beispiel wird die- <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft an mehreren Punkten in der Lebensdauer einer Liste gezeigt. Der Parameter lose Konstruktor wird zum Erstellen einer Liste von Zeichen folgen mit einer Kapazität von 0 verwendet, und die- <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird angezeigt, um dies zu veranschaulichen. Nachdem die- <xref:System.Collections.Generic.List%601.Add%2A> Methode zum Hinzufügen mehrerer Elemente verwendet wurde, werden die Elemente aufgelistet, und dann <xref:System.Collections.Generic.List%601.Capacity%2A> wird die-Eigenschaft zusammen mit der- <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaft erneut angezeigt, um anzuzeigen, dass die Kapazität nach Bedarf erweitert wurde.  
  
 Die- <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft wird erneut angezeigt, nachdem die- <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode verwendet wurde, um die Kapazität zu verringern, die der Anzahl entspricht. Schließlich wird die <xref:System.Collections.Generic.List%601.Clear%2A> -Methode verwendet, um alle Elemente aus der Liste zu entfernen, und die <xref:System.Collections.Generic.List%601.Capacity%2A> -Eigenschaft und die-Eigenschaft <xref:System.Collections.Generic.List%601.Count%2A> werden erneut angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.Generic.List`1.Capacity" /> ist auf einen Wert festgelegt, der kleiner als <see cref="P:System.Collections.Generic.List`1.Count" /> ist.</exception>
        <exception cref="T:System.OutOfMemoryException">Im System ist nicht genügend Arbeitsspeicher verfügbar.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> wird auf 0 festgelegt, und Verweise auf andere Objekte von Elementen der Auflistung werden ebenfalls freigegeben.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> bleibt unverändert. Um die Kapazität des zurückzusetzen <xref:System.Collections.Generic.List%601> , müssen Sie die- <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode oder die- <xref:System.Collections.Generic.List%601.Capacity%2A> Eigenschaft direkt festlegen. Durch das Verringern der Kapazität wird der Arbeitsspeicher neu zugewiesen und alle Elemente in kopiert <xref:System.Collections.Generic.List%601> . Durch Kürzen eines leeren wird <xref:System.Collections.Generic.List%601> die Kapazität von <xref:System.Collections.Generic.List%601> auf die Standardkapazität festgelegt.  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  

 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Clear%2A> -Methode und verschiedene andere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen-Klasse veranschaulicht. Die <xref:System.Collections.Generic.List%601.Clear%2A> -Methode wird am Ende des Programms verwendet, um alle Elemente aus der Liste zu entfernen, und <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.Count%2A> dann werden die Eigenschaften und angezeigt.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Bestimmt, ob sich ein Element in <see cref="T:System.Collections.Generic.List`1" /> befindet.</summary>
        <returns><see langword="true" />, wenn das <paramref name="item" /> in der <see cref="T:System.Collections.Generic.List`1" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt Gleichheit mithilfe des Standard Gleichheits Vergleichs, wie durch die Implementierung der-Methode des-Objekts definiert <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> `T` (den Typ der Werte in der Liste).  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Contains%2A> -Methode und die- <xref:System.Collections.Generic.List%601.Exists%2A> Methode in einem veranschaulicht <xref:System.Collections.Generic.List%601> , das ein einfaches Geschäftsobjekt enthält, das implementiert <xref:System.IEquatable%601.Equals%2A> .  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb" id="Snippet1"::: 
  
 Das folgende Beispiel enthält eine Liste komplexer Objekte des Typs `Cube` . Die- `Cube` Klasse implementiert die- <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> Methode, sodass zwei Cubes als gleich betrachtet werden, wenn ihre Dimensionen identisch sind. In diesem Beispiel gibt die- <xref:System.Collections.Generic.List%601.Contains%2A> Methode zurück `true` , weil ein Cube mit den angegebenen Dimensionen bereits in der Auflistung vorhanden ist.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Der Typ der Elemente des Zielarrays.</typeparam>
        <param name="converter">Ein <see cref="T:System.Converter`2" />-Delegat, der jedes Element von einem Typ in einen anderen Typ konvertiert.</param>
        <summary>Konvertiert die Elemente in der aktuellen <see cref="T:System.Collections.Generic.List`1" /> in einen anderen Typ und gibt eine Liste der konvertierten Elemente zurück.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.List`1" /> des Zieltyps, die die konvertierten Elemente aus der aktuellen <see cref="T:System.Collections.Generic.List`1" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Converter%602> ist ein Delegat einer Methode, die ein Objekt in den Zieltyp konvertiert.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Converter%602> , und die konvertierten Elemente werden in der neuen gespeichert <xref:System.Collections.Generic.List%601> .  
  
 Der aktuelle <xref:System.Collections.Generic.List%601> bleibt unverändert.  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel wird eine Methode mit dem Namen definiert `PointFToPoint` , die eine- <xref:System.Drawing.PointF> Struktur in eine- <xref:System.Drawing.Point> Struktur konvertiert. Im Beispiel wird dann eine <xref:System.Collections.Generic.List%601> von <xref:System.Drawing.PointF> Strukturen erstellt, ein Delegat `Converter\<PointF, Point>` ( `Converter(Of PointF, Point)` in Visual Basic) erstellt, um die `PointFToPoint` Methode darzustellen, und der Delegat wird an die Methode weitergeleitet <xref:System.Collections.Generic.List%601.ConvertAll%2A> . Die <xref:System.Collections.Generic.List%601.ConvertAll%2A> -Methode übergibt jedes Element der Eingabeliste an die `PointFToPoint` -Methode und fügt die konvertierten Elemente in eine neue Liste von- <xref:System.Drawing.Point> Strukturen ein. Beide Listen werden angezeigt.  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="converter" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert <see cref="T:System.Collections.Generic.List`1" /> oder einen Teil davon in ein Array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
   
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der- <xref:System.Collections.Generic.List%601.CopyTo%2A> Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit 5 Zeichen folgen gefüllt. Ein leeres Zeichen folgen Array mit 15 Elementen wird erstellt, und die- <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> Methoden Überladung wird verwendet, um alle Elemente der Liste in das Array zu kopieren, beginnend beim ersten Element des Arrays. Die- <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Methoden Überladung wird verwendet, um alle Elemente der Liste in das Array zu kopieren, beginnend am Array Index 6 (wobei Index 5 leer bleibt). Schließlich wird die- <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Methoden Überladung verwendet, um 3 Elemente aus der Liste, beginnend mit Index 2, in das Array zu kopieren, beginnend am Array Index 12 (wobei Index 11 leer bleibt). Daraufhin wird der Inhalt des Arrays angezeigt.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <summary>Kopiert die gesamte <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, wobei am Anfang des Zielarrays begonnen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType> , um die Elemente zu kopieren.  
  
 Die Elemente werden <xref:System.Array> in derselben Reihenfolge in den kopiert, in der der Enumerator durchläuft <xref:System.Collections.Generic.List%601> .  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
 
       ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als die Anzahl von Elementen, die das Ziel-<paramref name="array" /> enthalten kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die gesamte <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, beginnend am angegebenen Index des Zielarrays.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType> , um die Elemente zu kopieren.  
  
 Die Elemente werden <xref:System.Array> in derselben Reihenfolge in den kopiert, in der der Enumerator durchläuft <xref:System.Collections.Generic.List%601> .  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
   
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index in der Quell-<see cref="T:System.Collections.Generic.List`1" />, ab dem mit dem Kopieren begonnen wird.</param>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.List`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <param name="count">Die Anzahl der zu kopierenden Elemente.</param>
        <summary>Kopiert einen Bereich von Elementen aus der <see cref="T:System.Collections.Generic.List`1" /> in ein kompatibles eindimensionales Array, beginnend ab dem angegebenen Index im Zielarray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Copy%2A?displayProperty=nameWithType> , um die Elemente zu kopieren.  
  
 Die Elemente werden <xref:System.Array> in derselben Reihenfolge in den kopiert, in der der Enumerator durchläuft <xref:System.Collections.Generic.List%601> .  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist `count` .  
   
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="arrayIndex" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> ist gleich oder größer als die <see cref="P:System.Collections.Generic.List`1.Count" /> der Quell-<see cref="T:System.Collections.Generic.List`1" />.  
  
Oder 
Die Anzahl der Elemente vom <paramref name="index" /> bis zum Ende der Quell-<see cref="T:System.Collections.Generic.List`1" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1">P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Collections.Generic.List`1" /> enthalten sind.</summary>
        <value>Die Anzahl der Elemente, die in <see cref="T:System.Collections.Generic.List`1" /> enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> die Anzahl der Elemente, die von der <xref:System.Collections.Generic.List%601> gespeichert werden können, bevor die Größe geändert wird. <xref:System.Collections.Generic.List%601.Count%2A> die Anzahl der Elemente, die tatsächlich in der sind <xref:System.Collections.Generic.List%601> .  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> ist immer größer als oder gleich <xref:System.Collections.Generic.List%601.Count%2A> . Wenn <xref:System.Collections.Generic.List%601.Count%2A> <xref:System.Collections.Generic.List%601.Capacity%2A> beim Hinzufügen von Elementen überschreitet, wird die Kapazität erhöht, indem das interne Array automatisch neu zugewiesen wird, bevor die alten Elemente kopiert und die neuen Elemente hinzugefügt werden.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie die Kapazität und die Anzahl von einem-  <xref:System.Collections.Generic.List%601> Objekt überprüft werden, das ein einfaches Geschäftsobjekt enthält, und die Verwendung der-Methode veranschaulicht, <xref:System.Collections.Generic.List%601.TrimExcess%2A> um zusätzliche Kapazität zu entfernen.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb" id="Snippet1":::
  
 Das folgende Beispiel zeigt den Wert der- <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaft an verschiedenen Punkten während der Lebensdauer einer Liste. Nachdem die Liste erstellt und ausgefüllt und die zugehörigen Elemente angezeigt wurden, <xref:System.Collections.Generic.List%601.Capacity%2A> werden die <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften und angezeigt. Diese Eigenschaften werden erneut angezeigt, nachdem die <xref:System.Collections.Generic.List%601.TrimExcess%2A> -Methode aufgerufen wurde, und wieder, nachdem der Inhalt der Liste gelöscht wurde.  

 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Bestimmt, ob die <see cref="T:System.Collections.Generic.List`1" /> Elemente enthält, die mit den vom angegebenen Prädikat definierten Bedingungen übereinstimmen.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Collections.Generic.List`1" /> ein oder mehr Elemente enthält, die die durch das angegebene Prädikat definierten Bedingungen erfüllen; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Predicate%601> , und die Verarbeitung wird beendet, wenn eine Entsprechung gefunden wird.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Contains%2A> -Methode und die- <xref:System.Collections.Generic.List%601.Exists%2A> Methode in einem veranschaulicht <xref:System.Collections.Generic.List%601> , das ein einfaches Geschäftsobjekt enthält, das implementiert <xref:System.IEquatable%601.Equals%2A> .  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb" id="Snippet1":::
  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.Exists%2A> -Methode und verschiedene andere Methoden veranschaulicht, die den generischen-Delegaten verwenden <xref:System.Predicate%601> .  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, die acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Beispiel definiert auch eine Such Prädikat Methode `EndsWithSaurus` mit dem Namen, die einen Zeichen folgen Parameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Collections.Generic.List%601.Find%2A> <xref:System.Collections.Generic.List%601.FindLast%2A> -,-und- <xref:System.Collections.Generic.List%601.FindAll%2A> Methoden werden verwendet, um die Liste mit der Such Prädikat Methode zu durchsuchen, und anschließend wird die- <xref:System.Collections.Generic.List%601.RemoveAll%2A> Methode verwendet, um alle Einträge zu entfernen, die mit "saurus" enden.  
  
 Zum Schluss wird die- <xref:System.Collections.Generic.List%601.Exists%2A> Methode aufgerufen. Sie durchläuft die Liste von Anfang an, wobei jedes Element wiederum an die- `EndsWithSaurus` Methode übergeben wird. Die Suche wird beendet, und die Methode gibt zurück, `true` Wenn die `EndsWithSaurus` Methode `true` für ein beliebiges Element zurückgibt. Die <xref:System.Collections.Generic.List%601.Exists%2A> Methode gibt zurück, `false` da alle diese Elemente entfernt wurden.  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das erste Vorkommen im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Das erste Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten weitergegeben <xref:System.Predicate%601> , <xref:System.Collections.Generic.List%601> und zwar im vorwärts-Element, beginnend mit dem ersten Element und endet mit dem letzten Element.  Die Verarbeitung wird beendet, wenn eine Entsprechung gefunden wird.  
  
> [!IMPORTANT]
>  Stellen Sie beim Durchsuchen einer Liste, die Werttypen enthält, sicher, dass der Standardwert für den Typ nicht das Such Prädikat erfüllt. Andernfalls gibt es keine Möglichkeit, zwischen einem Standardwert zu unterscheiden, der angibt, dass keine Entsprechung gefunden wurde, und einem List-Element, das den Standardwert für den Typ hat. Wenn der Standardwert das Such Prädikat erfüllt, verwenden Sie <xref:System.Collections.Generic.List%601.FindIndex%2A> stattdessen die-Methode.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel wird die- <xref:System.Collections.Generic.List%601.Find%2A> Methode für ein- <xref:System.Collections.Generic.List%601> Objekt veranschaulicht, das ein einfaches komplexes Objekt enthält.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb" id="Snippet1":::
  
 Im folgenden Beispiel werden die Find-Methoden für die- <xref:System.Collections.Generic.List%601> Klasse veranschaulicht. Das Beispiel für die- <xref:System.Collections.Generic.List%601> Klasse enthält die- `book` Objekte der-Klasse `Book` mithilfe der Daten aus der [XML-Beispieldatei: Books (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die- `FillList` Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , um die Werte aus der XML-Datei mit den Eigenschafts Werten der-Objekte zu analysieren `book` .  
  
 In der folgenden Tabelle werden die Beispiele für die Find-Methoden beschrieben.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht ein Buch mit dem Prädikat Delegaten über eine ID `IDToFind` .<br /><br /> C#-Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen aller Bücher, deren `Genre` Eigenschaft "Computer" ist, mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung mit einem Veröffentlichungsdatum vor 2001 mit dem `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs in der zweiten Hälfte der Sammlung mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs in der zweiten Hälfte der Sammlung mit dem `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, nach denen gesucht werden soll.</param>
        <summary>Ruft alle Elemente ab, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Eine <see cref="T:System.Collections.Generic.List`1" /> mit allen Elementen, die ggf. die durch das angegebene Prädikat definierten Bedingungen erfüllen, andernfalls eine leere <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Predicate%601> , und die Elemente, die den Bedingungen entsprechen, werden in der zurückgegebenen gespeichert <xref:System.Collections.Generic.List%601> .  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel werden die Find-Methoden für die- <xref:System.Collections.Generic.List%601> Klasse veranschaulicht. Das Beispiel für die- <xref:System.Collections.Generic.List%601> Klasse enthält die- `book` Objekte der-Klasse `Book` mithilfe der Daten aus der [XML-Beispieldatei: Books (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die- `FillList` Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , um die Werte aus der XML-Datei mit den Eigenschafts Werten der-Objekte zu analysieren `book` .  
  
 In der folgenden Tabelle werden die Beispiele für die Find-Methoden beschrieben.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht ein Buch mit dem Prädikat Delegaten über eine ID `IDToFind` .<br /><br /> C#-Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen aller Bücher, deren `Genre` Eigenschaft "Computer" ist, mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung mit einem Veröffentlichungsdatum vor 2001 mit dem `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs in der zweiten Hälfte der Sammlung mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs in der zweiten Hälfte der Sammlung mit dem `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch ein angegebenes Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens in der <see cref="T:System.Collections.Generic.List`1" /> oder einem Teil davon zurück. Diese Methode gibt -1 zurück, wenn kein Element gefunden wird, das den Bedingungen entspricht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird nach vorne durchsucht, beginnend beim ersten Element und endet beim letzten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Predicate%601> . Der Delegat hat die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel wird eine `Employee` -Klasse mit zwei Feldern definiert: `Name` und `Id` . Außerdem wird eine- `EmployeeSearch` Klasse mit der einzelnen Methode definiert, die `StartsWith` angibt, ob das `Employee.Name` Feld mit einer angegebenen Teil Zeichenfolge beginnt, die für den `EmployeeSearch` Klassenkonstruktor bereitgestellt wird. Beachten Sie die Signatur dieser Methode.  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 entspricht der Signatur des Delegaten, der an die-Methode übermittelt werden kann <xref:System.Collections.Generic.List%601.FindIndex%2A> . Im Beispiel wird ein-Objekt instanziiert `List<Employee>` , eine Reihe von `Employee` -Objekten hinzugefügt und dann die- <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> Methode zweimal aufgerufen, um die gesamte Auflistung zu durchsuchen, das erste Mal für das erste `Employee` Objekt, dessen `Name` Feld mit "J" beginnt, und das zweite Mal für das erste `Employee` Objekt, dessen `Name` Feld mit "Ju" beginnt.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb" id="Snippet2":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der vom angegebenen Index bis zum letzten Element reicht.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird nach vorne durchsucht, beginnend bei `startIndex` und endet beim letzten Element.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Predicate%601> . Der Delegat hat die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* die Anzahl der Elemente von `startIndex` bis zum Ende der ist <xref:System.Collections.Generic.List%601> .
  
## Examples  
 Im folgenden Beispiel wird eine `Employee` -Klasse mit zwei Feldern definiert: `Name` und `Id` . Außerdem wird eine- `EmployeeSearch` Klasse mit der einzelnen Methode definiert, die `StartsWith` angibt, ob das `Employee.Name` Feld mit einer angegebenen Teil Zeichenfolge beginnt, die für den `EmployeeSearch` Klassenkonstruktor bereitgestellt wird. Beachten Sie die Signatur dieser Methode.  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 entspricht der Signatur des Delegaten, der an die-Methode übermittelt werden kann <xref:System.Collections.Generic.List%601.FindIndex%2A> . Im Beispiel wird ein-Objekt instanziiert `List<Employee>` , eine Reihe von `Employee` -Objekten hinzugefügt und dann die- <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> Methode zweimal aufgerufen, um die Auflistung beginnend mit ihrem fünften Element (d. h. dem-Member bei Index 4) zu durchsuchen. Beim ersten Mal sucht die Anwendung nach dem ersten `Employee` Objekt, dessen `Name` Feld mit "J" beginnt. beim zweiten Mal wird nach dem ersten Objekt gesucht, `Employee` dessen `Name` Feld mit "Ju" beginnt.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb" id="Snippet3"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Suche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen umfasst.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden; andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird nach vorne durchsucht `startIndex` , beginnend bei und endet bei `startIndex` Plus `count` 1, wenn `count` größer als 0 ist.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Predicate%601> . Der Delegat hat die Signatur:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist `count` .
  
## Examples  
 Im folgenden Beispiel wird eine `Employee` -Klasse mit zwei Feldern definiert: `Name` und `Id` . Außerdem wird eine- `EmployeeSearch` Klasse mit der einzelnen Methode definiert, die `StartsWith` angibt, ob das `Employee.Name` Feld mit einer angegebenen Teil Zeichenfolge beginnt, die für den `EmployeeSearch` Klassenkonstruktor bereitgestellt wird. Beachten Sie die Signatur dieser Methode.  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 entspricht der Signatur des Delegaten, der an die-Methode übermittelt werden kann <xref:System.Collections.Generic.List%601.FindIndex%2A> . Im Beispiel wird ein-Objekt instanziiert `List<Employee>` , eine Reihe von `Employee` -Objekten hinzugefügt und dann die-Methode zweimal aufgerufen, um die gesamte Auflistung (d. h. <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> die Elemente von Index 0 bis Index <xref:System.Collections.Generic.List%601.Count%2A> -1) zu durchsuchen. Beim ersten Mal sucht die Anwendung nach dem ersten `Employee` Objekt, dessen `Name` Feld mit "J" beginnt. beim zweiten Mal wird nach dem ersten Objekt gesucht, `Employee` dessen `Name` Feld mit "Ju" beginnt.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt das letzte Vorkommen im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Das letzte Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, sofern vorhanden, andernfalls der Standardwert für den Typ <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten weitergegeben <xref:System.Predicate%601> , wobei das-Element in den rückwärts verschoben <xref:System.Collections.Generic.List%601> wird, beginnend mit dem letzten-Element und endende mit dem ersten Element.  Die Verarbeitung wird beendet, wenn eine Entsprechung gefunden wird.  
  
> [!IMPORTANT]
>  Stellen Sie beim Durchsuchen einer Liste, die Werttypen enthält, sicher, dass der Standardwert für den Typ nicht das Such Prädikat erfüllt. Andernfalls gibt es keine Möglichkeit, zwischen einem Standardwert zu unterscheiden, der angibt, dass keine Entsprechung gefunden wurde, und einem List-Element, das den Standardwert für den Typ hat. Wenn der Standardwert das Such Prädikat erfüllt, verwenden Sie <xref:System.Collections.Generic.List%601.FindLastIndex%2A> stattdessen die-Methode.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel werden die Find-Methoden für die- <xref:System.Collections.Generic.List%601> Klasse veranschaulicht. Das Beispiel für die- <xref:System.Collections.Generic.List%601> Klasse enthält die- `book` Objekte der-Klasse `Book` mithilfe der Daten aus der [XML-Beispieldatei: Books (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die- `FillList` Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , um die Werte aus der XML-Datei mit den Eigenschafts Werten der-Objekte zu analysieren `book` .  
  
 In der folgenden Tabelle werden die Beispiele für die Find-Methoden beschrieben.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht ein Buch mit dem Prädikat Delegaten über eine ID `IDToFind` .<br /><br /> C#-Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen aller Bücher, deren `Genre` Eigenschaft "Computer" ist, mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung mit einem Veröffentlichungsdatum vor 2001 mit dem `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs in der zweiten Hälfte der Sammlung mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs in der zweiten Hälfte der Sammlung mit dem `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht nach einem Element, das die durch ein angegebenes Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens in der <see cref="T:System.Collections.Generic.List`1" /> oder einem Teil davon zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens im gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird rückwärts nach dem letzten Element und mit dem ersten Element durchsucht.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Predicate%601> .  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel werden die Find-Methoden für die- <xref:System.Collections.Generic.List%601> Klasse veranschaulicht. Das Beispiel für die- <xref:System.Collections.Generic.List%601> Klasse enthält die- `book` Objekte der-Klasse `Book` mithilfe der Daten aus der [XML-Beispieldatei: Books (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die- `FillList` Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , um die Werte aus der XML-Datei mit den Eigenschafts Werten der-Objekte zu analysieren `book` .  
  
 In der folgenden Tabelle werden die Beispiele für die Find-Methoden beschrieben.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht ein Buch mit dem Prädikat Delegaten über eine ID `IDToFind` .<br /><br /> C#-Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen aller Bücher, deren `Genre` Eigenschaft "Computer" ist, mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung mit einem Veröffentlichungsdatum vor 2001 mit dem `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs in der zweiten Hälfte der Sammlung mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs in der zweiten Hälfte der Sammlung mit dem `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der vom ersten Element bis zum angegeben Index reicht.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Collections.Generic.List%601> -Element wird nach hinten `startIndex` und am ersten Element durchsucht.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Predicate%601> .  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* die Anzahl der Elemente vom Anfang <xref:System.Collections.Generic.List%601> bis zum ist `startIndex` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für das Element definiert, nach dem gesucht werden soll.</param>
        <summary>Sucht nach einem Element, das die durch das angegebene Prädikat definierten Bedingungen erfüllt, und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen im <see cref="T:System.Collections.Generic.List`1" /> zurück, der die angegebene Anzahl von Elementen umfasst und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommnisses eines Elements, das mit den durch <paramref name="match" /> definierten Bedingungen übereinstimmt, sofern gefunden, andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird nach hinten durchsucht `startIndex` , beginnend bei und endet bei `startIndex` minus `count` plus 1, wenn `count` größer als 0 ist.  
  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Predicate%601> .  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist `count` .
  
## Examples  
 Im folgenden Beispiel werden die Find-Methoden für die- <xref:System.Collections.Generic.List%601> Klasse veranschaulicht. Das Beispiel für die- <xref:System.Collections.Generic.List%601> Klasse enthält die- `book` Objekte der-Klasse `Book` mithilfe der Daten aus der [XML-Beispieldatei: Books (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Die- `FillList` Methode im Beispiel verwendet [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , um die Werte aus der XML-Datei mit den Eigenschafts Werten der-Objekte zu analysieren `book` .  
  
 In der folgenden Tabelle werden die Beispiele für die Find-Methoden beschrieben.  
  
|Methode|Beispiel|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Sucht ein Buch mit dem Prädikat Delegaten über eine ID `IDToFind` .<br /><br /> C#-Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Suchen aller Bücher, deren `Genre` Eigenschaft "Computer" ist, mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Sucht das letzte Buch in der Auflistung mit einem Veröffentlichungsdatum vor 2001 mit dem `PubBefore2001` Prädikat Delegaten.<br /><br /> C#-Beispiel verwendet einen anonymen Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des ersten Computer Buchs in der zweiten Hälfte der Sammlung mit dem `FindComputer` Prädikat Delegaten.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Sucht den Index des letzten Computer Buchs in der zweiten Hälfte der Sammlung mit dem `FindComputer` Prädikat Delegaten.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="startIndex" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Der <see cref="T:System.Action`1" />-Delegat, der für jedes Element von <see cref="T:System.Collections.Generic.List`1" /> ausgeführt werden soll.</param>
        <summary>Führt die angegebene Aktion für jedes Element der <see cref="T:System.Collections.Generic.List`1" /> aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Action%601> ist ein Delegat für eine Methode, die eine Aktion für das an ihn weiter gegebene Objekt ausführt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Action%601> .  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 Das Ändern der zugrunde liegenden Auflistung im Hauptteil des Delegaten <xref:System.Action%601> wird nicht unterstützt und verursacht ein nicht definiertes Verhalten.
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der-Delegat <xref:System.Action%601> zum Drucken des Inhalts eines-Objekts verwendet wird <xref:System.Collections.Generic.List%601> . In diesem Beispiel wird die- `Print` Methode verwendet, um den Inhalt der Liste in der Konsole anzuzeigen.  
  
> [!NOTE]
>  Im c#-Beispiel wird nicht nur der Inhalt mithilfe der-Methode angezeigt, sondern es `Print` wird auch die Verwendung [anonymer Methoden](/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-methods) zum Anzeigen der Ergebnisse in der Konsole veranschaulicht.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs" interactive="try-dotnet-method" id="Snippet01":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb" id="Snippet01":::  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Ein Element in der Sammlung wurde geändert.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator? GetEnumerator ();" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der das <see cref="T:System.Collections.Generic.List`1" />-Objekt durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.List`1.Enumerator" /> für die <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- `foreach` Anweisung der c#-Sprache ( `for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist die- <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> Eigenschaft nicht definiert. Daher muss die-Methode aufgerufen werden <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> , um den Enumerator vor dem Lesen des Werts von auf das erste Element der Auflistung zu setzen <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> .  
  
 Die- <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> Eigenschaft gibt dasselbe Objekt zurück, bis <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> legt <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert bleibt. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste Rückruf von <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> oder löst <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> eine aus <xref:System.InvalidOperationException> .  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte <see cref="T:System.Collections.Generic.List`1" />-Index, an dem der Bereich beginnt.</param>
        <param name="count">Die Anzahl der Elemente im Bereich.</param>
        <summary>Erstellt eine flache Kopie eines Bereichs von Elementen in der Quell-<see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Eine flache Kopie eines Bereichs von Elementen in der Quell-<see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine flache Kopie einer Auflistung von Verweis Typen oder eine Teilmenge dieser Auflistung enthält nur die Verweise auf die Elemente der Auflistung. Die Objekte selbst werden nicht kopiert. Die Verweise in der neuen Liste zeigen auf die gleichen Objekte wie die Verweise in der ursprünglichen Liste.  
  
 Eine flache Kopie einer Auflistung von Werttypen oder eine Teilmenge dieser Auflistung enthält die Elemente der Auflistung. Wenn die Elemente der Auflistung jedoch Verweise auf andere Objekte enthalten, werden diese Objekte nicht kopiert. Die Verweise in den Elementen der neuen Auflistung zeigen auf die gleichen Objekte wie die Verweise in den Elementen der ursprünglichen Auflistung.  
  
 Im Gegensatz dazu kopiert eine tiefe Kopie einer Auflistung die Elemente und alle Elemente, die direkt oder indirekt von den Elementen referenziert werden.  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist `count` .
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.GetRange%2A> -Methode und andere Methoden der- <xref:System.Collections.Generic.List%601> Klasse veranschaulicht, die auf Bereiche reagieren. Am Ende des Beispiels wird die- <xref:System.Collections.Generic.List%601.GetRange%2A> Methode verwendet, um drei Elemente aus der Liste zu erhalten, beginnend mit Indexposition 2. Die- <xref:System.Collections.Generic.List%601.ToArray%2A> Methode wird für das resultierende aufgerufen <xref:System.Collections.Generic.List%601> und erstellt ein Array aus drei Elementen. Die Elemente des Arrays werden angezeigt.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1"::: 

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den nullbasierten Index des ersten Vorkommens eines Werts in der <see cref="T:System.Collections.Generic.List`1" /> bzw. in einem Abschnitt davon zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der- <xref:System.Collections.Generic.List%601.IndexOf%2A> Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, mit einem Eintrag, der zweimal angezeigt wird, an Indexposition 0 und Index Speicherort 5. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> -Methoden Überladung durchsucht die Liste von Anfang an und findet das erste Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> -Methoden Überladung wird verwendet, um die Liste zu durchsuchen, beginnend mit Index Speicherort 3 und bis zum Ende der Liste, und findet das zweite Vorkommen der Zeichenfolge. Schließlich wird die <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> -Methoden Überladung verwendet, um einen Bereich von zwei Einträgen zu durchsuchen, beginnend bei Indexposition 2; Sie gibt-1 zurück, da es keine Instanzen der Such Zeichenfolge in diesem Bereich gibt.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb der gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des ggf. ersten Vorkommens von <paramref name="item" /> in der gesamten <see cref="T:System.Collections.Generic.List`1" />, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird nach vorne durchsucht, beginnend beim ersten Element und endet beim letzten Element.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T` , dem Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Suche. 0 (null) ist in einer leeren Liste gültig.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der sich vom angegebenen Index bis zum letzten Element erstreckt.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in <see cref="T:System.Collections.Generic.List`1" />, der sich von <paramref name="index" /> bis zum letzten Element erstreckt, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird nach vorne durchsucht, beginnend bei `index` und endet beim letzten Element.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T` , dem Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* die Anzahl der Elemente von `index` bis zum Ende der ist <xref:System.Collections.Generic.List%601> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Suche. 0 (null) ist in einer leeren Liste gültig.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des ersten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der am angegebenen Index beginnt und die angegebene Anzahl von Elementen enthält.</summary>
        <returns>Der nullbasierte Index des ersten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in <see cref="T:System.Collections.Generic.List`1" />, der am <paramref name="index" /> beginnt und eine Anzahl von Elementen <paramref name="count" /> enthält, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird nach vorne durchsucht `index` , beginnend bei und endet bei `index` Plus `count` 1, wenn `count` größer als 0 ist.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T` , dem Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist `count` .  
  
  ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <paramref name="item" /> eingefügt werden soll.</param>
        <param name="item">Das einzufügende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.Generic.List`1" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> bereits entspricht <xref:System.Collections.Generic.List%601.Capacity%2A> , wird die Kapazität des <xref:System.Collections.Generic.List%601> erhöht, indem das interne Array automatisch neu zugewiesen wird und die vorhandenen Elemente in das neue Array kopiert werden, bevor das neue Element hinzugefügt wird.  
  
 Wenn `index` gleich ist <xref:System.Collections.Generic.List%601.Count%2A> , `item` wird am Ende von hinzugefügt <xref:System.Collections.Generic.List%601> .  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie ein einfaches Geschäftsobjekt in einem hinzugefügt, entfernt und eingefügt wird <xref:System.Collections.Generic.List%601> .  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs" id="Snippet1":::
  
 Im folgenden Beispiel wird die- <xref:System.Collections.Generic.List%601.Insert%2A> Methode zusammen mit verschiedenen anderen Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen-Klasse veranschaulicht. Nachdem die Liste erstellt wurde, werden Elemente hinzugefügt. Die- <xref:System.Collections.Generic.List%601.Insert%2A> Methode wird verwendet, um ein Element in die Mitte der Liste einzufügen. Das eingefügte Element ist ein Duplikat, das später mithilfe der-Methode entfernt wird <xref:System.Collections.Generic.List%601.Remove%2A> .  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet1"::: 
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> ist größer als <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem neue Elemente eingefügt werden sollen.</param>
        <param name="collection">Die Sammlung, deren Elemente in die <see cref="T:System.Collections.Generic.List`1" /> eingefügt werden sollen. Die Auflistung an sich kann nicht <see langword="null" /> sein, sie kann jedoch Elemente enthalten, die <see langword="null" /> sind, wenn Typ <paramref name="T" /> einen Referenztyp darstellt.</param>
        <summary>Fügt die Elemente einer Auflistung am angegebenen Index in die <see cref="T:System.Collections.Generic.List`1" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
 Wenn das neue <xref:System.Collections.Generic.List%601.Count%2A> (das aktuelle <xref:System.Collections.Generic.List%601.Count%2A> plus die Größe der Auflistung) größer als ist <xref:System.Collections.Generic.List%601.Capacity%2A> , wird die Kapazität des erhöht, <xref:System.Collections.Generic.List%601> indem das interne Array automatisch neu zugewiesen wird, um die neuen Elemente zu berücksichtigen, und die vorhandenen Elemente werden in das neue Array kopiert, bevor die neuen Elemente hinzugefügt werden.  
  
 Wenn `index` gleich ist <xref:System.Collections.Generic.List%601.Count%2A> , werden die Elemente am Ende von hinzugefügt <xref:System.Collections.Generic.List%601> .  
  
 Die Reihenfolge der Elemente in der Auflistung wird im beibehalten <xref:System.Collections.Generic.List%601> .  
  
 Bei dieser Methode handelt es sich um einen O (*n*  *  *m*)-Vorgang, wobei *n* die Anzahl der hinzu zufügenden Elemente und *m* ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.InsertRange%2A> -Methode und verschiedene andere Methoden der- <xref:System.Collections.Generic.List%601> Klasse, die auf Bereiche reagieren. Nachdem die Liste erstellt und mit den Namen von mehreren, friedlichen Pflanzen gegessen werden kann, wird die- <xref:System.Collections.Generic.List%601.InsertRange%2A> Methode verwendet, um in der Liste ein Array von drei wilden fleischfressenden Dinosaurier einzufügen, beginnend bei Indexposition 3.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> ist größer als <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Elements, das abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
 Über diese Eigenschaft können Sie mithilfe der folgenden Syntax auf ein bestimmtes Element der Auflistung zugreifen: `myCollection[index]`.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O (1)-Vorgang. das Festlegen der-Eigenschaft ist ebenfalls ein O (1)-Vorgang.
  
## Examples  
 Das Beispiel in diesem Abschnitt veranschaulicht die <xref:System.Collections.Generic.List%601.Item%2A> -Eigenschaft (Indexer in c#) und verschiedene andere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen-Klasse. Nachdem die Liste erstellt und mithilfe der-Methode aufgefüllt wurde <xref:System.Collections.Generic.List%601.Add%2A> , wird ein-Element mithilfe der-Eigenschaft abgerufen und angezeigt <xref:System.Collections.Generic.List%601.Item%2A> . (Ein Beispiel, in dem die- <xref:System.Collections.Generic.List%601.Item%2A> Eigenschaft verwendet wird, um den Wert eines List-Elements festzulegen, finden Sie unter <xref:System.Collections.Generic.List%601.AsReadOnly%2A> .)  
  
> [!NOTE]
>  Visual Basic, c# und C++ verfügen alle über die Syntax für den Zugriff auf die <xref:System.Collections.Generic.List%601.Item%2A> Eigenschaft, ohne ihren Namen zu verwenden. Stattdessen wird die Variable, die die enthält, <xref:System.Collections.Generic.List%601> so verwendet, als ob es sich um ein Array handelt.  
  
 Die Programmiersprache c# verwendet das- [`this`](/dotnet/csharp/language-reference/keywords/this) Schlüsselwort, um die Indexer zu definieren, statt die-Eigenschaft zu implementieren <xref:System.Collections.Generic.List%601.Item%2A> . Visual Basic implementiert <xref:System.Collections.Generic.List%601.Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet2":::
 [!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
 [!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den nullbasierten Index des letzten Vorkommens eines Werts in der <see cref="T:System.Collections.Generic.List`1" /> bzw. in einem Abschnitt davon zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
 
## Examples  
 Im folgenden Beispiel werden alle drei über Ladungen der- <xref:System.Collections.Generic.List%601.LastIndexOf%2A> Methode veranschaulicht. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, mit einem Eintrag, der zweimal angezeigt wird, an Indexposition 0 und Index Speicherort 5. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> -Methoden Überladung durchsucht die gesamte Liste vom Ende und findet das zweite Vorkommen der Zeichenfolge. Die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> -Methoden Überladung wird verwendet, um die Liste rückwärts zu durchsuchen, beginnend mit Index Speicherort 3 und bis zum Anfang der Liste, sodass das erste Vorkommen der Zeichenfolge in der Liste gefunden wird. Schließlich wird die <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> -Methoden Überladung verwendet, um einen Bereich von vier Einträgen zu durchsuchen, beginnend bei Indexposition 4 und rückwärts (d. h., Sie durchsucht die Elemente an den Positionen 4, 3, 2 und 1). diese Suche gibt-1 zurück, da in diesem Bereich keine Instanzen der Such Zeichenfolge vorhanden sind.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb der gesamten <see cref="T:System.Collections.Generic.List`1" /> zurück.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="item" /> in der gesamten <see cref="T:System.Collections.Generic.List`1" />; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird rückwärts nach dem letzten Element und mit dem ersten Element durchsucht.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T` , dem Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der sich vom angegebenen Index bis zum letzten Element erstreckt.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" />, der sich vom ersten Element bis <paramref name="index" /> erstreckt, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Collections.Generic.List%601> -Element wird nach hinten `index` und am ersten Element durchsucht.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T` , dem Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* die Anzahl der Elemente vom Anfang <xref:System.Collections.Generic.List%601> bis zum ist `index` .  
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.List`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <param name="index">Der nullbasierte Startindex für die Rückwärtssuche.</param>
        <param name="count">Die Anzahl der Elemente im zu durchsuchenden Abschnitt.</param>
        <summary>Sucht nach dem angegebenen Objekt und gibt den nullbasierten Index des letzten Vorkommens innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> zurück, der die angegebene Anzahl von Elementen enthält und am angegebenen Index endet.</summary>
        <returns>Der nullbasierte Index des letzten Vorkommens von <paramref name="item" /> innerhalb des Bereichs von Elementen in der <see cref="T:System.Collections.Generic.List`1" />, der <paramref name="count" /> Anzahl von Elementen enthält und am <paramref name="index" /> endet, sofern gefunden; andernfalls –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.List%601> wird nach hinten durchsucht `index` , beginnend bei und endet bei `index` minus `count` plus 1, wenn `count` größer als 0 ist.  
  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T` , dem Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist `count` .  
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> liegt außerhalb des Bereichs der gültigen Indizes für das <see cref="T:System.Collections.Generic.List`1" />.  
  
- oder - 
 <paramref name="count" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Abschnitt in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das aus der <see cref="T:System.Collections.Generic.List`1" /> zu entfernende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Entfernt das erste Vorkommen eines angegebenen Objekts aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns><see langword="true" />, wenn das <paramref name="item" /> erfolgreich entfernt wurde; andernfalls <see langword="false" />.  Diese Methode gibt auch dann <see langword="false" /> zurück, wenn das <paramref name="item" /> nicht in der <see cref="T:System.Collections.Generic.List`1" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `T` der Typ die <xref:System.IEquatable%601> generische Schnittstelle implementiert, ist der Gleichheits Vergleich die- <xref:System.IEquatable%601.Equals%2A> Methode dieser Schnittstelle; andernfalls ist der Standard Gleichheits Vergleich <xref:System.Object.Equals%2A?displayProperty=nameWithType> .  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie ein einfaches Geschäftsobjekt in einem hinzugefügt, entfernt und eingefügt wird <xref:System.Collections.Generic.List%601> .  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs" id="Snippet1":::
  
 Im folgenden Beispiel wird die- <xref:System.Collections.Generic.List%601.Remove%2A> Methode veranschaulicht. Mehrere Eigenschaften und Methoden der <xref:System.Collections.Generic.List%601> generischen-Klasse werden verwendet, um die Liste hinzuzufügen, einzufügen und zu durchsuchen. Nach diesen Vorgängen enthält die Liste ein Duplikat. Die <xref:System.Collections.Generic.List%601.Remove%2A> -Methode wird verwendet, um die erste Instanz des doppelten Elements zu entfernen, und der Inhalt wird angezeigt. Die- <xref:System.Collections.Generic.List%601.Remove%2A> Methode entfernt immer die erste Instanz, die Sie trifft.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, die entfernt werden sollen.</param>
        <summary>Entfernt alle Elemente, die die vom angegebenen Prädikat definierten Bedingungen erfüllen.</summary>
        <returns>Die Anzahl der aus der <see cref="T:System.Collections.Generic.List`1" />-Klasse entfernten Elemente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Predicate%601> , und die Elemente, die den Bedingungen entsprechen, werden aus entfernt <xref:System.Collections.Generic.List%601> .  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.RemoveAll%2A> -Methode und verschiedene andere Methoden veranschaulicht, die den generischen-Delegaten verwenden <xref:System.Predicate%601> .  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, die acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Beispiel definiert auch eine Such Prädikat Methode `EndsWithSaurus` mit dem Namen, die einen Zeichen folgen Parameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die <xref:System.Collections.Generic.List%601.Find%2A> <xref:System.Collections.Generic.List%601.FindLast%2A> -,-und- <xref:System.Collections.Generic.List%601.FindAll%2A> Methoden werden verwendet, um die Liste mit der Such Prädikat Methode zu durchsuchen.  
  
 Die- <xref:System.Collections.Generic.List%601.RemoveAll%2A> Methode wird verwendet, um alle Einträge zu entfernen, die mit "saurus" enden. Sie durchläuft die Liste von Anfang an, wobei jedes Element wiederum an die- `EndsWithSaurus` Methode übergeben wird. Das-Element wird entfernt, wenn die- `EndsWithSaurus` Methode zurückgibt `true` .  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 Zum Schluss <xref:System.Collections.Generic.List%601.Exists%2A> überprüft die Methode, ob in der Liste keine Zeichen folgen vorhanden sind, die mit "saurus" enden.  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des zu entfernenden Elements.</param>
        <summary>Entfernt das Element am angegebenen Index aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie <xref:System.Collections.Generic.List%601.RemoveAt%2A> zum Entfernen eines Elements aufzurufen, werden die restlichen Elemente in der Liste neu umbenannt, um das entfernte Element zu ersetzen. Wenn Sie z. b. das Element am Index 3 entfernen, wird das Element bei Index 4 an die 3-Position verschoben. Außerdem wird die Anzahl der Elemente in der Liste (wie durch die- <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaft dargestellt) um 1 reduziert.  
  
 Diese Methode ist ein O (*n*)-Vorgang, wobei *n* gleich ( <xref:System.Collections.Generic.List%601.Count%2A>  -  `index` ) ist.
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein einfaches Geschäftsobjekt in einem hinzugefügt, entfernt und eingefügt wird <xref:System.Collections.Generic.List%601> .  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb" id="Snippet1":::
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="index" /> ist größer oder gleich <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu entfernenden Bereichs von Elementen.</param>
        <param name="count">Die Anzahl der zu entfernenden Elemente.</param>
        <summary>Entfernt einen Bereich von Elementen aus der <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden entfernt, und alle Elemente, die in der enthalten sind, werden <xref:System.Collections.Generic.List%601> von reduziert `count` .  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.RemoveRange%2A> -Methode und verschiedene andere Methoden der- <xref:System.Collections.Generic.List%601> Klasse veranschaulicht, die auf Bereiche reagieren. Nachdem die Liste erstellt und geändert wurde, wird die- <xref:System.Collections.Generic.List%601.RemoveRange%2A> Methode verwendet, um zwei Elemente aus der Liste zu entfernen, beginnend bei Indexposition 2.  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kehrt die Reihenfolge der Elemente in der <see cref="T:System.Collections.Generic.List`1" /> bzw. in einem Teil davon um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel werden beide über Ladungen der- <xref:System.Collections.Generic.List%601.Reverse%2A> Methode veranschaulicht. Im Beispiel wird eine von Zeichen folgen erstellt <xref:System.Collections.Generic.List%601> und sechs Zeichen folgen hinzugefügt. Die <xref:System.Collections.Generic.List%601.Reverse> -Methoden Überladung wird zum Umkehren der Liste verwendet, und anschließend <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> wird die-Methoden Überladung verwendet, um die Mitte der Liste umzukehren, beginnend mit Element 1 und umfasst vier Elemente.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kehrt die Reihenfolge der Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Reverse%2A?displayProperty=nameWithType> , um die Reihenfolge der Elemente umzukehren.  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des Bereichs, in dem die Reihenfolge umgekehrt werden soll.</param>
        <param name="count">Die Anzahl der Elemente im Bereich, in dem die Reihenfolge umgekehrt werden soll.</param>
        <summary>Kehrt die Reihenfolge der Elemente im angegebenen Bereich um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet <xref:System.Array.Reverse%2A?displayProperty=nameWithType> , um die Reihenfolge der Elemente umzukehren.  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
   
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> an.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortiert die Elemente oder einen Teil der Elemente in <see cref="T:System.Collections.Generic.List`1" />, entweder über die angegebene oder eine Standardimplementierung von <see cref="T:System.Collections.Generic.IComparer`1" /> oder über einen bereitgestellten <see cref="T:System.Comparison`1" />-Delegat zum Vergleichen von Listenelementen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des Standardcomparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet den Standard Vergleich für den- <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Typ `T` , um die Reihenfolge der Listenelemente zu bestimmen. Die <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> -Eigenschaft überprüft `T` , ob der Typ die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Wenn nicht, wird <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob `T` der Typ die- <xref:System.IComparable> Schnittstelle implementiert.  Wenn der Typ `T` eine der beiden Schnittstellen nicht implementiert, löst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> eine aus <xref:System.InvalidOperationException> .  
  
 Diese Methode verwendet die- <xref:System.Array.Sort%2A?displayProperty=nameWithType> Methode, die die Introspektion wie folgt anwendet:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein Einfügungs Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 Protokoll *n*überschreitet, wobei *n* der Bereich des Eingabe Arrays ist, wird ein Heapsort-Algorithmus verwendet.  
  
-   Andernfalls wird ein QuickSort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O (*n* log *n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  

 Im folgenden Beispiel werden einige Namen zu einem-Objekt hinzugefügt. `List<String>` die Liste wird in der unsortierten Reihenfolge angezeigt, die <xref:System.Collections.Generic.List%601.Sort%2A> -Methode wird aufgerufen, und anschließend wird die sortierte Liste angezeigt.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb" id="Snippet2":::
  
 Der folgende Code veranschaulicht die <xref:System.Collections.Generic.List%601.Sort> -und- <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> Methoden Überladungen für ein einfaches Geschäftsobjekt. Das Aufrufen der- <xref:System.Collections.Generic.List%601.Sort> Methode führt zur Verwendung des Standardcomparers für den Teiltyp, und die- <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> Methode wird mit einer anonymen Methode implementiert.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb" id="Snippet1":::  
  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort> -Methoden Überladung und die- <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Methoden Überladung. Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste wird angezeigt, sortiert und erneut angezeigt.  
  
 Die <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> -Methoden Überladung wird dann verwendet, um nach zwei Zeichen folgen zu suchen, die nicht in der Liste enthalten sind, und die- <xref:System.Collections.Generic.List%601.Insert%2A> Methode wird verwendet, um Sie einzufügen. Der Rückgabewert der- <xref:System.Collections.Generic.List%601.BinarySearch%2A> Methode ist in jedem Fall negativ, da die Zeichen folgen nicht in der Liste enthalten sind. Das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) dieser negativen Zahl erzeugt den Index des ersten Elements in der Liste, das größer als die Such Zeichenfolge ist, und das Einfügen an dieser Stelle behält die Sortierreihenfolge bei. Die zweite Such Zeichenfolge ist größer als jedes Element in der Liste, sodass sich die Einfügeposition am Ende der Liste befindet.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann keine Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> finden.</exception>
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen Comparers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` angegeben wird, werden die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der angegebenen Implementierung sortiert <xref:System.Collections.Generic.IComparer%601> .  
  
 Wenn `comparer` `null` den Wert hat, überprüft der Standardcomparer, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> ob `T` der Typ die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Wenn nicht, wird <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob `T` der Typ die- <xref:System.IComparable> Schnittstelle implementiert.  Wenn der Typ `T` eine der beiden Schnittstellen nicht implementiert, löst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> eine aus <xref:System.InvalidOperationException> .  
  
 Diese Methode verwendet die- <xref:System.Array.Sort%2A?displayProperty=nameWithType> Methode, die die Introspektion wie folgt anwendet:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein Einfügungs Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 Protokoll *n*überschreitet, wobei *n* der Bereich des Eingabe Arrays ist, wird ein Heapsort-Algorithmus verwendet.  
  
-   Andernfalls wird ein QuickSort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O (*n* log *n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> -Methoden Überladung und die- <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methoden Überladung.  
  
 Im Beispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen DinoCompare definiert, der die `IComparer<string>` `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich funktioniert wie folgt: zuerst werden die Vergleiche für getestet `null` , und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste wird angezeigt, mit dem alternativen Vergleich sortiert und erneut angezeigt.  
  
 Die- <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methoden Überladung wird dann verwendet, um nach mehreren Zeichen folgen zu suchen, die nicht in der Liste enthalten sind, wobei der Alternative Vergleich verwendet wird. Die- <xref:System.Collections.Generic.List%601.Insert%2A> Methode wird zum Einfügen der Zeichen folgen verwendet. Diese beiden Methoden befinden sich in der-Funktion `SearchAndInsert` mit dem Namen, zusammen mit dem Code, um das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) der negativen Zahl zu verwenden, die von zurückgegeben wird, <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> und verwenden es als Index zum Einfügen der neuen Zeichenfolge.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> nicht finden.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">Die <see cref="T:System.Comparison`1" />, die beim Vergleich von Elementen verwendet werden soll.</param>
        <summary>Sortiert die Elemente in der gesamten <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparison` angegeben wird, werden die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der Methode sortiert, die durch den-Delegaten dargestellt wird.  
  
 Wenn den Wert `comparison` `null` hat, wird eine ausgelöst <xref:System.ArgumentNullException> .  
  
 Diese Methode verwendet <xref:System.Array.Sort%2A?displayProperty=nameWithType> , wodurch die introspektiven Sortierung wie folgt angewendet wird:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein Einfügungs Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 Protokoll *n*überschreitet, wobei *n* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein QuickSort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O (*n* log *n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Der folgende Code veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%2A> -und- <xref:System.Collections.Generic.List%601.Sort%2A> Methoden Überladungen für ein einfaches Geschäftsobjekt. Das Aufrufen der- <xref:System.Collections.Generic.List%601.Sort%2A> Methode führt zur Verwendung des Standardcomparers für den Teiltyp, und die- <xref:System.Collections.Generic.List%601.Sort%2A> Methode wird mit einer anonymen Methode implementiert.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb" id="Snippet1"::: 
  
 Im folgenden Beispiel wird die- <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> Methoden Überladung veranschaulicht.  
  
 Im Beispiel wird eine Alternative Vergleichsmethode für Zeichen folgen mit dem Namen definiert `CompareDinosByLength` . Diese Methode funktioniert wie folgt: zuerst werden die Vergleiche für getestet `null` , und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit vier Zeichen folgen ohne bestimmte Reihenfolge aufgefüllt. Die Liste enthält auch eine leere Zeichenfolge und einen NULL-Verweis. Die Liste wird angezeigt, mithilfe eines generischen Delegaten sortiert <xref:System.Comparison%601> , der die `CompareDinosByLength` Methode darstellt, und wird erneut angezeigt.  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparison" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Implementierung von <paramref name="comparison" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparison" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt;? comparer);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Startindex des zu sortierenden Bereichs.</param>
        <param name="count">Die Länge des zu sortierenden Bereichs.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die beim Vergleichen von Elementen verwendet werden soll, oder <see langword="null" />, wenn der Standardvergleich <see cref="P:System.Collections.Generic.Comparer`1.Default" /> verwendet werden soll.</param>
        <summary>Sortiert die Elemente in einem Bereich von Elementen in der <see cref="T:System.Collections.Generic.List`1" /> mithilfe des angegebenen Vergleichs.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `comparer` angegeben wird, werden die Elemente der <xref:System.Collections.Generic.List%601> mithilfe der angegebenen Implementierung sortiert <xref:System.Collections.Generic.IComparer%601> .  
  
 Wenn `comparer` `null` den Wert hat, überprüft der Standardcomparer, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> ob `T` der Typ die <xref:System.IComparable%601> generische Schnittstelle implementiert, und verwendet diese Implementierung, falls verfügbar.  Wenn nicht, wird <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> überprüft, ob `T` der Typ die- <xref:System.IComparable> Schnittstelle implementiert.  Wenn der Typ `T` eine der beiden Schnittstellen nicht implementiert, löst <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> eine aus <xref:System.InvalidOperationException> .  
  
 Diese Methode verwendet <xref:System.Array.Sort%2A?displayProperty=nameWithType> , wodurch die introspektiven Sortierung wie folgt angewendet wird:  
  
-   Wenn die Partitionsgröße kleiner als oder gleich 16 Elementen ist, wird ein Einfügungs Algorithmus verwendet.  
  
-   Wenn die Anzahl der Partitionen 2 Protokoll *n*überschreitet, wobei *n* der Bereich des Eingabe Arrays ist, wird ein [Heapsort](https://en.wikipedia.org/wiki/Heapsort) -Algorithmus verwendet.  
  
-   Andernfalls wird ein QuickSort-Algorithmus verwendet.  
  
 Diese Implementierung führt eine instabile Sortierung aus. Das heißt, wenn zwei Elemente gleich sind, wird ihre Reihenfolge möglicherweise nicht beibehalten. Im Gegensatz dazu behält eine stabile Sortierung die Reihenfolge der Elemente bei, die gleich sind.  
  
 Bei dieser Methode handelt es sich um einen O (*n* log *n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> -Methoden Überladung und die- <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methoden Überladung.  
  
 Im Beispiel wird ein alternativer Vergleich für Zeichen folgen mit dem Namen DinoCompare definiert, der die `IComparer<string>` `IComparer(Of String)` `IComparer<String^>` generische Schnittstelle (in Visual Basic Visual C++) implementiert. Der Vergleich funktioniert wie folgt: zuerst werden die Vergleiche für getestet `null` , und ein NULL-Verweis wird als kleiner als ein nicht-NULL-Wert behandelt. Zweitens werden die Zeichen folgen Längen verglichen, und die längere Zeichenfolge wird als größer eingestuft. Drittens: Wenn die Längen gleich sind, wird der normale Zeichen folgen Vergleich verwendet.  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt und mit den Namen von fünf herbialous-dinosaern und drei karnevaliösen dinosaern aufgefüllt. Innerhalb der beiden Gruppen befinden sich die Namen nicht in einer bestimmten Sortierreihenfolge. Die Liste wird angezeigt, der Bereich der HERBIVORES wird mit dem alternativen Comparer sortiert, und die Liste wird erneut angezeigt.  
  
 Die- <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Methoden Überladung wird dann verwendet, um nur den Bereich von HERBIVORES für "Brachiosaurus" zu durchsuchen. Die Zeichenfolge wurde nicht gefunden, und das bitweise Komplement (der ~-Operator in c# und Visual C++, `Xor` -1 in Visual Basic) der negativen Zahl, die von der-Methode zurückgegeben <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> wird, wird als Index zum Einfügen der neuen Zeichenfolge verwendet.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.  
  
- oder - 
 <paramref name="count" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> und <paramref name="count" /> geben keinen gültigen Bereich in der <see cref="T:System.Collections.Generic.List`1" /> an.  
  
Oder 
Die Implementierung von <paramref name="comparer" /> hat einen Fehler während der Sortierung verursacht. Beispielsweise gibt <paramref name="comparer" /> beim Vergleichen eines Elements mit sich selbst möglicherweise nicht 0 zurück.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> ist <see langword="null" />, und der Standardcomparer <see cref="P:System.Collections.Generic.Comparer`1.Default" /> kann die Implementierung der generischen <see cref="T:System.IComparable`1" />-Schnittstelle oder der <see cref="T:System.IComparable" />-Schnittstelle für den Typ <paramref name="T" /> nicht finden.</exception>
        <related type="Article" href="/dotnet/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Sammlungen</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly : bool" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der das Ändern der Auflistung verhindert. Wenn also Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, reflektiert die schreibgeschützte Auflistung diese Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;&#xA;override this.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;" Usage="list.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerator`1" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- `foreach` Anweisung der c#-Sprache ( `for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist die- <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Eigenschaft nicht definiert. Daher muss die-Methode aufgerufen werden <xref:System.Collections.IEnumerator.MoveNext%2A> , um den Enumerator vor dem Lesen des Werts von auf das erste Element der Auflistung zu setzen <xref:System.Collections.Generic.IEnumerator%601.Current%2A> .  
  
 Die- <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Eigenschaft gibt dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.Generic.IEnumerator%601.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert bleibt. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste Rückruf von <xref:System.Collections.IEnumerator.MoveNext%2A> oder löst <xref:System.Collections.IEnumerator.Reset%2A> eine aus <xref:System.InvalidOperationException> .  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As Array, arrayIndex As Integer) Implements ICollection.CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.ICollection.CopyTo : Array * int -&gt; unit&#xA;override this.System.Collections.ICollection.CopyTo : Array * int -&gt; unit" Usage="list.System.Collections.ICollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.ICollection" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.ICollection" /> in ein <see cref="T:System.Array" />, beginnend bei einem bestimmten <see cref="T:System.Array" />-Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ der Quelle <xref:System.Collections.ICollection> nicht automatisch in den Zieltyp umgewandelt werden kann, werden `array` die nicht generischen Implementierungen von <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw ausgelöst <xref:System.InvalidCastException> , während die generischen Implementierungen auslösen <xref:System.ArgumentException> .  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
 <paramref name="array" /> verwendet keine nullbasierte Indizierung.  
  
- oder - 
Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.ICollection" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />s.  
  
Oder 
Der Typ der Quell-<see cref="T:System.Collections.ICollection" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.IsSynchronized : bool" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value><see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  In den seltenen Fällen, in denen enumerationskonflikte mit Schreibzugriffen auftreten, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Die Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt Sperren, bevor Sie auf die Auflistung zugreifen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.SyncRoot : obj" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.  In der Standardimplementierung der <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer die aktuelle Instanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Die Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt Sperren, bevor Sie auf die Auflistung zugreifen. Der folgende Code zeigt die Verwendung der <xref:System.Collections.ICollection.SyncRoot%2A> -Eigenschaft für c#, C++ und Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="list.System.Collections.IEnumerable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- `foreach` Anweisung der c#-Sprache ( `for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist die- <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft nicht definiert. Daher muss die-Methode aufgerufen werden <xref:System.Collections.IEnumerator.MoveNext%2A> , um den Enumerator vor dem Lesen des Werts von auf das erste Element der Auflistung zu setzen <xref:System.Collections.IEnumerator.Current%2A> .  
  
 Die- <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft gibt dasselbe Objekt zurück, bis entweder <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert bleibt. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste Rückruf von <xref:System.Collections.IEnumerator.MoveNext%2A> oder löst <xref:System.Collections.IEnumerator.Reset%2A> eine aus <xref:System.InvalidOperationException> .  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Add : obj -&gt; int&#xA;override this.System.Collections.IList.Add : obj -&gt; int" Usage="list.System.Collections.IList.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das <see cref="T:System.Object" />, das in <see cref="T:System.Collections.IList" /> eingefügt werden soll.</param>
        <summary>Fügt der <see cref="T:System.Collections.IList" /> ein Element hinzu.</summary>
        <returns>Die Position, an der das neue Element eingefügt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Collections.Generic.List%601.Count%2A> kleiner als ist <xref:System.Collections.Generic.List%601.Capacity%2A> , ist diese Methode ein O (1)-Vorgang. Wenn die Kapazität für das neue Element erweitert werden muss, wird diese Methode zu einem O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Contains : obj -&gt; bool&#xA;override this.System.Collections.IList.Contains : obj -&gt; bool" Usage="list.System.Collections.IList.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das <see cref="T:System.Object" />, das in der <see cref="T:System.Collections.IList" /> gesucht werden soll.</param>
        <summary>Ermittelt, ob die <see cref="T:System.Collections.IList" /> einen bestimmten Wert enthält.</summary>
        <returns><see langword="true" />, wenn das <paramref name="item" /> in der <see cref="T:System.Collections.IList" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T` , dem Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.IndexOf : obj -&gt; int&#xA;override this.System.Collections.IList.IndexOf : obj -&gt; int" Usage="list.System.Collections.IList.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.IList" /> zu suchende Objekt.</param>
        <summary>Bestimmt den Index eines bestimmten Elements in der <see cref="T:System.Collections.IList" />.</summary>
        <returns>Der Index von <paramref name="item" />, wenn das Element in der Liste gefunden wird, andernfalls -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T` , dem Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Insert : int * obj -&gt; unit&#xA;override this.System.Collections.IList.Insert : int * obj -&gt; unit" Usage="list.System.Collections.IList.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index, an dem <paramref name="item" /> eingefügt werden soll.</param>
        <param name="item">Das in die <see cref="T:System.Collections.IList" /> einzufügende Objekt.</param>
        <summary>Fügt am angegebenen Index ein Element in die <see cref="T:System.Collections.IList" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `index` gleich der Anzahl der Elemente in <xref:System.Collections.IList> ist, wird `item` am Ende angefügt.  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.IsFixedSize : bool" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Collections.IList" /> eine feste Größe aufweist.</summary>
        <value>Ist <see langword="true" />, wenn die <see cref="T:System.Collections.IList" /> eine feste Größe aufweist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Auflistung mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem Erstellen der Auflistung nicht zu. Vorhandene Elemente können jedoch geändert werden.  
  
 Eine Auflistung mit fester Größe ist einfach eine Sammlung mit einem Wrapper, der das Hinzufügen und Entfernen von Elementen verhindert. Wenn Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, einschließlich hinzufügen oder Entfernen von Elementen, reflektiert die Auflistung mit fester Größe diese Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.IsReadOnly : bool" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.IList" /> schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Collections.IList" /> schreibgeschützt ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.List`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der das Ändern der Auflistung verhindert. Wenn also Änderungen an der zugrunde liegenden Auflistung vorgenommen werden, reflektiert die schreibgeschützte Auflistung diese Änderungen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.IList.Item(int) : obj with get, set" Usage="System.Collections.IList.Item" />
      <MemberSignature Language="C#" Value="object? System.Collections.IList.Item[int index] { get; set; }" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Der nullbasierte Index des Elements, das abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft das Element am angegebenen Index ab oder legt dieses fest.</summary>
        <value>Das Element am angegebenen Index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Programmiersprache c# verwendet das [this](/dotnet/csharp/language-reference/keywords/this) -Schlüsselwort zum Definieren der Indexer, anstatt die-Eigenschaft zu implementieren <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> . Visual Basic implementiert <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O (1)-Vorgang. das Festlegen der-Eigenschaft ist ebenfalls ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kein gültiger Index in <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">Die Eigenschaft wird festgelegt, und der <paramref name="value" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IList.Remove : obj -&gt; unit&#xA;override this.System.Collections.IList.Remove : obj -&gt; unit" Usage="list.System.Collections.IList.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Das aus der <see cref="T:System.Collections.IList" /> zu entfernende Objekt.</param>
        <summary>Entfernt das erste Vorkommen eines angegebenen Objekts aus der <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T` , dem Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (*n*)-Vorgang, wobei *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> weist einen Typ auf, der der <see cref="T:System.Collections.IList" /> nicht zugeordnet werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.Generic.List`1" /> in ein neues Array.</summary>
        <returns>Ein Array, das Kopien der Elemente aus <see cref="T:System.Collections.Generic.List`1" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Elemente werden mithilfe von kopiert <xref:System.Array.Copy%2A?displayProperty=nameWithType> . dabei handelt es sich um einen O (*n*)-Vorgang, wobei *n* ist <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.ToArray%2A> -Methode und andere Methoden der- <xref:System.Collections.Generic.List%601> Klasse veranschaulicht, die auf Bereiche reagieren. Am Ende des Beispiels wird die- <xref:System.Collections.Generic.List%601.GetRange%2A> Methode verwendet, um drei Elemente aus der Liste zu erhalten, beginnend mit Indexposition 2. Die- <xref:System.Collections.Generic.List%601.ToArray%2A> Methode wird für das resultierende aufgerufen <xref:System.Collections.Generic.List%601> und erstellt ein Array aus drei Elementen. Die Elemente des Arrays werden angezeigt.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb" id="Snippet1"::: 
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die Kapazität auf die Anzahl der tatsächlich in der <see cref="T:System.Collections.Generic.List`1" /> befindlichen Elemente fest, sofern diese Anzahl unter dem Schwellenwert liegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Arbeitsspeicher Aufwand einer Sammlung zu minimieren, wenn der Auflistung keine neuen Elemente hinzugefügt werden. Die Kosten für das erneute zuordnen und Kopieren eines großen <xref:System.Collections.Generic.List%601> kann jedoch beträchtlich sein, sodass die- <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode nichts bewirkt, wenn die Liste mehr als 90 Prozent der Kapazität hat. Dadurch wird vermieden, dass für einen relativ kleinen Gewinn keine großen Kosten für die erneute Zuordnung anfallen.  
  
> [!NOTE]
>  Der aktuelle Schwellenwert von 90 Prozent kann sich in zukünftigen Versionen ändern.  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .  
  
 Um einen <xref:System.Collections.Generic.List%601> auf seinen ursprünglichen Zustand zurückzusetzen, rufen Sie die-Methode auf, <xref:System.Collections.Generic.List%601.Clear%2A> bevor Sie die-Methode aufrufen <xref:System.Collections.Generic.List%601.TrimExcess%2A> . Durch Kürzen eines leeren wird <xref:System.Collections.Generic.List%601> die Kapazität von <xref:System.Collections.Generic.List%601> auf die Standardkapazität festgelegt.  
  
 Die Kapazität kann auch mit der-Eigenschaft festgelegt werden <xref:System.Collections.Generic.List%601.Capacity%2A> .
  
## Examples  

 Im folgenden Beispiel wird veranschaulicht, wie die Kapazität und die Anzahl von einem-  <xref:System.Collections.Generic.List%601> Objekt überprüft werden, das ein einfaches Geschäftsobjekt enthält, und die Verwendung der-Methode veranschaulicht, <xref:System.Collections.Generic.List%601.TrimExcess%2A> um zusätzliche Kapazität zu entfernen.  
 
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb" id="Snippet1":::
  
 Das folgende Beispiel veranschaulicht die <xref:System.Collections.Generic.List%601.TrimExcess%2A> Methode. Mehrere Eigenschaften und Methoden der- <xref:System.Collections.Generic.List%601> Klasse werden zum Hinzufügen, einfügen und Entfernen von Elementen aus einer Liste von Zeichen folgen verwendet. Anschließend <xref:System.Collections.Generic.List%601.TrimExcess%2A> wird die-Methode verwendet, um die Kapazität so zu reduzieren, dass Sie der Anzahl entspricht, und die <xref:System.Collections.Generic.List%601.Capacity%2A> -und- <xref:System.Collections.Generic.List%601.Count%2A> Eigenschaften werden angezeigt. Wenn die nicht genutzte Kapazität weniger als 10 Prozent der Gesamtkapazität war, wurde die Größe der Liste nicht geändert. Schließlich wird der Inhalt der Liste gelöscht.  
 
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb" id="Snippet1":::  
 :::code language="fsharp" source="~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen definiert, auf die die Elemente geprüft werden sollen.</param>
        <summary>Bestimmt, ob jedes Element in der <see cref="T:System.Collections.Generic.List`1" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt.</summary>
        <returns><see langword="true" />, wenn jedes Element in der <see cref="T:System.Collections.Generic.List`1" /> die vom angegebenen Prädikat definierten Bedingungen erfüllt; andernfalls <see langword="false" />. Wenn die Liste über keine Elemente verfügt, ist der Rückgabewert <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Predicate%601> ist ein Delegat für eine Methode, die zurückgibt, `true` Wenn das an Sie übergebenen Objekt mit den im Delegaten definierten Bedingungen übereinstimmt.  Die Elemente der aktuellen <xref:System.Collections.Generic.List%601> werden einzeln an den-Delegaten übermittelt <xref:System.Predicate%601> , und die Verarbeitung wird beendet, wenn der Delegat `false` für ein beliebiges Element zurückgibt. Die Elemente werden in der Reihenfolge verarbeitet, und alle Aufrufe werden in einem einzelnen Thread durchgeführt.  
  
 Diese Methode ist ein O (*n*)-Vorgang, bei dem *n* gleich ist <xref:System.Collections.Generic.List%601.Count%2A> .
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Collections.Generic.List%601.TrueForAll%2A> -Methode und verschiedene andere Methoden veranschaulicht, die einen generischen Delegaten verwenden <xref:System.Predicate%601> .  
  
 Eine <xref:System.Collections.Generic.List%601> von Zeichen folgen wird erstellt, die acht Dinosaurier Namen enthält, von denen zwei (an den Positionen 1 und 5) mit "saurus" enden. Das Beispiel definiert auch eine Such Prädikat Methode `EndsWithSaurus` mit dem Namen, die einen Zeichen folgen Parameter akzeptiert und einen booleschen Wert zurückgibt, der angibt, ob die Eingabe Zeichenfolge auf "saurus" endet.  
  
 Die- <xref:System.Collections.Generic.List%601.TrueForAll%2A> Methode durchläuft die Liste von Anfang an, wobei jedes Element wiederum an die-Methode übergeben wird `EndsWithSaurus` . Die Suche wird beendet, wenn die- `EndsWithSaurus` Methode zurückgibt `false` .  
  
> [!NOTE]
>  In c# und Visual Basic muss der Delegat `Predicate<string>` ( `Predicate(Of String)` in Visual Basic) nicht explizit erstellt werden. Diese Sprachen ableiten den korrekten Delegaten aus dem Kontext und erstellen ihn automatisch.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
