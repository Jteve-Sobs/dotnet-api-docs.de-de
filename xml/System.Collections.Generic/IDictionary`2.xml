<Type Name="IDictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="23a7800a49026caf07e10668535c53939b31f522" /><Meta Name="ms.sourcegitcommit" Value="05b28af3128fd8a2fe51178c9a1cc798d4601bf7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/12/2020" /><Meta Name="ms.locfileid" Value="83230984" /></Metadata><TypeSignature Language="C#" Value="public interface IDictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDictionary`2&lt;TKey, TValue&gt; implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.IDictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IEnumerable(Of KeyValuePair(Of TKey, TValue))" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public interface class IDictionary : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;" />
  <TypeSignature Language="F#" Value="type IDictionary&lt;'Key, 'Value&gt; = interface&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TKey">Der Typ der Schlüssel im Wörterbuch.</typeparam>
    <typeparam name="TValue">Der Typ der Werte im Wörterbuch.</typeparam>
    <summary>Stellt eine generische Auflistung von Schlüssel-Wert-Paaren dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.IDictionary%602>-Schnittstelle ist die Basisschnittstelle für generische Auflistungen von Schlüssel-Wert-Paaren.  
  
 Jedes Element ist ein Schlüssel-Wert-Paar, das in einem <xref:System.Collections.Generic.KeyValuePair%602> Objekt gespeichert wird.  
  
 Jedes Paar muss über einen eindeutigen Schlüssel verfügen. Implementierungen können unterschiedlich sein, unabhängig davon, ob `key` `null`werden können. Der Wert kann `null` und muss nicht eindeutig sein. Die <xref:System.Collections.Generic.IDictionary%602>-Schnittstelle ermöglicht das Auflisten der enthaltenen Schlüssel und Werte, aber Sie impliziert keine bestimmte Sortierreihenfolge.  
  
 Die `foreach`-Anweisung der C# Sprache (`For Each` in Visual Basic, `for each` in C++) gibt ein Objekt des Typs der Elemente in der Auflistung zurück. Da jedes Element des <xref:System.Collections.Generic.IDictionary%602> ein Schlüssel-Wert-Paar ist, ist der Elementtyp nicht der Typ des Schlüssels oder der Typ des Werts. Stattdessen wird der Elementtyp <xref:System.Collections.Generic.KeyValuePair%602>. Beispiel:  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source2.cpp" id="Snippet11":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source2.cs" id="Snippet11":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source2.vb" id="Snippet11":::
  
 Bei der `foreach`-Anweisung handelt es sich um einen Wrapper um den Enumerator, der nur das Lesen von, das Schreiben in die Auflistung ermöglicht.  
  
> [!NOTE]
>  Da Schlüssel geerbt werden können und ihr Verhalten geändert wird, kann die absolute Eindeutigkeit nicht durch Vergleiche mithilfe der <xref:System.Type.Equals%2A>-Methode garantiert werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine leere <xref:System.Collections.Generic.Dictionary%602> von Zeichen folgen mit Zeichen folgen Schlüsseln erstellt und über die <xref:System.Collections.Generic.IDictionary%602>-Schnittstelle darauf zugegriffen.  
  
 Das Codebeispiel verwendet die <xref:System.Collections.Generic.IDictionary%602.Add%2A>-Methode, um einige Elemente hinzuzufügen. Das Beispiel zeigt, dass die <xref:System.Collections.Generic.IDictionary%602.Add%2A>-Methode <xref:System.ArgumentException> auslöst, wenn versucht wird, einen doppelten Schlüssel hinzuzufügen.  
  
 Im Beispiel wird die <xref:System.Collections.Generic.IDictionary%602.Item%2A>-Eigenschaft (der Indexer C#in) verwendet, um Werte abzurufen. Dies zeigt, dass eine <xref:System.Collections.Generic.KeyNotFoundException> ausgelöst wird, wenn ein angeforderter Schlüssel nicht vorhanden ist, und dass der Wert, der einem Schlüssel zugeordnet ist, ersetzt werden kann.  
  
 Das Beispiel zeigt, wie die <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A>-Methode als effizientere Methode zum Abrufen von Werten verwendet wird, wenn ein Programm häufig Schlüsselwerte, die nicht im Wörterbuch enthalten sind, testen muss und die <xref:System.Collections.Generic.IDictionary%602.ContainsKey%2A>-Methode verwenden, um zu testen, ob ein Schlüssel vorhanden ist, bevor die <xref:System.Collections.Generic.IDictionary%602.Add%2A>-Methode aufgerufen wird.  
  
 Schließlich wird im Beispiel gezeigt, wie die Schlüssel und Werte im Wörterbuch aufgelistet werden und wie die Werte allein mithilfe der <xref:System.Collections.Generic.IDictionary%602.Values%2A>-Eigenschaft aufgelistet werden.  
  
  [!code-cpp[Generic.IDictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#1)]
  [!code-csharp[Generic.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#1)]
  [!code-vb[Generic.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#1)]  

 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Die implementierende Klasse muss über eine Mittel zum Vergleichen von Schlüsseln verfügen.</para></block>
    <altmember cref="T:System.Collections.Generic.ICollection`1" />
    <altmember cref="N:System.Collections" />
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; unit" Usage="iDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Das Objekt, das als Schlüssel des hinzuzufügenden Elements verwendet werden soll.</param>
        <param name="value">Das Objekt, das als Wert des hinzuzufügenden Elements verwendet werden soll.</param>
        <summary>Fügt der <see cref="T:System.Collections.Generic.IDictionary`2" />-Schnittstelle ein Element mit dem angegebenen Schlüssel und Wert hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch die <xref:System.Collections.Generic.IDictionary%602.Item%2A>-Eigenschaft verwenden, um neue Elemente hinzuzufügen, indem Sie den Wert eines Schlüssels festlegen, der nicht im Wörterbuch vorhanden ist. beispielsweise `myCollection["myNonexistentKey"] = myValue` in C# (`myCollection("myNonexistentKey") = myValue` in Visual Basic). Wenn der angegebene Schlüssel jedoch bereits im Wörterbuch vorhanden ist, überschreibt das Festlegen der <xref:System.Collections.Generic.IDictionary%602.Item%2A> Eigenschaft den alten Wert. Im Gegensatz dazu werden durch die <xref:System.Collections.Generic.IDictionary%602.Add%2A>-Methode vorhandene Elemente nicht geändert.  
  
 Implementierungen können variieren, wie Sie die Gleichheit von Objekten bestimmen. beispielsweise verwendet die <xref:System.Collections.Generic.List%601>-Klasse <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, während die <xref:System.Collections.Generic.Dictionary%602>-Klasse es dem Benutzer ermöglicht, die <xref:System.Collections.Generic.IComparer%601> Implementierung anzugeben, die zum Vergleichen von Schlüsseln verwendet werden soll.  
  
 Implementierungen können unterschiedlich sein, unabhängig davon, ob `key` `null`werden können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine leere <xref:System.Collections.Generic.Dictionary%602> von Zeichen folgen mit ganzzahligen Schlüsseln erstellt und über die <xref:System.Collections.Generic.IDictionary%602>-Schnittstelle darauf zugegriffen. Das Codebeispiel verwendet die <xref:System.Collections.Generic.IDictionary%602.Add%2A>-Methode, um einige Elemente hinzuzufügen. Das Beispiel zeigt, dass die <xref:System.Collections.Generic.IDictionary%602.Add%2A>-Methode eine <xref:System.ArgumentException> auslöst, wenn versucht wird, einen doppelten Schlüssel hinzuzufügen.  
  
 Dieser Code ist Teil eines größeren Beispiels, der kompiliert und ausgeführt werden kann. Siehe <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
  :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp" id="Snippet2":::
  :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs" interactive="try-dotnet-method" id="Snippet2":::
  :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb" id="Snippet2":::
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">In <see cref="T:System.Collections.Generic.IDictionary`2" /> ist bereits ein Element mit demselben Schlüssel enthalten.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Generic.IDictionary`2" /> ist schreibgeschützt.</exception>
        <altmember cref="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
        <altmember cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool" Usage="iDictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.Generic.IDictionary`2" /> zu suchende Schlüssel.</param>
        <summary>Ermittelt, ob das <see cref="T:System.Collections.Generic.IDictionary`2" /> ein Element mit dem angegebenen Schlüssel enthält.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Collections.Generic.IDictionary`2" /> ein Element mit dem Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementierungen können variieren, wie Sie die Gleichheit von Objekten bestimmen. beispielsweise verwendet die <xref:System.Collections.Generic.List%601>-Klasse <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, während die <xref:System.Collections.Generic.Dictionary%602>-Klasse es dem Benutzer ermöglicht, die <xref:System.Collections.Generic.IComparer%601> Implementierung anzugeben, die zum Vergleichen von Schlüsseln verwendet werden soll.  
  
 Implementierungen können unterschiedlich sein, unabhängig davon, ob `key` `null`werden können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Collections.Generic.IDictionary%602.ContainsKey%2A>-Methode verwendet wird, um zu testen, ob ein Schlüssel vorhanden ist, bevor die <xref:System.Collections.Generic.IDictionary%602.Add%2A>-Methode aufgerufen wird. Außerdem wird gezeigt, wie die <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A>-Methode verwendet wird, die eine effizientere Methode zum Abrufen von Werten sein kann, wenn ein Programm häufig Schlüsselwerte verwendet, die nicht im Wörterbuch vorhanden sind. Schließlich wird gezeigt, wie Elemente mithilfe <xref:System.Collections.Generic.IDictionary%602.Item%2A>-Eigenschaft (Indexer in C#) eingefügt werden.  
  
 Dieser Code ist Teil eines größeren Beispiels, der kompiliert und ausgeführt werden kann. Siehe <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#6](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#6)]
 [!code-csharp[Generic.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#6)]
 [!code-vb[Generic.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#6)]  
[!code-cpp[Generic.IDictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.IDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#5)]
[!code-vb[Generic.IDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#5)]  
[!code-cpp[Generic.IDictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des Elements, das abgerufen oder festgelegt werden soll.</param>
        <summary>Ruft das Element mit dem angegebenen Schlüssel ab oder legt dieses fest.</summary>
        <value>Das Element mit dem angegebenen Schlüssel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe der folgenden Syntax: `myCollection[key]` (`myCollection(key)` in Visual Basic).  
  
 Sie können auch die <xref:System.Collections.Generic.IDictionary%602.Item%2A>-Eigenschaft verwenden, um neue Elemente hinzuzufügen, indem Sie den Wert eines Schlüssels festlegen, der nicht im Wörterbuch vorhanden ist. beispielsweise `myCollection["myNonexistentKey"] = myValue` in C# (`myCollection("myNonexistentKey") = myValue` in Visual Basic). Wenn der angegebene Schlüssel jedoch bereits im Wörterbuch vorhanden ist, überschreibt das Festlegen der <xref:System.Collections.Generic.IDictionary%602.Item%2A> Eigenschaft den alten Wert. Im Gegensatz dazu werden durch die <xref:System.Collections.Generic.IDictionary%602.Add%2A>-Methode vorhandene Elemente nicht geändert.  
  
 Implementierungen können variieren, wie Sie die Gleichheit von Objekten bestimmen. beispielsweise verwendet die <xref:System.Collections.Generic.List%601>-Klasse <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, während die <xref:System.Collections.Generic.Dictionary%602>-Klasse es dem Benutzer ermöglicht, die <xref:System.Collections.Generic.IComparer%601> Implementierung anzugeben, die zum Vergleichen von Schlüsseln verwendet werden soll.  
  
 Die C# Sprache verwendet das [this](~/docs/csharp/language-reference/keywords/this.md) -Schlüsselwort zum Definieren der Indexer, anstatt die <xref:System.Collections.Generic.IDictionary%602.Item%2A>-Eigenschaft zu implementieren. Visual Basic implementiert <xref:System.Collections.Generic.IDictionary%602.Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Implementierungen können unterschiedlich sein, unabhängig davon, ob `key` `null`werden können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Collections.Generic.IDictionary%602.Item%2A>-Eigenschaft (der Indexer C#in) verwendet, um Werte abzurufen. Dies zeigt, dass eine <xref:System.Collections.Generic.KeyNotFoundException> ausgelöst wird, wenn ein angeforderter Schlüssel nicht vorhanden ist, und dass der Wert, der einem Schlüssel zugeordnet ist, ersetzt werden kann.  
  
 Das Beispiel zeigt auch, wie die <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A>-Methode als effizientere Methode zum Abrufen von Werten verwendet wird, wenn ein Programm häufig Schlüsselwerte ausprobieren muss, die nicht im Wörterbuch vorhanden sind.  
  
 Dieser Code ist Teil eines größeren Beispiels, der kompiliert und ausgeführt werden kann. Siehe <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#3](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#3)]
 [!code-csharp[Generic.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#3)]
 [!code-vb[Generic.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#3)]  
[!code-cpp[Generic.IDictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#4)]  
[!code-cpp[Generic.IDictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.IDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#5)]
[!code-vb[Generic.IDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Die Eigenschaft wird abgerufen, und <paramref name="key" /> wird nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException">Die Eigenschaft wird festgelegt, und <see cref="T:System.Collections.Generic.IDictionary`2" /> ist schreibgeschützt.</exception>
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.IDictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TKey&gt; ^ Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.ICollection&lt;'Key&gt;" Usage="System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.Generic.ICollection`1" /> ab, die die Schlüssel des <see cref="T:System.Collections.Generic.IDictionary`2" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.Generic.ICollection`1" />, die die Schlüssel des Objekts enthält, das <see cref="T:System.Collections.Generic.IDictionary`2" /> implementiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Schlüssel in der zurückgegebenen <xref:System.Collections.Generic.ICollection%601> ist nicht angegeben, es ist jedoch garantiert, dass Sie die gleiche Reihenfolge wie die entsprechenden Werte in der <xref:System.Collections.Generic.ICollection%601> haben, die von der <xref:System.Collections.Generic.IDictionary%602.Values%2A>-Eigenschaft zurückgegeben werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Schlüssel allein mit der <xref:System.Collections.Generic.IDictionary%602.Keys%2A>-Eigenschaft aufgelistet werden.  
  
 Dieser Code ist Teil eines größeren Beispiels, der kompiliert und ausgeführt werden kann. Siehe <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#9](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#9)]
 [!code-csharp[Generic.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#9)]
 [!code-vb[Generic.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; bool" Usage="iDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Schlüssel aus dem <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <returns><see langword="true" />, wenn das Element erfolgreich entfernt wurde, andernfalls <see langword="false" />.  Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="key" /> nicht im ursprünglichen <see cref="T:System.Collections.Generic.IDictionary`2" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementierungen können variieren, wie Sie die Gleichheit von Objekten bestimmen. beispielsweise verwendet die <xref:System.Collections.Generic.List%601>-Klasse <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, während die <xref:System.Collections.Generic.Dictionary%602>-Klasse es dem Benutzer ermöglicht, die <xref:System.Collections.Generic.IComparer%601> Implementierung anzugeben, die zum Vergleichen von Schlüsseln verwendet werden soll.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein Schlüssel-Wert-Paar mithilfe der <xref:System.Collections.Generic.IDictionary%602.Remove%2A>-Methode aus einem Wörterbuch entfernt wird.  
  
 Dieser Code ist Teil eines größeren Beispiels, der kompiliert und ausgeführt werden kann. Siehe <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#10](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#10)]
 [!code-csharp[Generic.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#10)]
 [!code-vb[Generic.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.Generic.IDictionary`2" /> ist schreibgeschützt.</exception>
        <altmember cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key * 'Value -&gt; bool" Usage="iDictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel, dessen Wert abgerufen werden soll.</param>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den dem angegebenen Schlüssel zugeordneten Wert, wenn der Schlüssel gefunden wird, andernfalls enthält sie den Standardwert für den Typ des <paramref name="value" />-Parameters. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Ruft den dem angegebenen Schlüssel zugeordneten Wert ab.</summary>
        <returns><see langword="true" />, wenn das Objekt, das <see cref="T:System.Collections.Generic.IDictionary`2" /> implementiert, ein Element mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kombiniert die Funktionalität der <xref:System.Collections.Generic.IDictionary%602.ContainsKey%2A>-Methode und der <xref:System.Collections.Generic.IDictionary%602.Item%2A>-Eigenschaft.  
  
 Wenn der Schlüssel nicht gefunden wird, ruft der `value`-Parameter den entsprechenden Standardwert für den Typ `TValue`ab. beispielsweise NULL (0) für ganzzahlige Typen, `false` für boolesche Typen und `null` für Verweis Typen.  
  
   
  
## Examples  
 Im Beispiel wird gezeigt, wie die <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A>-Methode zum Abrufen von Werten verwendet wird. Wenn ein Programm häufig Schlüsselwerte ausprobiert, die sich nicht in einem Wörterbuch befinden, kann die <xref:System.Collections.Generic.IDictionary%602.TryGetValue%2A> Methode effizienter sein als die Verwendung der <xref:System.Collections.Generic.IDictionary%602.Item%2A>-Eigenschaft ( C#Indexer in), die beim Versuch, nicht vorhandene Schlüssel abzurufen, Ausnahmen auslöst.  
  
 Dieser Code ist Teil eines größeren Beispiels, der kompiliert und ausgeführt werden kann. Siehe <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#5)]
 [!code-csharp[Generic.IDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#5)]
 [!code-vb[Generic.IDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#5)]  
[!code-cpp[Generic.IDictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.IDictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection(Of TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TValue&gt; ^ Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.ICollection&lt;'Value&gt;" Usage="System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.Generic.ICollection`1" /> ab, die die Werte im <see cref="T:System.Collections.Generic.IDictionary`2" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.Generic.ICollection`1" />, die die Werte des Objekts enthält, das <see cref="T:System.Collections.Generic.IDictionary`2" /> implementiert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Werte in der zurückgegebenen <xref:System.Collections.Generic.ICollection%601> ist nicht angegeben, es ist jedoch garantiert, dass Sie die gleiche Reihenfolge wie die entsprechenden Schlüssel in der <xref:System.Collections.Generic.ICollection%601> haben, die von der <xref:System.Collections.Generic.IDictionary%602.Keys%2A>-Eigenschaft zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie Werte allein mithilfe der <xref:System.Collections.Generic.IDictionary%602.Values%2A>-Eigenschaft aufgelistet werden.  
  
 Dieser Code ist Teil eines größeren Beispiels, der kompiliert und ausgeführt werden kann. Siehe <xref:System.Collections.Generic.IDictionary%602?displayProperty=nameWithType>.  
  
 [!code-cpp[Generic.IDictionary#8](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.IDictionary/cpp/source.cpp#8)]
 [!code-csharp[Generic.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.IDictionary/CS/source.cs#8)]
 [!code-vb[Generic.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.IDictionary/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
      </Docs>
    </Member>
  </Members>
</Type>
