<Type Name="HashSet&lt;T&gt;" FullName="System.Collections.Generic.HashSet&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7008b2a31c9e55a7a5f90738637426f9e23c7967" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.HashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Class HashSet(Of T)&#xA;Implements ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable, ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class HashSet : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">
      <span data-ttu-id="39bac-101">Der Typ der Elemente im Hashset.</span>
      <span class="sxs-lookup">
        <span data-stu-id="39bac-101">The type of elements in the hash set.</span>
      </span>
    </typeparam>
    <summary>
      <span data-ttu-id="39bac-102">Stellt eine Menge von Werten dar.</span>
      <span class="sxs-lookup">
        <span data-stu-id="39bac-102">Represents a set of values.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-103">Die <xref:System.Collections.Generic.HashSet%601> Klasse bietet hohe Leistung set-Vorgänge.</span><span class="sxs-lookup"><span data-stu-id="39bac-103">The <xref:System.Collections.Generic.HashSet%601> class provides high-performance set operations.</span></span> <span data-ttu-id="39bac-104">Eine Gruppe ist eine Auflistung, die keine doppelten Elemente enthält und dessen Elemente sind in keiner bestimmten Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="39bac-104">A set is a collection that contains no duplicate elements, and whose elements are in no particular order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="39bac-105"><xref:System.Collections.Generic.HashSet%601> implementiert die <xref:System.Collections.Generic.IReadOnlyCollection%601> Schnittstelle beginnend mit der [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in früheren Versionen von .NET Framework, die <xref:System.Collections.Generic.HashSet%601> Klasse implementiert diese Schnittstelle nicht.</span><span class="sxs-lookup"><span data-stu-id="39bac-105"><xref:System.Collections.Generic.HashSet%601> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> interface starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Generic.HashSet%601> class did not implement this interface.</span></span>  
  
 <span data-ttu-id="39bac-106">Die Kapazität einer <xref:System.Collections.Generic.HashSet%601> Objekt ist die Anzahl der Elemente, die das Objekt enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="39bac-106">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="39bac-107">Ein <xref:System.Collections.Generic.HashSet%601> objektspezifischen Kapazität automatisch erhöht wird, wenn Elemente mit dem Objekt hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="39bac-107">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="39bac-108">Die <xref:System.Collections.Generic.HashSet%601> Klasse basiert auf dem Modell mathematischen Mengen und bietet hohe Leistung Mengenoperationen ähnelt den Zugriff auf den Schlüssel von den <xref:System.Collections.Generic.Dictionary%602> oder <xref:System.Collections.Hashtable> Sammlungen.</span><span class="sxs-lookup"><span data-stu-id="39bac-108">The <xref:System.Collections.Generic.HashSet%601> class is based on the model of mathematical sets and provides high-performance set operations similar to accessing the keys of the <xref:System.Collections.Generic.Dictionary%602> or <xref:System.Collections.Hashtable> collections.</span></span> <span data-ttu-id="39bac-109">Einfach ausgedrückt die <xref:System.Collections.Generic.HashSet%601> Klasse als betrachtet eine <xref:System.Collections.Generic.Dictionary%602> Auflistung ohne Werte.</span><span class="sxs-lookup"><span data-stu-id="39bac-109">In simple terms, the <xref:System.Collections.Generic.HashSet%601> class can be thought of as a <xref:System.Collections.Generic.Dictionary%602> collection without values.</span></span>  
  
 <span data-ttu-id="39bac-110">Ein <xref:System.Collections.Generic.HashSet%601> Sammlung ist nicht sortiert und dürfen keine doppelten Elemente enthalten.</span><span class="sxs-lookup"><span data-stu-id="39bac-110">A <xref:System.Collections.Generic.HashSet%601> collection is not sorted and cannot contain duplicate elements.</span></span> <span data-ttu-id="39bac-111">Wenn Reihenfolge oder Duplizierung wichtiger als die Leistung für Ihre Anwendung ist, erwägen Sie die <xref:System.Collections.Generic.List%601> -Klasse zusammen mit der <xref:System.Collections.Generic.List%601.Sort%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="39bac-111">If order or element duplication is more important than performance for your application, consider using the <xref:System.Collections.Generic.List%601> class together with the <xref:System.Collections.Generic.List%601.Sort%2A> method.</span></span>  
  
 <span data-ttu-id="39bac-112"><xref:System.Collections.Generic.HashSet%601> bietet viele mathematische Vorgänge, z. B. Gruppe hinzufügen (Unions) und Subtraktion festgelegt.</span><span class="sxs-lookup"><span data-stu-id="39bac-112"><xref:System.Collections.Generic.HashSet%601> provides many mathematical set operations, such as set addition (unions) and set subtraction.</span></span> <span data-ttu-id="39bac-113">Die folgende Tabelle listet die bereitgestellten <xref:System.Collections.Generic.HashSet%601> Vorgänge und deren Entsprechungen in mathematischen.</span><span class="sxs-lookup"><span data-stu-id="39bac-113">The following table lists the provided <xref:System.Collections.Generic.HashSet%601> operations and their mathematical equivalents.</span></span>  
  
|<span data-ttu-id="39bac-114">Vorgang HashSet (Of T)</span><span class="sxs-lookup"><span data-stu-id="39bac-114">HashSet(Of T) operation</span></span>|<span data-ttu-id="39bac-115">Mathematische Entsprechung</span><span class="sxs-lookup"><span data-stu-id="39bac-115">Mathematical equivalent</span></span>|  
|-------------------------------|-----------------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<span data-ttu-id="39bac-116">Vereinigung oder hinzufügen</span><span class="sxs-lookup"><span data-stu-id="39bac-116">Union or set addition</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<span data-ttu-id="39bac-117">Schnittmenge</span><span class="sxs-lookup"><span data-stu-id="39bac-117">Intersection</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<span data-ttu-id="39bac-118">Mengensubtraktion</span><span class="sxs-lookup"><span data-stu-id="39bac-118">Set subtraction</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="39bac-119">Symmetrische Differenz</span><span class="sxs-lookup"><span data-stu-id="39bac-119">Symmetric difference</span></span>|  
  
 <span data-ttu-id="39bac-120">Zusätzlich zu den aufgeführten Set-Vorgänge die <xref:System.Collections.Generic.HashSet%601> Klasse bietet auch Methoden zum Bestimmen von Set auf Gleichheit, überlappen Mengen und gibt an, ob ein Satz eine Teilmenge oder Obermenge eines anderen Satzes ist.</span><span class="sxs-lookup"><span data-stu-id="39bac-120">In addition to the listed set operations, the <xref:System.Collections.Generic.HashSet%601> class also provides methods for determining set equality, overlap of sets, and whether a set is a subset or superset of another set.</span></span>  
  
 <span data-ttu-id="39bac-121">Für sehr große <xref:System.Collections.Generic.HashSet%601> Objekte aufweist, können Sie die maximale Kapazität auf 2 Milliarden Elemente auf einem 64-Bit-System erhöhen, indem die `enabled` Attribut des Konfigurationselements auf `true` in der Umgebung zur Laufzeit.</span><span class="sxs-lookup"><span data-stu-id="39bac-121">For very large <xref:System.Collections.Generic.HashSet%601> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the `enabled` attribute of the  configuration element to `true` in the run-time environment.</span></span>  
  
 <span data-ttu-id="39bac-122">Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Collections.Generic.HashSet%601> -Klasse implementiert die <xref:System.Collections.Generic.ISet%601> Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="39bac-122">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Collections.Generic.HashSet%601> class implements the <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
## <a name="hashset-and-linq-set-operations"></a><span data-ttu-id="39bac-123">HashSet- und LINQ-Mengenoperationen</span><span class="sxs-lookup"><span data-stu-id="39bac-123">HashSet and LINQ Set Operations</span></span>  
 <span data-ttu-id="39bac-124">LINQ ermöglicht den Zugriff auf die `Distinct`, `Union`, `Intersect` und `Except` set-Vorgänge auf einer beliebigen Datenquelle, die implementiert die <xref:System.Collections.IEnumerable> oder <xref:System.Linq.IQueryable> Schnittstellen.</span><span class="sxs-lookup"><span data-stu-id="39bac-124">LINQ provides access to the `Distinct`, `Union`, `Intersect` and `Except` set operations on any data source that implements the <xref:System.Collections.IEnumerable> or <xref:System.Linq.IQueryable> interfaces.</span></span>  <span data-ttu-id="39bac-125"><xref:System.Collections.Generic.HashSet%601> Stellt eine Auflistung mehr und stabilere Mengenoperationen bereit.</span><span class="sxs-lookup"><span data-stu-id="39bac-125"><xref:System.Collections.Generic.HashSet%601> provides a larger and more robust collection of set operations.</span></span> <span data-ttu-id="39bac-126">Beispielsweise <xref:System.Collections.Generic.HashSet%601> stellt Vergleiche bereit, z. B. <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> und <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-126">For example, <xref:System.Collections.Generic.HashSet%601> provides comparisons such as <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> and <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span></span>  
  
 <span data-ttu-id="39bac-127">Der Hauptunterschied zwischen LINQ-Mengenoperationen und <xref:System.Collections.Generic.HashSet%601> Vorgänge ist, dass LINQ-Mengenoperationen immer eine neue zurückgeben <xref:System.Collections.Generic.IEnumerable%601> Sammlung, während die <xref:System.Collections.Generic.HashSet%601> gleichwertigen Methoden ändern die aktuelle Auflistung.</span><span class="sxs-lookup"><span data-stu-id="39bac-127">The primary difference between LINQ set operations and <xref:System.Collections.Generic.HashSet%601> operations is that LINQ set operations always return a new <xref:System.Collections.Generic.IEnumerable%601> collection, whereas the <xref:System.Collections.Generic.HashSet%601> equivalent methods modify the current collection.</span></span>  
  
 <span data-ttu-id="39bac-128">In der Regel, wenn Sie eine neue Gruppe erstellen müssen, oder wenn Ihre Anwendung nur Zugriff auf die bereitgestellten Mengenoperationen benötigt, mit LINQ Mengenoperationen für ein beliebiges <xref:System.Collections.Generic.IEnumerable%601> Sammlung oder einem Array wird ausreichend sein.</span><span class="sxs-lookup"><span data-stu-id="39bac-128">Typically, if you must create a new set or if your application needs access only to the provided set operations, using LINQ set operations on any <xref:System.Collections.Generic.IEnumerable%601> collection or array will be sufficient.</span></span> <span data-ttu-id="39bac-129">Wenn Ihre Anwendung den Zugriff auf Weitere Mengenoperationen erfordert oder wenn es nicht wünschenswert oder zum Erstellen einer neuen Sammlung erforderlich ist, allerdings verwenden der <xref:System.Collections.Generic.HashSet%601> Klasse.</span><span class="sxs-lookup"><span data-stu-id="39bac-129">However, if your application requires access to additional set operations, or if it is not desirable or necessary to create a new collection, use the <xref:System.Collections.Generic.HashSet%601> class.</span></span>  
  
 <span data-ttu-id="39bac-130">Die folgende Tabelle zeigt die <xref:System.Collections.Generic.HashSet%601> Vorgänge und ihre entsprechenden LINQ-Mengenoperationen.</span><span class="sxs-lookup"><span data-stu-id="39bac-130">The following table shows the <xref:System.Collections.Generic.HashSet%601> operations and their equivalent LINQ set operations.</span></span>  
  
|<span data-ttu-id="39bac-131">Vorgang HashSet (Of T)</span><span class="sxs-lookup"><span data-stu-id="39bac-131">HashSet(Of T) operation</span></span>|<span data-ttu-id="39bac-132">LINQ-Entsprechung</span><span class="sxs-lookup"><span data-stu-id="39bac-132">LINQ equivalent</span></span>|  
|-------------------------------|---------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<xref:System.Linq.Enumerable.Union%2A>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<xref:System.Linq.Enumerable.Intersect%2A>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<xref:System.Linq.Enumerable.Except%2A>|  
|<span data-ttu-id="39bac-133">Nicht bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="39bac-133">Not provided.</span></span>|<xref:System.Linq.Enumerable.Distinct%2A>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="39bac-134">Nicht bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="39bac-134">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>|<span data-ttu-id="39bac-135">Nicht bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="39bac-135">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>|<span data-ttu-id="39bac-136">Nicht bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="39bac-136">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSubsetOf%2A>|<span data-ttu-id="39bac-137">Nicht bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="39bac-137">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>|<span data-ttu-id="39bac-138">Nicht bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="39bac-138">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSupersetOf%2A>|<span data-ttu-id="39bac-139">Nicht bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="39bac-139">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>|<span data-ttu-id="39bac-140">Nicht bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="39bac-140">Not provided.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="39bac-141">Im folgenden Beispiel wird veranschaulicht, wie zwei unterschiedliche Sätze zusammenführen.</span><span class="sxs-lookup"><span data-stu-id="39bac-141">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="39bac-142">Dieses Beispiel erstellt zwei <xref:System.Collections.Generic.HashSet%601> Objekte und bzw. mit selbst und ungerade Zahlen gefüllt.</span><span class="sxs-lookup"><span data-stu-id="39bac-142">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="39bac-143">Eine dritte <xref:System.Collections.Generic.HashSet%601> -Objekt wird erstellt, aus dem Satz, der geraden Zahlen enthält.</span><span class="sxs-lookup"><span data-stu-id="39bac-143">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="39bac-144">Das Beispiel ruft dann die <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> -Methode, die festgelegten ungerade Zahl auf die dritte Gruppe hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="39bac-144">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Generic.SortedSet`1" />
    <altmember cref="T:System.Collections.Generic.ISet`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="39bac-145">Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.HashSet`1" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-145">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="39bac-146">Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.HashSet`1" />-Klasse, bei der für den Mengentyp der Standardgleichheitsvergleich verwendet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-146">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-147">Die Kapazität einer <xref:System.Collections.Generic.HashSet%601> Objekt ist die Anzahl der Elemente, die das Objekt enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="39bac-147">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="39bac-148">Ein <xref:System.Collections.Generic.HashSet%601> objektspezifischen Kapazität automatisch erhöht wird, wenn Elemente mit dem Objekt hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="39bac-148">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="39bac-149">Dieser Konstruktor ist ein o(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-149">This constructor is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-150">Im folgenden Beispiel wird veranschaulicht, wie das Erstellen und füllen Sie zwei <xref:System.Collections.Generic.HashSet%601> Objekte.</span><span class="sxs-lookup"><span data-stu-id="39bac-150">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="39bac-151">In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="39bac-151">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">
          <span data-ttu-id="39bac-152">Die Auflistung, deren Elemente in den neuen Satz kopiert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-152">The collection whose elements are copied to the new set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-153">Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.HashSet`1" />-Klasse, die den Standardgleichheitsvergleich des Mengentyps verwendet, aus der angegebenen Auflistung kopierte Elemente enthält und über ausreichend Kapazität für die Anzahl von kopierten Elementen verfügt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-153">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-154">Die Kapazität einer <xref:System.Collections.Generic.HashSet%601> Objekt ist die Anzahl der Elemente, die das Objekt enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="39bac-154">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="39bac-155">Ein <xref:System.Collections.Generic.HashSet%601> objektspezifischen Kapazität automatisch erhöht wird, wenn Elemente mit dem Objekt hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="39bac-155">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="39bac-156">Wenn `collection` Duplikate enthält, enthält der Satz wird ein jedes eindeutige Element enthalten.</span><span class="sxs-lookup"><span data-stu-id="39bac-156">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="39bac-157">Es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="39bac-157">No exception will be thrown.</span></span> <span data-ttu-id="39bac-158">Daher ist die Größe des resultierenden Satzes nicht identisch mit der Größe der `collection`.</span><span class="sxs-lookup"><span data-stu-id="39bac-158">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="39bac-159">Dieser Konstruktor ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl der Elemente in der `collection` Parameter.</span><span class="sxs-lookup"><span data-stu-id="39bac-159">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-160">Im folgende Beispiel wird gezeigt, wie zum Erstellen einer <xref:System.Collections.Generic.HashSet%601> Auflistung aus einem vorhandenen Satz.</span><span class="sxs-lookup"><span data-stu-id="39bac-160">The following example shows how to create a <xref:System.Collections.Generic.HashSet%601> collection from an existing set.</span></span> <span data-ttu-id="39bac-161">In diesem Beispiel werden die zwei Sätze "mit ungerade und Ganzzahlen" erstellt.</span><span class="sxs-lookup"><span data-stu-id="39bac-161">In this example, two sets are created with even and odd integers, respectively.</span></span> <span data-ttu-id="39bac-162">Eine dritte <xref:System.Collections.Generic.HashSet%601> -Objekts wird dann aus dem Satz der gerade ganze Zahl.</span><span class="sxs-lookup"><span data-stu-id="39bac-162">A third <xref:System.Collections.Generic.HashSet%601> object is then created from the even integer set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-163">
            <paramref name="collection" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-163">
              <paramref name="collection" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">
          <span data-ttu-id="39bac-164">Die <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Implementierung, die zum Vergleichen von Werten in der Menge verwendet werden soll, oder <see langword="null" />, wenn die <see cref="T:System.Collections.Generic.EqualityComparer`1" />-Standardimplementierung für diesen Mengentyp verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-164">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-165">Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.HashSet`1" />-Klasse, bei der für den Mengentyp der angegebene Gleichheitsvergleich verwendet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-165">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-166">Die Kapazität einer <xref:System.Collections.Generic.HashSet%601> Objekt ist die Anzahl der Elemente, die das Objekt enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="39bac-166">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="39bac-167">Ein <xref:System.Collections.Generic.HashSet%601> objektspezifischen Kapazität automatisch erhöht wird, wenn Elemente mit dem Objekt hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="39bac-167">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="39bac-168">Dieser Konstruktor ist ein o(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-168">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T), comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">
          <span data-ttu-id="39bac-169">Die Auflistung, deren Elemente in den neuen Satz kopiert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-169">The collection whose elements are copied to the new set.</span>
          </span>
        </param>
        <param name="comparer">
          <span data-ttu-id="39bac-170">Die <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Implementierung, die zum Vergleichen von Werten in der Menge verwendet werden soll, oder <see langword="null" />, wenn die <see cref="T:System.Collections.Generic.EqualityComparer`1" />-Standardimplementierung für diesen Mengentyp verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-170">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-171">Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.HashSet`1" />-Klasse, die den angegebenen Gleichheitsvergleich des Mengentyps verwendet, aus der angegebenen Auflistung kopierte Elemente enthält und über ausreichend Kapazität für die Anzahl der kopierten Elemente verfügt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-171">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-172">Die Kapazität einer <xref:System.Collections.Generic.HashSet%601> Objekt ist die Anzahl der Elemente, die das Objekt enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="39bac-172">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="39bac-173">Ein <xref:System.Collections.Generic.HashSet%601> objektspezifischen Kapazität automatisch erhöht wird, wenn Elemente mit dem Objekt hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="39bac-173">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="39bac-174">Wenn `collection` Duplikate enthält, enthält der Satz wird ein jedes eindeutige Element enthalten.</span><span class="sxs-lookup"><span data-stu-id="39bac-174">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="39bac-175">Es wird keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="39bac-175">No exception will be thrown.</span></span> <span data-ttu-id="39bac-176">Daher ist die Größe des resultierenden Satzes nicht identisch mit der Größe der `collection`.</span><span class="sxs-lookup"><span data-stu-id="39bac-176">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="39bac-177">Dieser Konstruktor ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl der Elemente in der `collection` Parameter.</span><span class="sxs-lookup"><span data-stu-id="39bac-177">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-178">Im folgenden Beispiel wird ein angegebenes <xref:System.Collections.Generic.IEqualityComparer%601> , Groß-/Kleinschreibung Vergleiche auf die Elemente der ermöglichen eine <xref:System.Collections.Generic.HashSet%601> Auflistung Fahrzeugtypen.</span><span class="sxs-lookup"><span data-stu-id="39bac-178">The following example uses a supplied <xref:System.Collections.Generic.IEqualityComparer%601> to allow case-insensitive comparisons on the elements of a  <xref:System.Collections.Generic.HashSet%601> collection of vehicle types.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/source2.cpp#03)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/source2.cs#03)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/source2.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-179">
            <paramref name="collection" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-179">
              <paramref name="collection" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="39bac-180">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren des <see cref="T:System.Collections.Generic.HashSet`1" />-Objekts erforderlichen Informationen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-180">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="39bac-181">Eine <see cref="T:System.Runtime.Serialization.StreamingContext" />-Struktur, die die Quelle und das Ziel des serialisierten Streams enthält, der dem <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt zugeordnet ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-181">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-182">Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.HashSet`1" />-Klasse mit serialisierten Daten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-182">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class with serialized data.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-183">Dieser Konstruktor wird aufgerufen, während der Deserialisierung ein Objekts wiederherstellen kann, das über einen Stream übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="39bac-183">This constructor is called during deserialization to reconstitute an object that is transmitted over a stream.</span></span> <span data-ttu-id="39bac-184">Weitere Informationen finden Sie unter [XML- und SOAP-Serialisierung](~/docs/standard/serialization/xml-and-soap-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="39bac-184">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="39bac-185">Der Element, das zur Menge hinzugefügt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-185">The element to add to the set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-186">Fügt das angegebene Element zu einer Menge hinzu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-186">Adds the specified element to a set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-187">
            <see langword="true" />, wenn das Element zum <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt hinzugefügt wird, <see langword="false" />, wenn das Element bereits vorhanden ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-187">
              <see langword="true" /> if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; <see langword="false" /> if the element is already present.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-188">Wenn <xref:System.Collections.Generic.HashSet%601.Count%2A> bereits die Kapazität entspricht der <xref:System.Collections.Generic.HashSet%601> -Objekt, die Kapazität wird automatisch angepasst, um das neue Element aufzunehmen.</span><span class="sxs-lookup"><span data-stu-id="39bac-188">If <xref:System.Collections.Generic.HashSet%601.Count%2A> already equals the capacity of the <xref:System.Collections.Generic.HashSet%601> object, the capacity is automatically adjusted to accommodate the new item.</span></span>  
  
 <span data-ttu-id="39bac-189">Wenn <xref:System.Collections.Generic.HashSet%601.Count%2A> ist kleiner als die Kapazität des internen Arrays, diese Methode ist ein o(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-189">If <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the capacity of the internal array, this method is an O(1) operation.</span></span> <span data-ttu-id="39bac-190">Wenn die <xref:System.Collections.Generic.HashSet%601> -Objekts geändert werden muss, wird diese Methode eine O (`n`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-190">If the <xref:System.Collections.Generic.HashSet%601> object must be resized, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-191">Im folgenden Beispiel wird veranschaulicht, wie das Erstellen und füllen Sie zwei <xref:System.Collections.Generic.HashSet%601> Objekte.</span><span class="sxs-lookup"><span data-stu-id="39bac-191">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="39bac-192">In diesem Beispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="39bac-192">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="39bac-193">Entfernt alle Elemente aus einem <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-193">Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-194"><xref:System.Collections.Generic.HashSet%601.Count%2A> 0 (null) festgelegt ist und Verweise auf andere Objekte von Elementen in der Auflistung werden ebenfalls freigegeben.</span><span class="sxs-lookup"><span data-stu-id="39bac-194"><xref:System.Collections.Generic.HashSet%601.Count%2A> is set to zero and references to other objects from elements of the collection are also released.</span></span> <span data-ttu-id="39bac-195">Die Kapazität bleibt unverändert, bis ein Aufruf <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> erfolgt.</span><span class="sxs-lookup"><span data-stu-id="39bac-195">The capacity remains unchanged until a call to <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> is made.</span></span>  
  
 <span data-ttu-id="39bac-196">Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-196">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-197">Das folgende Beispiel erstellt und füllt eine <xref:System.Collections.Generic.HashSet%601> -Auflistung gelöscht, und gibt den Arbeitsspeicher auf die verwiesen wird von der Auflistung frei.</span><span class="sxs-lookup"><span data-stu-id="39bac-197">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, then clears it and releases the memory referenced by the collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="39bac-198">Ruft das <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Objekt ab, mit dem die Gleichheit der Werte in der Menge bestimmt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-198">Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="39bac-199">Das <see cref="T:System.Collections.Generic.IEqualityComparer`1" />-Objekt, mit dem die Gleichheit der Werte in der Menge bestimmt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-199">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-200">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-200">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="39bac-201">Das Element, das im <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt gesucht werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-201">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-202">Bestimmt, ob ein <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt das angegebene Element enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-202">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-203">
            <see langword="true" />, wenn das <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt das angegebene Element enthält, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-203">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-204">Diese Methode ist ein o(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-204">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-205">Im folgenden Beispiel wird veranschaulicht, wie entfernen Sie die Werte aus einer <xref:System.Collections.Generic.HashSet%601> Auflistung mithilfe der <xref:System.Collections.Generic.HashSet%601.Remove%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="39bac-205">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="39bac-206">In diesem Beispiel wird die <xref:System.Collections.Generic.HashSet%601.Contains%2A> Methode stellt sicher, dass die Menge einen Wert enthält, bevor Sie ihn entfernen.</span><span class="sxs-lookup"><span data-stu-id="39bac-206">In this example, the <xref:System.Collections.Generic.HashSet%601.Contains%2A> method verifies that the set contains a value before removing it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="39bac-207">Kopiert die Elemente einer <see cref="T:System.Collections.Generic.HashSet`1" />-Auflistung in ein Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-207">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> collection to an array.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="39bac-208">Das eindimensionale Array, in das die Elemente aus dem <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt kopiert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-208">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
          <span data-ttu-id="39bac-209">Für das Array muss eine nullbasierte Indizierung verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-209">The array must have zero-based indexing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-210">Kopiert die Elemente eines <see cref="T:System.Collections.Generic.HashSet`1" />-Objekts in ein Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-210">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-211">Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-211">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-212">
            <paramref name="array" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-212">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="39bac-213">Das eindimensionale Array, in das die Elemente aus dem <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt kopiert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-213">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
          <span data-ttu-id="39bac-214">Für das Array muss eine nullbasierte Indizierung verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-214">The array must have zero-based indexing.</span>
          </span>
        </param>
        <param name="arrayIndex">
          <span data-ttu-id="39bac-215">Der nullbasierte Index im <c>array</c>, ab dem kopiert wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-215">The zero-based index in <c>array</c> at which copying begins.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-216">Kopiert die Elemente eines <see cref="T:System.Collections.Generic.HashSet`1" />-Objekts in ein Array, beginnend am angegebenen Index des Arrays.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-216">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-217">Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-217">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-218">
            <paramref name="array" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-218">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="39bac-219">
            <paramref name="arrayIndex" /> ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-219">
              <paramref name="arrayIndex" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="39bac-220">
            <paramref name="arrayIndex" /> ist größer als die Länge des Ziel-<paramref name="array" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-220">
              <paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="39bac-221">Das eindimensionale Array, in das die Elemente aus dem <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt kopiert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-221">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
          <span data-ttu-id="39bac-222">Für das Array muss eine nullbasierte Indizierung verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-222">The array must have zero-based indexing.</span>
          </span>
        </param>
        <param name="arrayIndex">
          <span data-ttu-id="39bac-223">Der nullbasierte Index im <c>array</c>, ab dem kopiert wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-223">The zero-based index in <c>array</c> at which copying begins.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="39bac-224">Die Anzahl der Elemente, die in <c>array</c> kopiert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-224">The number of elements to copy to <c>array</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-225">Kopiert die angegebene Anzahl von Elementen eines <see cref="T:System.Collections.Generic.HashSet`1" />-Objekts in ein Array, beginnend am angegebenen Index des Arrays.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-225">Copies the specified number of elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-226">Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist `count`.</span><span class="sxs-lookup"><span data-stu-id="39bac-226">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-227">
            <paramref name="array" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-227">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="39bac-228">
            <paramref name="arrayIndex" /> ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-228">
              <paramref name="arrayIndex" /> is less than 0.</span>
          </span>
          <span data-ttu-id="39bac-229">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-229">-or-</span>
          </span>
          <span data-ttu-id="39bac-230">
            <paramref name="count" /> ist kleiner als 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-230">
              <paramref name="count" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="39bac-231">
            <paramref name="arrayIndex" /> ist größer als die Länge des Ziel-<paramref name="array" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-231">
              <paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span>
          </span>
          <span data-ttu-id="39bac-232">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-232">-or-</span>
          </span>
          <span data-ttu-id="39bac-233">
            <paramref name="count" /> ist größer als der verfügbare Platz zwischen dem <paramref name="index" /> und dem Ende des Ziel-<paramref name="array" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-233">
              <paramref name="count" /> is greater than the available space from the <paramref name="index" /> to the end of the destination <paramref name="array" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="39bac-234">Ruft die Anzahl der Elemente in einer Menge ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-234">Gets the number of elements that are contained in a set.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="39bac-235">Die Anzahl der Elemente in der Menge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-235">The number of elements that are contained in the set.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-236">Die Kapazität einer <xref:System.Collections.Generic.HashSet%601> Objekt ist die Anzahl der Elemente, die das Objekt enthalten kann.</span><span class="sxs-lookup"><span data-stu-id="39bac-236">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="39bac-237">Ein <xref:System.Collections.Generic.HashSet%601> objektspezifischen Kapazität automatisch erhöht wird, wenn Elemente mit dem Objekt hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="39bac-237">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="39bac-238">Die Kapazität ist immer größer als oder gleich <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-238">The capacity is always greater than or equal to <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span> <span data-ttu-id="39bac-239">Wenn <xref:System.Collections.Generic.HashSet%601.Count%2A> überschreitet die Kapazität beim Hinzufügen von Elementen, die Kapazität auf die erste Primzahl, der größer als die doppelte vorherige Kapazität festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="39bac-239">If <xref:System.Collections.Generic.HashSet%601.Count%2A> exceeds the capacity while adding elements, the capacity is set to the first prime number that is greater than double the previous capacity.</span></span>  
  
 <span data-ttu-id="39bac-240">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-240">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-241">Im folgenden Beispiel wird veranschaulicht, wie erstellen, füllen und Bearbeiten von zwei <xref:System.Collections.Generic.HashSet%601> Objekte.</span><span class="sxs-lookup"><span data-stu-id="39bac-241">The following example demonstrates how to create, populate, and manipulate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="39bac-242">In diesem Beispiel werden die Inhalte des Satzes und <xref:System.Collections.Generic.HashSet%601.Count%2A> in der Konsole anzeigen.</span><span class="sxs-lookup"><span data-stu-id="39bac-242">In this example, both the contents of the set and <xref:System.Collections.Generic.HashSet%601.Count%2A> display to the console.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.HashSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CreateSetComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer () As IEqualityComparer(Of HashSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::HashSet&lt;T&gt; ^&gt; ^ CreateSetComparer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="39bac-243">Gibt ein <see cref="T:System.Collections.IEqualityComparer" />-Objekt zurück, das für Gleichheitstests eines <see cref="T:System.Collections.Generic.HashSet`1" />-Objekts verwendet werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-243">Returns an <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for equality testing of a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-244">Ein <see cref="T:System.Collections.IEqualityComparer" />-Objekt, das für tiefe Gleichheitstests des <see cref="T:System.Collections.Generic.HashSet`1" />-Objekts verwendet werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-244">An <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for deep equality testing of the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-245">Die <xref:System.Collections.IEqualityComparer> Objekt auf Gleichheit auf nur einer Ebene überprüft, aber Sie können verketten Vergleiche auf zusätzlichen Ebenen, um tiefere Gleichheitstests auszuführen.</span><span class="sxs-lookup"><span data-stu-id="39bac-245">The <xref:System.Collections.IEqualityComparer> object checks for equality at only one level; however, you can chain together comparers at additional levels to perform deeper equality testing.</span></span>  
  
 <span data-ttu-id="39bac-246">Beim Aufrufen dieser Methode ist ein o(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-246">Calling this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="39bac-247">Die Auflistung der Elemente, die aus dem <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt entfernt werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-247">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-248">Entfernt alle Elemente in der angegebenen Auflistung aus dem aktuellen <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-248">Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-249">Die <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> Methode entspricht einer mathematischen Mengensubtraktion.</span><span class="sxs-lookup"><span data-stu-id="39bac-249">The <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method is the equivalent of mathematical set subtraction.</span></span>  
  
 <span data-ttu-id="39bac-250">Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl der Elemente in der `other` Parameter.</span><span class="sxs-lookup"><span data-stu-id="39bac-250">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-251">Das folgende Beispiel erstellt zwei <xref:System.Collections.Generic.HashSet%601> Sammlungen mit überlappenden Gruppen von Daten.</span><span class="sxs-lookup"><span data-stu-id="39bac-251">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="39bac-252">Dann wird der untere Bereich der Werte aus dem größeren Satz mit entfernt die <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="39bac-252">The lower range of values is then removed from the larger set using the <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/program.cpp#02)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-253">
            <paramref name="other" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-253">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.HashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.HashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As HashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::HashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="39bac-254">Gibt einen Enumerator zurück, der ein <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt durchläuft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-254">Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-255">Ein <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" />-Objekt für das <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-255">A <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-256">Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.</span><span class="sxs-lookup"><span data-stu-id="39bac-256">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="39bac-257">Verwenden Sie deshalb `foreach` wird direkt und den Enumerator nicht empfohlen.</span><span class="sxs-lookup"><span data-stu-id="39bac-257">Therefore, using `foreach` is recommended instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="39bac-258">Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="39bac-258">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="39bac-259">Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert.</span><span class="sxs-lookup"><span data-stu-id="39bac-259">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="39bac-260">An dieser Position ist die <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> Eigenschaft ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-260">At this position, the <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="39bac-261">Sie müssen daher rufen die <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-261">Therefore, you must call the <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="39bac-262">Die <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> Eigenschaft gibt das gleiche Objekt bis <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="39bac-262">The <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property returns the same object until <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="39bac-263"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> legt <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> auf das nächste Element fest.</span><span class="sxs-lookup"><span data-stu-id="39bac-263"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> sets <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="39bac-264">Wenn <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> gibt `false`.</span><span class="sxs-lookup"><span data-stu-id="39bac-264">If <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="39bac-265">Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> auch zurückgeben `false`.</span><span class="sxs-lookup"><span data-stu-id="39bac-265">When the enumerator is at this position, subsequent calls to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="39bac-266">Wenn der letzte Aufruf <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-266">If the last call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="39bac-267">Sie können keine festlegen <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> auf das erste Element der Auflistung erneut müssen Sie stattdessen ein neues Enumeratorobjekt erstellen.</span><span class="sxs-lookup"><span data-stu-id="39bac-267">You cannot set <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="39bac-268">Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist.</span><span class="sxs-lookup"><span data-stu-id="39bac-268">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="39bac-269">Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-269">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="39bac-270">Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.</span><span class="sxs-lookup"><span data-stu-id="39bac-270">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="39bac-271">Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.</span><span class="sxs-lookup"><span data-stu-id="39bac-271">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="39bac-272">Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.</span><span class="sxs-lookup"><span data-stu-id="39bac-272">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="39bac-273">Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-273">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="39bac-274">Diese Methode ist ein o(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-274">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="39bac-275">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den zum Serialisieren des <see cref="T:System.Collections.Generic.HashSet`1" />-Objekts erforderlichen Informationen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-275">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="39bac-276">Eine <see cref="T:System.Runtime.Serialization.StreamingContext" />-Struktur, die die Quelle und das Ziel des serialisierten Streams enthält, der dem <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt zugeordnet ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-276">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-277">Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und gibt die zum Serialisieren eines <see cref="T:System.Collections.Generic.HashSet`1" />-Objekts erforderlichen Daten zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-277">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and returns the data needed to serialize a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-278">Beim Aufrufen dieser Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-278">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-279">
            <paramref name="info" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-279">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="39bac-280">für das Bereitstellen von Serialisierungsdiensten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-280">for providing serialization services.</span>
          </span>
          <span data-ttu-id="39bac-281">Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-281">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="39bac-282">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-282">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="39bac-283">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-283">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-284">Ändert das aktuelle <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt so, dass nur noch Elemente vorhanden sind, die in diesem Objekt und in der angegebenen Auflistung vorhanden sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-284">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-285">Wenn die Auflistung von dargestellt die `other` Parameter ist ein <xref:System.Collections.Generic.HashSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.HashSet%601> -Objekt, diese Methode ist eine O (`n`) Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-285">If the collection represented by the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="39bac-286">Diese Methode ist, andernfalls eine O (`n` + `m`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.HashSet%601.Count%2A> und `m` ist die Anzahl der Elemente im `other`.</span><span class="sxs-lookup"><span data-stu-id="39bac-286">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-287">
            <paramref name="other" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-287">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="39bac-288">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-288">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-289">Bestimmt, ob ein <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt eine echte Teilmenge der angegebenen Auflistung ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-289">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-290">
            <see langword="true" />, wenn das aktuelle <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt eine echte Teilmenge von <paramref name="other" /> ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-290">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-291">Eine leere Menge ist eine echte Teilmenge von einer anderen Sammlung an.</span><span class="sxs-lookup"><span data-stu-id="39bac-291">An empty set is a proper subset of any other collection.</span></span> <span data-ttu-id="39bac-292">Daher, diese Methode gibt `true` , wenn die Auflistung von der aktuellen dargestellt <xref:System.Collections.Generic.HashSet%601> ist leer, es sei denn, die `other` Parameter ist auch ein leeres Resultset.</span><span class="sxs-lookup"><span data-stu-id="39bac-292">Therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty unless the `other` parameter is also an empty set.</span></span>  
  
 <span data-ttu-id="39bac-293">Diese Methode gibt immer `false` Wenn <xref:System.Collections.Generic.HashSet%601.Count%2A> ist größer als oder gleich der Anzahl der Elemente im `other`.</span><span class="sxs-lookup"><span data-stu-id="39bac-293">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="39bac-294">Wenn die Auflistung von dargestellt `other` ist ein <xref:System.Collections.Generic.HashSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.HashSet%601> -Objekt, dann ist diese Methode eine O (`n`) Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-294">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, then this method is an O(`n`) operation.</span></span> <span data-ttu-id="39bac-295">Diese Methode ist, andernfalls eine O (`n` + `m`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.HashSet%601.Count%2A> und `m` ist die Anzahl der Elemente im `other`.</span><span class="sxs-lookup"><span data-stu-id="39bac-295">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-296">Das folgende Beispiel erstellt zwei verschiedenartigen <xref:System.Collections.Generic.HashSet%601> Objekte und miteinander verglichen.</span><span class="sxs-lookup"><span data-stu-id="39bac-296">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="39bac-297">In diesem Beispiel `lowNumbers` ist eine Teilmenge und eine echte Teilmenge von `allNumbers` bis `allNumbers` geändert wird, mithilfe der <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> Methode, um nur die Werte enthalten, die in beiden Gruppen vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="39bac-297">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="39bac-298">Einmal `allNumbers` und `lowNumbers` sind nahezu identisch, `lowNumbers` ist immer noch eine Teilmenge der `allNumbers` ist jedoch nicht mehr eine echte Teilmenge.</span><span class="sxs-lookup"><span data-stu-id="39bac-298">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-299">
            <paramref name="other" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-299">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="39bac-300">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-300">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-301">Bestimmt, ob ein <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt eine echte Obermenge der angegebenen Auflistung ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-301">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-302">
            <see langword="true" />, wenn das <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt eine echte Obermenge von <paramref name="other" /> ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-302">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-303">Eine leere Menge ist eine echte Obermenge von einer anderen Sammlung an.</span><span class="sxs-lookup"><span data-stu-id="39bac-303">An empty set is a proper superset of any other collection.</span></span> <span data-ttu-id="39bac-304">Aus diesem Grund gibt diese Methode zurück `true` , wenn die Auflistung von dargestellt die `other` Parameter ist leer, wenn die aktuelle <xref:System.Collections.Generic.HashSet%601> Sammlung wird auch leer.</span><span class="sxs-lookup"><span data-stu-id="39bac-304">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty unless the current <xref:System.Collections.Generic.HashSet%601> collection is also empty.</span></span>  
  
 <span data-ttu-id="39bac-305">Diese Methode gibt immer `false` Wenn <xref:System.Collections.Generic.HashSet%601.Count%2A> ist kleiner oder gleich der Anzahl der Elemente im `other`.</span><span class="sxs-lookup"><span data-stu-id="39bac-305">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="39bac-306">Wenn die Auflistung von dargestellte `other` ist eine <xref:System.Collections.Generic.HashSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.HashSet%601> -Objekt, diese Methode ist eine O (`n`) Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-306">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="39bac-307">Diese Methode ist, andernfalls eine O (`n` + `m`)-Vorgang, in dem `n` ist die Anzahl der Elemente im `other` und `m` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-307">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-308">Das folgende Beispiel erstellt zwei verschiedenartigen <xref:System.Collections.Generic.HashSet%601> Objekte und miteinander verglichen.</span><span class="sxs-lookup"><span data-stu-id="39bac-308">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="39bac-309">In diesem Beispiel `allNumbers` ist eine Obermenge und eine echte Obermenge von `lowNumbers` bis `allNumbers` geändert wird, mithilfe der <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> Methode, um nur die Werte enthalten, die in beiden Gruppen vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="39bac-309">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="39bac-310">Einmal `allNumbers` und `lowNumbers` sind nahezu identisch, `allNumbers` ist immer noch eine Obermenge der `lowNumbers` ist jedoch nicht mehr eine echte Obermenge.</span><span class="sxs-lookup"><span data-stu-id="39bac-310">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-311">
            <paramref name="other" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-311">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="39bac-312">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-312">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-313">Bestimmt, ob ein <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt eine Teilmenge der angegebenen Auflistung ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-313">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-314">
            <see langword="true" />, wenn das aktuelle <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt eine Teilmenge von <paramref name="other" /> ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-314">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-315">Eine leere Menge ist eine Teilmenge einer anderen Sammlung, z. B. ein leeres Resultset. aus diesem Grund gibt diese Methode zurück `true` , wenn die vom aktuellen Auflistung dargestellte <xref:System.Collections.Generic.HashSet%601> Objekt leer ist, auch wenn die `other` Parameter ist eine leere Menge.</span><span class="sxs-lookup"><span data-stu-id="39bac-315">An empty set is a subset of any other collection, including an empty set; therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty, even if the `other` parameter is an empty set.</span></span>  
  
 <span data-ttu-id="39bac-316">Diese Methode gibt immer `false` Wenn <xref:System.Collections.Generic.HashSet%601.Count%2A> ist größer als die Anzahl der Elemente im `other`.</span><span class="sxs-lookup"><span data-stu-id="39bac-316">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="39bac-317">Wenn die Auflistung von dargestellte `other` ist eine <xref:System.Collections.Generic.HashSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.HashSet%601> -Objekt, diese Methode ist eine O (`n`) Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-317">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="39bac-318">Diese Methode ist, andernfalls eine O (`n` + `m`)-Vorgang, in dem `n` ist <xref:System.Collections.Generic.HashSet%601.Count%2A> und `m` ist die Anzahl der Elemente im `other`.</span><span class="sxs-lookup"><span data-stu-id="39bac-318">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-319">Das folgende Beispiel erstellt zwei verschiedenartigen <xref:System.Collections.Generic.HashSet%601> Objekte und miteinander verglichen.</span><span class="sxs-lookup"><span data-stu-id="39bac-319">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="39bac-320">In diesem Beispiel `lowNumbers` ist eine Teilmenge und eine echte Teilmenge von `allNumbers` bis `allNumbers` geändert wird, mithilfe der <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> Methode, um nur die Werte enthalten, die in beiden Gruppen vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="39bac-320">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="39bac-321">Einmal `allNumbers` und `lowNumbers` sind nahezu identisch, `lowNumbers` ist immer noch eine Teilmenge der `allNumbers` ist jedoch nicht mehr eine echte Teilmenge.</span><span class="sxs-lookup"><span data-stu-id="39bac-321">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-322">
            <paramref name="other" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-322">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="39bac-323">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-323">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-324">Bestimmt, ob ein <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt eine Obermenge der angegebenen Auflistung ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-324">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-325">
            <see langword="true" />, wenn das aktuelle <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt eine Obermenge von <paramref name="other" /> ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-325">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-326">Alle Auflistungen, einschließlich leerer Mengen sind Obermengen der Satz leer.</span><span class="sxs-lookup"><span data-stu-id="39bac-326">All collections, including the empty set, are supersets of the empty set.</span></span> <span data-ttu-id="39bac-327">Aus diesem Grund gibt diese Methode zurück `true` , wenn die Auflistung von dargestellt die `other` Parameter ist leer, auch wenn die aktuelle <xref:System.Collections.Generic.HashSet%601> Objekt leer ist.</span><span class="sxs-lookup"><span data-stu-id="39bac-327">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty, even if the current <xref:System.Collections.Generic.HashSet%601> object is empty.</span></span>  
  
 <span data-ttu-id="39bac-328">Diese Methode gibt immer `false` Wenn <xref:System.Collections.Generic.HashSet%601.Count%2A> ist kleiner als die Anzahl der Elemente im `other`.</span><span class="sxs-lookup"><span data-stu-id="39bac-328">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="39bac-329">Wenn die Auflistung von dargestellte `other` ist eine <xref:System.Collections.Generic.HashSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.HashSet%601> -Objekt, diese Methode ist eine O (`n`) Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-329">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="39bac-330">Diese Methode ist, andernfalls eine O (`n` + `m`)-Vorgang, in dem `n` ist die Anzahl der Elemente im `other` und `m` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-330">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-331">Das folgende Beispiel erstellt zwei verschiedenartigen <xref:System.Collections.Generic.HashSet%601> Objekte und miteinander verglichen.</span><span class="sxs-lookup"><span data-stu-id="39bac-331">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="39bac-332">In diesem Beispiel `allNumbers` ist eine Obermenge und eine echte Obermenge von `lowNumbers` bis `allNumbers` geändert wird, mithilfe der <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> Methode, um nur die Werte enthalten, die in beiden Gruppen vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="39bac-332">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="39bac-333">Einmal `allNumbers` und `lowNumbers` sind nahezu identisch, `allNumbers` ist immer noch eine Obermenge der `lowNumbers` ist jedoch nicht mehr eine echte Obermenge.</span><span class="sxs-lookup"><span data-stu-id="39bac-333">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-334">
            <paramref name="other" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-334">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">
          <span data-ttu-id="39bac-335">Die Quelle des Deserialisierungsereignisses.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-335">The source of the deserialization event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-336">Implementiert die <see cref="T:System.Runtime.Serialization.ISerializable" />-Schnittstelle und löst das Deserialisierungsereignis aus, sobald die Deserialisierung abgeschlossen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-336">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and raises the deserialization event when the deserialization is complete.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-337">Beim Aufrufen dieser Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-337">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <span data-ttu-id="39bac-338">Das dem aktuellen <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt zugeordnete <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-338">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object associated with the current <see cref="T:System.Collections.Generic.HashSet`1" /> object is invalid.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="39bac-339">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-339">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-340">Bestimmt, ob das aktuelle <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt und eine angegebene Auflistung gemeinsame Elemente enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-340">Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object and a specified collection share common elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-341">
            <see langword="true" />, wenn das <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt und <paramref name="other" /> mindestens ein gemeinsames Element enthalten, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-341">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and <paramref name="other" /> share at least one common element; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-342">Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist die Anzahl der Elemente in `other`.</span><span class="sxs-lookup"><span data-stu-id="39bac-342">This method is an O(`n`) operation, where `n` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-343">Das folgende Beispiel erstellt zwei verschiedenartigen <xref:System.Collections.Generic.HashSet%601> Objekte und miteinander verglichen.</span><span class="sxs-lookup"><span data-stu-id="39bac-343">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="39bac-344">In diesem Beispiel `allNumbers` und `lowNumbers` angezeigt werden, um gemeinsame Elemente der <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="39bac-344">In this example, `allNumbers` and `lowNumbers` are shown to share common elements using the <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-345">
            <paramref name="other" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-345">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="39bac-346">Das zu entfernende Element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-346">The element to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-347">Entfernt das angegebene Element aus einem <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-347">Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-348">
            <see langword="true" />, wenn das Element gefunden und entfernt wurde, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-348">
              <see langword="true" /> if the element is successfully found and removed; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="39bac-349">Diese Methode gibt <see langword="false" /> zurück, wenn <paramref name="item" /> nicht im <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt gefunden wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-349">This method returns <see langword="false" /> if <paramref name="item" /> is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-350">Wenn die <xref:System.Collections.Generic.HashSet%601> -Objekt das angegebene Element nicht enthält, wird das Objekt bleibt unverändert.</span><span class="sxs-lookup"><span data-stu-id="39bac-350">If the <xref:System.Collections.Generic.HashSet%601> object does not contain the specified element, the object remains unchanged.</span></span> <span data-ttu-id="39bac-351">Es werden keine Ausnahmen ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="39bac-351">No exception is thrown.</span></span>  
  
 <span data-ttu-id="39bac-352">Diese Methode ist ein o(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-352">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-353">Im folgenden Beispiel wird veranschaulicht, wie entfernen Sie die Werte aus einer <xref:System.Collections.Generic.HashSet%601> Auflistung mithilfe der <xref:System.Collections.Generic.HashSet%601.Remove%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="39bac-353">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="39bac-354">In diesem Beispiel wird 0 (null) nach dem Zufallsprinzip aus entfernt die <xref:System.Collections.Generic.HashSet%601> Auflistung.</span><span class="sxs-lookup"><span data-stu-id="39bac-354">In this example, zero is arbitrarily removed from the <xref:System.Collections.Generic.HashSet%601> collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveWhere (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveWhere(Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <span data-ttu-id="39bac-355">Der <see cref="T:System.Predicate`1" />-Delegat, der die Bedingungen für die Elemente definiert, die entfernt werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-355">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-356">Entfernt alle Elemente aus einer <see cref="T:System.Collections.Generic.HashSet`1" />-Auflistung, die die im angegebenen Prädikat definierten Bedingungen erfüllen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-356">Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-357">Die Anzahl von Elementen, die aus der <see cref="T:System.Collections.Generic.HashSet`1" />-Auflistung entfernt wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-357">The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-358">Beim Aufrufen dieser Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-358">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-359">Im folgenden Beispiel wird veranschaulicht, wie entfernen Sie die Werte aus einer <xref:System.Collections.Generic.HashSet%601> Auflistung mithilfe der <xref:System.Collections.Generic.HashSet%601.Remove%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="39bac-359">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="39bac-360">In diesem Beispiel werden alle ungerade Zahlen aus entfernt die <xref:System.Collections.Generic.HashSet%601> Auflistung entsprechend den Angaben von der `match` delegieren.</span><span class="sxs-lookup"><span data-stu-id="39bac-360">In this example, all odd integers are removed from the <xref:System.Collections.Generic.HashSet%601> collection as specified by the `match` delegate.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-361">
            <paramref name="match" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-361">
              <paramref name="match" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="39bac-362">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-362">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-363">Ermittelt, ob ein <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt und die angegebene Auflistung dieselben Elemente enthalten.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-363">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object and the specified collection contain the same elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-364">
            <see langword="true" />, wenn das <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt gleich <paramref name="other" /> ist, anderfalls „false“.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-364">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is equal to <paramref name="other" />; otherwise, false.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-365">Die <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> -Methode ignoriert doppelte Einträge und die Reihenfolge der Elemente in der `other` Parameter.</span><span class="sxs-lookup"><span data-stu-id="39bac-365">The <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method ignores duplicate entries and the order of elements in the `other` parameter.</span></span>  
  
 <span data-ttu-id="39bac-366">Wenn die Auflistung von dargestellte `other` ist eine <xref:System.Collections.Generic.HashSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.HashSet%601> -Objekt, diese Methode ist eine O (`n`) Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-366">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="39bac-367">Diese Methode ist, andernfalls eine O (`n` + `m`)-Vorgang, in dem `n` ist die Anzahl der Elemente im `other` und `m` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-367">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-368">Das folgende Beispiel erstellt zwei verschiedenartigen <xref:System.Collections.Generic.HashSet%601> Objekte und miteinander verglichen.</span><span class="sxs-lookup"><span data-stu-id="39bac-368">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="39bac-369">Zu Beginn der zwei Sätze ungleich sind, wird die veranschaulicht, mit der <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="39bac-369">Initially, the two sets are not equal, which is demonstrated by using the <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method.</span></span> <span data-ttu-id="39bac-370">Die `allNumbers` <xref:System.Collections.Generic.HashSet%601> Objekt dann geändert werden kann, wonach die Gruppen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="39bac-370">The `allNumbers`<xref:System.Collections.Generic.HashSet%601> object is then modified, after which the sets are equal.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-371">
            <paramref name="other" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-371">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SymmetricExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="39bac-372">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-372">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-373">Ändert das aktuelle <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt so, dass nur noch Elemente vorhanden sind, die entweder in diesem Objekt oder aber in der angegebenen Auflistung, nicht jedoch in beiden vorhanden sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-373">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-374">Wenn die `other` Parameter ist ein <xref:System.Collections.Generic.HashSet%601> Auflistung mit den gleichen Gleichheitsvergleich wie die aktuelle <xref:System.Collections.Generic.HashSet%601> -Objekt, diese Methode ist eine O (`n`) Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-374">If the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="39bac-375">Diese Methode ist, andernfalls eine O (`n` + `m`)-Vorgang, in dem `n` ist die Anzahl der Elemente im `other` und `m` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-375">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-376">Das folgende Beispiel erstellt zwei <xref:System.Collections.Generic.HashSet%601> Sammlungen mit überlappenden Gruppen von Daten.</span><span class="sxs-lookup"><span data-stu-id="39bac-376">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="39bac-377">Die Gruppe, die die niedrigeren Werte enthält dann geändert werden kann, mithilfe der <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> Methode, um nur die Werte enthalten, die nicht in beiden Gruppen vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="39bac-377">The set that contains the lower values is then modified, using the <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> method, to contain only the values that are not present in both sets.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-378">
            <paramref name="other" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-378">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="39bac-379">Das Objekt, das dem <see cref="T:System.Collections.Generic.ICollection`1" />-Objekt hinzugefügt werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-379">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-380">Fügt einem <see cref="T:System.Collections.Generic.ICollection`1" />-Objekt ein Element hinzu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-380">Adds an item to an <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-381">Wenn <xref:System.Collections.Generic.List%601.Count%2A> ist kleiner als <xref:System.Collections.Generic.List%601.Capacity%2A>, diese Methode ist ein o(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-381">If <xref:System.Collections.Generic.List%601.Count%2A> is less than <xref:System.Collections.Generic.List%601.Capacity%2A>, this method is an O(1) operation.</span></span> <span data-ttu-id="39bac-382">Wenn die Kapazität erhöht werden muss, um das neue Element aufzunehmen, wird diese Methode eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.List%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-382">If the capacity must be increased to accommodate the new element, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="39bac-383">
            <see cref="T:System.Collections.Generic.ICollection`1" /> ist schreibgeschützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-383">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="39bac-384">Ruft einen Wert ab, der angibt, ob eine Auflistung schreibgeschützt ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-384">Gets a value indicating whether a collection is read-only.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="39bac-385">
            <see langword="true" />, wenn die Auflistung schreibgeschützt ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-385">
              <see langword="true" /> if the collection is read-only; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-386">Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-386">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="39bac-387">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-387">Returns an enumerator that iterates through a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-388">Ein <see cref="T:System.Collections.Generic.IEnumerator`1" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-388">An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-389">Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.</span><span class="sxs-lookup"><span data-stu-id="39bac-389">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="39bac-390">Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.</span><span class="sxs-lookup"><span data-stu-id="39bac-390">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="39bac-391">Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="39bac-391">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="39bac-392">Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert.</span><span class="sxs-lookup"><span data-stu-id="39bac-392">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="39bac-393">An dieser Position ist die <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Eigenschaft ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-393">At this position, the <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property is undefined.</span></span> <span data-ttu-id="39bac-394">Sie müssen daher rufen die <xref:System.Collections.IEnumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-394">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span></span>  
  
 <span data-ttu-id="39bac-395">Die <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Eigenschaft gibt das gleiche Objekt bis <xref:System.Collections.IEnumerator.MoveNext%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="39bac-395">The <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property returns the same object until <xref:System.Collections.IEnumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="39bac-396"><xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.Generic.IEnumerator%601.Current%2A> auf das nächste Element fest.</span><span class="sxs-lookup"><span data-stu-id="39bac-396"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="39bac-397">Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false`.</span><span class="sxs-lookup"><span data-stu-id="39bac-397">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="39bac-398">Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.IEnumerator.MoveNext%2A> auch zurückgeben `false`.</span><span class="sxs-lookup"><span data-stu-id="39bac-398">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="39bac-399">Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-399">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> is undefined.</span></span> <span data-ttu-id="39bac-400">Sie können keine festlegen <xref:System.Collections.Generic.IEnumerator%601.Current%2A> auf das erste Element der Auflistung erneut müssen Sie stattdessen ein neues Enumeratorobjekt erstellen.</span><span class="sxs-lookup"><span data-stu-id="39bac-400">You cannot set <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="39bac-401">Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist.</span><span class="sxs-lookup"><span data-stu-id="39bac-401">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="39bac-402">Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-402">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="39bac-403">Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.</span><span class="sxs-lookup"><span data-stu-id="39bac-403">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="39bac-404">Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.</span><span class="sxs-lookup"><span data-stu-id="39bac-404">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="39bac-405">Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.</span><span class="sxs-lookup"><span data-stu-id="39bac-405">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="39bac-406">Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-406">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="39bac-407">Diese Methode ist ein o(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-407">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="39bac-408">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-408">Returns an enumerator that iterates through a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="39bac-409">Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das zum Durchlaufen der Auflistung verwendet werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-409">An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-410">Die `foreach` -Anweisung der Programmiersprache c# (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren.</span><span class="sxs-lookup"><span data-stu-id="39bac-410">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="39bac-411">Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.</span><span class="sxs-lookup"><span data-stu-id="39bac-411">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="39bac-412">Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="39bac-412">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="39bac-413">Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert.</span><span class="sxs-lookup"><span data-stu-id="39bac-413">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="39bac-414"><xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.</span><span class="sxs-lookup"><span data-stu-id="39bac-414"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="39bac-415">An dieser Position ist die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-415">At this position, the <xref:System.Collections.IEnumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="39bac-416">Sie müssen daher rufen die <xref:System.Collections.IEnumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-416">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="39bac-417">Die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft gibt das gleiche Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="39bac-417">The <xref:System.Collections.IEnumerator.Current%2A> property returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="39bac-418"><xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.</span><span class="sxs-lookup"><span data-stu-id="39bac-418"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="39bac-419">Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> übergibt am Ende der Auflistung der Enumerator hinter dem letzten Element in der Auflistung positioniert ist und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false`.</span><span class="sxs-lookup"><span data-stu-id="39bac-419">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="39bac-420">Wenn der Enumerator ist an dieser Position ist nachfolgende Aufrufe <xref:System.Collections.IEnumerator.MoveNext%2A> auch zurückgeben `false`.</span><span class="sxs-lookup"><span data-stu-id="39bac-420">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="39bac-421">Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-421">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="39bac-422">Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.</span><span class="sxs-lookup"><span data-stu-id="39bac-422">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="39bac-423">Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist.</span><span class="sxs-lookup"><span data-stu-id="39bac-423">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="39bac-424">Werden an der Auflistung Änderungen wie z. B. Hinzufügen, Bearbeiten oder Entfernen von Elementen vorgenommen, verliert der Enumerator unwiederbringlich seine Gültigkeit und sein Verhalten ist nicht definiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-424">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="39bac-425">Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.</span><span class="sxs-lookup"><span data-stu-id="39bac-425">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span>  <span data-ttu-id="39bac-426">Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.</span><span class="sxs-lookup"><span data-stu-id="39bac-426">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="39bac-427">Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.</span><span class="sxs-lookup"><span data-stu-id="39bac-427">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="39bac-428">Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.</span><span class="sxs-lookup"><span data-stu-id="39bac-428">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="39bac-429">Diese Methode ist ein o(1)-Vorgang.</span><span class="sxs-lookup"><span data-stu-id="39bac-429">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="39bac-430">Legt die Kapazität eines <see cref="T:System.Collections.Generic.HashSet`1" />-Objekts auf die Anzahl der tatsächlich enthaltenen Elemente fest, aufgerundet auf einen nahe gelegenen implementierungsabhängigen Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-430">Sets the capacity of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-431">Können Sie die <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> Methode minimieren eine <xref:System.Collections.Generic.HashSet%601> Speicherbedarf des Objekts, wenn bekannt ist, dass keine neuen Elemente hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="39bac-431">You can use the <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> method to minimize a <xref:System.Collections.Generic.HashSet%601> object's memory overhead once it is known that no new elements will be added.</span></span> <span data-ttu-id="39bac-432">Vollständig Löschen einer <xref:System.Collections.Generic.HashSet%601> Objekt und freizugeben und alle verwiesen wird, rufen Sie diese Methode nach dem Aufruf der <xref:System.Collections.Generic.HashSet%601.Clear%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="39bac-432">To completely clear a <xref:System.Collections.Generic.HashSet%601> object and release all memory referenced by it, call this method after calling the <xref:System.Collections.Generic.HashSet%601.Clear%2A> method.</span></span>  
  
 <span data-ttu-id="39bac-433">Diese Methode ist eine O (`n`) Vorgang, wobei `n` ist <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="39bac-433">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-434">Das folgende Beispiel erstellt und füllt eine <xref:System.Collections.Generic.HashSet%601> Auflistung und löscht die Auflistung und gibt den verwiesen wird Arbeitsspeicher frei.</span><span class="sxs-lookup"><span data-stu-id="39bac-434">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, and then clears the collection and releases the memory referenced by it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue">To be added.</param>
        <param name="actualValue">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnionWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="39bac-435">Die Auflistung, die mit dem aktuellen <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-435">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="39bac-436">Ändert das aktuelle <see cref="T:System.Collections.Generic.HashSet`1" />-Objekt so, dass alle Elemente vorhanden sind, die in diesem Objekt, in der angegebenen Auflistung oder beiden vorhanden sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-436">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in itself, the specified collection, or both.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="39bac-437">Diese Methode ist eine O (`n`)-Vorgang, in dem `n` ist die Anzahl der Elemente in der `other` Parameter.</span><span class="sxs-lookup"><span data-stu-id="39bac-437">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="39bac-438">Im folgenden Beispiel wird veranschaulicht, wie zwei unterschiedliche Sätze zusammenführen.</span><span class="sxs-lookup"><span data-stu-id="39bac-438">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="39bac-439">Dieses Beispiel erstellt zwei <xref:System.Collections.Generic.HashSet%601> Objekte und bzw. mit selbst und ungerade Zahlen gefüllt.</span><span class="sxs-lookup"><span data-stu-id="39bac-439">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="39bac-440">Eine dritte <xref:System.Collections.Generic.HashSet%601> -Objekt wird erstellt, aus dem Satz, der geraden Zahlen enthält.</span><span class="sxs-lookup"><span data-stu-id="39bac-440">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="39bac-441">Das Beispiel ruft dann die <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> -Methode, die festgelegten ungerade Zahl auf die dritte Gruppe hinzugefügt.</span><span class="sxs-lookup"><span data-stu-id="39bac-441">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="39bac-442">
            <paramref name="other" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="39bac-442">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>