<Type Name="SortedDictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="08cf61b64810c38160ff9c5df54c1b29afc16da9" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58681864" /></Metadata><TypeSignature Language="C#" Value="public class SortedDictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedDictionary`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.SortedDictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedDictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class SortedDictionary : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedDictionary&lt;'Key, 'Value&gt; = class&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IDictionary&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Der Typ der Schlüssel im Wörterbuch.</typeparam>
    <typeparam name="TValue">Der Typ der Werte im Wörterbuch.</typeparam>
    <summary>Stellt eine Auflistung von Schlüssel-Wert-Paaren dar, deren Reihenfolge anhand des Schlüssels bestimmt wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.SortedDictionary%602> generische Klasse ist einer binären Suchstruktur mit O (Log n) Abruf, wobei n die Anzahl der Elemente im Wörterbuch. In dieser Hinsicht ähnelt der <xref:System.Collections.Generic.SortedList%602> generische Klasse. Die Klassen verfügen über ähnliche Objektmodelle, und beide verfügen über eine O (Log n) abrufen. In dem die beiden Klassen unterscheiden sich in der speichernutzung und Geschwindigkeit Einfüge-und Entfernvorgänge:  
  
-   <xref:System.Collections.Generic.SortedList%602> belegt weniger Speicher als <xref:System.Collections.Generic.SortedDictionary%602>.  
  
-   <xref:System.Collections.Generic.SortedDictionary%602> ist schneller und Löschvorgänge für unsortierte Daten: O (Log n) im Gegensatz zu O(n) für <xref:System.Collections.Generic.SortedList%602>.  
  
-   Wenn die Liste alle auf einmal mit sortierten Daten gefüllt wird <xref:System.Collections.Generic.SortedList%602> ist schneller als <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 Jedes Schlüssel-Wert-Paar kann abgerufen werden, als eine <xref:System.Collections.Generic.KeyValuePair%602> Struktur oder als eine <xref:System.Collections.DictionaryEntry> über die nicht generische <xref:System.Collections.IDictionary> Schnittstelle.  
  
 Schlüssel müssen unveränderlich sein, solange sie als Schlüssel verwendet werden die <xref:System.Collections.Generic.SortedDictionary%602>. Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedDictionary%602> muss eindeutig sein. Ein Schlüssel kann nicht `null`, jedoch kann ein Wert, wenn der Werttyp, `TValue` ein Verweistyp ist.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> erfordert eine Vergleichs-Implementierung, um wichtige Vergleiche durchzuführen. Sie können angeben, dass eine Implementierung von der <xref:System.Collections.Generic.IComparer%601> generische Schnittstelle mithilfe eines Konstruktors, die akzeptiert eine `comparer` Parameter; Wenn Sie keine Implementierung, die standardmäßig Genericcomparer angeben <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> wird verwendet. Wenn Typ `TKey` implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> generische Schnittstelle, die standardmäßige Vergleichsfunktion verwendet diese Implementierung.  
  
 Die `foreach` -Anweisung der c#-Sprache (`for each` in C++ `For Each` in Visual Basic) gibt ein Objekt des Typs der Elemente in der Auflistung zurück. Da jedes Element von der <xref:System.Collections.Generic.SortedDictionary%602> Schlüssel/Wert-Paar, ist der Elementtyp ist nicht der Typ des Schlüssels oder den Typ des Werts. Stattdessen ist der Typ des Elements <xref:System.Collections.Generic.KeyValuePair%602>. Der folgende Code zeigt, c#, C++ und Visual Basic-Syntax.  
  
 [!code-cpp[Generic.Dictionary#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source2.cpp#11)]
 [!code-csharp[Generic.Dictionary#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source2.cs#11)]
 [!code-vb[Generic.Dictionary#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source2.vb#11)]  
  
 Die `foreach` Anweisung ist ein Wrapper um den Enumerator, der nur das Lesen aus der Auflistung zulässt, nicht in den sie schreiben.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein leeres <xref:System.Collections.Generic.SortedDictionary%602> von Zeichenfolgen mit Zeichenfolgenschlüsseln und verwendet die <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> Methode, um einige Elemente hinzuzufügen. Im Beispiel wird veranschaulicht, die die <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> -Methode löst eine <xref:System.ArgumentException> beim Versuch, einen doppelten Schlüssel hinzuzufügen.  
  
 Im Beispiel wird die <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> -Eigenschaft (Indexer in c#) zum Abrufen von Werten, die veranschaulicht, dass eine <xref:System.Collections.Generic.KeyNotFoundException> wird ausgelöst, wenn ein angeforderte Schlüssel nicht vorhanden ist, und zeigt, dass der Wert mit einem Schlüssel zugeordnete ersetzt werden.  
  
 Im Beispiel wird gezeigt, wie mithilfe der <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> Methode als eine effizientere Methode zum Abrufen der Werte, wenn ein Programm häufig versucht Schlüsselwerte, die nicht im Wörterbuch vorhanden sind, und es zeigt, wie die <xref:System.Collections.Generic.SortedDictionary%602.ContainsKey%2A> Methode zu testen, ob ein Schlüssel vorhanden ist, vor dem Aufrufen der <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> Methode.  
  
 Das Beispiel zeigt, wie die Schlüssel und Werte im Wörterbuch aufgelistet werden und wie die Schlüssel aufgelistet werden, und Werte mithilfe von allein die <xref:System.Collections.Generic.SortedDictionary%602.Keys%2A> Eigenschaft und die <xref:System.Collections.Generic.SortedDictionary%602.Values%2A> Eigenschaft.  
  
 Zum Schluss das Beispiel veranschaulicht die <xref:System.Collections.Generic.SortedDictionary%602.Remove%2A> Methode.  
  
 [!code-csharp[Generic.SortedDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind threadsicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Ein <see cref="T:System.Collections.Generic.SortedDictionary`2" /> gleichzeitige Unterstützung für mehrere Reader, solange die Auflistung nicht geändert wird.  Trotzdem ist die Enumeration einer Auflistung systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.</threadsafe>
    <altmember cref="T:System.Collections.SortedList" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.SortedDictionary`2" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.SortedDictionary`2" />-Klasse, bei der die <see cref="T:System.Collections.Generic.IComparer`1" />-Standardimplementierung für den Typ des Schlüssels verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedDictionary%602> anhand des Standardcomparers eindeutig sein.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> erfordert eine Vergleichs-Implementierung, um wichtige Vergleiche durchzuführen. Dieser Konstruktor verwendet den Standardgleichheitsvergleich für den generischen <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Wenn Typ `TKey` implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> generische Schnittstelle, die standardmäßige Vergleichsfunktion verwendet diese Implementierung. Alternativ können Sie angeben, eine Implementierung der <xref:System.Collections.Generic.IComparer%601> generische Schnittstelle mithilfe eines Konstruktors, die akzeptiert eine `comparer` Parameter.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein leeres <xref:System.Collections.Generic.SortedDictionary%602> von Zeichenfolgen mit Zeichenfolgenschlüsseln und verwendet die <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> Methode, um einige Elemente hinzuzufügen. Im Beispiel wird veranschaulicht, die die <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> -Methode löst eine <xref:System.ArgumentException> beim Versuch, einen doppelten Schlüssel hinzuzufügen.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedDictionary%602> Klasse.  
  
 [!code-csharp[Generic.SortedDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#2)]
 [!code-vb[Generic.SortedDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary (System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary(System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die zum Vergleichen von Schlüsseln verwendet werden soll, oder <see langword="null" />, wenn der Standard-<see cref="T:System.Collections.Generic.Comparer`1" /> für diesen Schlüsseltyp verwendet werden soll.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.SortedDictionary`2" />-Klasse, bei der die angegebene <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung für den Vergleich von Schlüsseln verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedDictionary%602> entsprechend des angegebenen Vergleichs eindeutig sein.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> erfordert eine Vergleichs-Implementierung, um wichtige Vergleiche durchzuführen. Wenn `comparer` ist `null`, dieser Konstruktor verwendet den generischen Standardgleichheitsvergleich <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Wenn Typ `TKey` implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> generische Schnittstelle, die standardmäßige Vergleichsfunktion verwendet diese Implementierung.  
  
 Dieser Konstruktor ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Collections.Generic.SortedDictionary%602> mit einem Vergleich Groß-/Kleinschreibung, für die aktuelle Kultur. Das Beispiel fügt vier Elemente enthalten, von einige mit Kleinbuchstaben Schlüsseln und einige mit Großbuchstaben-Schlüsseln. Anschließend wird versucht, ein Element mit einem Schlüssel hinzuzufügen, die aus einem vorhandenen Schlüssel nur durch Fall unterscheidet sich die ausgelöste Ausnahme abfängt, und zeigt eine Fehlermeldung an. Zum Schluss zeigt das Beispiel die Elemente in der Sortierreihenfolge für Groß-/Kleinschreibung.  
  
 [!code-csharp[Generic.SortedDictionary.ctor_IComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.ctor_IComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; dictionary" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Das <see cref="T:System.Collections.Generic.IDictionary`2" />, dessen Elemente in das neue <see cref="T:System.Collections.Generic.SortedDictionary`2" /> kopiert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.SortedDictionary`2" />-Klasse, die Elemente enthält, die aus dem angegebenen <see cref="T:System.Collections.Generic.IDictionary`2" /> kopiert wurden, und bei der die <see cref="T:System.Collections.Generic.IComparer`1" />-Standardimplementierung für den Typ des Schlüssels verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedDictionary%602> muss gemäß der Standardeinstellung eindeutig sein Comparer; aus diesem Grund jeder Schlüssel in der Quelle `dictionary` muss auch anhand des Standardcomparers eindeutig sein.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> erfordert eine Vergleichs-Implementierung, um wichtige Vergleiche durchzuführen. Dieser Konstruktor verwendet den generischen Standardgleichheitsvergleich <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Wenn Typ `TKey` implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> generische Schnittstelle, die standardmäßige Vergleichsfunktion verwendet diese Implementierung. Alternativ können Sie angeben, eine Implementierung der <xref:System.Collections.Generic.IComparer%601> generische Schnittstelle mithilfe eines Konstruktors, die akzeptiert eine `comparer` Parameter.  
  
 Dieser Konstruktor ist eine O (`n` Log `n`)-Vorgang, in denen `n` ist die Anzahl der Elemente im `dictionary`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit <xref:System.Collections.Generic.SortedDictionary%602> erstellen Sie eine sortierte Kopie der Informationen in einer <xref:System.Collections.Generic.Dictionary%602>, übergeben die <xref:System.Collections.Generic.Dictionary%602> auf die <xref:System.Collections.Generic.SortedDictionary%602.%23ctor%28System.Collections.Generic.IComparer%7B%600%7D%29> Konstruktor.  
  
 [!code-csharp[Generic.SortedDictionary.ctor_IDic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDic/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.ctor_IDic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dictionary" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dictionary" /> enthält mindestens einen doppelten Schlüssel.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; (dictionary, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Das <see cref="T:System.Collections.Generic.IDictionary`2" />, dessen Elemente in das neue <see cref="T:System.Collections.Generic.SortedDictionary`2" /> kopiert werden.</param>
        <param name="comparer">Die <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung, die zum Vergleichen von Schlüsseln verwendet werden soll, oder <see langword="null" />, wenn der Standard-<see cref="T:System.Collections.Generic.Comparer`1" /> für diesen Schlüsseltyp verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.SortedDictionary`2" />-Klasse, die Elemente enthält, die aus dem angegebenen <see cref="T:System.Collections.Generic.IDictionary`2" /> kopiert wurden, und bei der die angegebene <see cref="T:System.Collections.Generic.IComparer`1" />-Implementierung für den Vergleich von Schlüsseln verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Schlüssel im einem <xref:System.Collections.Generic.SortedDictionary%602> muss entsprechend der angegebenen eindeutig sein Comparer; aus diesem Grund jeder Schlüssel in der Quelle `dictionary` muss ebenfalls entsprechend des angegebenen Vergleichs eindeutig sein.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> erfordert eine Vergleichs-Implementierung, um wichtige Vergleiche durchzuführen. Wenn `comparer` ist `null`, dieser Konstruktor verwendet den generischen Standardgleichheitsvergleich <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Wenn Typ `TKey` implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> generische Schnittstelle, die standardmäßige Vergleichsfunktion verwendet diese Implementierung.  
  
 Dieser Konstruktor ist eine O (`n` Log `n`)-Vorgang, in denen `n` ist die Anzahl der Elemente im `dictionary`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit <xref:System.Collections.Generic.SortedDictionary%602> Erstellung einer Groß-/Kleinschreibung sortiert Kopie der Informationen in einem Groß-/Kleinschreibung <xref:System.Collections.Generic.Dictionary%602>, durch das Übergeben der <xref:System.Collections.Generic.Dictionary%602> auf die <xref:System.Collections.Generic.SortedDictionary%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Konstruktor. In diesem Beispiel wird die Groß-/Kleinschreibung Vergleiche für die aktuelle Kultur sind.  
  
 [!code-csharp[Generic.SortedDictionary.ctor_IDicIComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDicIComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.ctor_IDicIComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDicIComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dictionary" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dictionary" /> enthält mindestens einen doppelten Schlüssel.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; unit&#xA;override this.Add : 'Key * 'Value -&gt; unit" Usage="sortedDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des hinzuzufügenden Elements.</param>
        <param name="value">Der Wert des hinzuzufügenden Elements. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt dem <see cref="T:System.Collections.Generic.SortedDictionary`2" /> ein Element mit dem angegebenen Schlüssel und Wert hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch die <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> Eigenschaft, um neue Elemente hinzufügen, indem dem Wert eines Schlüssels, das ist nicht in der <xref:System.Collections.Generic.SortedDictionary%602>, z. B. `myCollection["myNonexistentKey"] = myValue` (in Visual Basic `myCollection("myNonexistantKey") = myValue`). Jedoch, wenn der angegebene Schlüssel bereits vorhanden ist die <xref:System.Collections.Generic.SortedDictionary%602>wird durch das Festlegen der <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> Eigenschaft überschreibt den alten Wert. Im Gegensatz dazu die <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> Methode löst eine Ausnahme aus, wenn ein Element mit dem angegebenen Schlüssel bereits vorhanden ist.  
  
 Ein Schlüssel kann nicht `null`, jedoch kann ein Wert, wenn der Werttyp, `TValue` ein Verweistyp ist.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt ein leeres <xref:System.Collections.Generic.SortedDictionary%602> von Zeichenfolgen mit Zeichenfolgenschlüsseln und verwendet die <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> Methode, um einige Elemente hinzuzufügen. Im Beispiel wird veranschaulicht, die die <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> -Methode löst eine <xref:System.ArgumentException> beim Versuch, einen doppelten Schlüssel hinzuzufügen.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedDictionary%602> Klasse.  
  
 [!code-csharp[Generic.SortedDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#2)]
 [!code-vb[Generic.SortedDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ein Element mit dem gleichen Schlüssel ist bereits im <see cref="T:System.Collections.Generic.SortedDictionary`2" /> vorhanden.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Elemente aus der <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Collections.Generic.SortedDictionary%602.Count%2A> Eigenschaft auf 0 festgelegt ist, und Verweise auf andere Objekte von Elementen in der Auflistung werden ebenfalls freigegeben.  
  
 Diese Methode ist ein o(1)-Vorgang, da Sie einfach im Stammverzeichnis des internen Datenstrukturen für die Garbagecollection freigegeben wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IComparer&lt;'Key&gt;" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Collections.Generic.IComparer`1" /> ab, der zum Sortieren der Elemente des <see cref="T:System.Collections.Generic.SortedDictionary`2" /> verwendet wird.</summary>
        <value>Der <see cref="T:System.Collections.Generic.IComparer`1" />, der zum Sortieren der Elemente des <see cref="T:System.Collections.Generic.SortedDictionary`2" /> verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedDictionary%602> erfordert eine Vergleichs-Implementierung, um wichtige Vergleiche durchzuführen. Sie können angeben, dass eine Implementierung von der <xref:System.Collections.Generic.IComparer%601> generische Schnittstelle mithilfe eines Konstruktors, die akzeptiert eine `comparer` Parameter. Wenn Sie nicht, führen Sie die generischen Standardgleichheitsvergleich <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, verwendet wird. Wenn Typ `TKey` implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> generische Schnittstelle, die standardmäßige Vergleichsfunktion verwendet diese Implementierung.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Collections.Generic.SortedDictionary`2.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="sortedDictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.Generic.SortedDictionary`2" /> zu suchende Schlüssel.</param>
        <summary>Ermittelt, ob das <see cref="T:System.Collections.Generic.SortedDictionary`2" /> ein Element mit dem angegebenen Schlüssel enthält.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Collections.Generic.SortedDictionary`2" /> ein Element mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine O (Log `n`) Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Collections.Generic.SortedDictionary%602.ContainsKey%2A> Methode zum Überprüfen, ob ein Schlüssel vorhanden, vor dem Aufrufen ist der <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> Methode. Darüber hinaus wird mit der <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> Methode zum Abrufen von Werten, die ist eine effiziente Möglichkeit zum Abrufen von Werten, wenn ein Programm häufig Schlüssel versucht, die nicht im Wörterbuch vorhanden sind. Schließlich werden der am wenigsten effizienten Methode zum Testen, ob ein Schlüssel vorhanden sind, mithilfe der <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> -Eigenschaft (Indexer in c#).  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedDictionary%602> Klasse.  
  
 [!code-csharp[Generic.SortedDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#6)]
 [!code-vb[Generic.SortedDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.SortedDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#5)]
[!code-vb[Generic.SortedDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#5)]  
[!code-csharp[Generic.SortedDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.ContainsValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsValue (value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.ContainsValue : 'Value -&gt; bool" Usage="sortedDictionary.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Der im <see cref="T:System.Collections.Generic.SortedDictionary`2" /> zu suchende Wert. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Ermittelt, ob das <see cref="T:System.Collections.Generic.SortedDictionary`2" /> ein Element mit dem angegebenen Wert enthält.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Collections.Generic.SortedDictionary`2" /> ein Element mit dem angegebenen Wert enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt mithilfe des Standardgleichheitsvergleichs Gleichheit <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für den Werttyp `TValue`.  
  
 Diese Methode führt eine lineare Suche. aus diesem Grund ist die durchschnittliche Ausführungszeit proportional zu der <xref:System.Collections.Generic.SortedDictionary%602.Count%2A> Eigenschaft. Diese Methode ist, also eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;[] * int -&gt; unit&#xA;override this.CopyTo : System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;[] * int -&gt; unit" Usage="sortedDictionary.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array von <see cref="T:System.Collections.Generic.KeyValuePair`2" />-Strukturen, in das die Elemente aus der aktuellen <see cref="T:System.Collections.Generic.SortedDictionary`2" /> kopiert werden. Für das Array muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente des <see cref="T:System.Collections.Generic.SortedDictionary`2" /> in das angegebene Array von <see cref="T:System.Collections.Generic.KeyValuePair`2" />-Strukturen, wobei am angegebenen Index begonnen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ der Quelle <xref:System.Collections.Generic.SortedDictionary%602> kann nicht automatisch in den Typ des Ziels umgewandelt werden `array`, die nicht generischen Implementierungen der <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> auslösen <xref:System.InvalidCastException>, während die Implementierungen die generischen auslösen <xref:System.ArgumentException>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.SortedDictionary`2" /> überschreitet den verfügbaren Platz vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Schlüssel-Wert-Paare im <see cref="T:System.Collections.Generic.SortedDictionary`2" /> ab.</summary>
        <value>Die Anzahl der Schlüssel-Wert-Paare im <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.SortedDictionary`2/Enumerator&lt;!TKey, !TValue&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As SortedDictionary(Of TKey, TValue).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Enumerator" Usage="sortedDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die <see cref="T:System.Collections.Generic.SortedDictionary`2" /> durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.SortedDictionary`2.Enumerator" /> für die <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Enumeration wird jedes Element ist ein <xref:System.Collections.Generic.KeyValuePair%602> Struktur, die einen Wert und ihrem Schlüssel darstellt.  
  
 Die `foreach` -Anweisung der c#-Sprache (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Das Wörterbuch wird in einer sortierten Reihenfolge mithilfe einer internen Struktur beibehalten. Die richtige Sortierposition jedes neues Element positioniert ist, und die Struktur wird angepasst, um die Sortierreihenfolge zu gewährleisten, wenn ein Element entfernt wird. Beim Aufzählen von ist, wird die Sortierreihenfolge beibehalten.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist die <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> Eigenschaft ist nicht definiert. Aus diesem Grund müssen Sie Aufrufen der <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A>.  
  
 Die <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> Eigenschaft gibt das gleiche Element erst die <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> Methode wird aufgerufen. <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> legt <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn der Auflistung, z. B. das Hinzufügen Änderungen, ändern oder Löschen von Elementen, wenn der Enumerator unwiederbringlich ist ungültig, und der nächste Aufruf von <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> oder <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein O (Log n)-Vorgang, wobei n die Anzahl ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.SortedDictionary`2.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des abzurufenden oder festzulegenden Werts.</param>
        <summary>Ruft den Wert ab, der dem angegebenen Schlüssel zugeordnet ist, oder legt diesen fest.</summary>
        <value>Der dem angegebenen Schlüssel zugeordnete Wert. Wenn der angegebene Schlüssel nicht gefunden wird, löst ein Get-Vorgang eine <see cref="T:System.Collections.Generic.KeyNotFoundException" /> aus, und durch einen Set-Vorgang wird ein neues Element mit dem angegebenen Schlüssel erstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe der folgenden C#-Syntax: `myCollection[key]` (`myCollection(key)` in Visual Basic).  
  
 Sie können auch die <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> zum Hinzufügen neuer Elemente durch Festlegen des Werts eines Schlüssels, die Eigenschaft ist nicht vorhanden, der <xref:System.Collections.Generic.SortedDictionary%602>, z. B. `myCollection["myNonexistentKey"] = myValue` Jedoch, wenn der angegebene Schlüssel bereits vorhanden ist die <xref:System.Collections.Generic.SortedDictionary%602>wird durch das Festlegen der <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> Eigenschaft überschreibt den alten Wert. Im Gegensatz dazu die <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> Methode vorhandene Elemente nicht geändert.  
  
 Ein Schlüssel kann nicht `null`, jedoch kann ein Wert, wenn der Werttyp, `TValue` ein Verweistyp ist.  
  
 Die Programmiersprache c# verwendet das Schlüsselwort der Indexer definieren die <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> Eigenschaft. Visual Basic implementiert <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Abrufen des Werts dieser Eigenschaft ist eine O (Log `n`)-Vorgang; die Eigenschaft ist auch eine O (Log `n`) Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> -Eigenschaft (Indexer in c#) zum Abrufen von Werten, die veranschaulicht, dass eine <xref:System.Collections.Generic.KeyNotFoundException> wird ausgelöst, wenn ein angeforderte Schlüssel nicht vorhanden ist, und zeigt, dass der Wert mit einem Schlüssel zugeordnete ersetzt werden.  
  
 Außerdem wird gezeigt, wie Sie mit der <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> Methode als eine effizientere Möglichkeit, Werte abzurufen, wenn ein Programm häufig Schlüsselwerte, die nicht im Wörterbuch vorhanden sind.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedDictionary%602> Klasse.  
  
 [!code-csharp[Generic.SortedDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#3)]
 [!code-vb[Generic.SortedDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.SortedDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.SortedDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#5)]
[!code-vb[Generic.SortedDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Die Eigenschaft wird abgerufen, und der <paramref name="key" /> ist nicht in der Auflistung vorhanden.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;.KeyCollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SortedDictionary`2/KeyCollection&lt;!TKey, !TValue&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As SortedDictionary(Of TKey, TValue).KeyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::KeyCollection ^ Keys { System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::KeyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.KeyCollection" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;+KeyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung ab, die die Schlüssel im <see cref="T:System.Collections.Generic.SortedDictionary`2" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.Generic.SortedDictionary`2.KeyCollection" />, die die Schlüssel im <see cref="T:System.Collections.Generic.SortedDictionary`2" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Schlüssel in der <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> entsprechend sortiert sind die <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> -Eigenschaft und sind in der gleichen Reihenfolge wie die zugeordneten Werte in der <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> zurückgegebenes der <xref:System.Collections.Generic.SortedDictionary%602.Values%2A> Eigenschaft.  
  
 Das zurückgegebene <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> ist nicht statisch, sondern, die <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> verweist zurück auf die Schlüssel in der ursprünglichen <xref:System.Collections.Generic.SortedDictionary%602>. Daher wird in der <xref:System.Collections.Generic.SortedDictionary%602> im berücksichtigt werden weiterhin die <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection>.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die Schlüssel im Wörterbuch mit aufgelistet werden die <xref:System.Collections.Generic.SortedDictionary%602.Keys%2A> -Eigenschaft, und wie die Schlüssel und Werte im Wörterbuch aufgelistet.  
  
 Dieser Code ist Teil eines größeren Beispiels, das kompiliert und ausgeführt werden kann. Siehe <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 [!code-csharp[Generic.SortedDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#9)]
 [!code-vb[Generic.SortedDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.SortedDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.SortedDictionary`2.KeyCollection" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; bool&#xA;override this.Remove : 'Key -&gt; bool" Usage="sortedDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Schlüssel aus dem <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <returns><see langword="true" />, wenn das Element erfolgreich entfernt wurde, andernfalls <see langword="false" />.  Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="key" /> nicht in der <see cref="T:System.Collections.Generic.SortedDictionary`2" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Collections.Generic.SortedDictionary%602> enthält kein Element mit dem angegebenen Schlüssel, der <xref:System.Collections.Generic.SortedDictionary%602> bleibt unverändert. Es wird keine Ausnahme ausgelöst.  
  
 Diese Methode ist eine O (Log `n`) Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie So entfernen Sie aus dem Wörterbuch mit Schlüssel/Wert-Paar der <xref:System.Collections.Generic.SortedDictionary%602.Remove%2A> Methode.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedDictionary%602> Klasse.  
  
 [!code-csharp[Generic.SortedDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#10)]
 [!code-vb[Generic.SortedDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.Add(`0,`1)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (keyValuePair As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">Die <see cref="T:System.Collections.Generic.KeyValuePair`2" />-Struktur, die der <see cref="T:System.Collections.Generic.ICollection`1" /> hinzugefügt werden soll.</param>
        <summary>Fügt der <see cref="T:System.Collections.Generic.ICollection`1" /> ein Element hinzu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keyValuePair" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ein Element mit dem gleichen Schlüssel ist bereits im <see cref="T:System.Collections.Generic.SortedDictionary`2" /> vorhanden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Contains (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">Die <see cref="T:System.Collections.Generic.KeyValuePair`2" />-Struktur, die in die <see cref="T:System.Collections.Generic.ICollection`1" /> gesucht werden soll.</param>
        <summary>Ermittelt, ob die <see cref="T:System.Collections.Generic.ICollection`1" /> einen bestimmten Schlüssel und Wert enthält.</summary>
        <returns><see langword="true" />, wenn das <paramref name="keyValuePair" /> in der <see cref="T:System.Collections.Generic.ICollection`1" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey,TValue&gt;&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Collections.Generic.ICollection`1" /> schreibgeschützt ist, andernfalls <see langword="false" />. In der Standardimplementierung von <see cref="T:System.Collections.Generic.SortedDictionary`2" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">Die <see cref="T:System.Collections.Generic.KeyValuePair`2" />-Struktur, die aus der <see cref="T:System.Collections.Generic.ICollection`1" /> entfernt werden soll.</param>
        <summary>Entfernt das erste Vorkommen des angegebenen Elements aus der <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <returns><see langword="true" />, wenn das <paramref name="keyValuePair" /> erfolgreich aus der <see cref="T:System.Collections.Generic.ICollection`1" /> entfernt wurde, andernfalls <see langword="false" />. Diese Methode gibt auch dann <see langword="false" /> zurück, wenn das <paramref name="keyValuePair" /> nicht in der <see cref="T:System.Collections.Generic.ICollection`1" /> gefunden wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of TKey) Implements IDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TKey&gt; ^ System::Collections::Generic::IDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.Generic.ICollection`1" /> ab, die die Schlüssel des <see cref="T:System.Collections.Generic.IDictionary`2" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.Generic.ICollection`1" />, die die Schlüssel des <see cref="T:System.Collections.Generic.IDictionary`2" /> enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of TValue) Implements IDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TValue&gt; ^ System::Collections::Generic::IDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.Generic.ICollection`1" /> ab, die die Werte im <see cref="T:System.Collections.Generic.IDictionary`2" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.Generic.ICollection`1" />, die die Werte im <see cref="T:System.Collections.Generic.IDictionary`2" /> enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein Enumerator, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As IEnumerable(Of TKey) Implements IReadOnlyDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung ab, die die Schlüssel im <see cref="T:System.Collections.Generic.SortedDictionary`2" /> enthält.</summary>
        <value>Eine Auflistung, die die Schlüssel des <see cref="T:System.Collections.Generic.SortedDictionary`2" /> enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As IEnumerable(Of TValue) Implements IReadOnlyDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung ab, die die Werte im <see cref="T:System.Collections.Generic.SortedDictionary`2" /> enthält.</summary>
        <value>Eine Auflistung mit den Werten in der <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale Array, das das Ziel der aus <see cref="T:System.Collections.Generic.ICollection`1" /> kopierten Elemente ist. Für das Array muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.Generic.ICollection`1" /> in ein Array, wobei am angegebenen Arrayindex begonnen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ der Quelle <xref:System.Collections.ICollection> kann nicht automatisch in den Typ des Ziels umgewandelt werden `array`, die nicht generischen Implementierungen der <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> auslösen eine <xref:System.InvalidCastException>, während die Implementierungen die generischen auslösen eine <xref:System.ArgumentException>.  
  
 Diese Methode ist eine O (`n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
 <paramref name="array" /> hat keine nullbasierte Indizierung.  
  
- oder - 
Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.ICollection`1" /> überschreitet den verfügbaren Platz vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />.  
  
- oder - 
Der Typ der Quell-<see cref="T:System.Collections.Generic.ICollection`1" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value><see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.SortedDictionary`2" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur. Auch wenn eine Auflistung synchronisiert ist, können andere Threads weiterhin die Auflistung ändern, die den Enumerator eine Ausnahme verursachen kann. Um während der Enumeration Threadsicherheit zu gewährleisten, können Sie entweder die Auflistung während der gesamten Enumeration sperren oder die Ausnahmen, die aus von anderen Threads stammenden Änderungen resultieren, abfangen.  
  
 Die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23ICollection%23SyncRoot%2A> Eigenschaft gibt ein Objekt, das verwendet werden kann, um das Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads das Objekt zu sperren, bevor Sie den Zugriff auf die Auflistung.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23ICollection%23SyncRoot%2A> Eigenschaft gibt ein Objekt, das verwendet werden kann, um das Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Synchronisierung ist nur wirksam, wenn alle Threads das Objekt zu sperren, bevor Sie den Zugriff auf die Auflistung. Der folgende Code zeigt die Verwendung der <xref:System.Collections.ICollection.SyncRoot%2A> -Eigenschaft für c#, C++ und Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Das Objekt, das als Schlüssel für das hinzuzufügende Element verwendet werden soll.</param>
        <param name="value">Das Objekt, das als Wert für das hinzuzufügende Element verwendet werden soll.</param>
        <summary>Fügt der <see cref="T:System.Collections.IDictionary" />-Schnittstelle ein Element mit dem angegebenen Schlüssel und Wert hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch die <xref:System.Collections.IDictionary.Item%2A> Eigenschaft zum Hinzufügen neuer Elemente durch Festlegen der Wert eines Schlüssels, der nicht vorhanden ist, im Wörterbuch enthalten z. B. `myCollection["myNonexistentKey"] = myValue` Aber wenn es sich bei der angegebene Schlüssel im Wörterbuch bereits vorhanden ist, Festlegen der <xref:System.Collections.IDictionary.Item%2A> Eigenschaft überschreibt den alten Wert. Im Gegensatz dazu die <xref:System.Collections.IDictionary.Add%2A> Methode vorhandene Elemente nicht geändert.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie den Zugriff auf die <xref:System.Collections.Generic.SortedDictionary%602> Klasse über die <xref:System.Collections.IDictionary?displayProperty=nameWithType> Schnittstelle. Das Codebeispiel erstellt ein leeres <xref:System.Collections.Generic.SortedDictionary%602> von Zeichenfolgen mit Zeichenfolgenschlüsseln und verwendet die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> Methode, um einige Elemente hinzuzufügen. Im Beispiel wird veranschaulicht, die die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> -Methode löst eine <xref:System.ArgumentException> beim Versuch, einen doppelten Schlüssel hinzuzufügen, oder wenn ein Schlüssel oder Wert, der den falschen Datentyp angegeben wird.  
  
 Im Codebeispiel veranschaulicht die Verwendung mehrerer anderer Member, der die <xref:System.Collections.IDictionary?displayProperty=nameWithType> Schnittstelle.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="key" /> weist einen Typ auf, der dem Schlüsseltyp <paramref name="TKey" /> des <see cref="T:System.Collections.IDictionary" /> nicht zugeordnet werden kann.  
  
- oder - 
 <paramref name="value" /> weist einen Typ auf, der dem Werttyp <paramref name="TValue" /> des <see cref="T:System.Collections.IDictionary" /> nicht zugeordnet werden kann.  
  
- oder - 
Ein Element mit dem gleichen Schlüssel ist bereits im <see cref="T:System.Collections.IDictionary" /> vorhanden.</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der im <see cref="T:System.Collections.IDictionary" /> zu suchende Schlüssel.</param>
        <summary>Ermittelt, ob das <see cref="T:System.Collections.IDictionary" /> ein Element mit dem angegebenen Schlüssel enthält.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Collections.IDictionary" /> ein Element mit dem Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `false` Wenn `key` ist ein Typ, der nicht zugewiesen werden, um den Typ des Schlüssels ist `TKey` von der <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 Diese Methode ist eine O (Log `n`)-Vorgang, in denen `n` ist <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Contains%2A> Methode der <xref:System.Collections.IDictionary?displayProperty=nameWithType> eine Verbindung mit einer <xref:System.Collections.Generic.SortedDictionary%602>. Im Beispiel wird veranschaulicht, dass der Methodenrückgabe `false` Wenn ein Schlüssel von den falschen Datentyp angegeben ist.  
  
 Das Codebeispiel ist Teil eines größeren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#6)]
[!code-vb[Generic.SortedDictionary.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Collections.IDictionaryEnumerator" /> für das <see cref="T:System.Collections.IDictionary" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Collections.IDictionaryEnumerator" /> für das <see cref="T:System.Collections.IDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Enumeration wird jedes Element ist ein <xref:System.Collections.DictionaryEntry> Struktur.  
  
 Die `foreach` -Anweisung der c#-Sprache (`for each` in C++ `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. Die <xref:System.Collections.IEnumerator.Reset%2A> Methode setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IDictionaryEnumerator.Entry%2A> nicht definiert. Aus diesem Grund müssen Sie Aufrufen der <xref:System.Collections.IEnumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.IDictionaryEnumerator.Entry%2A>.  
  
 Die <xref:System.Collections.IDictionaryEnumerator.Entry%2A> Eigenschaft dasselbe Objekt zurück, bis entweder <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IDictionaryEnumerator.Entry%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IDictionaryEnumerator.Entry%2A> ist nicht definiert. Um <xref:System.Collections.IDictionaryEnumerator.Entry%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn der Auflistung, z. B. das Hinzufügen Änderungen, ändern oder Löschen von Elementen, wenn der Enumerator unwiederbringlich ist ungültig, und der nächste Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein O (Log n)-Vorgang, wobei n eine Anzahl von Elementen in einer Auflistung ist.
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Aufzählen von Schlüssel/Wert-Paare im Wörterbuch mit den `foreach` Anweisung (`For Each` in Visual Basic `for each` in C++), der die Verwendung des Enumerators verborgen. Beachten Sie insbesondere, dass der Enumerator für die <xref:System.Collections.IDictionary?displayProperty=nameWithType> -Schnittstelle gibt <xref:System.Collections.DictionaryEntry> Objekte statt <xref:System.Collections.Generic.KeyValuePair%602> Objekte.  
  
 Das Codebeispiel ist Teil eines größeren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.IDictionary" /> eine feste Größe aufweist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Collections.IDictionary" /> eine feste Größe aufweist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.SortedDictionary`2" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Auflistung mit fester Größe lässt das Hinzufügen oder Entfernen von Elementen nach dem Erstellen der Auflistung nicht zu. Vorhandene Elemente können jedoch geändert werden.  
  
 Eine Auflistung mit fester Größe ist einfach eine Sammlung mit einem Wrapper, der verhindert wird, hinzufügen und Entfernen von Elementen. Wenn Änderungen, um die zugrunde liegende Auflistung vorgenommen werden, z. B. zum Hinzufügen oder Entfernen von Elementen, gibt die Auflistung mit fester Größe aus diesem Grund, diese Änderungen wieder.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Collections.IDictionary" /> schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Collections.IDictionary" /> schreibgeschützt ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.SortedDictionary`2" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Auflistung gestattet nach dem Erstellen der Auflistung weder das Hinzufügen noch das Ändern oder Entfernen von Elementen.  
  
 Eine Auflistung, die schreibgeschützt ist, ist einfach eine Sammlung mit einem Wrapper, der verhindert, dass die Auflistung zu ändern; Wenn die zugrunde liegende Auflistung Änderungen vorgenommen werden, spiegelt die schreibgeschützte Auflistung aus diesem Grund diese Änderungen wider.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IDictionary::Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des abzurufenden Elements.</param>
        <summary>Ruft das Element mit dem angegebenen Schlüssel ab oder legt dieses fest.</summary>
        <value>Das Element mit dem angegebenen Schlüssel, oder <see langword="null" />, wenn <paramref name="key" /> nicht im Wörterbuch enthalten ist oder <paramref name="key" /> einen Typ aufweist, der dem Schlüsseltyp <paramref name="TKey" /> des <see cref="T:System.Collections.Generic.SortedDictionary`2" /> nicht zugeordnet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht den Zugriff auf ein bestimmtes Element in der Auflistung mithilfe der folgenden C#-Syntax: `myCollection[key]` (`myCollection(key)` in Visual Basic).  
  
 Sie können auch die <xref:System.Collections.IDictionary.Item%2A> Eigenschaft zum Hinzufügen neuer Elemente durch Festlegen der Wert eines Schlüssels, der nicht vorhanden ist, im Wörterbuch enthalten z. B. `myCollection["myNonexistentKey"] = myValue` Aber wenn es sich bei der angegebene Schlüssel im Wörterbuch bereits vorhanden ist, Festlegen der <xref:System.Collections.IDictionary.Item%2A> Eigenschaft überschreibt den alten Wert. Im Gegensatz dazu die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> Methode vorhandene Elemente nicht geändert.  
  
 Die C#-Sprache verwendet die [dies](~/docs/csharp/language-reference/keywords/this.md) -Schlüsselwort zum Definieren der Indexer der <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A> Eigenschaft. Visual Basic implementiert <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A> als Standardeigenschaft und stellt auf diese Weise dieselbe Indizierungsfunktionalität bereit.  
  
 Abrufen des Werts dieser Eigenschaft ist eine O (Log `n`)-Vorgang; die Eigenschaft ist auch eine O (Log `n`) Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A> Eigenschaft (Indexer in c#) die <xref:System.Collections.IDictionary?displayProperty=nameWithType> eine Verbindung mit einer <xref:System.Collections.Generic.SortedDictionary%602>, sowie Möglichkeiten, die die Eigenschaft unterscheidet sich von der <xref:System.Collections.Generic.SortedDictionary%602.Item%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Im Beispiel wird veranschaulicht, wie z. B. die <xref:System.Collections.Generic.SortedDictionary%602.Item%2A?displayProperty=nameWithType> -Eigenschaft, die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> -Eigenschaft den Wert eines vorhandenen Schlüssels ändern kann, und können verwendet werden, um ein neues Schlüssel/Wert-Paar hinzufügen, wenn der angegebene Schlüssel nicht im Wörterbuch vorhanden ist. Außerdem wird gezeigt, die im Gegensatz zu den <xref:System.Collections.Generic.SortedDictionary%602.Item%2A?displayProperty=nameWithType> -Eigenschaft, die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> Eigenschaft löst keine Ausnahme aus, wenn `key` nicht im Wörterbuch vorhanden ist, gibt einen null-Verweis stattdessen. Schließlich im Beispiel wird veranschaulicht, dass beim Abrufen der <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> Eigenschaft gibt einen null-Verweis zurück, wenn `key` ist nicht der richtige Datentyp, und das Festlegen der Eigenschaft löst eine Ausnahme aus, wenn `key` ist nicht der richtigen Datentyp.  
  
 Das Codebeispiel ist Teil eines größeren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#3)]
[!code-vb[Generic.SortedDictionary.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Es wird ein Wert zugewiesen, und <paramref name="key" /> ist ein Typ, der dem Schlüsseltyp <paramref name="TKey" /> des <see cref="T:System.Collections.Generic.SortedDictionary`2" /> nicht zugeordnet werden kann.  
  
- oder - 
Es wird ein Wert zugewiesen, und <paramref name="value" /> ist ein Typ, der dem Werttyp <paramref name="TValue" /> des <see cref="T:System.Collections.Generic.SortedDictionary`2" /> nicht zugeordnet werden kann.</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.ICollection" /> ab, die die Schlüssel des <see cref="T:System.Collections.IDictionary" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.ICollection" />, die die Schlüssel des <see cref="T:System.Collections.IDictionary" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Schlüssel in der zurückgegebenen <xref:System.Collections.ICollection> werden entsprechend sortiert die <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> -Eigenschaft und sind garantiert in der gleichen Reihenfolge wie die entsprechenden Werte in der <xref:System.Collections.ICollection> zurückgegebenes der <xref:System.Collections.IDictionary.Values%2A> Eigenschaft.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Collections.IDictionary.Keys%2A> Eigenschaft der <xref:System.Collections.IDictionary?displayProperty=nameWithType> eine Verbindung mit einem <xref:System.Collections.Generic.SortedDictionary%602>, zum Auflisten der Schlüssel im Wörterbuch. Außerdem wird veranschaulicht, wie die Schlüssel/Wert-Paare im Wörterbuch aufgelistet; Beachten Sie, dass der Enumerator für die <xref:System.Collections.IDictionary?displayProperty=nameWithType> -Schnittstelle gibt <xref:System.Collections.DictionaryEntry> Objekte statt <xref:System.Collections.Generic.KeyValuePair%602> Objekte.  
  
 Das Codebeispiel ist Teil eines größeren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#9)]
[!code-vb[Generic.SortedDictionary.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des zu entfernenden Elements.</param>
        <summary>Entfernt das Element mit dem angegebenen Schlüssel aus dem <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine O (Log `n`) Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Remove%2A> von der <xref:System.Collections.IDictionary?displayProperty=nameWithType> eine Verbindung mit einem <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 Das Codebeispiel ist Teil eines größeren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#10)]
[!code-vb[Generic.SortedDictionary.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#10)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Collections.ICollection" /> ab, die die Werte im <see cref="T:System.Collections.IDictionary" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.ICollection" />, die die Werte im <see cref="T:System.Collections.IDictionary" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Werte in der zurückgegebenen <xref:System.Collections.ICollection> werden entsprechend sortiert die <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> -Eigenschaft und sind garantiert in der gleichen Reihenfolge wie die entsprechenden Schlüssel in der <xref:System.Collections.ICollection> zurückgegebenes der <xref:System.Collections.IDictionary.Keys%2A> Eigenschaft.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Values%2A> Eigenschaft der <xref:System.Collections.IDictionary?displayProperty=nameWithType> eine Verbindung mit einer <xref:System.Collections.Generic.SortedDictionary%602>, um die Werte im Wörterbuch aufgelistet. Außerdem wird veranschaulicht, wie die Schlüssel/Wert-Paare im Wörterbuch aufgelistet; Beachten Sie, dass der Enumerator für die <xref:System.Collections.IDictionary?displayProperty=nameWithType> -Schnittstelle gibt <xref:System.Collections.DictionaryEntry> Objekte statt <xref:System.Collections.Generic.KeyValuePair%602> Objekte.  
  
 Das Codebeispiel ist Teil eines größeren Beispiels, einschließlich der Ausgabe, für die <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> Methode.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#8)]
[!code-vb[Generic.SortedDictionary.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Die `foreach` -Anweisung der c#-Sprache (`for each` in C++ `For Each` Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft ist nicht definiert. Aus diesem Grund müssen Sie Aufrufen der <xref:System.Collections.IEnumerator.MoveNext%2A> Methode, um den Enumerator auf das erste Element der Auflistung vor dem Lesen des Werts von <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Die <xref:System.Collections.IEnumerator.Current%2A> Eigenschaft gibt das gleiche Element erst die <xref:System.Collections.IEnumerator.MoveNext%2A> Methode wird aufgerufen. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.IEnumerator.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn der Auflistung, z. B. das Hinzufügen Änderungen, ändern oder Löschen von Elementen, wenn der Enumerator unwiederbringlich ist ungültig, und der nächste Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standardimplementierungen der Auflistungen im <xref:System.Collections.Generic?displayProperty=nameWithType>-Namespace werden nicht synchronisiert.  
  
 Diese Methode ist ein O (Log n)-Vorgang, wobei n eine Anzahl von Elementen in einer Auflistung ist.
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.GetEnumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="sortedDictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel des abzurufenden Werts.</param>
        <param name="value">Wenn diese Methode zurückgegeben wird, enthält sie den dem angegebenen Schlüssel zugeordneten Wert, wenn der Schlüssel gefunden wird, andernfalls enthält sie den Standardwert für den Typ des <paramref name="value" />-Parameters.</param>
        <summary>Ruft den dem angegebenen Schlüssel zugeordneten Wert ab.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Collections.Generic.SortedDictionary`2" /> ein Element mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kombiniert die Funktionalität der <xref:System.Collections.Generic.SortedDictionary%602.ContainsKey%2A> Methode und die <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> Eigenschaft.  
  
 Wenn der Schlüssel nicht gefunden wird, und klicken Sie dann die `value` Parameter Ruft den entsprechenden Standardwert für den Werttyp `TValue`; z. B. 0 (null) für ganzzahlige Typen, `false` für boolesche Typen und `null` für Verweistypen zulässig.  
  
 Diese Methode ist eine O (Log `n`) Vorgang.  
  
   
  
## Examples  
 Das Beispiel zeigt, wie Sie mit der <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> Methode als eine effizientere Möglichkeit zum Abrufen von Werten in einem Programm, das häufig Schlüssel versucht, die nicht im Wörterbuch vorhanden sind. Im Beispiel wird auch gezeigt, wie die <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> -Eigenschaft (Indexer in c#) löst Ausnahmen aus, bei dem Versuch, die nicht vorhandene Schlüssel abzurufen.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedDictionary%602> Klasse.  
  
 [!code-csharp[Generic.SortedDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#5)]
 [!code-vb[Generic.SortedDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#5)]  
[!code-csharp[Generic.SortedDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;.ValueCollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SortedDictionary`2/ValueCollection&lt;!TKey, !TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As SortedDictionary(Of TKey, TValue).ValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::ValueCollection ^ Values { System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::ValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.ValueCollection" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;+ValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung ab, die die Werte im <see cref="T:System.Collections.Generic.SortedDictionary`2" /> enthält.</summary>
        <value>Eine <see cref="T:System.Collections.Generic.SortedDictionary`2.ValueCollection" />, die die Werte im <see cref="T:System.Collections.Generic.SortedDictionary`2" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Werte in der <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> werden entsprechend sortiert die <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> -Eigenschaft und sind in der gleichen Reihenfolge wie die zugehörigen Schlüssel in der <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> zurückgegebenes der <xref:System.Collections.Generic.SortedDictionary%602.Keys%2A> Eigenschaft.  
  
 Das zurückgegebene <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> ist nicht statisch, sondern, die <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> verweist zurück auf die Werte in der ursprünglichen <xref:System.Collections.Generic.SortedDictionary%602>. Daher wird in der <xref:System.Collections.Generic.SortedDictionary%602> im berücksichtigt werden weiterhin die <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection>.  
  
 Abrufen des Werts dieser Eigenschaft ist ein o(1)-Vorgang.  
  
   
  
## Examples  
 In diesem Codebeispiel wird veranschaulicht, wie die Werte im Wörterbuch mit Auflisten der <xref:System.Collections.Generic.SortedDictionary%602.Values%2A> -Eigenschaft, und wie die Schlüssel und Werte im Wörterbuch aufgelistet.  
  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Collections.Generic.SortedDictionary%602> Klasse.  
  
 [!code-csharp[Generic.SortedDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#8)]
 [!code-vb[Generic.SortedDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.SortedDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.SortedDictionary`2.ValueCollection" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>