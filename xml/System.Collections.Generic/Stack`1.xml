<Type Name="Stack&lt;T&gt;" FullName="System.Collections.Generic.Stack&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="472148ca2dba95c20c7a22169fb84ecb2843df8f" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75151483" /></Metadata><TypeSignature Language="C#" Value="public class Stack&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Stack`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Stack(Of T)&#xA;Implements ICollection, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Stack : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Stack&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_StackDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Gibt den Typ der Elemente im Stapel an.</typeparam>
    <summary>Stellt eine LIFO (Last-In-First-Out)-Auflistung variabler Größe von Instanzen desselben angegebenen Typs dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> wird als Array implementiert.  
  
 Stapel und Warteschlangen sind nützlich, wenn Sie temporären Speicher für Informationen benötigen. Das heißt, wenn Sie ein Element nach dem Abrufen seines Werts verwerfen möchten. Verwenden Sie <xref:System.Collections.Generic.Queue%601>, wenn Sie auf die Informationen in derselben Reihenfolge zugreifen müssen, in der Sie in der Sammlung gespeichert sind. Verwenden Sie <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType>, wenn Sie in umgekehrter Reihenfolge auf die Informationen zugreifen müssen.  
  
 Verwenden Sie die Typen <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> und <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>, wenn Sie von mehreren Threads gleichzeitig auf die Auflistung zugreifen müssen.  
  
 Eine häufige Verwendung für <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> ist das Beibehalten von Variablen Zuständen während Aufrufen anderer Prozeduren.  
  
 Drei Haupt Vorgänge können für eine <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> und deren Elemente ausgeführt werden:  
  
-   <xref:System.Collections.Generic.Stack%601.Push%2A> fügt ein Element am Anfang des <xref:System.Collections.Stack>ein.  
  
-   <xref:System.Collections.Generic.Stack%601.Pop%2A> entfernt ein Element von der obersten Position des <xref:System.Collections.Generic.Stack%601>.  
  
-   <xref:System.Collections.Generic.Stack%601.Peek%2A> gibt ein Element zurück, das sich oben in der <xref:System.Collections.Generic.Stack%601> befindet, aber nicht aus dem <xref:System.Collections.Generic.Stack%601>entfernt wird.  
  
 Die Kapazität einer <xref:System.Collections.Generic.Stack%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Stack%601> enthalten kann. Wenn Elemente zu einem <xref:System.Collections.Generic.Stack%601>hinzugefügt werden, wird die Kapazität nach Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird. Die Kapazität kann verringert werden, indem <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>aufgerufen wird.  
  
 Wenn <xref:System.Collections.Generic.Stack%601.Count%2A> kleiner als die Kapazität des Stapels ist, ist <xref:System.Collections.Generic.Stack%601.Push%2A> ein O (1)-Vorgang. Wenn die Kapazität für das neue Element erweitert werden muss, wird <xref:System.Collections.Generic.Stack%601.Push%2A> zu einem O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Stack%601.Count%2A>ist. <xref:System.Collections.Generic.Stack%601.Pop%2A> ist ein O (1)-Vorgang.  
  
 <xref:System.Collections.Generic.Stack%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen-Klasse veranschaulicht. Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher. Es wird nicht garantiert, dass alle Instanzmitglieder threadsicher sind.  
  
Eine <see cref="T:System.Collections.Generic.Stack`1" /> kann mehrere Leser gleichzeitig unterstützen, solange die Sammlung nicht geändert wird.  Obwohl das Auflisten durch eine Auflistung intrinsisch nicht eine Thread sichere Prozedur ist.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Iteratoren (C# und Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.Stack`1" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.Stack`1" />-Klasse, die die Standardanfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.Stack%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Stack%601> aufnehmen kann. Wenn Elemente zu einem <xref:System.Collections.Generic.Stack%601>hinzugefügt werden, wird die Kapazität nach Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Generic.Stack%601>eine Reihe von Größen der Größenänderung auszuführen.  
  
 Die Kapazität kann verringert werden, indem <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>aufgerufen wird.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden dieser Konstruktor und mehrere Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse veranschaulicht.  
  
 Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, aus der Elemente kopiert werden sollen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.Stack`1" />-Klasse, die aus der angegebenen Auflistung kopierte Elemente enthält und eine ausreichende Kapazität für die Anzahl der kopierten Elemente aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.Stack%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Stack%601> aufnehmen kann. Wenn Elemente zu einem <xref:System.Collections.Generic.Stack%601>hinzugefügt werden, wird die Kapazität nach Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Generic.Stack%601>eine Reihe von Größen der Größenänderung auszuführen.  
  
 Die Kapazität kann verringert werden, indem <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>aufgerufen wird.  
  
 Die Elemente werden in der Reihenfolge, in der Sie vom <xref:System.Collections.Generic.IEnumerator%601> der Auflistung gelesen werden, auf die <xref:System.Collections.Generic.Stack%601> kopiert.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, bei dem `n` die Anzahl der Elemente in `collection`ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden dieser Konstruktor und mehrere Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse veranschaulicht.  
  
 Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : int -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die anfängliche Anzahl von Elementen, die das <see cref="T:System.Collections.Generic.Stack`1" /> enthalten kann.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.Stack`1" />-Klasse, die über die angegebene anfängliche Kapazität, mindestens aber über die anfängliche Standardkapazität verfügt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.Stack%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Stack%601> aufnehmen kann. Wenn Elemente zu einem <xref:System.Collections.Generic.Stack%601>hinzugefügt werden, wird die Kapazität nach Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Generic.Stack%601>eine Reihe von Größen der Größenänderung auszuführen.  
  
 Die Kapazität kann verringert werden, indem <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>aufgerufen wird.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, bei dem `n` `capacity`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="stack.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Objekte aus dem <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601.Count%2A> ist auf NULL festgelegt, und Verweise auf andere Objekte von Elementen der Auflistung werden ebenfalls freigegeben.  
  
 Die Kapazität bleibt unverändert. Um die Kapazität des <xref:System.Collections.Generic.Stack%601>zurückzusetzen, wenden Sie <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>an. Wenn Sie ein leeres <xref:System.Collections.Generic.Stack%601> kürzen, wird die Kapazität des <xref:System.Collections.Generic.Stack%601> auf die Standardkapazität festgelegt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Stack%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberSignature Language="F#" Value="member this.Contains : 'T -&gt; bool" Usage="stack.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.Stack`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Bestimmt, ob sich ein Element in <see cref="T:System.Collections.Generic.Stack`1" /> befindet.</summary>
        <returns><see langword="true" />, wenn das <paramref name="item" /> in der <see cref="T:System.Collections.Generic.Stack`1" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, den Typ der Werte in der Liste.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Stack%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen in Auflistungen</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="stack.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.Stack`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index in <paramref name="array" />, an dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert <see cref="T:System.Collections.Generic.Stack`1" /> in ein vorhandenes eindimensionales <see cref="T:System.Array" />, beginnend beim angegebenen Arrayindex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden auf das Array in der LIFO-Reihenfolge (Last-in-First-Out) kopiert, ähnlich der Reihenfolge der Elemente, die von einer Folge von Aufrufen an <xref:System.Collections.Generic.Stack%601.Pop%2A>zurückgegeben werden.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Stack%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.Stack`1" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.ToArray" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.Stack&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Collections.Generic.Stack`1" /> enthalten sind.</summary>
        <value>Die Anzahl der Elemente, die in <see cref="T:System.Collections.Generic.Stack`1" /> enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität des <xref:System.Collections.Generic.Stack%601> ist die Anzahl der Elemente, die der <xref:System.Collections.Generic.Stack%601> speichern kann. <xref:System.Collections.Generic.Stack%601.Count%2A> ist die Anzahl der Elemente, die sich tatsächlich in der <xref:System.Collections.Generic.Stack%601>befinden.  
  
 Die Kapazität ist immer größer oder gleich <xref:System.Collections.Generic.Stack%601.Count%2A>. Wenn <xref:System.Collections.Generic.Stack%601.Count%2A> die Kapazität beim Hinzufügen von Elementen überschreitet, wird die Kapazität erhöht, indem das interne Array automatisch neu zugewiesen wird, bevor die alten Elemente kopiert und die neuen Elemente hinzugefügt werden.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden mehrere Eigenschaften und Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft.  
  
 Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Stack&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Stack`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Stack(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Stack&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.Stack&lt;'T&gt;.Enumerator" Usage="stack.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Stack&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator für den <see cref="T:System.Collections.Generic.Stack`1" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Stack`1.Enumerator" /> für den <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach`-Anweisung der C# Sprache (`for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> legt <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert bleibt. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste aufrufungs <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> oder <xref:System.Collections.Generic.Stack%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> löst eine <xref:System.InvalidOperationException>aus.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standard Implementierungen von Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dass die <xref:System.Collections.Generic.Stack%601> generische Klasse aufzählt. Die `foreach`-Anweisung (`For Each` in Visual Basic, `for each` C++in) wird zum Auflisten der Warteschlange verwendet.  
  
 Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Stack`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; 'T" Usage="stack.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das oberste Objekt von <see cref="T:System.Collections.Generic.Stack`1" /> zurück, ohne es zu entfernen.</summary>
        <returns>Das oberste Objekt im <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ähnelt der <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode, aber <xref:System.Collections.Generic.Stack%601.Peek%2A> ändert die <xref:System.Collections.Generic.Stack%601> nicht.  
  
 Wenn der Typ `T` ein Verweistyp ist, können `null` bei Bedarf als Platzhalter auf die <xref:System.Collections.Generic.Stack%601> geschoben werden.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Generic.Stack`1" /> ist leer.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public T Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Function Pop () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Pop();" />
      <MemberSignature Language="F#" Value="member this.Pop : unit -&gt; 'T" Usage="stack.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt das Objekt oben im <see cref="T:System.Collections.Generic.Stack`1" /> und gibt es zurück.</summary>
        <returns>Das Objekt, das von der obersten Position des <see cref="T:System.Collections.Generic.Stack`1" /> entfernt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ähnelt der <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode, aber <xref:System.Collections.Generic.Stack%601.Peek%2A> ändert die <xref:System.Collections.Generic.Stack%601> nicht.  
  
 Wenn der Typ `T` ein Verweistyp ist, können `null` bei Bedarf als Platzhalter auf die <xref:System.Collections.Generic.Stack%601> geschoben werden.  
  
 <xref:System.Collections.Generic.Stack%601> wird als Array implementiert. Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Generic.Stack`1" /> ist leer.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Push(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Push (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Push(T item);" />
      <MemberSignature Language="F#" Value="member this.Push : 'T -&gt; unit" Usage="stack.Push item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das Objekt, das auf dem <see cref="T:System.Collections.Generic.Stack`1" /> abgelegt werden soll. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt ein Objekt am Anfang des <see cref="T:System.Collections.Generic.Stack`1" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> wird als Array implementiert.  
  
 Wenn <xref:System.Collections.Generic.Stack%601.Count%2A> bereits der Kapazität entspricht, wird die Kapazität des <xref:System.Collections.Generic.Stack%601> erhöht, indem das interne Array automatisch neu zugewiesen wird. die vorhandenen Elemente werden dann in das neue Array kopiert, bevor das neue Element hinzugefügt wird.  
  
 Wenn der Typ `T` ein Verweistyp ist, können `null` bei Bedarf als Platzhalter auf die <xref:System.Collections.Generic.Stack%601> geschoben werden. Es belegt einen Slot im Stapel und wird wie ein beliebiges Objekt behandelt.  
  
 Wenn <xref:System.Collections.Generic.Stack%601.Count%2A> kleiner als die Kapazität des Stapels ist, ist <xref:System.Collections.Generic.Stack%601.Push%2A> ein O (1)-Vorgang. Wenn die Kapazität für das neue Element erweitert werden muss, wird <xref:System.Collections.Generic.Stack%601.Push%2A> zu einem O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Stack%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerator`1" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach`-Anweisung der C# Sprache (`for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.Generic.IEnumerator%601.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.Generic.IEnumerator%601.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert bleibt. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste aufrufungs <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>aus.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standard Implementierungen von Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.ICollection" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index in <paramref name="array" />, an dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.ICollection" /> in ein <see cref="T:System.Array" />, beginnend bei einem bestimmten <see cref="T:System.Array" />-Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ des Quell <xref:System.Collections.ICollection> nicht automatisch in den Typ des Ziel `array`umgewandelt werden kann, lösen die nicht generischen Implementierungen von <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> <xref:System.InvalidCastException>aus, wohingegen die generischen Implementierungen <xref:System.ArgumentException>auslösen.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Stack%601.Count%2A>ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
 <paramref name="array" /> verwendet keine nullbasierte Indizierung.  
  
- oder - 
Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.ICollection" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />.  
  
- oder - 
Der Typ der Quell-<see cref="T:System.Collections.ICollection" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value><see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.Stack`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standard Implementierungen von Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  In den seltenen Fällen, in denen Enumerationen mit Schreibzugriffen kämpfen, müssen Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Die Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt Sperren, bevor Sie auf die Auflistung zugreifen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.  In der Standardimplementierung der <see cref="T:System.Collections.Generic.Stack`1" /> gibt diese Eigenschaft immer die aktuelle Instanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standard Implementierungen von Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Gibt ein Objekt, das verwendet werden kann, zum Synchronisieren des Zugriffs auf die <xref:System.Collections.ICollection>. Die Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt Sperren, bevor Sie auf die Auflistung zugreifen. Der folgende Code zeigt die Verwendung der <xref:System.Collections.ICollection.SyncRoot%2A>-Eigenschaft für C#, C++und Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach`-Anweisung der C# Sprache (`for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert bleibt. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste aufrufungs <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>aus.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standard Implementierungen von Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="stack.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert <see cref="T:System.Collections.Generic.Stack`1" /> in ein neues Array.</summary>
        <returns>Ein neues Array, das Kopien der Elemente aus <see cref="T:System.Collections.Generic.Stack`1" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden auf das Array in der LIFO-Reihenfolge (Last-in-First-Out) kopiert, ähnlich der Reihenfolge der Elemente, die von einer Folge von Aufrufen an <xref:System.Collections.Generic.Stack%601.Pop%2A>zurückgegeben werden.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Stack%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Stack%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode.  
  
 Im Codebeispiel wird ein Stapel von Zeichen folgen mit Standardkapazität erstellt, und die <xref:System.Collections.Generic.Stack%601.Push%2A>-Methode wird verwendet, um fünf Zeichen folgen auf den Stapel zu überbringen. Die Elemente des Stapels werden aufgezählt, wodurch sich der Status des Stapels nicht ändert. Die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode wird verwendet, um die erste Zeichenfolge aus dem Stapel zu Popups. Die <xref:System.Collections.Generic.Stack%601.Peek%2A>-Methode wird verwendet, um das nächste Element im Stapel zu sehen, und anschließend wird die <xref:System.Collections.Generic.Stack%601.Pop%2A>-Methode verwendet, um Sie zu deaktivieren.  
  
 Die <xref:System.Collections.Generic.Stack%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Stapel Elemente darauf zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente erstellen. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array, das doppelt so groß wie der Stapel ist, wird erstellt, und die <xref:System.Collections.Generic.Stack%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Stack%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine Kopie des Stapels mit der Reihenfolge der umgekehrten Elemente zu erstellen; Daher befinden sich die drei NULL-Elemente am Ende.  
  
 Die <xref:System.Collections.Generic.Stack%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass die Zeichenfolge "vier" in der ersten Kopie des Stapels enthalten ist, nach der die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode die Kopie löscht, und die <xref:System.Collections.Generic.Stack%601.Count%2A>-Eigenschaft zeigt an, dass der Stapel leer ist.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="stack.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die Kapazität auf die Anzahl der tatsächlich im <see cref="T:System.Collections.Generic.Stack`1" /> befindlichen Elemente fest, sofern diese Anzahl unter 90 Prozent der aktuellen Kapazität liegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Arbeitsspeicher Aufwand einer Sammlung zu minimieren, wenn der Auflistung keine neuen Elemente hinzugefügt werden. Die Kosten für das erneute zuordnen und Kopieren einer großen <xref:System.Collections.Generic.Stack%601> können jedoch beträchtlich sein, sodass die <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>-Methode nichts bewirkt, wenn die Liste mehr als 90 Prozent der Kapazität hat. Dadurch wird vermieden, dass für einen relativ kleinen Gewinn keine großen Kosten für die erneute Zuordnung anfallen.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Stack%601.Count%2A>ist.  
  
 Um einen <xref:System.Collections.Generic.Stack%601> auf seinen ursprünglichen Zustand zurückzusetzen, rufen Sie die <xref:System.Collections.Generic.Stack%601.Clear%2A>-Methode auf, bevor Sie <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>-Methode aufrufen. Wenn Sie ein leeres <xref:System.Collections.Generic.Stack%601> kürzen, wird die Kapazität des <xref:System.Collections.Generic.Stack%601> auf die Standardkapazität festgelegt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Stack`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPeek : 'T -&gt; bool" Usage="stack.TryPeek result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop">
      <MemberSignature Language="C#" Value="public bool TryPop (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPop([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPop(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPop (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPop([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPop : 'T -&gt; bool" Usage="stack.TryPop result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
