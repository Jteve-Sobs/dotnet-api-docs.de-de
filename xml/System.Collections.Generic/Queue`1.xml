<Type Name="Queue&lt;T&gt;" FullName="System.Collections.Generic.Queue&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8ed33a0e4a44d158c8ec61951b56e47a9cee6c5a" /><Meta Name="ms.sourcegitcommit" Value="1b924db57b3a1cf768d98c21f9b988d6966a0f2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/06/2020" /><Meta Name="ms.locfileid" Value="78718216" /></Metadata><TypeSignature Language="C#" Value="public class Queue&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Queue`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Queue`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Queue(Of T)&#xA;Implements ICollection, IEnumerable(Of T), IReadOnlyCollection(Of T)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Queue : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Queue&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface ICollection" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public class Queue&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.ICollection" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Queue`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2" />
  <TypeSignature Language="VB.NET" Value="Public Class Queue(Of T)&#xA;Implements ICollection, IEnumerable(Of T)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Queue : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::ICollection" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type Queue&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IEnumerable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Queue`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Queue&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Queue`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type Queue&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System" FromVersion="4.0.0.0" To="System.Collections" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_QueueDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Gibt den Typ der Elemente in der Warteschlange an.</typeparam>
    <summary>Stellt eine FIFO-Auflistung (First-In-First-Out) von Objekten dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse implementiert eine generische Warteschlange als zirkuläres Array. In einem <xref:System.Collections.Generic.Queue%601> gespeicherte Objekte werden an einem Ende eingefügt und aus dem anderen entfernt. Warteschlangen und Stapel sind nützlich, wenn Sie temporären Speicher für Informationen benötigen. Das heißt, wenn Sie ein Element nach dem Abrufen seines Werts verwerfen möchten. Verwenden Sie <xref:System.Collections.Generic.Queue%601>, wenn Sie auf die Informationen in derselben Reihenfolge zugreifen müssen, in der Sie in der Sammlung gespeichert sind. Verwenden Sie <xref:System.Collections.Generic.Stack%601>, wenn Sie in umgekehrter Reihenfolge auf die Informationen zugreifen müssen. Verwenden Sie <xref:System.Collections.Concurrent.ConcurrentQueue%601> oder <xref:System.Collections.Concurrent.ConcurrentStack%601>, wenn Sie von mehreren Threads gleichzeitig auf die Sammlung zugreifen müssen.  
  
 Drei Haupt Vorgänge können für eine <xref:System.Collections.Generic.Queue%601> und deren Elemente ausgeführt werden:  
  
-   <xref:System.Collections.Generic.Queue%601.Enqueue%2A> fügt ein Element am Ende der <xref:System.Collections.Generic.Queue%601>hinzu.  
  
-   <xref:System.Collections.Generic.Queue%601.Dequeue%2A> entfernt das älteste Element am Anfang des <xref:System.Collections.Generic.Queue%601>.  
  
-   <xref:System.Collections.Generic.Queue%601.Peek%2A> Peek gibt das älteste Element zurück, das sich am Anfang des <xref:System.Collections.Generic.Queue%601> befindet, aber nicht aus dem <xref:System.Collections.Generic.Queue%601>entfernt wird.  
  
 Die Kapazität einer <xref:System.Collections.Generic.Queue%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Queue%601> enthalten kann. Wenn Elemente zu einem <xref:System.Collections.Generic.Queue%601>hinzugefügt werden, wird die Kapazität nach Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird. Die Kapazität kann verringert werden, indem <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>aufgerufen wird.  
  
 <xref:System.Collections.Generic.Queue%601> akzeptiert `null` als gültigen Wert für Verweis Typen und ermöglicht doppelte Elemente.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Queue%601> generischen-Klasse veranschaulicht. Im Codebeispiel wird eine Warteschlange mit Standardkapazität erstellt und die <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode verwendet, um fünf Zeichen folgen in die Warteschlange zu stellen. Die Elemente der Warteschlange werden aufgezählt, wodurch der Status der Warteschlange nicht geändert wird. Die <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Methode wird verwendet, um die erste Zeichenfolge aus der Warteschlange zu entfernen. Die <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode wird verwendet, um das nächste Element in der Warteschlange zu überprüfen. Anschließend wird die <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode verwendet, um Sie aus der Warteschlange zu entfernen.  
  
 Die <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Warteschlangen Elemente darin zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie der Warteschlange erstellt. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array wird doppelt so groß wie die Warteschlange erstellt, und die <xref:System.Collections.Generic.Queue%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine zweite Kopie der Warteschlange zu erstellen, die drei NULL-Elemente am Anfang enthält.  
  
 Die <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass sich die Zeichenfolge "vier" in der ersten Kopie der Warteschlange befindet, nach der die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode die Kopie löscht und die <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft anzeigt, dass die Warteschlange leer ist.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Öffentliche statische (<see langword="Shared" /> in Visual Basic) Member dieses Typs sind Thread sicher. Bei Instanzmembern ist die Threadsicherheit nicht gewährleistet.  
  
Eine <see cref="T:System.Collections.Generic.Queue`1" /> kann mehrere Leser gleichzeitig unterstützen, solange die Sammlung nicht geändert wird.  Obwohl das Auflisten durch eine Auflistung intrinsisch nicht eine Thread sichere Prozedur ist. Eine Thread sichere Warteschlange finden Sie unter <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.Queue`1" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.Queue`1" />-Klasse, die die Standardanfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.Queue%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Queue%601> aufnehmen kann. Wenn Elemente zu einem <xref:System.Collections.Generic.Queue%601>hinzugefügt werden, wird die Kapazität nach Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Generic.Queue%601>eine Reihe von Größen der Größenänderung auszuführen.  
  
 Die Kapazität kann verringert werden, indem <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>aufgerufen wird.  
  
 Dieser Konstruktor ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht diesen Konstruktor und mehrere andere Methoden der <xref:System.Collections.Generic.Queue%601> generischen-Klasse. Im Codebeispiel wird eine Warteschlange mit Standardkapazität erstellt und die <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode verwendet, um fünf Zeichen folgen in die Warteschlange zu stellen. Die Elemente der Warteschlange werden aufgezählt, wodurch der Status der Warteschlange nicht geändert wird. Die <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Methode wird verwendet, um die erste Zeichenfolge aus der Warteschlange zu entfernen. Die <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode wird verwendet, um das nächste Element in der Warteschlange zu überprüfen. Anschließend wird die <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode verwendet, um Sie aus der Warteschlange zu entfernen.  
  
 Die <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Warteschlangen Elemente darin zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie der Warteschlange erstellt. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array wird doppelt so groß wie die Warteschlange erstellt, und die <xref:System.Collections.Generic.Queue%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine zweite Kopie der Warteschlange zu erstellen, die drei NULL-Elemente am Anfang enthält.  
  
 Die <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass sich die Zeichenfolge "vier" in der ersten Kopie der Warteschlange befindet, nach der die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode die Kopie löscht und die <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft anzeigt, dass die Warteschlange leer ist.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Queue&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.Queue&lt;'T&gt;" Usage="new System.Collections.Generic.Queue&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Die Auflistung, deren Elemente in die neue <see cref="T:System.Collections.Generic.Queue`1" /> kopiert werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Collections.Generic.Queue`1" />-Klasse, die aus der angegebenen Auflistung kopierte Elemente enthält und eine ausreichende Kapazität für die Anzahl der kopierten Elemente aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.Queue%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Queue%601> aufnehmen kann. Wenn Elemente zu einem <xref:System.Collections.Generic.Queue%601>hinzugefügt werden, wird die Kapazität nach Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Generic.Queue%601>eine Reihe von Größen der Größenänderung auszuführen.  
  
 Die Kapazität kann verringert werden, indem <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>aufgerufen wird.  
  
 Die Elemente werden in der Reihenfolge, in der Sie vom <xref:System.Collections.Generic.IEnumerator%601> der Auflistung gelesen werden, auf die <xref:System.Collections.Generic.Queue%601> kopiert.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, bei dem `n` die Anzahl der Elemente in `collection`ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht diesen Konstruktor und mehrere andere Methoden der <xref:System.Collections.Generic.Queue%601> generischen-Klasse. Im Codebeispiel wird eine Warteschlange mit Standardkapazität erstellt und die <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode verwendet, um fünf Zeichen folgen in die Warteschlange zu stellen. Die Elemente der Warteschlange werden aufgezählt, wodurch der Status der Warteschlange nicht geändert wird. Die <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Methode wird verwendet, um die erste Zeichenfolge aus der Warteschlange zu entfernen. Die <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode wird verwendet, um das nächste Element in der Warteschlange zu überprüfen. Anschließend wird die <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode verwendet, um Sie aus der Warteschlange zu entfernen.  
  
 Die <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Warteschlangen Elemente darin zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie der Warteschlange erstellt. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array wird doppelt so groß wie die Warteschlange erstellt, und die <xref:System.Collections.Generic.Queue%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine zweite Kopie der Warteschlange zu erstellen, die drei NULL-Elemente am Anfang enthält.  
  
 Die <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass sich die Zeichenfolge "vier" in der ersten Kopie der Warteschlange befindet, nach der die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode die Kopie löscht und die <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft anzeigt, dass die Warteschlange leer ist.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Queue(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Queue&lt;'T&gt; : int -&gt; System.Collections.Generic.Queue&lt;'T&gt;" Usage="new System.Collections.Generic.Queue&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Die anfängliche Anzahl von Elementen, die das <see cref="T:System.Collections.Generic.Queue`1" /> enthalten kann.</param>
        <summary>Initialisiert eine neue, leere Instanz der <see cref="T:System.Collections.Generic.Queue`1" />-Klasse, die die angegebene Anfangskapazität aufweist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.Queue%601> ist die Anzahl der Elemente, die die <xref:System.Collections.Generic.Queue%601> aufnehmen kann. Wenn Elemente zu einem <xref:System.Collections.Generic.Queue%601>hinzugefügt werden, wird die Kapazität nach Bedarf automatisch erhöht, indem das interne Array neu zugewiesen wird.  
  
 Wenn die Größe der Auflistung geschätzt werden kann, entfällt beim Angeben der anfänglichen Kapazität die Notwendigkeit, beim Hinzufügen von Elementen zum <xref:System.Collections.Generic.Queue%601>eine Reihe von Größen der Größenänderung auszuführen.  
  
 Die Kapazität kann verringert werden, indem <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>aufgerufen wird.  
  
 Dieser Konstruktor ist ein O (`n`)-Vorgang, bei dem `n` `capacity`ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> ist kleiner als Null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="queue.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Objekte aus dem <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Queue%601.Count%2A> ist auf NULL festgelegt, und Verweise auf andere Objekte von Elementen der Auflistung werden ebenfalls freigegeben.  
  
 Die Kapazität bleibt unverändert. Um die Kapazität des <xref:System.Collections.Generic.Queue%601>zurückzusetzen, wenden Sie <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>an. Wenn Sie ein leeres <xref:System.Collections.Generic.Queue%601> kürzen, wird die Kapazität des <xref:System.Collections.Generic.Queue%601> auf die Standardkapazität festgelegt.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Queue%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Queue%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode.  
  
 Im Codebeispiel wird eine Warteschlange mit Standardkapazität erstellt und die <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode verwendet, um fünf Zeichen folgen in die Warteschlange zu stellen. Die Elemente der Warteschlange werden aufgezählt, wodurch der Status der Warteschlange nicht geändert wird. Die <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Methode wird verwendet, um die erste Zeichenfolge aus der Warteschlange zu entfernen. Die <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode wird verwendet, um das nächste Element in der Warteschlange zu überprüfen. Anschließend wird die <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode verwendet, um Sie aus der Warteschlange zu entfernen.  
  
 Die <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Warteschlangen Elemente darin zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie der Warteschlange erstellt. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array wird doppelt so groß wie die Warteschlange erstellt, und die <xref:System.Collections.Generic.Queue%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine zweite Kopie der Warteschlange zu erstellen, die drei NULL-Elemente am Anfang enthält.  
  
 Die <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass sich die Zeichenfolge "vier" in der ersten Kopie der Warteschlange befindet, nach der die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode die Kopie löscht und die <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft anzeigt, dass die Warteschlange leer ist.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.TrimExcess" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberSignature Language="F#" Value="member this.Contains : 'T -&gt; bool" Usage="queue.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das im <see cref="T:System.Collections.Generic.Queue`1" /> zu suchende Objekt. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Bestimmt, ob sich ein Element in <see cref="T:System.Collections.Generic.Queue`1" /> befindet.</summary>
        <returns><see langword="true" />, wenn das <paramref name="item" /> in der <see cref="T:System.Collections.Generic.Queue`1" /> gefunden wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bestimmt die Gleichheit mithilfe des Standard Gleichheits Vergleichs <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> für `T`, dem Typ der Werte in der Warteschlange.  
  
 Diese Methode führt eine lineare Suche aus. Daher ist diese Methode ein O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Queue%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Queue%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode.  
  
 Im Codebeispiel wird eine Warteschlange mit Standardkapazität erstellt und die <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode verwendet, um fünf Zeichen folgen in die Warteschlange zu stellen. Die Elemente der Warteschlange werden aufgezählt, wodurch der Status der Warteschlange nicht geändert wird. Die <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Methode wird verwendet, um die erste Zeichenfolge aus der Warteschlange zu entfernen. Die <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode wird verwendet, um das nächste Element in der Warteschlange zu überprüfen. Anschließend wird die <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode verwendet, um Sie aus der Warteschlange zu entfernen.  
  
 Die <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Warteschlangen Elemente darin zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie der Warteschlange erstellt. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array wird doppelt so groß wie die Warteschlange erstellt, und die <xref:System.Collections.Generic.Queue%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine zweite Kopie der Warteschlange zu erstellen, die drei NULL-Elemente am Anfang enthält.  
  
 Die <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass sich die Zeichenfolge "vier" in der ersten Kopie der Warteschlange befindet, nach der die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode die Kopie löscht und die <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft anzeigt, dass die Warteschlange leer ist.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations.md">Durchführen kulturunabhängiger Zeichenfolgenoperationen</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="queue.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.Generic.Queue`1" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="arrayIndex">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die <see cref="T:System.Collections.Generic.Queue`1" />-Elemente in ein vorhandenes eindimensionales <see cref="T:System.Array" />, beginnend beim angegebenen Arrayindex.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente werden in der gleichen Reihenfolge in die <xref:System.Array> kopiert, in der der Enumerator die <xref:System.Collections.Generic.Queue%601>durchläuft.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Queue%601.Count%2A>ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.Generic.Queue`1" /> ist größer als der verfügbare Platz vom <paramref name="arrayIndex" /> bis zum Ende des Ziel-<paramref name="array" />s.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.Queue&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente ab, die in <see cref="T:System.Collections.Generic.Queue`1" /> enthalten sind.</summary>
        <value>Die Anzahl der Elemente, die in <see cref="T:System.Collections.Generic.Queue`1" /> enthalten sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kapazität einer <xref:System.Collections.Generic.Queue%601> ist die Anzahl der Elemente, die von der <xref:System.Collections.Generic.Queue%601> gespeichert werden können. <xref:System.Collections.Generic.Queue%601.Count%2A> ist die Anzahl der Elemente, die sich tatsächlich in der <xref:System.Collections.Generic.Queue%601>befinden.  
  
 Die Kapazität ist immer größer oder gleich <xref:System.Collections.Generic.Queue%601.Count%2A>. Wenn <xref:System.Collections.Generic.Queue%601.Count%2A> die Kapazität beim Hinzufügen von Elementen überschreitet, wird die Kapazität erhöht, indem das interne Array automatisch neu zugewiesen wird, bevor die alten Elemente kopiert und die neuen Elemente hinzugefügt werden.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden mehrere Eigenschaften und Methoden der <xref:System.Collections.Generic.Queue%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft.  
  
 Im Codebeispiel wird eine Warteschlange mit Standardkapazität erstellt und die <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode verwendet, um fünf Zeichen folgen in die Warteschlange zu stellen. Die Elemente der Warteschlange werden aufgezählt, wodurch der Status der Warteschlange nicht geändert wird. Die <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Methode wird verwendet, um die erste Zeichenfolge aus der Warteschlange zu entfernen. Die <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode wird verwendet, um das nächste Element in der Warteschlange zu überprüfen. Anschließend wird die <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode verwendet, um Sie aus der Warteschlange zu entfernen.  
  
 Die <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Warteschlangen Elemente darin zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie der Warteschlange erstellt. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array wird doppelt so groß wie die Warteschlange erstellt, und die <xref:System.Collections.Generic.Queue%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine zweite Kopie der Warteschlange zu erstellen, die drei NULL-Elemente am Anfang enthält.  
  
 Die <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass sich die Zeichenfolge "vier" in der ersten Kopie der Warteschlange befindet, nach der die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode die Kopie löscht und die <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft anzeigt, dass die Warteschlange leer ist.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dequeue">
      <MemberSignature Language="C#" Value="public T Dequeue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Dequeue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Dequeue" />
      <MemberSignature Language="VB.NET" Value="Public Function Dequeue () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Dequeue();" />
      <MemberSignature Language="F#" Value="member this.Dequeue : unit -&gt; 'T" Usage="queue.Dequeue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt das Objekt am Anfang der <see cref="T:System.Collections.Generic.Queue`1" /> und gibt es zurück.</summary>
        <returns>Das Objekt, das vom Anfang der <see cref="T:System.Collections.Generic.Queue`1" /> entfernt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ähnelt der <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode, aber <xref:System.Collections.Generic.Queue%601.Peek%2A> ändert die <xref:System.Collections.Generic.Queue%601> nicht.  
  
 Wenn der Typ `T` ein Verweistyp ist, können `null` dem <xref:System.Collections.Generic.Queue%601> als Wert hinzugefügt werden.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Queue%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode.  
  
 Im Codebeispiel wird eine Warteschlange mit Standardkapazität erstellt und die <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode verwendet, um fünf Zeichen folgen in die Warteschlange zu stellen. Die Elemente der Warteschlange werden aufgezählt, wodurch der Status der Warteschlange nicht geändert wird. Die <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Methode wird verwendet, um die erste Zeichenfolge aus der Warteschlange zu entfernen. Die <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode wird verwendet, um das nächste Element in der Warteschlange zu überprüfen. Anschließend wird die <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode verwendet, um Sie aus der Warteschlange zu entfernen.  
  
 Die <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Warteschlangen Elemente darin zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie der Warteschlange erstellt. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array wird doppelt so groß wie die Warteschlange erstellt, und die <xref:System.Collections.Generic.Queue%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine zweite Kopie der Warteschlange zu erstellen, die drei NULL-Elemente am Anfang enthält.  
  
 Die <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass sich die Zeichenfolge "vier" in der ersten Kopie der Warteschlange befindet, nach der die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode die Kopie löscht und die <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft anzeigt, dass die Warteschlange leer ist.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Generic.Queue`1" /> ist leer.</exception>
        <altmember cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Peek" />
      </Docs>
    </Member>
    <Member MemberName="Enqueue">
      <MemberSignature Language="C#" Value="public void Enqueue (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Enqueue(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Enqueue (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Enqueue(T item);" />
      <MemberSignature Language="F#" Value="member this.Enqueue : 'T -&gt; unit" Usage="queue.Enqueue item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Das Objekt, das <see cref="T:System.Collections.Generic.Queue`1" /> hinzugefügt werden soll. Der Wert kann für Verweistypen <see langword="null" /> sein.</param>
        <summary>Fügt am Ende der <see cref="T:System.Collections.Generic.Queue`1" /> ein Objekt hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Collections.Generic.Queue%601.Count%2A> bereits der Kapazität entspricht, wird die Kapazität des <xref:System.Collections.Generic.Queue%601> erhöht, indem das interne Array automatisch neu zugewiesen wird. die vorhandenen Elemente werden dann in das neue Array kopiert, bevor das neue Element hinzugefügt wird.  
  
 Wenn <xref:System.Collections.Generic.Queue%601.Count%2A> kleiner als die Kapazität des internen Arrays ist, ist diese Methode ein O (1)-Vorgang. Wenn das interne Array neu zugeordnet werden muss, um das neue Element aufnehmen zu können, wird diese Methode zu einem O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Queue%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Queue%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode.  
  
 Im Codebeispiel wird eine Warteschlange mit Standardkapazität erstellt und die <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode verwendet, um fünf Zeichen folgen in die Warteschlange zu stellen. Die Elemente der Warteschlange werden aufgezählt, wodurch der Status der Warteschlange nicht geändert wird. Die <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Methode wird verwendet, um die erste Zeichenfolge aus der Warteschlange zu entfernen. Die <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode wird verwendet, um das nächste Element in der Warteschlange zu überprüfen. Anschließend wird die <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode verwendet, um Sie aus der Warteschlange zu entfernen.  
  
 Die <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Warteschlangen Elemente darin zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie der Warteschlange erstellt. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array wird doppelt so groß wie die Warteschlange erstellt, und die <xref:System.Collections.Generic.Queue%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine zweite Kopie der Warteschlange zu erstellen, die drei NULL-Elemente am Anfang enthält.  
  
 Die <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass sich die Zeichenfolge "vier" in der ersten Kopie der Warteschlange befindet, nach der die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode die Kopie löscht und die <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft anzeigt, dass die Warteschlange leer ist.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.Dequeue" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Peek" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Queue&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Queue`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Queue(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Queue&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.Queue&lt;'T&gt;.Enumerator" Usage="queue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Queue&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der die <see cref="T:System.Collections.Generic.Queue`1" /> durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.Queue`1.Enumerator" /> für das <see cref="T:System.Collections.Generic.Queue`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach`-Anweisung der C# Sprache (`for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> legt <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.Queue%601.Enumerator.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste aufrufungs <xref:System.Collections.Generic.Queue%601.Enumerator.MoveNext%2A> oder <xref:System.Collections.Generic.Queue%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> löst eine <xref:System.InvalidOperationException>aus.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standard Implementierungen von Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, dass die <xref:System.Collections.Generic.Queue%601> generische Klasse aufzählt. Die `foreach`-Anweisung (`For Each` in Visual Basic, `for each` C++in) wird zum Auflisten der Warteschlange verwendet.  
  
 Im Codebeispiel wird eine Warteschlange mit Standardkapazität erstellt und die <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode verwendet, um fünf Zeichen folgen in die Warteschlange zu stellen. Die Elemente der Warteschlange werden aufgezählt, wodurch der Status der Warteschlange nicht geändert wird. Die <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Methode wird verwendet, um die erste Zeichenfolge aus der Warteschlange zu entfernen. Die <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode wird verwendet, um das nächste Element in der Warteschlange zu überprüfen. Anschließend wird die <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode verwendet, um Sie aus der Warteschlange zu entfernen.  
  
 Die <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Warteschlangen Elemente darin zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie der Warteschlange erstellt. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array wird doppelt so groß wie die Warteschlange erstellt, und die <xref:System.Collections.Generic.Queue%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine zweite Kopie der Warteschlange zu erstellen, die drei NULL-Elemente am Anfang enthält.  
  
 Die <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass sich die Zeichenfolge "vier" in der ersten Kopie der Warteschlange befindet, nach der die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode die Kopie löscht und die <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft anzeigt, dass die Warteschlange leer ist.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Queue`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; 'T" Usage="queue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das Objekt am Anfang der <see cref="T:System.Collections.Generic.Queue`1" /> zurück, ohne es zu entfernen.</summary>
        <returns>Das Objekt am Anfang der <see cref="T:System.Collections.Generic.Queue`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ähnelt der <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode, aber <xref:System.Collections.Generic.Queue%601.Peek%2A> ändert die <xref:System.Collections.Generic.Queue%601> nicht.  
  
 Wenn der Typ `T` ein Verweistyp ist, können `null` dem <xref:System.Collections.Generic.Queue%601> als Wert hinzugefügt werden.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Queue%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode.  
  
 Im Codebeispiel wird eine Warteschlange mit Standardkapazität erstellt und die <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode verwendet, um fünf Zeichen folgen in die Warteschlange zu stellen. Die Elemente der Warteschlange werden aufgezählt, wodurch der Status der Warteschlange nicht geändert wird. Die <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Methode wird verwendet, um die erste Zeichenfolge aus der Warteschlange zu entfernen. Die <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode wird verwendet, um das nächste Element in der Warteschlange zu überprüfen. Anschließend wird die <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode verwendet, um Sie aus der Warteschlange zu entfernen.  
  
 Die <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Warteschlangen Elemente darin zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie der Warteschlange erstellt. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array wird doppelt so groß wie die Warteschlange erstellt, und die <xref:System.Collections.Generic.Queue%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine zweite Kopie der Warteschlange zu erstellen, die drei NULL-Elemente am Anfang enthält.  
  
 Die <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass sich die Zeichenfolge "vier" in der ersten Kopie der Warteschlange befindet, nach der die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode die Kopie löscht und die <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft anzeigt, dass die Warteschlange leer ist.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="T:System.Collections.Generic.Queue`1" /> ist leer.</exception>
        <altmember cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)" />
        <altmember cref="M:System.Collections.Generic.Queue`1.Dequeue" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;&#xA;override this.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;" Usage="queue.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.Generic.IEnumerator`1" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach`-Anweisung der C# Sprache (`for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. An dieser Position ist <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.Generic.IEnumerator%601.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.Generic.IEnumerator%601.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ist nicht definiert. Sie können <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nicht erneut auf das erste Element der Auflistung festlegen, sondern müssen eine neue Enumeratorinstanz erstellen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste aufrufungs <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>aus.  
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren. Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standard Implementierungen von Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.GetEnumerator" />
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As Array, index As Integer) Implements ICollection.CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.ICollection.CopyTo : Array * int -&gt; unit&#xA;override this.System.Collections.ICollection.CopyTo : Array * int -&gt; unit" Usage="queue.System.Collections.ICollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Das eindimensionale <see cref="T:System.Array" />, das das Ziel der aus der <see cref="T:System.Collections.ICollection" /> kopierten Elemente ist. Für das <see cref="T:System.Array" /> muss eine nullbasierte Indizierung verwendet werden.</param>
        <param name="index">Der nullbasierte Index im <paramref name="array" />, bei dem der Kopiervorgang beginnt.</param>
        <summary>Kopiert die Elemente der <see cref="T:System.Collections.ICollection" /> in ein <see cref="T:System.Array" />, beginnend bei einem bestimmten <see cref="T:System.Array" />-Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn der Typ des Quell <xref:System.Collections.ICollection> nicht automatisch in den Typ des Ziel `array`umgewandelt werden kann, lösen die nicht generischen Implementierungen von <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> <xref:System.InvalidCastException>aus, wohingegen die generischen Implementierungen <xref:System.ArgumentException>auslösen.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Queue%601.Count%2A>ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ist mehrdimensional.  
  
- oder - 
 <paramref name="array" /> hat keine nullbasierte Indizierung.  
  
- oder - 
Die Anzahl der Elemente in der Quell-<see cref="T:System.Collections.ICollection" /> ist größer als der verfügbare Platz vom <paramref name="index" /> bis zum Ende des Ziel-<paramref name="array" />s.  
  
- oder - 
Der Typ der Quell-<see cref="T:System.Collections.ICollection" /> kann nicht automatisch in den Typ des Ziel-<paramref name="array" /> umgewandelt werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.IsSynchronized : bool" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist.</summary>
        <value><see langword="true" />, wenn der Zugriff auf das <see cref="T:System.Collections.ICollection" /> synchronisiert (threadsicher) ist, andernfalls <see langword="false" />.  In der Standardimplementierung von <see cref="T:System.Collections.Generic.Queue`1" /> gibt diese Eigenschaft immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standard Implementierungen von Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> gibt ein Objekt zurück, mit dem der Zugriff auf <xref:System.Collections.ICollection> synchronisiert werden kann. Die Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt Sperren, bevor Sie auf die Auflistung zugreifen.  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Queue`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.System.Collections.ICollection.SyncRoot : obj" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, mit dem der Zugriff auf <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.</summary>
        <value>Ein Objekt, mit dem der Zugriff auf die <see cref="T:System.Collections.ICollection" /> synchronisiert werden kann.  In der Standardimplementierung der <see cref="T:System.Collections.Generic.Queue`1" /> gibt diese Eigenschaft immer die aktuelle Instanz zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standard Implementierungen von Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> werden nicht synchronisiert.  
  
 Die Enumeration einer Auflistung ist systemintern keine threadsichere Prozedur.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> gibt ein Objekt zurück, mit dem der Zugriff auf <xref:System.Collections.ICollection> synchronisiert werden kann. Die Synchronisierung ist nur wirksam, wenn alle Threads dieses Objekt Sperren, bevor Sie auf die Auflistung zugreifen. Der folgende Code zeigt die Verwendung der <xref:System.Collections.ICollection.SyncRoot%2A>-Eigenschaft für C#, C++und Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Das Abrufen des Werts dieser Eigenschaft ist ein O(1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="queue.System.Collections.IEnumerable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />, der zum Durchlaufen der Auflistung verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `foreach`-Anweisung der C# Sprache (`for each` in C++, `For Each` in Visual Basic) verbirgt die Komplexität der Enumeratoren. Daher empfiehlt es sich, `foreach` zu verwenden und den Enumerator nicht direkt zu ändern.  
  
 Mit Enumeratoren können die Daten in der Auflistung zwar gelesen, jedoch nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zu Beginn wird der Enumerator vor das erste Element in der Auflistung positioniert. <xref:System.Collections.IEnumerator.Reset%2A> setzt den Enumerator ebenfalls auf diese Position zurück.  An dieser Position ist <xref:System.Collections.IEnumerator.Current%2A> nicht definiert. Daher muss der Enumerator durch einen Aufruf von <xref:System.Collections.IEnumerator.MoveNext%2A> auf das erste Element der Auflistung gesetzt werden, bevor der Wert von <xref:System.Collections.IEnumerator.Current%2A> gelesen werden kann.  
  
 <xref:System.Collections.IEnumerator.Current%2A> gibt solange dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. <xref:System.Collections.IEnumerator.MoveNext%2A> legt <xref:System.Collections.IEnumerator.Current%2A> auf das nächste Element fest.  
  
 Wenn <xref:System.Collections.IEnumerator.MoveNext%2A> das Ende der Auflistung übergibt, wird der Enumerator hinter dem letzten Element in der Auflistung platziert, und <xref:System.Collections.IEnumerator.MoveNext%2A> gibt `false` zurück. Wenn sich der Enumerator an dieser Position befindet, geben nachfolgende Aufrufe von <xref:System.Collections.IEnumerator.MoveNext%2A> auch `false` zurück. Wenn der letzte Aufruf <xref:System.Collections.IEnumerator.MoveNext%2A> zurückgegebene `false`, <xref:System.Collections.IEnumerator.Current%2A> ist nicht definiert. Um <xref:System.Collections.IEnumerator.Current%2A> wieder auf das erste Element der Auflistung festzulegen, können Sie <xref:System.Collections.IEnumerator.Reset%2A> gefolgt von <xref:System.Collections.IEnumerator.MoveNext%2A> aufrufen.  
  
 Ein Enumerator bleibt gültig, solange die Auflistung unverändert ist. Wenn an der Auflistung Änderungen vorgenommen werden, z. b. das Hinzufügen, ändern oder Löschen von Elementen, wird der Enumerator unwiederbringlich ungültig, und der nächste aufrufungs <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> löst eine <xref:System.InvalidOperationException>aus. 
  
 Der Enumerator hat keinen exklusiven Zugriff auf die Auflistung; daher ist die Enumeration einer Auflistung systembedingt kein threadsicheres Verfahren.  Um während der Enumeration Threadsicherheit zu garantieren, können Sie die Auflistung während der gesamten Enumeration sperren.  Um den Lese- und Schreibzugriff auf diese Auflistung durch mehrere Threads zuzulassen, müssen Sie eine eigene Synchronisierung implementieren.  
  
 Standard Implementierungen von Auflistungen in <xref:System.Collections.Generic?displayProperty=nameWithType> werden nicht synchronisiert.  
  
 Diese Methode ist ein O (1)-Vorgang.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="queue.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die <see cref="T:System.Collections.Generic.Queue`1" />-Elemente in ein neues Array.</summary>
        <returns>Ein neues Array mit Elementen, die aus <see cref="T:System.Collections.Generic.Queue`1" /> kopiert werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Collections.Generic.Queue%601> wird nicht geändert. Die Reihenfolge der Elemente im neuen Array entspricht der Reihenfolge der Elemente vom Anfang des <xref:System.Collections.Generic.Queue%601> bis zum Ende.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Queue%601.Count%2A>ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden verschiedene Methoden der <xref:System.Collections.Generic.Queue%601> generischen Klasse veranschaulicht, einschließlich der <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode.  
  
 Im Codebeispiel wird eine Warteschlange mit Standardkapazität erstellt und die <xref:System.Collections.Generic.Queue%601.Enqueue%2A>-Methode verwendet, um fünf Zeichen folgen in die Warteschlange zu stellen. Die Elemente der Warteschlange werden aufgezählt, wodurch der Status der Warteschlange nicht geändert wird. Die <xref:System.Collections.Generic.Queue%601.Dequeue%2A> Methode wird verwendet, um die erste Zeichenfolge aus der Warteschlange zu entfernen. Die <xref:System.Collections.Generic.Queue%601.Peek%2A>-Methode wird verwendet, um das nächste Element in der Warteschlange zu überprüfen. Anschließend wird die <xref:System.Collections.Generic.Queue%601.Dequeue%2A>-Methode verwendet, um Sie aus der Warteschlange zu entfernen.  
  
 Die <xref:System.Collections.Generic.Queue%601.ToArray%2A>-Methode wird verwendet, um ein Array zu erstellen und die Warteschlangen Elemente darin zu kopieren. Anschließend wird das Array an den <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor übergeben, der <xref:System.Collections.Generic.IEnumerable%601>annimmt, und eine Kopie der Warteschlange erstellt. Die Elemente der Kopie werden angezeigt.  
  
 Ein Array wird doppelt so groß wie die Warteschlange erstellt, und die <xref:System.Collections.Generic.Queue%601.CopyTo%2A>-Methode wird verwendet, um die Array Elemente beginnend an der Mitte des Arrays zu kopieren. Der <xref:System.Collections.Generic.Queue%601.%23ctor%2A>-Konstruktor wird erneut verwendet, um eine zweite Kopie der Warteschlange zu erstellen, die drei NULL-Elemente am Anfang enthält.  
  
 Die <xref:System.Collections.Generic.Queue%601.Contains%2A>-Methode wird verwendet, um anzuzeigen, dass sich die Zeichenfolge "vier" in der ersten Kopie der Warteschlange befindet, nach der die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode die Kopie löscht und die <xref:System.Collections.Generic.Queue%601.Count%2A>-Eigenschaft anzeigt, dass die Warteschlange leer ist.  
  
 [!code-csharp[Generic.Queue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Queue/cs/source.cs#1)]
 [!code-vb[Generic.Queue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Queue/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="queue.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die Kapazität auf die Anzahl der tatsächlich im <see cref="T:System.Collections.Generic.Queue`1" /> befindlichen Elemente fest, sofern diese Anzahl unter 90 Prozent der aktuellen Kapazität liegt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um den Arbeitsspeicher Aufwand einer Sammlung zu minimieren, wenn der Auflistung keine neuen Elemente hinzugefügt werden. Die Kosten für das erneute zuordnen und Kopieren einer großen <xref:System.Collections.Generic.Queue%601> können jedoch beträchtlich sein, sodass die <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>-Methode nichts bewirkt, wenn die Liste mehr als 90 Prozent der Kapazität hat. Dadurch wird vermieden, dass für einen relativ kleinen Gewinn keine großen Kosten für die erneute Zuordnung anfallen.  
  
 Bei dieser Methode handelt es sich um einen O (`n`)-Vorgang, bei dem `n` <xref:System.Collections.Generic.Queue%601.Count%2A>ist.  
  
 Um einen <xref:System.Collections.Generic.Queue%601> auf seinen ursprünglichen Zustand zurückzusetzen, rufen Sie die <xref:System.Collections.Generic.Queue%601.Clear%2A>-Methode auf, bevor Sie <xref:System.Collections.Generic.Queue%601.TrimExcess%2A>-Methode aufrufen. Wenn Sie ein leeres <xref:System.Collections.Generic.Queue%601> kürzen, wird die Kapazität des <xref:System.Collections.Generic.Queue%601> auf die Standardkapazität festgelegt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Queue`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Queue`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="public bool TryDequeue (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryDequeue([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TryDequeue(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryDequeue (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryDequeue([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryDequeue : 'T -&gt; bool" Usage="queue.TryDequeue result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Queue`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPeek : 'T -&gt; bool" Usage="queue.TryPeek result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
