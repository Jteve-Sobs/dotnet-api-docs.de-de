<Type Name="WorkflowApplication" FullName="System.Activities.WorkflowApplication">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f3823380661482a43a8cc40c25fb70788b8dbf4d" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39861022" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class WorkflowApplication : System.Activities.Hosting.WorkflowInstance" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowApplication extends System.Activities.Hosting.WorkflowInstance" />
  <TypeSignature Language="DocId" Value="T:System.Activities.WorkflowApplication" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowApplication&#xA;Inherits WorkflowInstance" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowApplication sealed : System::Activities::Hosting::WorkflowInstance" />
  <TypeSignature Language="F#" Value="type WorkflowApplication = class&#xA;    inherit WorkflowInstance" />
  <AssemblyInfo>
    <AssemblyName>System.Activities</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Activities.Hosting.WorkflowInstance</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt einen Host für eine einzelne Instanz eines Workflows bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Activities.WorkflowApplication>-Klasse stellt einen Host für eine einzelne Workflowinstanz bereit. Dabei handelt es sich um einen Proxy für die tatsächliche Workflowinstanz, die über die Workflowlaufzeit verwaltet wird. Benutzer der <xref:System.Activities.WorkflowApplication>-Klasse können die Workflowlaufzeit anweisen, durch Aufrufen der entsprechenden Methoden für ein <xref:System.Activities.WorkflowApplication>-Objekt Aktionen für eine Workflowinstanz auszuführen. Wenn eine angeforderte Aktion nicht gültig ist, wird eine Ausnahme ausgelöst.  
  
 Mit der <xref:System.Activities.WorkflowApplication>-Klasse können Sie folgende Aufgaben ausführen:  
  
1.  Erstellen einer neuen Workflowinstanz oder Laden einer Workflowinstanz aus einem Instanzspeicher  
  
2.  Bereitstellen von Erweiterungen für Aktivitäten in einer Workflowinstanz  
  
3.  Steuern der Ausführung einer Workflowinstanz  
  
4.  Wiederaufnahme eines von einer Aktivität erstellten Lesezeichens in einer Workflowinstanz  
  
5.  Ablegen im Persistenzspeicher/Entladen einer Workflowinstanz  
  
6.  Aktivieren von Benachrichtigungen bei Ereignissen im Workflowinstanzlebenszyklus  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mit der angegebenen Workflowdefinition erstellt, die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Wenn der Workflow abgeschlossen ist, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Activities.WorkflowApplication" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication workflowDefinition" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Die Workflowdefinition.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Activities.WorkflowApplication" />-Klasse mit der angegebenen Workflowdefinition.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mithilfe einer Workflowdefinition erstellt, die aus einer einzelnen `DiceRoll`-Aktivität besteht. Die `DiceRoll`-Aktivität verfügt über zwei Ausgabeargumente, die die Ergebnisse des Würfelvorgangs darstellen. Wenn der Workflow abgeschlossen wurde, werden die Ausgaben im <xref:System.Activities.WorkflowApplication.Completed%2A>-Handler abgerufen, und die folgende Ausgabe wird in der Konsole angezeigt.  
  
```Output  
Workflow aae3fb48-7229-4737-b969-d63e131b96b3 Completed.   
The two dice are 1 and 5.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#21](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Activities.WorkflowIdentity definitionIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Activities.WorkflowIdentity definitionIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Activities.WorkflowIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, definitionIdentity As WorkflowIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Activities::WorkflowIdentity ^ definitionIdentity);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Activities.WorkflowIdentity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, definitionIdentity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Die Workflowdefinition.</param>
        <param name="definitionIdentity">Die Definitionsidentität.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Activities.WorkflowApplication" />-Klasse mit der angegebenen Workflowdefinition und Definitionsidentität.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, inputs As IDictionary(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, inputs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Die Workflowdefinition.</param>
        <param name="inputs">Die für die Stammaktivität der Workflowdefinition definierten Argumentwerte, die nach Argumentnamen geordnet sind.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Activities.WorkflowApplication" />-Klasse, die die angegebene Workflowdefinition und Argumentwerte verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mithilfe einer Workflowdefinition erstellt, die aus einer einzelnen `Divide`-Aktivität besteht. Diese Aktivität akzeptiert zwei Eingabeargumente und ein Wörterbuch von Eingabeargumenten, das die zwei weiterzugebenden Werte enthält, die nach Argumentnamen geordnet sind. Die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Wenn der Workflow abgeschlossen ist, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Workflow 8dc844c1-bbf8-4b21-a9a2-05f89e416055 Completed  
500 / 36 = 13 Remainder 32  
Workflow 8dc844c1-bbf8-4b21-a9a2-05f89e416055 Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowApplication (System.Activities.Activity workflowDefinition, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, System.Activities.WorkflowIdentity definitionIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflowDefinition, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, class System.Activities.WorkflowIdentity definitionIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.#ctor(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object},System.Activities.WorkflowIdentity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflowDefinition As Activity, inputs As IDictionary(Of String, Object), definitionIdentity As WorkflowIdentity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowApplication(System::Activities::Activity ^ workflowDefinition, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, System::Activities::WorkflowIdentity ^ definitionIdentity);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowApplication : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; * System.Activities.WorkflowIdentity -&gt; System.Activities.WorkflowApplication" Usage="new System.Activities.WorkflowApplication (workflowDefinition, inputs, definitionIdentity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflowDefinition" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
      </Parameters>
      <Docs>
        <param name="workflowDefinition">Die Workflowdefinition.</param>
        <param name="inputs">Die Definitionsidentität.</param>
        <param name="definitionIdentity">Die für die Stammaktivität der Workflowdefinition definierten Argumentwerte, die nach Argumentnamen geordnet sind.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Activities.WorkflowApplication" />-Klasse, die die angegebene Workflowdefinition, Argumentwerte und Definitionsidentität verwendet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Benachrichtigt die Workflowlaufzeit, dass diese Workflowinstanz abgebrochen werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein von einer <xref:System.Activities.WorkflowApplication> gehosteter Workflow abgebrochen wird, wird der <xref:System.Activities.WorkflowApplication.Aborted%2A>-Handler aufgerufen, und der <xref:System.Activities.WorkflowApplication.Completed%2A>-Handler wird nicht aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="override this.Abort : unit -&gt; unit" Usage="workflowApplication.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Benachrichtigt die Workflowlaufzeit, dass diese Workflowinstanz abgebrochen werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein von einer <xref:System.Activities.WorkflowApplication> gehosteter Workflow abgebrochen wird, wird der <xref:System.Activities.WorkflowApplication.Aborted%2A>-Handler aufgerufen, und der <xref:System.Activities.WorkflowApplication.Completed%2A>-Handler wird nicht aufgerufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mit der angegebenen Workflowdefinition erstellt, die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Nachdem der Workflow gestartet wurde, wird <xref:System.Activities.WorkflowApplication.Abort%2A> aufgerufen. Wenn der Workflow abgebrochen wird, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Starting the workflow.   
Workflow 3b76d562-516a-4a52-b17c-0f2ce531ad93 Idle.   
Workflow 3b76d562-516a-4a52-b17c-0f2ce531ad93 Aborted  
Exception: System.Activities.WorkflowApplicationAbortedException  
The workflow has been aborted.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#11](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (string reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(string reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Abort(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (reason As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::String ^ reason);" />
      <MemberSignature Language="F#" Value="override this.Abort : string -&gt; unit" Usage="workflowApplication.Abort reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="reason">Der Grund für den angeforderten Abbruch.</param>
        <summary>Benachrichtigt die Workflowlaufzeit, dass diese Workflowinstanz aus dem angegebenen Grund abgebrochen werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein von einer <xref:System.Activities.WorkflowApplication> gehosteter Workflow abgebrochen wird, wird der <xref:System.Activities.WorkflowApplication.Aborted%2A>-Handler aufgerufen, und der <xref:System.Activities.WorkflowApplication.Completed%2A>-Handler wird nicht aufgerufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mit der angegebenen Workflowdefinition erstellt, die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Nachdem der Workflow gestartet wurde, wird <xref:System.Activities.WorkflowApplication.Abort%2A> aufgerufen. Wenn der Workflow abgebrochen wird, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Starting the workflow.   
Workflow 607b042e-98db-4bbe-abe8-f4d750feec41 Idle.   
Workflow 607b042e-98db-4bbe-abe8-f4d750feec41 Aborted  
Exception: System.Activities.WorkflowApplicationAbortedException  
The reason for aborting the workflow.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#11](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Aborted">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt; Aborted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationAbortedEventArgs&gt; Aborted" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Aborted" />
      <MemberSignature Language="VB.NET" Value="Public Property Aborted As Action(Of WorkflowApplicationAbortedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ Aborted { Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationAbortedEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Aborted : Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Aborted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationAbortedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Action`1" />-Aktion ab, die bei Abbruch der Workflowinstanz ausgelöst wird, bzw. legt sie fest.</summary>
        <value>Die Aktion, die bei Abbruch der Workflowinstanz ausgelöst wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein von einer <xref:System.Activities.WorkflowApplication> gehosteter Workflow abgebrochen wird, wird der <xref:System.Activities.WorkflowApplication.Aborted%2A>-Handler aufgerufen, und der <xref:System.Activities.WorkflowApplication.Completed%2A>-Handler wird nicht aufgerufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die in den <xref:System.Activities.WorkflowApplicationAbortedEventArgs>-Handler einer <xref:System.Activities.WorkflowApplication.Aborted%2A>-Instanz übergebenen <xref:System.Activities.WorkflowApplication> überprüft, und es werden Informationen darüber angezeigt, warum der Workflow abgebrochen wurde.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#5](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInitialInstanceValues">
      <MemberSignature Language="C#" Value="public void AddInitialInstanceValues (System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,object&gt; writeOnlyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInitialInstanceValues(class System.Collections.Generic.IDictionary`2&lt;class System.Xml.Linq.XName, object&gt; writeOnlyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.AddInitialInstanceValues(System.Collections.Generic.IDictionary{System.Xml.Linq.XName,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddInitialInstanceValues (writeOnlyValues As IDictionary(Of XName, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddInitialInstanceValues(System::Collections::Generic::IDictionary&lt;System::Xml::Linq::XName ^, System::Object ^&gt; ^ writeOnlyValues);" />
      <MemberSignature Language="F#" Value="member this.AddInitialInstanceValues : System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName, obj&gt; -&gt; unit" Usage="workflowApplication.AddInitialInstanceValues writeOnlyValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writeOnlyValues" Type="System.Collections.Generic.IDictionary&lt;System.Xml.Linq.XName,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="writeOnlyValues">Die Metadatenwerte, die in der ersten Persistenz enthalten sein sollen.</param>
        <summary>Gibt Instanzmetadatenwerte an, die in der ersten Persistenz einer neuen Instanz enthalten sind.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginCancel">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bricht einen Workflow mithilfe des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters asynchron ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginCancel (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginCancel(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCancel(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginCancel (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginCancel(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginCancel : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginCancel (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Abbruchvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Bricht eine Workflowinstanz mithilfe des angegebenen <see cref="T:System.AsyncCallback" /> und des vom Benutzer bereitgestellten Status asynchron ab.</summary>
        <returns>Ein Verweis auf den asynchronen Abbruchvorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, ob der Abbruchvorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndCancel%2A> auf. <xref:System.Activities.WorkflowApplication.EndCancel%2A> kann innerhalb oder außerhalb der `callback`-Methode aufgerufen werden. Wenn das <xref:System.Activities.WorkflowApplication.EndCancel%2A>-Element aufgerufen wird, bevor der Abbruchvorgang abgeschlossen ist, wird es bis zum Abschluss des Abbruchvorgangs gesperrt. Standardmäßig muss der Abbruchvorgang innerhalb von 30 Sekunden abgeschlossen sein. Andernfalls löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndCancel%2A> aus.  
  
 Diese Methode bricht einen Workflow mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron ab. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginCancel (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginCancel(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCancel(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginCancel (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginCancel(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginCancel : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginCancel (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Intervall, in dem der Abbruchvorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Abbruchvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Bricht eine Workflowinstanz mithilfe des angegebenen Timeoutintervalls, des angegebenen <see cref="T:System.AsyncCallback" /> und des vom Benutzer bereitgestellten Status asynchron ab.</summary>
        <returns>Ein Verweis auf den asynchronen Abbruchvorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, ob der Abbruchvorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndCancel%2A> auf. <xref:System.Activities.WorkflowApplication.EndCancel%2A> kann innerhalb oder außerhalb der im `callback`-Parameter angegebenen Methode aufgerufen werden. Wenn das <xref:System.Activities.WorkflowApplication.EndCancel%2A>-Element aufgerufen wird, bevor der Abbruchvorgang abgeschlossen ist, wird es bis zum Abschluss des Abbruchvorgangs gesperrt. Wenn der Abbruchvorgang nicht innerhalb des mit dem `timeOut`-Parameter angegebenen Intervalls abgeschlossen wird, löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndCancel%2A> aus.  
  
 Diese Methode bricht einen Workflow mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron ab. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginCreateDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen Standardinstanzbesitzer asynchronen mithilfe des asynchronen <see cref="T:System.IAsyncResult" /> Entwurfsmusters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginCreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginCreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginCreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginCreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="definitionIdentity">Die Definitionsidentität.</param>
        <param name="identityFilter">Der Identität-Filter.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Erstellt einen Standardinstanzbesitzer asynchron mithilfe des <see cref="T:System.IAsyncResult" /> asynchronen Entwurfsmusters mit dem angegebenen Instanzspeicher, Definitionsidentität, Identitätsfilter, Rückruf und Zustand.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginCreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginCreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginCreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginCreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginCreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="definitionIdentity">Die Definitionsidentität.</param>
        <param name="identityFilter">Der Identität-Filter.</param>
        <param name="timeout">Das Intervall, in dem der Ladebeginnvorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Erstellt einen Standardinstanzbesitzer asynchron mithilfe des <see cref="T:System.IAsyncResult" /> asynchronen Entwurfsmusters mit dem angegebenen Instanzspeicher, Definitionsidentität, Identitätsfilter, Timeoutintervall, Rückruf und Zustand.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginDeleteDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht einen Standardinstanzbesitzer asynchron mithilfe des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginDeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginDeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginDeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginDeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner (instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Löscht den Standardbesitzer einer Instanz asynchron unter Verwendung des <see cref="T:System.IAsyncResult" /> asynchronen Entwurfsmusters mit angegebenem Instanzspeicher, Rückruf und Zustand.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginDeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginDeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginDeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginDeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginDeleteDefaultInstanceOwner (instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="timeout">Das Intervall, in dem der Ladebeginnvorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Löscht den Standardbesitzer einer Instanz asynchron unter Verwendung des <see cref="T:System.IAsyncResult" /> asynchronen Entwurfsmusters mit angegebenem Instanzspeicher, Timeoutinterval, Rückruf und Zustand.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginGetInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft asynchron den Besitzer einer Instanz unter Verwendung des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginGetInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetInstance (instanceId, instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Der Instanzbezeichner.</param>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Ruft asynchron den Besitzer einer Instanz mithilfe des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters mit dem angegebenen Instanzbezeichner, Instanzspeicher, Rückruf und Zustand ab.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetInstance (instanceId, instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Der Instanzbezeichner.</param>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="timeout">Das Intervall, in dem der Ladebeginnvorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Ruft asynchron den Besitzer einer Instanz mithilfe des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters mit dem angegebenen Instanzbezeichner, Instanzspeicher, Timeoutinterval, Rückruf und Zustand ab.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginGetRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft asynchron den Besitzer einer ausführbaren Instanz unter Verwendung des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetRunnableInstance (instanceStore, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Ruft asynchron den Besitzer einer ausführbaren Instanz unter Verwendung des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters mit angegebenem Instanzspeicher, Rückruf und Zustand ab.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static IAsyncResult BeginGetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IAsyncResult BeginGetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginGetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IAsyncResult ^ BeginGetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member BeginGetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="System.Activities.WorkflowApplication.BeginGetRunnableInstance (instanceStore, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="timeout">Das Intervall, in dem der Ladebeginnvorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Ruft asynchron den Besitzer einer ausführbaren Instanz unter Verwendung des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters mit angegebenem Instanzspeicher, Timeoutinterval, Rückruf und Zustand ab.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoad">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt einen Workflow mithilfe des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters asynchron aus einem Instanzspeicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Lädt einen Workflow asynchron aus einem Instanzspeicher unter Verwendung des asynchronen Entwurfsmusters <see cref="T:System.IAsyncResult" /> mit angegebener Instanz sowie angegebenem Rückruf und Zustand.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (Guid instanceId, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(valuetype System.Guid instanceId, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Guid,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instanceId As Guid, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(Guid instanceId, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Guid * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instanceId, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Ein eindeutiger Bezeichner (128 Bit) für die Workflowinstanz.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Lädt einen Workflow asynchron aus einem Instanzspeicher, wobei der angegebene Instanzbezeichner, die angegebene Rückrufmethode und der vom Benutzer bereitgestellte Status verwendet werden.</summary>
        <returns>Der Status eines asynchronen Vorgangs.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, updateMap, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz.</param>
        <param name="updateMap">Die Updatezuordnung.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Lädt einen Workflow asynchron aus einem Instanzspeicher unter Verwendung des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters mit angegebener Instanz und Update-Zuordnung sowie angegebenem Rückruf und Zustand.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz.</param>
        <param name="timeout">Das Intervall, in dem der Ladebeginnvorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Lädt einen Workflow asynchron aus einem Instanzspeicher unter Verwendung des asynchronen Entwurfsmusters <see cref="T:System.IAsyncResult" /> mit angegebener Instanz und Zeitüberschreitungs-Intervall sowie angegebenem Timeoutinterval, Rückruf und Zustand.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (Guid instanceId, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(valuetype System.Guid instanceId, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Guid,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instanceId As Guid, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(Guid instanceId, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : Guid * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instanceId, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instanceId">Ein eindeutiger Bezeichner (128 Bit) für die Workflowinstanz.</param>
        <param name="timeout">Das Intervall, in dem der Ladebeginnvorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Lädt einen Workflow asynchron aus einem Instanzspeicher, wobei der angegebene Instanzbezeichner, das angegebene Timeoutintervall, die angegebene Rückrufmethode und der vom Benutzer bereitgestellte Status verwendet werden.</summary>
        <returns>Der Status eines asynchronen Vorgangs.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoad (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoad(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoad(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoad (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoad(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoad : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoad (instance, updateMap, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz.</param>
        <param name="updateMap">Die Updatezuordnung.</param>
        <param name="timeout">Das Intervall, in dem der Ladebeginnvorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Ladebeginnvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Lädt einen Workflow asynchron aus einem Instanzspeicher unter Verwendung des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters mit angegebener Instanz und Update-Zuordnung sowie angegebenem Timeoutinterval, Rückruf und Zustand.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoadRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initiiert den asynchronen Prozess zum Laden einer ausführbaren Workflowinstanz aus dem <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine ausführbare Instanz ist eine Instanz, für die der Timer bzw. die Instanzsperre abgelaufen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoadRunnableInstance (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoadRunnableInstance(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoadRunnableInstance(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoadRunnableInstance (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoadRunnableInstance(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoadRunnableInstance : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoadRunnableInstance (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Die Methode, die aufgerufen werden soll, wenn der Vorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales anwendungsspezifisches Objekt, das Informationen über den asynchronen Vorgang enthält.</param>
        <summary>Initiiert einen Vorgang zum Laden einer ausführbaren Workflowinstanz aus dem <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine ausführbare Instanz ist eine Instanz, für die der Timer bzw. die Instanzsperre abgelaufen ist.  
  
 Um zu ermitteln, ob der Ladevorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> auf. <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> kann innerhalb oder außerhalb der `callback`-Methode aufgerufen werden. Wenn das <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> aufgerufen wird, bevor der Wiederaufnahmevorgang abgeschlossen ist, wird es bis zum Abschluss des Wiederaufnahmevorgangs gesperrt. Standardmäßig muss der Wiederaufnahmevorgang innerhalb von 30 Sekunden abgeschlossen sein. Andernfalls löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> aus.  
  
 Diese Methode lädt einen Workflow mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginLoadRunnableInstance (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginLoadRunnableInstance(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginLoadRunnableInstance(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginLoadRunnableInstance (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginLoadRunnableInstance(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginLoadRunnableInstance : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginLoadRunnableInstance (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Intervall, in dem der Ladevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen werden soll, wenn der Vorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales anwendungsspezifisches Objekt, das Informationen über den asynchronen Vorgang enthält.</param>
        <summary>Initiiert einen Vorgang zum Laden einer ausführbaren Workflowinstanz aus dem <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />, wobei das angegebene Timeoutintervall verwendet wird.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine ausführbare Instanz ist eine Instanz, für die der Timer bzw. die Instanzsperre abgelaufen ist.  
  
 Um zu ermitteln, ob der Ladevorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> auf. <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> kann innerhalb oder außerhalb der `callback`-Methode aufgerufen werden. Wenn das <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> aufgerufen wird, bevor der Wiederaufnahmevorgang abgeschlossen ist, wird es bis zum Abschluss des Wiederaufnahmevorgangs gesperrt. Wenn der Ladevorgang innerhalb des angegebenen Timeoutintervalls nicht abgeschlossen wird, löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndLoadRunnableInstance%2A> aus.  
  
 Diese Methode lädt einen Workflow mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPersist">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Speichert eine Workflowinstanz mithilfe des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters asynchron in einem Instanzspeicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPersist">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPersist (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPersist(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginPersist(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPersist (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPersist(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginPersist : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginPersist (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Beibehaltungsvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Speichert eine Workflowinstanz mithilfe der angegebenen Rückrufmethode und des vom Benutzer bereitgestellten Status asynchron in einem Instanzspeicher.</summary>
        <returns>Ein Verweis auf den asynchronen Persistenzspeichervorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, ob der Persistenzspeichervorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndPersist%2A> auf. <xref:System.Activities.WorkflowApplication.EndPersist%2A> kann innerhalb oder außerhalb der Methode aufgerufen werden, auf die im `callback`-Parameter verwiesen wird. Wenn das <xref:System.Activities.WorkflowApplication.EndPersist%2A>-Element aufgerufen wird, bevor der Persistenzspeichervorgang abgeschlossen ist, wird es bis zum Abschluss des Persistenzspeichervorgangs gesperrt. Wenn der Persistenzspeichervorgang innerhalb von 30 Sekunden nicht abgeschlossen wird, löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndPersist%2A> aus.  
  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
 Diese Methode speichert einen Workflow mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron im Persistenzspeicher. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginPersist">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPersist (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPersist(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginPersist(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPersist (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPersist(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginPersist : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginPersist (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Intervall, in dem der Persistenzspeichervorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Beibehaltungsvorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Speichert eine Workflowinstanz mithilfe des angegebenen Timeoutintervalls, der angegebenen Rückrufmethode und des vom Benutzer bereitgestellten Status asynchron in einem Instanzspeicher.</summary>
        <returns>Ein Verweis auf den asynchronen Persistenzspeichervorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, ob der Persistenzspeichervorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndPersist%2A> auf. <xref:System.Activities.WorkflowApplication.EndPersist%2A> kann innerhalb oder außerhalb der Methode aufgerufen werden, auf die im `callback`-Parameter verwiesen wird. Wenn das <xref:System.Activities.WorkflowApplication.EndPersist%2A>-Element aufgerufen wird, bevor der Persistenzspeichervorgang abgeschlossen ist, wird es bis zum Abschluss des Persistenzspeichervorgangs gesperrt. Wenn der Persistenzspeichervorgang innerhalb des angegebenen Timeoutintervalls nicht abgeschlossen wird, löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndPersist%2A> aus.  
  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
 Diese Methode speichert eine Workflowinstanz mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron im Persistenzspeicher. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginResumeBookmark">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initiiert einen asynchronen Vorgang zur Wiederaufnahme eines Lesezeichens.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (System.Activities.Bookmark bookmark, object value, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.Activities.Bookmark,System.Object,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : System.Activities.Bookmark * obj * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmark, value, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Das wiederaufzunehmende Lesezeichen.</param>
        <param name="value">Ein Objekt, das als Parameter an die Methode übergeben wird, die bei Wiederaufnahme des Lesezeichens aufgerufen wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Wiederaufnahmevorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Initiiert einen Vorgang zur Wiederaufnahme eines Lesezeichens, wobei der angegebene Wert, die angegebene Rückrufmethode und der angegebene Status verwendet werden.</summary>
        <returns>Ein Verweis auf den asynchronen Lesezeichenwiederaufnahmevorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, ob der Wiederaufnahmevorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> auf. <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> kann innerhalb oder außerhalb der `callback`-Methode aufgerufen werden. Wenn das <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> aufgerufen wird, bevor der Wiederaufnahmevorgang abgeschlossen ist, wird es bis zum Abschluss des Wiederaufnahmevorgangs gesperrt. Standardmäßig muss der Wiederaufnahmevorgang innerhalb von 30 Sekunden abgeschlossen sein. Andernfalls löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> aus.  
  
 Diese Methode nimmt ein Lesezeichen mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron wieder auf. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (string bookmarkName, object value, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(string bookmarkName, object value, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.String,System.Object,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginResumeBookmark (bookmarkName As String, value As Object, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : string * obj * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmarkName, value, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Der Name des Lesezeichens, das wiederaufgenommen werden soll.</param>
        <param name="value">Ein Objekt, das als Parameter an die Methode übergeben wird, die bei Wiederaufnahme des Lesezeichens aufgerufen wird.</param>
        <param name="callback">Die Methode, die bei Abschluss des asynchronen Vorgangs aufgerufen wird.</param>
        <param name="state">Der Ausführungsstatus eines Workflows, der vor dem Beginn eines asynchronen Vorgangs vom aufrufenden Thread gespeichert wurde.</param>
        <summary>Initiiert einen asynchronen Vorgang zur Wiederaufnahme des Lesezeichens mit dem angegebenen Namen, wobei der angegebene Wert, die angegebene Rückrufmethode und der angegebene Status verwendet werden. Das wiederaufzunehmende Lesezeichen wurde zuvor von einer Aktivität innerhalb der Workflowinstanz erstellt.</summary>
        <returns>Das Ergebnis des Lesezeichenwiederaufnahmevorgangs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis gibt an, ob der Wiederaufnahmenvorgang erfolgreich war.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : System.Activities.Bookmark * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmark, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Das wiederaufzunehmende Lesezeichen.</param>
        <param name="value">Ein Objekt, das als Parameter an die Methode übergeben wird, die bei Wiederaufnahme des Lesezeichens aufgerufen wird.</param>
        <param name="timeout">Das Intervall, in dem der Wiederaufnahmevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Wiederaufnahmevorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Initiiert einen Vorgang zur Wiederaufnahme eines Lesezeichens, wobei der angegebene Wert, das angegebene Timeoutintervall, die angegebene Rückrufmethode und der angegebene Status verwendet werden.</summary>
        <returns>Ein Verweis auf den asynchronen Lesezeichenwiederaufnahmevorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, ob der Wiederaufnahmevorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> auf. <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> kann innerhalb oder außerhalb der `callback`-Methode aufgerufen werden. Wenn das <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A> aufgerufen wird, bevor der Wiederaufnahmevorgang abgeschlossen ist, wird es bis zum Abschluss des Wiederaufnahmevorgangs gesperrt. Wenn der Wiederaufnahmevorgang innerhalb des angegebenen Timeoutintervalls nicht abgeschlossen wird, wird eine <xref:System.TimeoutException> vom <xref:System.Activities.WorkflowApplication.EndResumeBookmark%2A>-Vorgang ausgelöst.  
  
 Diese Methode nimmt ein Lesezeichen mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron wieder auf. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginResumeBookmark">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginResumeBookmark (string bookmarkName, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginResumeBookmark(string bookmarkName, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginResumeBookmark(System.String,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginResumeBookmark (bookmarkName As String, value As Object, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginResumeBookmark : string * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginResumeBookmark (bookmarkName, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Der Name des Lesezeichens, das wiederaufgenommen werden soll.</param>
        <param name="value">Ein Objekt, das als Parameter an die Methode übergeben wird, die bei Wiederaufnahme des Lesezeichens aufgerufen wird.</param>
        <param name="timeout">Das Zeitintervall, in dem das Lesezeichen wiederaufgenommen werden muss.</param>
        <param name="callback">Die Methode, die bei Abschluss des asynchronen Vorgangs aufgerufen wird.</param>
        <param name="state">Der Ausführungsstatus eines Workflows, der vor dem Beginn eines asynchronen Vorgangs vom aufrufenden Thread gespeichert wurde.</param>
        <summary>Initiiert einen asynchronen Vorgang zur Wiederaufnahme des Lesezeichens mit dem angegebenen Namen, wobei der angegebene Wert, das angegebene Timeoutintervall, die angegebene Rückrufmethode und der angegebene Status verwendet werden. Das wiederaufzunehmende Lesezeichen wurde zuvor von einer Aktivität innerhalb der Workflowinstanz erstellt.</summary>
        <returns>Das Ergebnis des Lesezeichenwiederaufnahmevorgangs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis gibt an, ob der Wiederaufnahmenvorgang erfolgreich war.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginRun">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet eine Workflowinstanz mithilfe des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters asynchron bzw. nimmt sie asynchron wieder auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginRun">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginRun (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginRun(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginRun(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginRun (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginRun(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginRun : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginRun (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Wiederaufnahmevorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Startet eine Workflowinstanz mithilfe der angegebenen Rückrufmethode und des vom Benutzer bereitgestellten Status asynchron bzw. nimmt sie asynchron wieder auf.</summary>
        <returns>Ein Verweis auf den asynchronen Ausführungsvorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, ob der Ausführungsvorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndRun%2A> auf. <xref:System.Activities.WorkflowApplication.EndRun%2A> kann innerhalb oder außerhalb der Methode aufgerufen werden, auf die im `callback`-Parameter verwiesen wird. Wenn das <xref:System.Activities.WorkflowApplication.EndRun%2A> aufgerufen wird, bevor der Wiederaufnahmevorgang abgeschlossen ist, wird es bis zum Abschluss des Wiederaufnahmevorgangs gesperrt. Standardmäßig muss der Wiederaufnahmevorgang innerhalb von 30 Sekunden abgeschlossen sein. Andernfalls wird eine <xref:System.TimeoutException> vom <xref:System.Activities.WorkflowApplication.EndRun%2A>-Vorgang ausgegeben.  
  
 Diese Methode startet einen Workflow mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron bzw. nimmt ihn asynchron wieder auf. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRun">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginRun (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginRun(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginRun(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginRun (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginRun(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginRun : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginRun (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Intervall, in dem der Wiederaufnahmevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die Methode, die aufgerufen wird, wenn der Wiederaufnahmevorgang abgeschlossen ist.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Startet eine Workflowinstanz mithilfe des angegebenen Timeoutintervalls, der angegebenen Rückrufmethode und des vom Benutzer bereitgestellten Status asynchron bzw. nimmt sie asynchron wieder auf.</summary>
        <returns>Ein Verweis auf den asynchronen Ausführungsvorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, ob der Ausführungsvorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndRun%2A> auf. <xref:System.Activities.WorkflowApplication.EndRun%2A> kann innerhalb oder außerhalb der Methode aufgerufen werden, auf die im `callback`-Parameter verwiesen wird. Wenn das <xref:System.Activities.WorkflowApplication.EndRun%2A> aufgerufen wird, bevor der Wiederaufnahmevorgang abgeschlossen ist, wird es bis zum Abschluss des Wiederaufnahmevorgangs gesperrt. Wenn der Wiederaufnahmevorgang innerhalb des angegebenen Timeoutintervalls nicht abgeschlossen wird, wird eine <xref:System.TimeoutException> vom <xref:System.Activities.WorkflowApplication.EndRun%2A>-Vorgang ausgelöst.  
  
 Diese Methode startet einen Workflow mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron bzw. nimmt ihn asynchron wieder auf. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginTerminate">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet eine Workflowinstanz mithilfe des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters asynchron.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (Exception reason, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(class System.Exception reason, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.Exception,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As Exception, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(Exception ^ reason, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : Exception * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Der Grund für das Beenden der Workflowinstanz.</param>
        <param name="callback">Die bei Abschluss des <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />-Vorgangs aufzurufende Methode.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Beendet eine Workflowinstanz mithilfe der angegebenen Ausnahme, der angegebenen Rückrufmethode und des vom Benutzer bereitgestellten Status asynchron.</summary>
        <returns>Ein Verweis auf den aktuellen <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />-Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode plant die Beendigung der Workflowinstanz. Um benachrichtigt zu werden, wenn die Beendigung abgeschlossen ist, verwenden Sie das <xref:System.Activities.WorkflowApplication.Completed%2A>-Handle.  
  
 Um zu ermitteln, ob der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndTerminate%2A> auf. <xref:System.Activities.WorkflowApplication.EndTerminate%2A> kann innerhalb oder außerhalb der Methode aufgerufen werden, auf die im `callback`-Parameter verwiesen wird. Wenn <xref:System.Activities.WorkflowApplication.EndTerminate%2A> aufgerufen wird, bevor der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang abgeschlossen ist, greift bis zum Abschluss des <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgangs eine Sperre. Standardmäßig muss der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang innerhalb von 30 Sekunden abgeschlossen werden. Andernfalls löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndTerminate%2A> aus.  
  
 Diese Methode beendet einen Workflow mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (string reason, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(string reason, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(System::String ^ reason, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Der Grund für das Beenden der Workflowinstanz.</param>
        <param name="callback">Die bei Abschluss des <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />-Vorgangs aufzurufende Methode.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Beendet eine Workflowinstanz mithilfe der angegebenen Fehlermeldung, der angegebenen Rückrufmethode und des vom Benutzer bereitgestellten Status asynchron.</summary>
        <returns>Ein Verweis auf den aktuellen <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />-Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode plant die Beendigung der Workflowinstanz. Um benachrichtigt zu werden, wenn die Beendigung abgeschlossen ist, verwenden Sie das <xref:System.Activities.WorkflowApplication.Completed%2A>-Handle.  
  
 Um zu ermitteln, ob der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndTerminate%2A> auf. <xref:System.Activities.WorkflowApplication.EndTerminate%2A> kann innerhalb oder außerhalb der Methode aufgerufen werden, auf die im `callback`-Parameter verwiesen wird. Wenn <xref:System.Activities.WorkflowApplication.EndTerminate%2A> aufgerufen wird, bevor der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang abgeschlossen ist, greift bis zum Abschluss des <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgangs eine Sperre. Standardmäßig muss der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang innerhalb von 30 Sekunden abgeschlossen werden. Andernfalls löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndTerminate%2A> aus.  
  
 Diese Methode beendet eine Workflowinstanz mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (Exception reason, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(class System.Exception reason, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.Exception,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As Exception, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(Exception ^ reason, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : Exception * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Der Grund für das Beenden der Workflowinstanz.</param>
        <param name="timeout">Das Intervall, in dem der <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />-Vorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die bei Abschluss des <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />-Vorgangs aufzurufende Methode.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Beendet eine Workflowinstanz mithilfe der angegebenen Ausnahme, des angegebenen Timeoutintervalls, der angegebenen Rückrufmethode und des vom Benutzer bereitgestellten Status asynchron.</summary>
        <returns>Ein Verweis auf den aktuellen <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />-Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode plant die Beendigung der Workflowinstanz. Um benachrichtigt zu werden, wenn die Beendigung abgeschlossen ist, verwenden Sie das <xref:System.Activities.WorkflowApplication.Completed%2A>-Handle.  
  
 Um zu ermitteln, ob der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndTerminate%2A> auf. <xref:System.Activities.WorkflowApplication.EndTerminate%2A> kann innerhalb oder außerhalb der `callback`-Methode aufgerufen werden. Wenn <xref:System.Activities.WorkflowApplication.EndTerminate%2A> aufgerufen wird, bevor der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang abgeschlossen ist, greift bis zum Abschluss des <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgangs eine Sperre. Wenn der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang nicht innerhalb des angegebenen Timeoutintervalls abgeschlossen wird, wird eine <xref:System.TimeoutException> ausgelöst. Diese oder beliebige andere Ausnahmen, die während des <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Prozesses auftreten, werden von <xref:System.Activities.WorkflowApplication.EndTerminate%2A> ausgelöst.  
  
 Diese Methode beendet einen Workflow mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginTerminate">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginTerminate (string reason, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginTerminate(string reason, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginTerminate(System.String,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginTerminate (reason As String, timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginTerminate(System::String ^ reason, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginTerminate : string * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginTerminate (reason, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reason">Der Grund für das Beenden der Workflowinstanz.</param>
        <param name="timeout">Das Intervall, in dem der <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />-Vorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die bei Abschluss des <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />-Vorgangs aufzurufende Methode.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Beendet eine Workflowinstanz mithilfe der angegebenen Fehlermeldung, des angegebenen Timeoutintervalls, der angegebenen Rückrufmethode und des vom Benutzer bereitgestellten Status asynchron.</summary>
        <returns>Ein Verweis auf den asynchronen <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />-Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode plant die Beendigung der Workflowinstanz. Um benachrichtigt zu werden, wenn die Beendigung abgeschlossen ist, verwenden Sie das <xref:System.Activities.WorkflowApplication.Completed%2A>-Handle.  
  
 Um zu ermitteln, ob der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndTerminate%2A> auf. <xref:System.Activities.WorkflowApplication.EndTerminate%2A> kann innerhalb oder außerhalb der Methode aufgerufen werden, auf die im `callback`-Parameter verwiesen wird. Wenn <xref:System.Activities.WorkflowApplication.EndTerminate%2A> aufgerufen wird, bevor der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang abgeschlossen ist, greift bis zum Abschluss des <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgangs eine Sperre. Wenn der <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang nicht innerhalb des angegebenen Timeoutintervalls abgeschlossen wird, löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndTerminate%2A> aus.  
  
 Diese Methode beendet eine Workflowinstanz mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginUnload">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Speichert eine Workflowinstanz mithilfe des asynchronen <see cref="T:System.IAsyncResult" />-Entwurfsmusters asynchron im Persistenzspeicher und entfernt sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginUnload">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginUnload (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginUnload(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginUnload(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginUnload (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginUnload(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginUnload : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginUnload (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Die bei Abschluss des <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" />-Vorgangs aufzurufende Methode.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Speichert eine Workflowinstanz mithilfe der angegebenen Rückrufmethode und des vom Benutzer bereitgestellten Status asynchron im Persistenzspeicher und entfernt sie.</summary>
        <returns>Ein Verweis auf den asynchronen <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" />-Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, ob der <xref:System.Activities.WorkflowApplication.BeginUnload%2A>-Vorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndUnload%2A> auf. <xref:System.Activities.WorkflowApplication.EndUnload%2A> kann innerhalb oder außerhalb der Methode aufgerufen werden, auf die im `callback`-Parameter verwiesen wird. Wenn <xref:System.Activities.WorkflowApplication.EndUnload%2A> aufgerufen wird, bevor der <xref:System.Activities.WorkflowApplication.BeginUnload%2A>-Vorgang abgeschlossen ist, greift bis zum Abschluss des <xref:System.Activities.WorkflowApplication.BeginUnload%2A>-Vorgangs eine Sperre. Standardmäßig muss der <xref:System.Activities.WorkflowApplication.BeginUnload%2A>-Vorgang innerhalb von 30 Sekunden abgeschlossen werden. Andernfalls löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndUnload%2A> aus.  
  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
 Diese Methode speichert eine Workflowinstanz mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron im Persistenzspeicher und entfernt sie. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginUnload">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginUnload (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginUnload(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.BeginUnload(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginUnload (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginUnload(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginUnload : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.BeginUnload (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Intervall, in dem der <see cref="Overload:System.Activities.WorkflowApplication.BeginTerminate" />-Vorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <param name="callback">Die bei Abschluss des <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" />-Vorgangs aufzurufende Methode.</param>
        <param name="state">Ein optionales, anwendungsspezifisches Objekt, das Informationen über die asynchrone Operation enthält.</param>
        <summary>Speichert eine Workflowinstanz mithilfe des angegebenen Timeoutintervalls, der angegebenen Rückrufmethode und des vom Benutzer bereitgestellten Status asynchron im Persistenzspeicher und entfernt sie.</summary>
        <returns>Ein Verweis auf den asynchronen <see cref="Overload:System.Activities.WorkflowApplication.BeginUnload" />-Vorgang.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zu ermitteln, ob der <xref:System.Activities.WorkflowApplication.BeginUnload%2A>-Vorgang erfolgreich war, rufen Sie <xref:System.Activities.WorkflowApplication.EndUnload%2A> auf. <xref:System.Activities.WorkflowApplication.EndUnload%2A> kann innerhalb oder außerhalb der Methode aufgerufen werden, auf die im `callback`-Parameter verwiesen wird. Wenn <xref:System.Activities.WorkflowApplication.EndUnload%2A> aufgerufen wird, bevor der <xref:System.Activities.WorkflowApplication.BeginUnload%2A>-Vorgang abgeschlossen ist, greift bis zum Abschluss des <xref:System.Activities.WorkflowApplication.BeginUnload%2A>-Vorgangs eine Sperre. Wenn der <xref:System.Activities.WorkflowApplication.BeginUnload%2A>-Vorgang nicht innerhalb des angegebenen Timeoutintervalls abgeschlossen wird, löst <xref:System.TimeoutException> eine <xref:System.Activities.WorkflowApplication.EndUnload%2A> aus.  
  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
 Diese Methode speichert eine Workflowinstanz mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron im Persistenzspeicher und entlädt sie. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Cancel">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bricht die Workflowinstanz ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode plant den Abbruch der Workflowinstanz. Um bei Abschluss des Abbruchvorgangs benachrichtigt zu werden, verwenden Sie das <xref:System.Activities.WorkflowApplication.Completed%2A>-Handle.  
  
 Standardmäßig muss der Abbruchvorgang innerhalb von 30 Sekunden abgeschlossen werden. Andernfalls wird eine <xref:System.TimeoutException> ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Cancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel();" />
      <MemberSignature Language="F#" Value="member this.Cancel : unit -&gt; unit" Usage="workflowApplication.Cancel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht die Workflowinstanz ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode plant den Abbruch der Workflowinstanz. Um bei Abschluss des Abbruchvorgangs benachrichtigt zu werden, verwenden Sie den <xref:System.Activities.WorkflowApplication.Completed%2A>-Handler.  
  
 Standardmäßig muss der Abbruchvorgang innerhalb von 30 Sekunden abgeschlossen werden. Andernfalls wird eine <xref:System.TimeoutException> ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mit der angegebenen Workflowdefinition erstellt, die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Nachdem der Workflow gestartet wurde, wird <xref:System.Activities.WorkflowApplication.Cancel%2A> aufgerufen. Wenn der Workflow abgebrochen wurde, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Starting the workflow.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Idle.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Canceled  
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#13](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public void Cancel (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cancel(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Cancel(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cancel (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cancel(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Cancel : TimeSpan -&gt; unit" Usage="workflowApplication.Cancel timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Intervall, in dem der Abbruchvorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <summary>Bricht die Workflowinstanz mithilfe des angegebenen Timeoutintervalls ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode plant den Abbruch der Workflowinstanz. Um bei Abschluss des Abbruchvorgangs benachrichtigt zu werden, verwenden Sie den <xref:System.Activities.WorkflowApplication.Completed%2A>-Handler.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mit der angegebenen Workflowdefinition erstellt, die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Nachdem der Workflow gestartet wurde, wird <xref:System.Activities.WorkflowApplication.Cancel%2A> aufgerufen. Wenn der Workflow abgebrochen wurde, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Starting the workflow.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Idle.   
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Canceled  
Workflow bcce00c2-d323-42c2-8c25-19ff0c4b6dac Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#13](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completed">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt; Completed { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationCompletedEventArgs&gt; Completed" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Completed" />
      <MemberSignature Language="VB.NET" Value="Public Property Completed As Action(Of WorkflowApplicationCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ Completed { Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationCompletedEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Completed : Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Completed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Action`1" />-Aktion ab, die bei Abschluss der Workflowinstanz ausgelöst wird, bzw. legt sie fest.</summary>
        <value>Die Aktion, die bei Abschluss der Workflowinstanz ausgelöst wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel werden die in den <xref:System.Activities.WorkflowApplicationCompletedEventArgs>-Handler einer <xref:System.Activities.WorkflowApplication.Completed%2A>-Instanz übergebenen <xref:System.Activities.WorkflowApplication> überprüft, und es werden Informationen darüber angezeigt, wie der Workflow abgeschlossen wurde.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#4](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen Standardinstanzbesitzer für den Workflow.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void CreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.CreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter);" />
      <MemberSignature Language="F#" Value="static member CreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter -&gt; unit" Usage="System.Activities.WorkflowApplication.CreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="definitionIdentity">Die Definitionsidentität des Workflows.</param>
        <param name="identityFilter">Der Identität-Filter.</param>
        <summary>Erstellt einen Standardinstanzbesitzer für den Workflow mithilfe des angegebenen Instanzspeichers, der Definitionsidentität und dem Identitätsfilter.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void CreateDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, System.Activities.WorkflowIdentity definitionIdentity, System.Activities.WorkflowIdentityFilter identityFilter, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, class System.Activities.WorkflowIdentity definitionIdentity, valuetype System.Activities.WorkflowIdentityFilter identityFilter, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.CreateDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.Activities.WorkflowIdentity,System.Activities.WorkflowIdentityFilter,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, System::Activities::WorkflowIdentity ^ definitionIdentity, System::Activities::WorkflowIdentityFilter identityFilter, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member CreateDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * System.Activities.WorkflowIdentity * System.Activities.WorkflowIdentityFilter * TimeSpan -&gt; unit" Usage="System.Activities.WorkflowApplication.CreateDefaultInstanceOwner (instanceStore, definitionIdentity, identityFilter, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="definitionIdentity" Type="System.Activities.WorkflowIdentity" />
        <Parameter Name="identityFilter" Type="System.Activities.WorkflowIdentityFilter" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="definitionIdentity">Die Definitionsidentität des Workflows.</param>
        <param name="identityFilter">Der Identität-Filter.</param>
        <param name="timeout">Das Intervall, in dem der Startladevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen wird.</param>
        <summary>Erstellt einen Standardinstanzbesitzer für den Workflow mithilfe des angegebenen Instanzspeichers, der Definitionsidentität, dem Identitätsfilter, Timeoutintervall, Rückruf und Zustand.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDefaultInstanceOwner">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht einen Standardinstanzbesitzer für den Workflow.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void DeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member DeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore -&gt; unit" Usage="System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner instanceStore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <summary>Löscht einen Standardinstanzbesitzer für den Workflow mit dem angegebenem Instanzspeicher.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void DeleteDefaultInstanceOwner (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteDefaultInstanceOwner(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteDefaultInstanceOwner(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member DeleteDefaultInstanceOwner : System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; unit" Usage="System.Activities.WorkflowApplication.DeleteDefaultInstanceOwner (instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="timeout">Das Intervall, in dem der Startladevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen wird.</param>
        <summary>Löscht einen Standardinstanzbesitzer für den Workflow mit dem angegebenen Timeoutintervall und Instanzspeicher.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public void EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndCancel (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndCancel : IAsyncResult -&gt; unit" Usage="workflowApplication.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Der asynchrone Abbruchvorgang.</param>
        <summary>Wartet, bis der ausstehende asynchrone Abbruchvorgang abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermittelt, ob ein <xref:System.Activities.WorkflowApplication.BeginCancel%2A>-Vorgang erfolgreich war. Wenn sie aufgerufen wird, bevor der Abbruchvorgang abgeschlossen ist, wird sie bis zum Abschluss des Abbruchvorgangs gesperrt.  
  
 Diese Methode schließt den asynchronen Abbruchvorgang mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters ab. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndCreateDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void EndCreateDefaultInstanceOwner (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCreateDefaultInstanceOwner(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndCreateDefaultInstanceOwner(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCreateDefaultInstanceOwner (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCreateDefaultInstanceOwner(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndCreateDefaultInstanceOwner : IAsyncResult -&gt; unit" Usage="System.Activities.WorkflowApplication.EndCreateDefaultInstanceOwner asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das asynchrone Ergebnis.</param>
        <summary>Wartet, bis die Erstellung des Standardinstanzbesitzers abgeschlossen ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndDeleteDefaultInstanceOwner">
      <MemberSignature Language="C#" Value="public static void EndDeleteDefaultInstanceOwner (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndDeleteDefaultInstanceOwner(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndDeleteDefaultInstanceOwner(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndDeleteDefaultInstanceOwner (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndDeleteDefaultInstanceOwner(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndDeleteDefaultInstanceOwner : IAsyncResult -&gt; unit" Usage="System.Activities.WorkflowApplication.EndDeleteDefaultInstanceOwner asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das asynchrone Ergebnis.</param>
        <summary>Wartet, bis die Löschung des Standardinstanzbesitzers abgeschlossen ist.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance EndGetInstance (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance EndGetInstance(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndGetInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndGetInstance (asyncResult As IAsyncResult) As WorkflowApplicationInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ EndGetInstance(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndGetInstance : IAsyncResult -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.EndGetInstance asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das asynchrone Ergebnis.</param>
        <summary>Wartet, bis der Instanz-Abruf abgeschlossen ist.</summary>
        <returns>Das Ergebnis der Operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance EndGetRunnableInstance (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance EndGetRunnableInstance(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndGetRunnableInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EndGetRunnableInstance (asyncResult As IAsyncResult) As WorkflowApplicationInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ EndGetRunnableInstance(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="static member EndGetRunnableInstance : IAsyncResult -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.EndGetRunnableInstance asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Das asynchrone Ergebnis.</param>
        <summary>Wartet, bis der asynchrone Abruf für die ausführbare Instanz abgeschlossen ist.</summary>
        <returns>Das Ergebnis der Operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoad">
      <MemberSignature Language="C#" Value="public void EndLoad (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoad(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndLoad(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoad (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoad(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndLoad : IAsyncResult -&gt; unit" Usage="workflowApplication.EndLoad result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Der asynchrone Ladevorgang.</param>
        <summary>Wartet, bis der ausstehende asynchrone Ladevorgang abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode aufgerufen wird, bevor der Ladevorgang abgeschlossen ist, wird sie bis zum Abschluss des Ladevorgangs gesperrt.  
  
 Diese Methode schließt den asynchronen Ladevorgang mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters ab. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void EndLoadRunnableInstance (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadRunnableInstance(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndLoadRunnableInstance(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadRunnableInstance (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadRunnableInstance(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndLoadRunnableInstance : IAsyncResult -&gt; unit" Usage="workflowApplication.EndLoadRunnableInstance result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ein Verweis auf den asynchronen Ladevorgang.</param>
        <summary>Wartet, bis der asynchrone Ladevorgang für die ausführbare Instanz abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermittelt, ob ein <xref:System.Activities.WorkflowApplication.BeginLoadRunnableInstance%2A>-Vorgang erfolgreich war. Wenn sie aufgerufen wird, bevor der Ladevorgang abgeschlossen ist, wird sie bis zum Abschluss des Vorgangs gesperrt.  
  
 Diese Methode lädt Workflows mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndPersist">
      <MemberSignature Language="C#" Value="public void EndPersist (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndPersist(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndPersist(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndPersist (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndPersist(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndPersist : IAsyncResult -&gt; unit" Usage="workflowApplication.EndPersist result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Der asynchrone Persistenzspeichervorgang.</param>
        <summary>Wartet, bis der ausstehende asynchrone Persistenzspeichervorgang abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermittelt, ob ein <xref:System.Activities.WorkflowApplication.BeginPersist%2A>-Vorgang erfolgreich war. Wenn sie aufgerufen wird, bevor der Persistenzspeichervorgang abgeschlossen ist, wird sie bis zum Abschluss des Persistenzspeichervorgangs gesperrt.  
  
 Diese Methode schließt den asynchronen Persistenzspeichervorgang mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters ab. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult EndResumeBookmark (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult EndResumeBookmark(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndResumeBookmark(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndResumeBookmark (result As IAsyncResult) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult EndResumeBookmark(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndResumeBookmark : IAsyncResult -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.EndResumeBookmark result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Ein Verweis auf den asynchronen Lesezeichenwiederaufnahmevorgang.</param>
        <summary>Wartet, bis ein Lesezeichenwiederaufnahmevorgang abgeschlossen ist.</summary>
        <returns>Einer der Enumerationswerte, der das Ergebnis eines Lesezeichenwiederaufnahmevorgangs angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermittelt, ob ein <xref:System.Activities.WorkflowApplication.BeginResumeBookmark%2A>-Vorgang erfolgreich war. Wenn sie aufgerufen wird, bevor der Ladevorgang abgeschlossen ist, wird sie bis zum Abschluss des Vorgangs gesperrt.  
  
 Diese Methode nimmt ein Lesezeichen mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters asynchron wieder auf. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRun">
      <MemberSignature Language="C#" Value="public void EndRun (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndRun(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndRun(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndRun (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndRun(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndRun : IAsyncResult -&gt; unit" Usage="workflowApplication.EndRun result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Der asynchrone Ausführungsvorgang.</param>
        <summary>Wartet, bis der ausstehende asynchrone Ausführungsvorgang abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermittelt, ob ein <xref:System.Activities.WorkflowApplication.BeginRun%2A>-Vorgang erfolgreich war. Wenn die Methode aufgerufen wird, bevor der Wiederaufnahmevorgang abgeschlossen ist, wird sie bis zum Abschluss des Wiederaufnahmevorgangs gesperrt.  
  
 Diese Methode schließt einen asynchronen Ausführungsvorgang mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters ab. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndTerminate">
      <MemberSignature Language="C#" Value="public void EndTerminate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndTerminate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndTerminate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndTerminate (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndTerminate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndTerminate : IAsyncResult -&gt; unit" Usage="workflowApplication.EndTerminate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Der asynchrone Beendigungsvorgang.</param>
        <summary>Wartet, bis der ausstehende asynchrone Beendigungsvorgang abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, um zu bestimmen, ob ein <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang erfolgreich war. Wenn die Methode aufgerufen wird, bevor der Beendigungsvorgang abgeschlossen ist, wird sie bis zum Abschluss des Vorgangs gesperrt.  
  
 Diese Methode schließt einen asynchronen <xref:System.Activities.WorkflowApplication.BeginTerminate%2A>-Vorgang mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters ab. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndUnload">
      <MemberSignature Language="C#" Value="public void EndUnload (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndUnload(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.EndUnload(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndUnload (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndUnload(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndUnload : IAsyncResult -&gt; unit" Usage="workflowApplication.EndUnload result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Der asynchrone Entladevorgang.</param>
        <summary>Wartet, bis der ausstehende asynchrone Entladevorgang abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, um zu bestimmen, ob ein <xref:System.Activities.WorkflowApplication.BeginUnload%2A>-Vorgang erfolgreich war. Wenn die Methode aufgerufen wird, bevor der Entladevorgang abgeschlossen ist, wird sie bis zum Abschluss des Vorgangs gesperrt.  
  
 Diese Methode schließt einen asynchronen <xref:System.Activities.WorkflowApplication.BeginUnload%2A>-Vorgang mithilfe des asynchronen <xref:System.IAsyncResult>-Entwurfsmusters ab. Weitere Informationen finden Sie unter [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As WorkflowInstanceExtensionManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::Hosting::WorkflowInstanceExtensionManager ^ Extensions { System::Activities::Hosting::WorkflowInstanceExtensionManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.Activities.Hosting.WorkflowInstanceExtensionManager" Usage="System.Activities.WorkflowApplication.Extensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.Hosting.WorkflowInstanceExtensionManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Auflistung der Erweiterungen für die aktuelle Workflowinstanz ab.</summary>
        <value>Eine Auflistung von Objekten.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBookmarks">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die Auflistung der Lesezeichen für die Workflowinstanz zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBookmarks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetBookmarks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBookmarks () As ReadOnlyCollection(Of BookmarkInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Activities::Hosting::BookmarkInfo ^&gt; ^ GetBookmarks();" />
      <MemberSignature Language="F#" Value="member this.GetBookmarks : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;" Usage="workflowApplication.GetBookmarks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Auflistung der Lesezeichen für die Workflowinstanz zurück.</summary>
        <returns>Eine schreibgeschützte Auflistung von Lesezeichen für die Workflowinstanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn dieser Vorgang innerhalb von 30 Sekunden nicht abgeschlossen wird, wird eine <xref:System.TimeoutException> ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow erstellt, der eine `ReadLine`-Aktivität verwendet, die ein <xref:System.Activities.Bookmark> erstellt. Der Workflow wird gestartet, und sobald das <xref:System.Activities.Bookmark> erstellt wurde und der Workflow in den Leerlauf übergeht, wird <xref:System.Activities.WorkflowApplication.GetBookmarks%2A> aufgerufen. Wenn der Workflow abgeschlossen ist, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
What is your name?   
BookmarkName: UserName - OwnerDisplayName: ReadLine  
Steve  
Hello, Steve  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#14](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBookmarks">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Activities.Hosting.BookmarkInfo&gt; GetBookmarks(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetBookmarks(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBookmarks (timeout As TimeSpan) As ReadOnlyCollection(Of BookmarkInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Activities::Hosting::BookmarkInfo ^&gt; ^ GetBookmarks(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.GetBookmarks : TimeSpan -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;" Usage="workflowApplication.GetBookmarks timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Activities.Hosting.BookmarkInfo&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Intervall, in dem diese Methode abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <summary>Gibt die Auflistung der Lesezeichen für die Workflowinstanz mit dem angegebenen Timeoutintervall zurück.</summary>
        <returns>Eine schreibgeschützte Auflistung von Lesezeichen für die Workflowinstanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird ein Workflow erstellt, der eine `ReadLine`-Aktivität verwendet, die ein <xref:System.Activities.Bookmark> erstellt. Der Workflow wird gestartet, und sobald das <xref:System.Activities.Bookmark> erstellt wurde und der Workflow in den Leerlauf übergeht, wird <xref:System.Activities.WorkflowApplication.GetBookmarks%2A> aufgerufen. Wenn der Workflow abgeschlossen ist, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
What is your name?   
BookmarkName: UserName - OwnerDisplayName: ReadLine  
Steve  
Hello, Steve  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#14](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Workflowinstanz ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member GetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetInstance (instanceId, instanceStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
      </Parameters>
      <Docs>
        <param name="instanceId">Der Instanzbezeichner.</param>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <summary>Ruft die Workflowinstanz unter Verwendung des angegebenen Instanzbezeichners und Instanzspeichers ab.</summary>
        <returns>Die abgerufene Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetInstance (Guid instanceId, System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetInstance(valuetype System.Guid instanceId, class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetInstance(System.Guid,System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetInstance(Guid instanceId, System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member GetInstance : Guid * System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetInstance (instanceId, instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceId">Der Instanzbezeichner.</param>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung.</param>
        <param name="timeout">Das Intervall, in dem der Startladevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen wird.</param>
        <summary>Ruft die Workflowinstanz unter Verwendung des angegebenen Instanzbezeichners, Instanzspeichers und Timeoutintervals ab.</summary>
        <returns>Ein Verweis auf den asynchronen Vorgang.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die ausführbare Instanz des Workflows ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore);" />
      <MemberSignature Language="F#" Value="static member GetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetRunnableInstance instanceStore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung</param>
        <summary>Ruft die ausführbare Instanz des Workflows mit angegebenem Instanzspeicher ab.</summary>
        <returns>Die ausführbare Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRunnableInstance">
      <MemberSignature Language="C#" Value="public static System.Activities.WorkflowApplicationInstance GetRunnableInstance (System.Runtime.DurableInstancing.InstanceStore instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Activities.WorkflowApplicationInstance GetRunnableInstance(class System.Runtime.DurableInstancing.InstanceStore instanceStore, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.GetRunnableInstance(System.Runtime.DurableInstancing.InstanceStore,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Activities::WorkflowApplicationInstance ^ GetRunnableInstance(System::Runtime::DurableInstancing::InstanceStore ^ instanceStore, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member GetRunnableInstance : System.Runtime.DurableInstancing.InstanceStore * TimeSpan -&gt; System.Activities.WorkflowApplicationInstance" Usage="System.Activities.WorkflowApplication.GetRunnableInstance (instanceStore, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.WorkflowApplicationInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceStore" Type="System.Runtime.DurableInstancing.InstanceStore" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceStore">Der Zugriff auf den beibehaltenen Zustand der aktuellen Instanz der Workflowanwendung</param>
        <param name="timeout">Das Intervall, in dem der Startladevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen wird.</param>
        <summary>Ruft die ausführbare Instanz des Workflows mit angegebenem Instanzspeicher und Timeoutinterval ab.</summary>
        <returns>Die ausführbare Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public override Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Id" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Activities.WorkflowApplication.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den 128-Bit-Bezeichner (GUID) der aktuellen Workflowanwendungsinstanz ab.</summary>
        <value>Ein eindeutiger Bezeichner (GUID, Globally Unique Identifier) mit 128 Bit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Activities.WorkflowApplication>-Instanz erstellt und anschließend der <xref:System.Activities.WorkflowApplication.Id%2A>-Wert in der Konsole angezeigt.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#28](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt; Idle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationIdleEventArgs&gt; Idle" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Property Idle As Action(Of WorkflowApplicationIdleEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ Idle { Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationIdleEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Idle : Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Idle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationIdleEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Action`1" />-Aktion ab, die ausgelöst wird, wenn die aktuelle Workflowinstanz in den Leerlauf wechselt, bzw. legt sie fest.</summary>
        <value>Eine Aktion, die ausgeführt wird, wenn eine Workflowinstanz in den Leerlauf wechselt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel werden die in den <xref:System.Activities.WorkflowApplicationIdleEventArgs>-Handler einer <xref:System.Activities.WorkflowApplication.Idle%2A>-Instanz übergebenen <xref:System.Activities.WorkflowApplication> überprüft. In diesem Beispiel geht der Workflow in den Leerlauf über und verfügt über ein <xref:System.Activities.Bookmark> mit dem Namen `EnterGuess`, das sich im Besitz einer Aktivität mit dem Namen `ReadInt` befindet. Dieses Codebeispiel basiert auf [wie: Ausführen eines Workflows](~/docs/framework/windows-workflow-foundation/how-to-run-a-workflow.md), diese ist Teil der [Getting Started Tutorial &#91;.NET Framework 4.5&#93;](~/docs/framework/windows-workflow-foundation/getting-started-tutorial.md). Wenn der <xref:System.Activities.WorkflowApplication.Idle%2A>-Handler in diesem Schritt geändert wird, um den Code aus diesem Beispiel zu enthalten, wird die folgende Ausgabe angezeigt.  
  
```Output  
BookmarkName: EnterGuess - OwnerDisplayName: ReadInt  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceStore">
      <MemberSignature Language="C#" Value="public System.Runtime.DurableInstancing.InstanceStore InstanceStore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.DurableInstancing.InstanceStore InstanceStore" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.InstanceStore" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceStore As InstanceStore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::DurableInstancing::InstanceStore ^ InstanceStore { System::Runtime::DurableInstancing::InstanceStore ^ get(); void set(System::Runtime::DurableInstancing::InstanceStore ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceStore : System.Runtime.DurableInstancing.InstanceStore with get, set" Usage="System.Activities.WorkflowApplication.InstanceStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.DurableInstancing.InstanceStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, das Zugriff auf den Persistenzstatus der aktuellen Instanz der Workflowanwendung bereitstellt, bzw. legt es fest.</summary>
        <value>Ein Instanzspeicher.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine WorkflowApplication-Instanz erstellt und anschließend der <xref:System.Activities.WorkflowApplication.InstanceStore%2A> mithilfe eines <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> konfiguriert. Dieses Codebeispiel ist Teil des [Vorgehensweise: Erstellen und Ausführen einer Workflows mit langer Laufzeit](~/docs/framework/windows-workflow-foundation/how-to-create-and-run-a-long-running-workflow.md), diese ist Teil der [Getting Started Tutorial &#91;.NET Framework 4.5&#93;](~/docs/framework/windows-workflow-foundation/getting-started-tutorial.md).  
  
 [!code-csharp[CFX_WorkflowApplicationExample#28](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt eine Workflowinstanz aus einem Instanzspeicher.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance -&gt; unit" Usage="workflowApplication.Load instance" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz.</param>
        <summary>Lädt eine Workflowinstanz aus einem Instanzspeicher mit angegebener Instanz.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instanceId As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(Guid instanceId);" />
      <MemberSignature Language="F#" Value="member this.Load : Guid -&gt; unit" Usage="workflowApplication.Load instanceId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">Ein eindeutiger Bezeichner (128 Bit) für die Workflowinstanz.</param>
        <summary>Lädt die angegebene Workflowinstanz aus einem Instanzspeicher in den Arbeitsspeicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Activities.WorkflowApplication.Load%2A> aufgerufen, um die beibehaltene Workflowinstanz aus einem <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> zu laden. Dieses Beispiel stammt aus dem `LoadAndCompleteInstance` -Methode in der die [beibehalten einer Workflowanwendung](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) Beispiel.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#27](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap -&gt; unit" Usage="workflowApplication.Load (instance, updateMap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz.</param>
        <param name="updateMap">Die Updatezuordnung.</param>
        <summary>Lädt eine Workflowinstanz aus einem Instanzspeicher mit angegebener Instanz und Update-Zuordnung.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instance, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz.</param>
        <param name="timeout">Das Intervall, in dem der Startladevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen wird.</param>
        <summary>Lädt eine Workflowinstanz aus einem Instanzspeicher mit angegebener Instanz und angegebenem Timeoutinterval.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (Guid instanceId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(valuetype System.Guid instanceId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Guid,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instanceId As Guid, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(Guid instanceId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : Guid * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instanceId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instanceId">Ein eindeutiger Bezeichner (128 Bit) für die Workflowinstanz.</param>
        <param name="timeout">Das Intervall, in dem der Ladevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <summary>Lädt die angegebene Workflowinstanz aus einem Instanzspeicher in den Arbeitsspeicher, wobei das angegebene Timeoutintervall verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Activities.WorkflowApplication.Load%2A> aufgerufen, um die beibehaltene Workflowinstanz aus einem <xref:System.Activities.DurableInstancing.SqlWorkflowInstanceStore> zu laden. Dieses Beispiel stammt aus dem `LoadAndCompleteInstance` -Methode in der die [beibehalten einer Workflowanwendung](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) Beispiel.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#27](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Activities.WorkflowApplicationInstance instance, System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Activities.WorkflowApplicationInstance instance, class System.Activities.DynamicUpdate.DynamicUpdateMap updateMap, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Load(System.Activities.WorkflowApplicationInstance,System.Activities.DynamicUpdate.DynamicUpdateMap,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (instance As WorkflowApplicationInstance, updateMap As DynamicUpdateMap, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Activities::WorkflowApplicationInstance ^ instance, System::Activities::DynamicUpdate::DynamicUpdateMap ^ updateMap, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Activities.WorkflowApplicationInstance * System.Activities.DynamicUpdate.DynamicUpdateMap * TimeSpan -&gt; unit" Usage="workflowApplication.Load (instance, updateMap, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Activities.WorkflowApplicationInstance" />
        <Parameter Name="updateMap" Type="System.Activities.DynamicUpdate.DynamicUpdateMap" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="instance">Die Instanz.</param>
        <param name="updateMap">Die Updatezuordnung.</param>
        <param name="timeout">Das Intervall, in dem der Startladevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen wird.</param>
        <summary>Lädt eine Workflowinstanz aus einem Instanzspeicher mit angegebener Instanz und Update-Zuordnung sowie angegebenem Timeoutinterval.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadRunnableInstance">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt eine ausführbare Workflowinstanz aus dem <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine ausführbare Instanz ist eine Instanz, für die der Timer bzw. die Instanzsperre abgelaufen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void LoadRunnableInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadRunnableInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.LoadRunnableInstance" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadRunnableInstance ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadRunnableInstance();" />
      <MemberSignature Language="F#" Value="member this.LoadRunnableInstance : unit -&gt; unit" Usage="workflowApplication.LoadRunnableInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lädt eine ausführbare Workflowinstanz aus dem <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine ausführbare Instanz ist eine Instanz, für die der Timer bzw. die Instanzsperre abgelaufen ist.  
  
 Standardmäßig muss der Ladevorgang innerhalb von 30 Sekunden abgeschlossen sein. Andernfalls wird eine <xref:System.TimeoutException> ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadRunnableInstance">
      <MemberSignature Language="C#" Value="public void LoadRunnableInstance (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadRunnableInstance(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.LoadRunnableInstance(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadRunnableInstance (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadRunnableInstance(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.LoadRunnableInstance : TimeSpan -&gt; unit" Usage="workflowApplication.LoadRunnableInstance timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Intervall, in dem der Ladevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <summary>Lädt eine ausführbare Workflowinstanz aus dem <see cref="P:System.Activities.WorkflowApplication.InstanceStore" />, wobei das angegebene Timeoutintervall verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine ausführbare Instanz ist eine Instanz, für die der Timer bzw. die Instanzsperre abgelaufen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginAssociateKeys">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginAssociateKeys (System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; keys, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginAssociateKeys(class System.Collections.Generic.ICollection`1&lt;class System.Runtime.DurableInstancing.InstanceKey&gt; keys, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginAssociateKeys(System.Collections.Generic.ICollection{System.Runtime.DurableInstancing.InstanceKey},System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnBeginAssociateKeys (keys As ICollection(Of InstanceKey), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginAssociateKeys(System::Collections::Generic::ICollection&lt;System::Runtime::DurableInstancing::InstanceKey ^&gt; ^ keys, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginAssociateKeys : System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginAssociateKeys (keys, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt;" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="keys">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginPersist">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginPersist (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginPersist(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginPersist(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnBeginPersist (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginPersist(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginPersist : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginPersist (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginResumeBookmark">
      <MemberSignature Language="C#" Value="protected internal override IAsyncResult OnBeginResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.IAsyncResult OnBeginResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnBeginResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override IAsyncResult ^ OnBeginResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginResumeBookmark : System.Activities.Bookmark * obj * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowApplication.OnBeginResumeBookmark (bookmark, value, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">To be added.</param>
        <param name="value">To be added.</param>
        <param name="timeout">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDisassociateKeys">
      <MemberSignature Language="C#" Value="protected internal override void OnDisassociateKeys (System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; keys);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnDisassociateKeys(class System.Collections.Generic.ICollection`1&lt;class System.Runtime.DurableInstancing.InstanceKey&gt; keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnDisassociateKeys(System.Collections.Generic.ICollection{System.Runtime.DurableInstancing.InstanceKey})" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnDisassociateKeys (keys As ICollection(Of InstanceKey))" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnDisassociateKeys(System::Collections::Generic::ICollection&lt;System::Runtime::DurableInstancing::InstanceKey ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="override this.OnDisassociateKeys : System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt; -&gt; unit" Usage="workflowApplication.OnDisassociateKeys keys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.ICollection&lt;System.Runtime.DurableInstancing.InstanceKey&gt;" />
      </Parameters>
      <Docs>
        <param name="keys">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndAssociateKeys">
      <MemberSignature Language="C#" Value="protected internal override void OnEndAssociateKeys (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnEndAssociateKeys(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndAssociateKeys(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnEndAssociateKeys (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnEndAssociateKeys(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndAssociateKeys : IAsyncResult -&gt; unit" Usage="workflowApplication.OnEndAssociateKeys result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndPersist">
      <MemberSignature Language="C#" Value="protected internal override void OnEndPersist (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnEndPersist(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndPersist(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnEndPersist (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnEndPersist(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndPersist : IAsyncResult -&gt; unit" Usage="workflowApplication.OnEndPersist result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndResumeBookmark">
      <MemberSignature Language="C#" Value="protected internal override System.Activities.BookmarkResumptionResult OnEndResumeBookmark (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance valuetype System.Activities.BookmarkResumptionResult OnEndResumeBookmark(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnEndResumeBookmark(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function OnEndResumeBookmark (result As IAsyncResult) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Activities::BookmarkResumptionResult OnEndResumeBookmark(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndResumeBookmark : IAsyncResult -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.OnEndResumeBookmark result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyPaused">
      <MemberSignature Language="C#" Value="protected override void OnNotifyPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnNotifyPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnNotifyPaused" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnNotifyPaused ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnNotifyPaused();" />
      <MemberSignature Language="F#" Value="override this.OnNotifyPaused : unit -&gt; unit" Usage="workflowApplication.OnNotifyPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNotifyUnhandledException">
      <MemberSignature Language="C#" Value="protected override void OnNotifyUnhandledException (Exception exception, System.Activities.Activity exceptionSource, string exceptionSourceInstanceId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnNotifyUnhandledException(class System.Exception exception, class System.Activities.Activity exceptionSource, string exceptionSourceInstanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnNotifyUnhandledException(System.Exception,System.Activities.Activity,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnNotifyUnhandledException(Exception ^ exception, System::Activities::Activity ^ exceptionSource, System::String ^ exceptionSourceInstanceId);" />
      <MemberSignature Language="F#" Value="override this.OnNotifyUnhandledException : Exception * System.Activities.Activity * string -&gt; unit" Usage="workflowApplication.OnNotifyUnhandledException (exception, exceptionSource, exceptionSourceInstanceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
        <Parameter Name="exceptionSource" Type="System.Activities.Activity" />
        <Parameter Name="exceptionSourceInstanceId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="exception">To be added.</param>
        <param name="exceptionSource">To be added.</param>
        <param name="exceptionSourceInstanceId">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRequestAbort">
      <MemberSignature Language="C#" Value="protected internal override void OnRequestAbort (Exception reason);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRequestAbort(class System.Exception reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.OnRequestAbort(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRequestAbort (reason As Exception)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRequestAbort(Exception ^ reason);" />
      <MemberSignature Language="F#" Value="override this.OnRequestAbort : Exception -&gt; unit" Usage="workflowApplication.OnRequestAbort reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="reason">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnhandledException">
      <MemberSignature Language="C#" Value="public Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs,System.Activities.UnhandledExceptionAction&gt; OnUnhandledException { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class System.Activities.WorkflowApplicationUnhandledExceptionEventArgs, valuetype System.Activities.UnhandledExceptionAction&gt; OnUnhandledException" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.OnUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Property OnUnhandledException As Func(Of WorkflowApplicationUnhandledExceptionEventArgs, UnhandledExceptionAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ OnUnhandledException { Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ get(); void set(Func&lt;System::Activities::WorkflowApplicationUnhandledExceptionEventArgs ^, System::Activities::UnhandledExceptionAction&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OnUnhandledException : Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs, System.Activities.UnhandledExceptionAction&gt; with get, set" Usage="System.Activities.WorkflowApplication.OnUnhandledException" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Activities.WorkflowApplicationUnhandledExceptionEventArgs,System.Activities.UnhandledExceptionAction&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Func`2" />-Aktion ab, die ausgelöst wird, wenn die aktuelle Workflowinstanz eine unbehandelte Ausnahme erkennt, bzw. legt sie fest.</summary>
        <value>Der Delegat, der ausgelöst wird, wenn bei einer Workflowinstanz ein Ausnahmefehler auftritt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A> als auch <xref:System.ServiceModel.Activities.Description.WorkflowUnhandledExceptionBehavior> bestimmen das Verhalten der Laufzeit, wenn eine Ausnahme nicht im Workflow behandelt wird. <xref:System.ServiceModel.Activities.Description.WorkflowUnhandledExceptionBehavior> kann einen unterbrochenen Workflow jedoch optional im Persistenzspeicher belassen. Diese Option besteht bei <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A> nicht. Der Grund dafür ist, dass die Vorgänge im Zusammenhang mit einem unterbrochenen Workflow im Gegensatz zu <xref:System.Activities.WorkflowApplication> hostspezifisch sind. Um diese Funktion mit <xref:System.Activities.WorkflowApplication> zu implementieren, erstellen Sie einen benutzerdefinierten <xref:System.Activities.Persistence.PersistenceParticipant>, der dieses Verhalten aufweist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow aufgerufen, der eine Ausnahme auslöst. Die Ausnahme wird vom Workflow nicht behandelt, und der <xref:System.Activities.WorkflowApplication.OnUnhandledException%2A>-Handler wird aufgerufen. Die <xref:System.Activities.WorkflowApplicationUnhandledExceptionEventArgs> werden überprüft, um Informationen zur Ausnahme bereitzustellen, und der Workflow wird beendet.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Persist">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Speichert eine Workflowinstanz in einem Instanzspeicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="public void Persist ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Persist() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Persist" />
      <MemberSignature Language="VB.NET" Value="Public Sub Persist ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Persist();" />
      <MemberSignature Language="F#" Value="member this.Persist : unit -&gt; unit" Usage="workflowApplication.Persist " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert eine Workflowinstanz in einem Instanzspeicher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Persistenzspeichervorgang innerhalb von 30 Sekunden nicht abgeschlossen wird, wird eine <xref:System.TimeoutException> ausgelöst.  
  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Activities.WorkflowApplication.Persist%2A> aufgerufen, um eine Workflowinstanz beizubehalten, bevor der Workflow gestartet wird. In diesem Beispiel ist Teil der `StartAndUnloadInstance` -Methode in der die [beibehalten einer Workflowanwendung](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) Beispiel.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Persist">
      <MemberSignature Language="C#" Value="public void Persist (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Persist(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Persist(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Persist (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Persist(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Persist : TimeSpan -&gt; unit" Usage="workflowApplication.Persist timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Intervall, in dem der Persistenzspeichervorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <summary>Speichert eine Workflowinstanz in einem Instanzspeicher, wobei das angegebene Timeoutintervall verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Activities.WorkflowApplication.Persist%2A> aufgerufen, um eine Workflowinstanz beizubehalten, bevor der Workflow gestartet wird. Dieses Beispiel stammt aus dem `StartAndUnloadInstance` -Methode in der die [beibehalten einer Workflowanwendung](~/docs/framework/windows-workflow-foundation/samples/persisting-a-workflow-application.md) Beispiel.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistableIdle">
      <MemberSignature Language="C#" Value="public Func&lt;System.Activities.WorkflowApplicationIdleEventArgs,System.Activities.PersistableIdleAction&gt; PersistableIdle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Func`2&lt;class System.Activities.WorkflowApplicationIdleEventArgs, valuetype System.Activities.PersistableIdleAction&gt; PersistableIdle" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.PersistableIdle" />
      <MemberSignature Language="VB.NET" Value="Public Property PersistableIdle As Func(Of WorkflowApplicationIdleEventArgs, PersistableIdleAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ PersistableIdle { Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ get(); void set(Func&lt;System::Activities::WorkflowApplicationIdleEventArgs ^, System::Activities::PersistableIdleAction&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PersistableIdle : Func&lt;System.Activities.WorkflowApplicationIdleEventArgs, System.Activities.PersistableIdleAction&gt; with get, set" Usage="System.Activities.WorkflowApplication.PersistableIdle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Activities.WorkflowApplicationIdleEventArgs,System.Activities.PersistableIdleAction&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Delegaten ab, der aufgerufen wird, wenn die aktuelle Workflowinstanz sich im Leerlauf befindet und im Persistenzspeicher abgelegt werden kann.</summary>
        <value>Der Delegat, der aufgerufen wird, wenn die aktuelle Workflowinstanz im Leerlauf befindet und beibehalten werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Workflow in den Leerlauf übergeht und beibehalten werden kann, werden <xref:System.Activities.WorkflowApplication.Idle%2A> und <xref:System.Activities.WorkflowApplication.PersistableIdle%2A> in dieser Reihenfolge aufgerufen. Der <xref:System.Activities.WorkflowApplication.PersistableIdle%2A>-Handler gibt einen der <xref:System.Activities.PersistableIdleAction> Enumerationswerte von <xref:System.Activities.PersistableIdleAction.None>, <xref:System.Activities.PersistableIdleAction.Persist> oder <xref:System.Activities.PersistableIdleAction.Unload> zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Activities.WorkflowApplication.PersistableIdle%2A>-Handler behandelt und das Laufzeitmodul angewiesen, den Workflow beizubehalten und zu entladen.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#26](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeBookmark">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initiiert einen Vorgang zur Wiederaufnahme eines Lesezeichens.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (System.Activities.Bookmark bookmark, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(class System.Activities.Bookmark bookmark, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.Activities.Bookmark,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : System.Activities.Bookmark * obj -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmark, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmark">Das wiederaufzunehmende Lesezeichen.</param>
        <param name="value">Ein Objekt, das als Parameter an die Methode übergeben wird, die bei Wiederaufnahme des Lesezeichens aufgerufen wird.</param>
        <summary>Initiiert einen Vorgang zur Wiederaufnahme des angegebenen Lesezeichens, wobei der angegebene Wert verwendet wird. Das wiederaufzunehmende Lesezeichen wurde zuvor von einer Aktivität innerhalb der Workflowinstanz erstellt.</summary>
        <returns>Das Ergebnis des Lesezeichenwiederaufnahmevorgangs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis gibt an, ob der Wiederaufnahmenvorgang erfolgreich war.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow erstellt, der eine `ReadLine`-Aktivität verwendet, die ein <xref:System.Activities.Bookmark> erstellt. Der Workflow wird gestartet, und sobald das <xref:System.Activities.Bookmark> erstellt wurde und der Workflow in den Leerlauf übergeht, wird die Eingabe des Benutzers erfasst und das Lesezeichen wieder aufgenommen.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#24](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (string bookmarkName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(string bookmarkName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResumeBookmark (bookmarkName As String, value As Object) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::String ^ bookmarkName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : string * obj -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmarkName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Der Name des Lesezeichens, das wiederaufgenommen werden soll.</param>
        <param name="value">Ein Objekt, das als Parameter an die Methode übergeben wird, die bei Wiederaufnahme des Lesezeichens aufgerufen wird.</param>
        <summary>Initiiert einen Vorgang zur Wiederaufnahme des Lesezeichens mit dem angegebenen Namen, wobei der angegebene Wert verwendet wird. Das wiederaufzunehmende Lesezeichen wurde zuvor von einer Aktivität innerhalb der Workflowinstanz erstellt.</summary>
        <returns>Das Ergebnis des Lesezeichenwiederaufnahmevorgangs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis gibt an, ob der Wiederaufnahmenvorgang erfolgreich war.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow erstellt, der eine `ReadLine`-Aktivität verwendet, die ein <xref:System.Activities.Bookmark> erstellt. Der Workflow wird gestartet, und sobald das <xref:System.Activities.Bookmark> erstellt wurde und der Workflow in den Leerlauf übergeht, wird die Eingabe des Benutzers erfasst und das Lesezeichen wieder aufgenommen.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (System.Activities.Bookmark bookmark, object value, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(class System.Activities.Bookmark bookmark, object value, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.Activities.Bookmark,System.Object,System.TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::Activities::Bookmark ^ bookmark, System::Object ^ value, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : System.Activities.Bookmark * obj * TimeSpan -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmark, value, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Activities.Bookmark" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="bookmark">Das wiederaufzunehmende Lesezeichen.</param>
        <param name="value">Ein Objekt, das als Parameter an die Methode übergeben wird, die bei Wiederaufnahme des Lesezeichens aufgerufen wird.</param>
        <param name="timeout">Das Zeitintervall, in dem das Lesezeichen wiederaufgenommen werden muss.</param>
        <summary>Initiiert einen Vorgang zur Wiederaufnahme des angegebenen Lesezeichens, wobei der angegebene Wert und das angegebene Timeoutintervall verwendet werden. Das wiederaufzunehmende Lesezeichen wurde zuvor von einer Aktivität innerhalb der Workflowinstanz erstellt.</summary>
        <returns>Das Ergebnis des Lesezeichenwiederaufnahmevorgangs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis gibt an, ob der Wiederaufnahmenvorgang erfolgreich war.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow erstellt, der eine `ReadLine`-Aktivität verwendet, die ein <xref:System.Activities.Bookmark> erstellt. Der Workflow wird gestartet, und sobald das <xref:System.Activities.Bookmark> erstellt wurde und der Workflow in den Leerlauf übergeht, wird die Eingabe des Benutzers erfasst und das Lesezeichen wieder aufgenommen.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#25](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResumeBookmark">
      <MemberSignature Language="C#" Value="public System.Activities.BookmarkResumptionResult ResumeBookmark (string bookmarkName, object value, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Activities.BookmarkResumptionResult ResumeBookmark(string bookmarkName, object value, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.ResumeBookmark(System.String,System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResumeBookmark (bookmarkName As String, value As Object, timeout As TimeSpan) As BookmarkResumptionResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Activities::BookmarkResumptionResult ResumeBookmark(System::String ^ bookmarkName, System::Object ^ value, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ResumeBookmark : string * obj * TimeSpan -&gt; System.Activities.BookmarkResumptionResult" Usage="workflowApplication.ResumeBookmark (bookmarkName, value, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.BookmarkResumptionResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Der Name des Lesezeichens, das wiederaufgenommen werden soll.</param>
        <param name="value">Ein Objekt, das als Parameter an die Methode übergeben wird, die bei Wiederaufnahme des Lesezeichens aufgerufen wird.</param>
        <param name="timeout">Das Zeitintervall, in dem das Lesezeichen wiederaufgenommen werden muss.</param>
        <summary>Initiiert einen Vorgang zur Wiederaufnahme des Lesezeichens mit dem angegebenen Namen, wobei der angegebene Wert und das angegebene Timeoutintervall verwendet werden. Das wiederaufzunehmende Lesezeichen wurde zuvor von einer Aktivität innerhalb der Workflowinstanz erstellt.</summary>
        <returns>Das Ergebnis des Lesezeichenwiederaufnahmevorgangs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis gibt an, ob der Wiederaufnahmenvorgang erfolgreich war.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow erstellt, der eine `ReadLine`-Aktivität verwendet, die ein <xref:System.Activities.Bookmark> erstellt. Der Workflow wird gestartet, und sobald das <xref:System.Activities.Bookmark> erstellt wurde und der Workflow in den Leerlauf übergeht, wird die Eingabe des Benutzers erfasst und das Lesezeichen wieder aufgenommen.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#15](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#15)]  
  
 [!code-csharp[CFX_WorkflowApplicationExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Startet die Ausführung einer Workflowinstanz bzw. nimmt sie wieder auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, um die Ausführung einer neu erstellten Workflowinstanz zu starten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Run" />
      <MemberSignature Language="VB.NET" Value="Public Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; unit" Usage="workflowApplication.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet die Ausführung einer Workflowinstanz bzw. nimmt sie wieder auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, um die Ausführung einer neu erstellten Workflowinstanz zu starten.  
  
 Wenn der Ausführungsvorgang innerhalb von 30 Sekunden nicht abgeschlossen wird, wird eine <xref:System.TimeoutException> ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mit der angegebenen Workflowdefinition erstellt, die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Wenn der Workflow abgeschlossen ist, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public void Run (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Run(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Run(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Run (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Run(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Run : TimeSpan -&gt; unit" Usage="workflowApplication.Run timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Rufen Sie diese Methode auf, um die Ausführung einer neu erstellten Workflowinstanz zu starten.  
  
Das Intervall, in dem der Ausführungsvorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <summary>Startet die Ausführung einer Workflowinstanz bzw. nimmt sie wieder auf, wobei das angegebene Timeoutintervall verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Im Gegensatz zu <xref:System.Activities.WorkflowInvoker.Invoke%2A> erfolgt für diese Methode kein Timeout, wenn der Workflow nicht innerhalb des angegebenen Zeitraums abgeschlossen wird. Stattdessen erfolgt ein Timeout, wenn der Workflow nicht innerhalb des angegebenen Zeitraums gestartet wird. Der Grund dafür ist, dass <xref:System.Activities.WorkflowInvoker.Invoke%2A> den Workflow synchron ausführt (und den Hostthread blockiert), während <xref:System.Activities.WorkflowApplication.Run%2A> asynchron ausgeführt wird und den Hostthread nur so lange blockiert, bis der Workflow gestartet ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mit der angegebenen Workflowdefinition erstellt, die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Wenn der Workflow abgeschlossen ist, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Starting the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Idle.   
Ending the workflow.   
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Completed  
Workflow 593976e8-558d-4989-94d6-50a14b34fd7b Unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#9](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsInstanceKeys">
      <MemberSignature Language="C#" Value="protected internal override bool SupportsInstanceKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsInstanceKeys" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.SupportsInstanceKeys" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property SupportsInstanceKeys As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool SupportsInstanceKeys { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsInstanceKeys : bool" Usage="System.Activities.WorkflowApplication.SupportsInstanceKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Terminate">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet eine Workflowinstanz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (Exception reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(class System.Exception reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(Exception ^ reason);" />
      <MemberSignature Language="F#" Value="member this.Terminate : Exception -&gt; unit" Usage="workflowApplication.Terminate reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="reason">Der Grund für das Beenden der Workflowinstanz.</param>
        <summary>Beendet eine Workflowinstanz aus dem angegebenen Grund.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode plant die Beendigung der Workflowinstanz. Um benachrichtigt zu werden, wenn die Beendigung abgeschlossen ist, verwenden Sie das <xref:System.Activities.WorkflowApplication.Completed%2A>-Handle.  
  
 Standardmäßig muss der <xref:System.Activities.WorkflowApplication.Terminate%2A>-Vorgang innerhalb von 30 Sekunden abgeschlossen werden. Andernfalls wird eine <xref:System.TimeoutException> ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mit der angegebenen Workflowdefinition erstellt, die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Nachdem der Workflow gestartet wurde, wird <xref:System.Activities.WorkflowApplication.Terminate%2A> aufgerufen. Wenn der Workflow beendet wurde, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Starting the workflow.   
Workflow e6b33409-f010-49f1-82ce-56f8baabe5e5 Terminated.  
Exception: System.ApplicationException  
Terminating the workflow.   
Workflow e6b33409-f010-49f1-82ce-56f8baabe5e5 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#16](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string reason);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string reason) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ reason);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string -&gt; unit" Usage="workflowApplication.Terminate reason" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="reason">Der Grund für das Beenden der Workflowinstanz.</param>
        <summary>Beendet eine Workflowinstanz mit der angegebenen Fehlermeldung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode plant die Beendigung der Workflowinstanz. Um benachrichtigt zu werden, wenn die Beendigung abgeschlossen ist, verwenden Sie das <xref:System.Activities.WorkflowApplication.Completed%2A>-Handle.  
  
 Standardmäßig muss der <xref:System.Activities.WorkflowApplication.Terminate%2A>-Vorgang innerhalb von 30 Sekunden abgeschlossen werden. Andernfalls wird eine <xref:System.TimeoutException> ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mit der angegebenen Workflowdefinition erstellt, die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Nachdem der Workflow gestartet wurde, wird <xref:System.Activities.WorkflowApplication.Terminate%2A> aufgerufen. Wenn der Workflow beendet wurde, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Starting the workflow.   
Workflow f87c6f91-4fe4-40b9-b7cb-4f1bd071bf84 Terminated.   
Exception: System.Activities.WorkflowApplicationTerminatedException  
Terminating the workflow.   
Workflow f87c6f91-4fe4-40b9-b7cb-4f1bd071bf84 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#18](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (Exception reason, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(class System.Exception reason, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.Exception,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As Exception, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(Exception ^ reason, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Terminate : Exception * TimeSpan -&gt; unit" Usage="workflowApplication.Terminate (reason, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.Exception" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="reason">Der Grund für das Beenden der Workflowinstanz.</param>
        <param name="timeout">Das Intervall, in dem der <see cref="M:System.Activities.WorkflowApplication.Terminate(System.Exception,System.TimeSpan)" />-Vorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <summary>Beendet eine Workflowinstanz, wobei die angegebene Ausnahme und das angegebene Timeoutintervall verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode plant die Beendigung des Workflows. Um benachrichtigt zu werden, wenn die Beendigung abgeschlossen ist, verwenden Sie das <xref:System.Activities.WorkflowApplication.Completed%2A>-Handle.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mit der angegebenen Workflowdefinition erstellt, die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Nachdem der Workflow gestartet wurde, wird <xref:System.Activities.WorkflowApplication.Terminate%2A> aufgerufen. Wenn der Workflow beendet wurde, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Starting the workflow.   
Workflow de28efe5-9057-472b-8d95-899c249893c5 Terminated.  
Exception: System.ApplicationException  
Terminating the workflow.   
Workflow de28efe5-9057-472b-8d95-899c249893c5 unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#17](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Terminate">
      <MemberSignature Language="C#" Value="public void Terminate (string reason, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Terminate(string reason, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Terminate(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Terminate (reason As String, timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Terminate(System::String ^ reason, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Terminate : string * TimeSpan -&gt; unit" Usage="workflowApplication.Terminate (reason, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reason" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="reason">Der Grund für das Beenden der Workflowinstanz.</param>
        <param name="timeout">Das Intervall, in dem der <see cref="M:System.Activities.WorkflowApplication.Terminate(System.String,System.TimeSpan)" />-Vorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <summary>Beendet eine Workflowinstanz, wobei die angegebene Fehlermeldung und das angegebene Timeoutintervall verwendet werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode plant die Beendigung der Workflowinstanz. Um benachrichtigt zu werden, wenn die Beendigung abgeschlossen ist, verwenden Sie das <xref:System.Activities.WorkflowApplication.Completed%2A>-Handle.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Workflow mit <xref:System.Activities.WorkflowApplication> gehostet. Eine <xref:System.Activities.WorkflowApplication>-Instanz wird mit der angegebenen Workflowdefinition erstellt, die gewünschten Lebenszyklusereignisse des Workflows werden behandelt, und der Workflow wird mit einem Aufruf von <xref:System.Activities.WorkflowApplication.Run%2A> aufgerufen. Nachdem der Workflow gestartet wurde, wird <xref:System.Activities.WorkflowApplication.Terminate%2A> aufgerufen. Wenn der Workflow beendet wurde, wird die folgende Ausgabe in der Konsole angezeigt.  
  
```Output  
Starting the workflow.   
Workflow 2897d2ef-377e-4224-ae93-5c19b38f487c Terminated.   
Exception: System.Activities.WorkflowApplicationTerminatedException  
Terminating the workflow.   
Workflow 2897d2ef-377e-4224-ae93-5c19b38f487c unloaded.  
  
```  
  
 [!code-csharp[CFX_WorkflowApplicationExample#19](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unload">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Speichert eine Workflowinstanz im Persistenzspeicher und entlädt sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig muss der Entladevorgang innerhalb von 30 Sekunden abgeschlossen sein. Andernfalls wird eine <xref:System.TimeoutException> ausgelöst.  
  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="workflowApplication.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert eine Workflowinstanz im Persistenzspeicher und entlädt sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig muss der Entladevorgang innerhalb von 30 Sekunden abgeschlossen sein. Andernfalls wird eine <xref:System.TimeoutException> ausgelöst.  
  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist Teil der [NoPersistScope-Aktivität](~/docs/framework/windows-workflow-foundation/samples/nopersistscope-activity.md) Beispiel. In diesem Beispiel befindet sich der Workflow im Leerlauf, und die Hostanwendung wartet auf eine Benutzereingabe. Wenn der Benutzer das Entladen auswählt, wird <xref:System.Activities.WorkflowApplication.Unload%2A> aufgerufen. Bei Erfolg wird der Workflow beibehalten und aus dem Arbeitsspeicher entladen.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowApplication.Unload(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Unload : TimeSpan -&gt; unit" Usage="workflowApplication.Unload timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Das Intervall, in dem der Entladevorgang abgeschlossen werden muss, bevor der Vorgang abgebrochen und eine <see cref="T:System.TimeoutException" /> ausgelöst wird.</param>
        <summary>Speichert eine Workflowinstanz im Persistenzspeicher und entlädt sie, wobei das angegebene Timeoutintervall verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Workflowinstanz zuvor aus dem permanenten Speicher geladen wurde, wird für den permanenten Speicher der <xref:System.Runtime.DurableInstancing.InstanceStore> verwendet, mit dem der Workflow geladen wurde. Wenn der Workflow erstellt und noch nicht permanent gespeichert wurde, muss vor dem Aufrufen dieser Methode ein <xref:System.Activities.WorkflowApplication.InstanceStore%2A> konfiguriert werden. Andernfalls wird beim Aufrufen dieser Methode eine <xref:System.InvalidOperationException> ausgelöst.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist Teil der [NoPersistScope-Aktivität](~/docs/framework/windows-workflow-foundation/samples/nopersistscope-activity.md) Beispiel. In diesem Beispiel befindet sich der Workflow im Leerlauf, und die Hostanwendung wartet auf eine Benutzereingabe. Wenn der Benutzer das Entladen auswählt, wird <xref:System.Activities.WorkflowApplication.Unload%2A> aufgerufen. Bei Erfolg wird der Workflow beibehalten und aus dem Arbeitsspeicher entladen.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public Action&lt;System.Activities.WorkflowApplicationEventArgs&gt; Unloaded { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Action`1&lt;class System.Activities.WorkflowApplicationEventArgs&gt; Unloaded" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowApplication.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Property Unloaded As Action(Of WorkflowApplicationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ Unloaded { Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ get(); void set(Action&lt;System::Activities::WorkflowApplicationEventArgs ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Unloaded : Action&lt;System.Activities.WorkflowApplicationEventArgs&gt; with get, set" Usage="System.Activities.WorkflowApplication.Unloaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Activities.WorkflowApplicationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Action`1" />-Aktion ab, die beim Entladen des aktuellen Workflows ausgelöst wird, bzw. legt sie fest.</summary>
        <value>Die Aktion, die beim Entladen einer Workflowinstanz ausgelöst wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel werden die in den <xref:System.Activities.WorkflowApplicationEventArgs>-Handler einer <xref:System.Activities.WorkflowApplication.Unloaded%2A>-Instanz übergebenen <xref:System.Activities.WorkflowApplication> überprüft, und die <xref:System.Activities.WorkflowApplicationEventArgs.InstanceId%2A> des Workflows, der entladen wurde, wird angezeigt.  
  
 [!code-csharp[CFX_WorkflowApplicationExample#3](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowapplicationexample/cs/program.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>