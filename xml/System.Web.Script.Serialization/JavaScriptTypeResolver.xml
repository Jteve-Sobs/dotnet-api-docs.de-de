<Type Name="JavaScriptTypeResolver" FullName="System.Web.Script.Serialization.JavaScriptTypeResolver">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dc4d361a43ced23669530a32d2b8051850a4dd1c" /><Meta Name="ms.sourcegitcommit" Value="0398021c376446770e5d349e60aa72d49fc34f22" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/28/2020" /><Meta Name="ms.locfileid" Value="87260292" /></Metadata><TypeSignature Language="C#" Value="public abstract class JavaScriptTypeResolver" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit JavaScriptTypeResolver extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Script.Serialization.JavaScriptTypeResolver" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class JavaScriptTypeResolver" />
  <TypeSignature Language="C++ CLI" Value="public ref class JavaScriptTypeResolver abstract" />
  <TypeSignature Language="F#" Value="type JavaScriptTypeResolver = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web.Extensions</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="c957b-101">Stellt die abstrakte Basisklasse zum Implementieren eines benutzerdefinierten Typresolvers bereit.</span><span class="sxs-lookup"><span data-stu-id="c957b-101">Provides the abstract base class for implementing a custom type resolver.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c957b-102">Die- <xref:System.Web.Script.Serialization.JavaScriptTypeResolver> Klasse stellt die Dienste für bereit:</span><span class="sxs-lookup"><span data-stu-id="c957b-102">The <xref:System.Web.Script.Serialization.JavaScriptTypeResolver> class provides the services for:</span></span>  
  
-   <span data-ttu-id="c957b-103">Informationen zu verwalteten Typen werden mithilfe der-Methode in einen Zeichen folgen Wert umgerechnet <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> .</span><span class="sxs-lookup"><span data-stu-id="c957b-103">Converting managed type information to a string value through the <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> method.</span></span>  
  
-   <span data-ttu-id="c957b-104">Auflösen eines Zeichen folgen Werts zurück in den entsprechenden verwalteten Typ durch die- <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="c957b-104">Resolving a string value back to the appropriate managed type through the <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> method.</span></span>  
  
 <span data-ttu-id="c957b-105">Wenn das <xref:System.Web.Script.Serialization.JavaScriptSerializer> Objekt benutzerdefinierte Typen serialisiert, kann es optional in die serialisierte JavaScript Object Notation (JSON)-Zeichenfolge einen Wert einschließen, der Typinformationen enthält.</span><span class="sxs-lookup"><span data-stu-id="c957b-105">When the <xref:System.Web.Script.Serialization.JavaScriptSerializer> object serializes custom types, it can optionally include in the serialized JavaScript Object Notation (JSON) string a value that contains type information.</span></span> <span data-ttu-id="c957b-106">Während der Deserialisierung <xref:System.Web.Script.Serialization.JavaScriptSerializer> kann dann auf diesen Zeichen folgen Wert verweisen, um den entsprechenden verwalteten Typ zu bestimmen, in den die JSON-Zeichenfolge konvertiert wird.</span><span class="sxs-lookup"><span data-stu-id="c957b-106">During deserialization, <xref:System.Web.Script.Serialization.JavaScriptSerializer> can then reference this string value to determine the appropriate managed type to which the JSON string will be converted.</span></span>  
  
 <span data-ttu-id="c957b-107">Wenn Sie einen Typresolver für die <xref:System.Web.Script.Serialization.JavaScriptSerializer> -Instanz bereitstellen, verwendet das Serialisierungsprogramm die <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> -Methode und die- <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> Methode, um den verwalteten Typ und den Zeichen folgen Wert während des Serialisierungs-bzw. Deserialisierungsprozesses zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="c957b-107">If you provide a type resolver to the <xref:System.Web.Script.Serialization.JavaScriptSerializer> instance, the serializer will use the <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> and <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> methods to map between the managed type and the string value during the serialization and deserialization process, respectively.</span></span>  
  
 <span data-ttu-id="c957b-108">Die- <xref:System.Web.Script.Serialization.JavaScriptTypeResolver> Klasse ist die Basisklasse für die- <xref:System.Web.Script.Serialization.SimpleTypeResolver> Klasse, die eine Implementierung eines Typresolvers bereitstellt, der den durch die Assembly qualifizierten Namen des verwalteten Typs verwendet.</span><span class="sxs-lookup"><span data-stu-id="c957b-108">The <xref:System.Web.Script.Serialization.JavaScriptTypeResolver> class is the base class for the <xref:System.Web.Script.Serialization.SimpleTypeResolver> class, which provides an implementation of a type resolver that uses the managed type assembly-qualified name.</span></span>  

> [!NOTE]
> <span data-ttu-id="c957b-109">Wenn Sie einen verwenden `JavaScriptTypeResolver` , enthält die resultierende JSON-Nutzlast eine spezielle `__type` Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="c957b-109">When using a `JavaScriptTypeResolver`, the resulting JSON payload contains a special `__type` property.</span></span> <span data-ttu-id="c957b-110">Diese Eigenschaft enthält den vollständigen Typnamen (einschließlich Namespace) des Zieltyps.</span><span class="sxs-lookup"><span data-stu-id="c957b-110">This property includes the full type name, including namespace, of the target type.</span></span> <span data-ttu-id="c957b-111">Vergewissern Sie sich vor der Verwendung eines benutzerdefinierten Konflikt Lösers, dass der vollständige Name des Zieltyps keine sensiblen oder privilegierten Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="c957b-111">Before using a custom resolver, verify that the full name of the target type does not contain sensitive or privileged information.</span></span>

## Examples  

<span data-ttu-id="c957b-112">Im folgenden Beispiel wird gezeigt, wie ein benutzerdefiniertes erstellt wird `JavaScriptTypeResolver` und wie es verwendet wird, um ein Objekt zu serialisieren oder zu deserialisieren.</span><span class="sxs-lookup"><span data-stu-id="c957b-112">The following example shows how to create a custom `JavaScriptTypeResolver` and how to use it to serialize or deserialize an object.</span></span>

```cs
using System;
using System.Linq;
using System.Web.Script.Serialization;

namespace SampleApp
{
    class Program
    {
        static void Main(string[] args)
        {
            // The object array to serialize.
            Person[] people = new Person[]
            {
                new Person()
                {
                    Name = "Kristen Solstad",
                    Age = 15,
                    HomeAddress = new Address()
                    {
                        Street1 = "123 Palm Ave",
                        City = "Some City",
                        StateOrProvince = "ST",
                        Country = "United States",
                        PostalCode = "00000"
                    }
                },
                new Adult()
                {
                    Name = "Alex Johnson",
                    Age = 39,
                    Occupation = "Mechanic",
                    HomeAddress = new Address()
                    {
                        Street1 = "445 Lorry Way",
                        Street2 = "Unit 3A",
                        City = "Some City",
                        Country = "United Kingdom",
                        PostalCode = "AA0 A00"
                    }
                }
            };

            // Serialize the object array, then write it to the console.
            string serializedData = SerializePeopleArray(people);
            Console.WriteLine("Serialized:");
            Console.WriteLine(serializedData);
            Console.WriteLine();

            // Now deserialize the object array.
            Person[] deserializedArray = DeserializePeopleArray(serializedData);
            Console.WriteLine("Deserialized " + deserializedArray.Length + " people.");
            foreach (Person person in deserializedArray)
            {
                Console.WriteLine(person.Name + " (Age " + person.Age + ") [" + person.GetType() + "]");
            }
        }

        static string SerializePeopleArray(Person[] people)
        {
            // The custom type resolver to use.
            // Note: Except for primitives like int and string, *every* type that
            // we might see in the object graph must be listed here.
            CustomTypeResolver resolver = new CustomTypeResolver(
                typeof(Person),
                typeof(Adult),
                typeof(Address));

            // Instantiate the serializer.
            JavaScriptSerializer serializer = new JavaScriptSerializer(resolver);

            // Serialize the object array, then return it.
            string serialized = serializer.Serialize(people);
            return serialized;
        }

        static Person[] DeserializePeopleArray(string serializedData)
        {
            // The custom type resolver to use.
            // Note: This is the same list that was provided to the Serialize routine.
            CustomTypeResolver resolver = new CustomTypeResolver(
                typeof(Person),
                typeof(Adult),
                typeof(Address));

            // Instantiate the serializer.
            JavaScriptSerializer serializer = new JavaScriptSerializer(resolver);

            // Deserialize the object array, then return it.
            Person[] deserialized = serializer.Deserialize<Person[]>(serializedData);
            return deserialized;
        }
    }

    public class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }
        public Address HomeAddress { get; set; }
    }

    public class Adult : Person
    {
        public string Occupation { get; set; }
    }

    public class Address
    {
        public string Street1 { get; set; }
        public string Street2 { get; set; }
        public string City { get; set; }
        public string StateOrProvince { get; set; }
        public string Country { get; set; }
        public string PostalCode { get; set; }
    }

    // A custom JavaScriptTypeResolver that restricts the payload
    // to a set of known good types.
    class CustomTypeResolver : JavaScriptTypeResolver
    {
        private readonly Type[] _allowedTypes;

        public CustomTypeResolver(params Type[] allowedTypes)
        {
            if (allowedTypes == null)
            {
                throw new ArgumentNullException("allowedTypes");
            }

            // Make a copy of the array the caller gave us.
            _allowedTypes = (Type[])allowedTypes.Clone();
        }

        public override Type ResolveType(string id)
        {
            // Iterate over all of the allowed types, looking for a match
            // for the 'id' parameter. Calling Type.GetType(id) is dangerous,
            // so we instead perform a match on the Type.FullName property.
            foreach (Type allowedType in _allowedTypes)
            {
                if (allowedType.FullName == id)
                {
                    return allowedType;
                }
            }

            // The caller provided a type we don't recognize. This could be
            // dangerous, so we'll fail the operation immediately.
            throw new ArgumentException("Unknown type: " + id, "id");
        }

        public override string ResolveTypeId(Type type)
        {
            // Before we serialize data, quickly double-check to make
            // sure we're allowed to deserialize the data. Otherwise it's
            // no good serializing something if we can't deserialize it.
            if (_allowedTypes.Contains(type))
            {
                return type.FullName;
            }

            throw new InvalidOperationException("Cannot serialize an object of type " + type + ". Did you forget to add it to the allow list?");
        }
    }
}
```

<span data-ttu-id="c957b-113">Die vorherige App gibt Folgendes an der Konsole aus, die für die Lesbarkeit formatiert ist.</span><span class="sxs-lookup"><span data-stu-id="c957b-113">The preceding app outputs the following to the console, formatted for readability.</span></span>

```txt
Serialized:
[
    {
        "__type": "SampleApp.Person",
        "Name": "Kristen Solstad",
        "Age": 15,
        "HomeAddress": {
            "__type": "SampleApp.Address",
            "Street1": "123 Palm Ave",
            "Street2": null,
            "City": "Some City",
            "StateOrProvince": "ST",
            "Country": "United States",
            "PostalCode": "00000"
        }
    },
    {
        "__type": "SampleApp.Adult",
        "Occupation": "Mechanic",
        "Name": "Alex Johnson",
        "Age": 39,
        "HomeAddress": {
            "__type": "SampleApp.Address",
            "Street1": "445 Lorry Way",
            "Street2": "Unit 3A",
            "City": "Some City",
            "StateOrProvince": null,
            "Country": "United Kingdom",
            "PostalCode": "AA0 A00"
        }
    }
]

Deserialized 2 people.
Kristen Solstad (Age 15) [SampleApp.Person]
Alex Johnson (Age 39) [SampleApp.Adult]
```

<span data-ttu-id="c957b-114">Im vorherigen Beispiel ist der Typ `Adult` Unterklassen `Person` .</span><span class="sxs-lookup"><span data-stu-id="c957b-114">In the preceding sample, the `Adult` type subclasses the `Person` type.</span></span> <span data-ttu-id="c957b-115">Ein Benutzer `JavaScriptTypeResolver` definiertes wird verwendet, um die Typinformationen als Teil der generierten JSON-Nutzlast einzuschließen.</span><span class="sxs-lookup"><span data-stu-id="c957b-115">A custom `JavaScriptTypeResolver` is used to include the type information as part of the generated JSON payload.</span></span> <span data-ttu-id="c957b-116">Dies ermöglicht eine eingeschränkte Polymorphie beim Deserialisieren der JSON-Nutzlast zurück in ein .NET-Objekt Diagramm.</span><span class="sxs-lookup"><span data-stu-id="c957b-116">This allows limited polymorphism when deserializing the JSON payload back into a .NET object graph.</span></span> <span data-ttu-id="c957b-117">Die Nutzlast kann steuern, ob eine Basis `Person` Instanz oder eine abgeleitete `Adult` Instanz zurück an den Aufrufer zurückgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="c957b-117">The payload can control whether to return a base `Person` instance or a derived `Adult` instance back to the caller.</span></span>

<span data-ttu-id="c957b-118">Dieses Beispiel ist sicher, weil es einen `allow-list` Mechanismus zum Steuern der Deserialisierung verwendet.</span><span class="sxs-lookup"><span data-stu-id="c957b-118">This sample is safe because it uses an `allow-list` mechanism to control deserialization.</span></span> <span data-ttu-id="c957b-119">Der Code:</span><span class="sxs-lookup"><span data-stu-id="c957b-119">The code:</span></span>

* <span data-ttu-id="c957b-120">Initialisiert `CustomTypeResolver` mit einer expliziten Liste zulässiger Typen.</span><span class="sxs-lookup"><span data-stu-id="c957b-120">Initializes the `CustomTypeResolver` with an explicit list of allowed types.</span></span>
* <span data-ttu-id="c957b-121">Schränkt den Deserialisierungsprozess auf eine genehmigte Liste von Typen ein.</span><span class="sxs-lookup"><span data-stu-id="c957b-121">Restricts the deserialization process to only approved list of types.</span></span> <span data-ttu-id="c957b-122">Die Einschränkung verhindert [deserialisierungsangriffe](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data), bei denen der Remote Client eine böswillige `__type` in der JSON-Nutzlast angibt und den Server zur Deserialisierung eines gefährlichen Typs verleitet.</span><span class="sxs-lookup"><span data-stu-id="c957b-122">The restriction prevents [deserialization attacks](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data), where the remote client specifies a malicious `__type` in the JSON payload and tricks the server into deserializing a dangerous type.</span></span>

<span data-ttu-id="c957b-123">Obwohl die app nur erwartet `Person` , dass-und- `Adult` Instanzen als Teil des Arrays der obersten Ebene deserialisiert werden, ist es trotzdem erforderlich, dass Sie der Zulassungsliste hinzufügen, `Address` da:</span><span class="sxs-lookup"><span data-stu-id="c957b-123">Even though the app only expects `Person` and `Adult` instances to be deserialized as part of the top-level array, it's still necessary to add `Address` to the allow-list because:</span></span>

* <span data-ttu-id="c957b-124">Beim Serialisieren `Person` von oder wird `Adult` auch ein `Address` als Teil des Objekt Diagramms serialisiert.</span><span class="sxs-lookup"><span data-stu-id="c957b-124">Serializing a `Person` or `Adult` also serializes an `Address` as part of the object graph.</span></span>
* <span data-ttu-id="c957b-125">Alle Typen, die im Objekt Diagramm vorhanden sein können, müssen in der Zulassungsliste berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="c957b-125">All types that might be present in the object graph need to be accounted for in the allow list.</span></span> <span data-ttu-id="c957b-126">Primitive wie `int` und `string` müssen nicht angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="c957b-126">Primitives like `int` and `string` do not need to be specified.</span></span>

> [!WARNING]
>  <span data-ttu-id="c957b-127">Nicht `Type.GetType(id)` innerhalb der-Methode aufzurufen `ResolveType` .</span><span class="sxs-lookup"><span data-stu-id="c957b-127">Do not call `Type.GetType(id)` within the `ResolveType` method.</span></span> <span data-ttu-id="c957b-128">Dies kann zu einer Sicherheits-vunerability in der APP führen.</span><span class="sxs-lookup"><span data-stu-id="c957b-128">This could introduce a security vunerability into the app.</span></span> <span data-ttu-id="c957b-129">Durchlaufen Sie stattdessen die Liste der zulässigen Typen, und vergleichen Sie Ihre- `Type.FullName` Eigenschaft mit der eingehenden `id` , wie im vorherigen Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="c957b-129">Instead, iterate through the list of allowed types and compare their `Type.FullName` property against the incoming `id`, as shown in the preceding sample.</span></span>
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="c957b-130">Wenn Sie einen Typresolver implementieren, muss die Zeichenfolge, die von der-Methode zurückgegeben wird, <see cref="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId(System.Type)" /> wieder dem gleichen verwalteten Typ zugeordnet werden, wenn der Zeichen folgen Wert an die-Methode übermittelt wird <see cref="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType(System.String)" /> .</span><span class="sxs-lookup"><span data-stu-id="c957b-130">When you implement a type resolver, the string that is returned by the <see cref="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId(System.Type)" /> method must map back to the same managed type when the string value is passed to the <see cref="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType(System.String)" /> method.</span></span></para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected JavaScriptTypeResolver ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Script.Serialization.JavaScriptTypeResolver.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; JavaScriptTypeResolver();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c957b-131">Initialisiert eine neue Instanz der <see cref="T:System.Web.Script.Serialization.JavaScriptTypeResolver" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="c957b-131">Initializes a new instance of the <see cref="T:System.Web.Script.Serialization.JavaScriptTypeResolver" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public abstract Type ResolveType (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResolveType (id As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ ResolveType(System::String ^ id);" />
      <MemberSignature Language="F#" Value="abstract member ResolveType : string -&gt; Type" Usage="javaScriptTypeResolver.ResolveType id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id"><span data-ttu-id="c957b-132">Der Name des verwalteten Typs.</span><span class="sxs-lookup"><span data-stu-id="c957b-132">The name of the managed type.</span></span></param>
        <summary><span data-ttu-id="c957b-133">Gibt beim Überschreiben in einer abgeleiteten Klasse das <see cref="T:System.Type" />-Objekt zurück, das dem angegebenen Typnamen zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="c957b-133">When overridden in a derived class, returns the <see cref="T:System.Type" /> object that is associated with the specified type name.</span></span></summary>
        <returns><span data-ttu-id="c957b-134">Das <see cref="T:System.Type" />-Objekt, das dem angegebenen Typnamen zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="c957b-134">The <see cref="T:System.Type" /> object that is associated with the specified type name.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c957b-135">Wenn ein Typresolver einer-Instanz zugeordnet ist <xref:System.Web.Script.Serialization.JavaScriptSerializer> , verwendet das Serialisierungsprogramm die- <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> Methode, wenn es eine JSON-Zeichenfolge durchläuft, um den spezifischen verwalteten Typ zu bestimmen, in den der JSON-Typ konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="c957b-135">When a type resolver is associated with a <xref:System.Web.Script.Serialization.JavaScriptSerializer> instance, the serializer uses the <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveType%2A> method when it iterates through a JSON string to determine the specific managed type to which the JSON type should be converted.</span></span>  

 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="c957b-136">Wenn ein Zeichen folgen Wert angegeben ist, muss der Typresolver ein-Objekt zurückgeben <see cref="T:System.Type" /> , das den entsprechenden verwalteten Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="c957b-136">Given a string value, the type resolver must return a <see cref="T:System.Type" /> object that represents the corresponding managed type.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="ResolveTypeId">
      <MemberSignature Language="C#" Value="public abstract string ResolveTypeId (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveTypeId(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResolveTypeId (type As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ ResolveTypeId(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member ResolveTypeId : Type -&gt; string" Usage="javaScriptTypeResolver.ResolveTypeId type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web.Extensions</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="c957b-137">Der aufzulösende verwaltete Typ.</span><span class="sxs-lookup"><span data-stu-id="c957b-137">The managed type to be resolved.</span></span></param>
        <summary><span data-ttu-id="c957b-138">Gibt beim Überschreiben in einer abgeleiteten Klasse den Typnamen für das angegebene <see cref="T:System.Type" />-Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="c957b-138">When overridden in a derived class, returns the type name for the specified <see cref="T:System.Type" /> object.</span></span></summary>
        <returns><span data-ttu-id="c957b-139">Der Name des angegebenen verwalteten Typs.</span><span class="sxs-lookup"><span data-stu-id="c957b-139">The name of the specified managed type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c957b-140">Wenn die <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> Methode oder zurückgibt, wird der- `null` <xref:System.String.Empty> Typ vom Typresolver nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="c957b-140">If the <xref:System.Web.Script.Serialization.JavaScriptTypeResolver.ResolveTypeId%2A> method returns either `null` or <xref:System.String.Empty>, then the type resolver does not support the type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
