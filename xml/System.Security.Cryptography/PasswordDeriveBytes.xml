<Type Name="PasswordDeriveBytes" FullName="System.Security.Cryptography.PasswordDeriveBytes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7c9a58f545c265cbfb450791e8e32e036c0a6d00" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39782164" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PasswordDeriveBytes : System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PasswordDeriveBytes extends System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.PasswordDeriveBytes" />
  <TypeSignature Language="VB.NET" Value="Public Class PasswordDeriveBytes&#xA;Inherits DeriveBytes" />
  <TypeSignature Language="C++ CLI" Value="public ref class PasswordDeriveBytes : System::Security::Cryptography::DeriveBytes" />
  <TypeSignature Language="F#" Value="type PasswordDeriveBytes = class&#xA;    inherit DeriveBytes" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.DeriveBytes</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1">
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Leitet mithilfe einer Erweiterung des PBKDF1-Algorithmus einen Schlüssel von einem Kennwort ab.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse verwendet eine Erweiterung des PBKDF1-Algorithmus in die PKCS #5 Version 2.0 standard definiert, um Bytes aus einem Kennwort für die Verwendung als Schlüsselmaterial geeignet sind. Der Standard ist in IETF RRC 2898 dokumentiert.  
  
> [!IMPORTANT]
>  Niemals hartcodierte ein Kennwort ein, in Ihrem Quellcode.  Hartcodierten Kennwörter abgerufen werden können, aus einer Assembly mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Tool, ein hex-Editor, oder durch das Öffnen der Assembly in einem Text-Editor wie z. B. notepad.exe.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Schlüssel aus einem Kennwort mithilfe der <xref:System.Security.Cryptography.PasswordDeriveBytes> Klasse.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#1)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#1)]
 [!code-vb[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PasswordDeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.PasswordDeriveBytes : byte[] * byte[] -&gt; System.Security.Cryptography.PasswordDeriveBytes" Usage="new System.Security.Cryptography.PasswordDeriveBytes (password, salt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="password">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse und gibt das Kennwort und den Salt-Wert des Schlüssels an, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Codieren Sie niemals hart ein Kennwort in Ihrem Quellcode.  Fest programmierte Kennwörter abgerufen werden können, aus einer Assembly mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), ein hex-Editor, oder durch das Öffnen der Assembly in einem Text-Editor, z. B. Notepad.exe.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Schlüssel aus einem Kennwort mithilfe der <xref:System.Security.Cryptography.PasswordDeriveBytes> Klasse.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#1)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#1)]
 [!code-vb[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (strPassword As String, rgbSalt As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PasswordDeriveBytes(System::String ^ strPassword, cli::array &lt;System::Byte&gt; ^ rgbSalt);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.PasswordDeriveBytes : string * byte[] -&gt; System.Security.Cryptography.PasswordDeriveBytes" Usage="new System.Security.Cryptography.PasswordDeriveBytes (strPassword, rgbSalt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="strPassword">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="rgbSalt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse mit dem Kennwort und dem Salt-Wert, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Niemals hartcodierte ein Kennwort ein, in Ihrem Quellcode.  Hartcodierten Kennwörter abgerufen werden können, aus einer Assembly mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Tool, ein hex-Editor, oder durch das Öffnen der Assembly in einem Text-Editor wie z. B. notepad.exe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.Security.Cryptography.CspParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), cspParams As CspParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PasswordDeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, System::Security::Cryptography::CspParameters ^ cspParams);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.PasswordDeriveBytes : byte[] * byte[] * System.Security.Cryptography.CspParameters -&gt; System.Security.Cryptography.PasswordDeriveBytes" Usage="new System.Security.Cryptography.PasswordDeriveBytes (password, salt, cspParams)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="password">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="cspParams">Die CSP-Parameter für den Vorgang.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse und gibt das Kennwort, den Salt-Wert des Schlüssels und den CSP (Cryptographic Service Provider) an, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Codieren Sie niemals hart ein Kennwort in Ihrem Quellcode.  Fest programmierte Kennwörter abgerufen werden können, aus einer Assembly mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) l, ein hex-Editor, oder durch das Öffnen der Assembly in einem Text-Editor, z. B. Notepad.exe.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt einen Schlüssel aus einem Kennwort mithilfe der <xref:System.Security.Cryptography.PasswordDeriveBytes> Klasse.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#1)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#1)]
 [!code-vb[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.Security.Cryptography.CspParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (strPassword As String, rgbSalt As Byte(), cspParams As CspParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PasswordDeriveBytes(System::String ^ strPassword, cli::array &lt;System::Byte&gt; ^ rgbSalt, System::Security::Cryptography::CspParameters ^ cspParams);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.PasswordDeriveBytes : string * byte[] * System.Security.Cryptography.CspParameters -&gt; System.Security.Cryptography.PasswordDeriveBytes" Usage="new System.Security.Cryptography.PasswordDeriveBytes (strPassword, rgbSalt, cspParams)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="strPassword">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="rgbSalt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="cspParams">Die CSP-Parameter für die Operation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse mit dem Kennwort, dem Salt-Wert des Schlüssels und den CSP-Parametern (Cryptographic Service Provider), die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Niemals hartcodierte ein Kennwort ein, in Ihrem Quellcode.  Hartcodierten Kennwörter abgerufen werden können, aus einer Assembly mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Tool, ein hex-Editor, oder durch das Öffnen der Assembly in einem Text-Editor wie z. B. notepad.exe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt, string hashName, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, string hashName, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), hashName As String, iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PasswordDeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, System::String ^ hashName, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.PasswordDeriveBytes : byte[] * byte[] * string * int -&gt; System.Security.Cryptography.PasswordDeriveBytes" Usage="new System.Security.Cryptography.PasswordDeriveBytes (password, salt, hashName, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="hashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="hashName">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="iterations">Die Anzahl der Iterationen, die zum Ableiten des Schlüssels verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse und gibt das Kennwort, den Salt-Wert des Schlüssels, den Hashnamen und die Anzahl der Iterationen an, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Codieren Sie niemals hart ein Kennwort in Ihrem Quellcode.  Fest programmierte Kennwörter abgerufen werden können, aus einer Assembly mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), ein hex-Editor, oder durch das Öffnen der Assembly in einem Text-Editor, z. B. Notepad.exe.  
  
 Eine Liste der Namen der Hash-Algorithmus finden Sie unter den <xref:System.Security.Cryptography.CryptoConfig> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.Cryptography.CryptoConfig" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt, string strHashName, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt, string strHashName, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (strPassword As String, rgbSalt As Byte(), strHashName As String, iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PasswordDeriveBytes(System::String ^ strPassword, cli::array &lt;System::Byte&gt; ^ rgbSalt, System::String ^ strHashName, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.PasswordDeriveBytes : string * byte[] * string * int -&gt; System.Security.Cryptography.PasswordDeriveBytes" Usage="new System.Security.Cryptography.PasswordDeriveBytes (strPassword, rgbSalt, strHashName, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
        <Parameter Name="strHashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strPassword">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="rgbSalt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="strHashName">Der Name des Hashalgorithmus für die Operation.</param>
        <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse mit dem Kennwort, dem Salt-Wert des Schlüssels, dem Hashnamen und der Anzahl der Iterationen, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Niemals hartcodierte ein Kennwort ein, in Ihrem Quellcode.  Hartcodierten Kennwörter abgerufen werden können, aus einer Assembly mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Tool, ein hex-Editor, oder durch das Öffnen der Assembly in einem Text-Editor wie z. B. notepad.exe.  
  
 Eine Liste der Namen der Hash-Algorithmus finden Sie unter den <xref:System.Security.Cryptography.CryptoConfig> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.Cryptography.CryptoConfig" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt, string hashName, int iterations, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, string hashName, int32 iterations, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.String,System.Int32,System.Security.Cryptography.CspParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), hashName As String, iterations As Integer, cspParams As CspParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PasswordDeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, System::String ^ hashName, int iterations, System::Security::Cryptography::CspParameters ^ cspParams);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.PasswordDeriveBytes : byte[] * byte[] * string * int * System.Security.Cryptography.CspParameters -&gt; System.Security.Cryptography.PasswordDeriveBytes" Usage="new System.Security.Cryptography.PasswordDeriveBytes (password, salt, hashName, iterations, cspParams)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="hashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="password">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="hashName">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="iterations">Die Anzahl der Iterationen, die zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="cspParams">Die CSP-Parameter für den Vorgang.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse und gibt das Kennwort, den Salt-Wert des Schlüssels, den Hashnamen, die Iterationen und die CSP-Parameter an, die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Codieren Sie niemals hart ein Kennwort in Ihrem Quellcode.  Fest programmierte Kennwörter abgerufen werden können, aus einer Assembly mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), ein hex-Editor, oder durch das Öffnen der Assembly in einem Text-Editor, z. B. Notepad.exe.  
  
 Eine Liste der Namen der Hash-Algorithmus finden Sie unter den <xref:System.Security.Cryptography.CryptoConfig> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.Cryptography.CryptoConfig" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt, string strHashName, int iterations, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt, string strHashName, int32 iterations, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.String,System.Int32,System.Security.Cryptography.CspParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (strPassword As String, rgbSalt As Byte(), strHashName As String, iterations As Integer, cspParams As CspParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PasswordDeriveBytes(System::String ^ strPassword, cli::array &lt;System::Byte&gt; ^ rgbSalt, System::String ^ strHashName, int iterations, System::Security::Cryptography::CspParameters ^ cspParams);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.PasswordDeriveBytes : string * byte[] * string * int * System.Security.Cryptography.CspParameters -&gt; System.Security.Cryptography.PasswordDeriveBytes" Usage="new System.Security.Cryptography.PasswordDeriveBytes (strPassword, rgbSalt, strHashName, iterations, cspParams)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
        <Parameter Name="strHashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="strPassword">Das Kennwort, für das der Schlüssel abgeleitet werden soll.</param>
        <param name="rgbSalt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="strHashName">Der Name des Hashalgorithmus für die Operation.</param>
        <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
        <param name="cspParams">Die CSP-Parameter für die Operation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse mit dem Kennwort, dem Salt-Wert des Schlüssels, dem Hashnamen, der Anzahl der Iterationen und den CSP-Parametern (Cryptographic Service Provider), die zum Ableiten des Schlüssels verwendet werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Niemals hartcodierte ein Kennwort ein, in Ihrem Quellcode.  Hartcodierten Kennwörter abgerufen werden können, aus einer Assembly mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) Tool, ein hex-Editor, oder durch das Öffnen der Assembly in einem Text-Editor wie z. B. notepad.exe.  
  
 Eine Liste der Namen der Hash-Algorithmus finden Sie unter den <xref:System.Security.Cryptography.CryptoConfig> Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.Cryptography.CryptoConfig" />
      </Docs>
    </Member>
    <Member MemberName="CryptDeriveKey">
      <MemberSignature Language="C#" Value="public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] CryptDeriveKey(string algname, string alghashname, int32 keySize, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CryptDeriveKey (algname As String, alghashname As String, keySize As Integer, rgbIV As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ CryptDeriveKey(System::String ^ algname, System::String ^ alghashname, int keySize, cli::array &lt;System::Byte&gt; ^ rgbIV);" />
      <MemberSignature Language="F#" Value="member this.CryptDeriveKey : string * string * int * byte[] -&gt; byte[]" Usage="passwordDeriveBytes.CryptDeriveKey (algname, alghashname, keySize, rgbIV)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algname" Type="System.String" />
        <Parameter Name="alghashname" Type="System.String" />
        <Parameter Name="keySize" Type="System.Int32" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="algname">Der Name des Algorithmus, für den der Schlüssel abgeleitet werden soll.</param>
        <param name="alghashname">Der Name des Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="keySize">Die Größe des abzuleitenden Schlüssels in Bits.</param>
        <param name="rgbIV">Der zum Ableiten des Schlüssels zu verwendende Initialisierungsvektor.</param>
        <summary>Leitet einen kryptografischen Schlüssel vom <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Objekt ab.</summary>
        <returns>Der abgeleitete Schlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion ist ein Wrapper für die Kryptografie-API-Funktion CryptDeriveKey() und Interoperabilität mit Anwendungen, die mithilfe der Kryptografie-API bieten soll.  
  
 Wenn die `keySize` Parameter auf 0 Bit festgelegt ist, wird die Standard-Schlüsselgröße für den angegebenen Algorithmus verwendet.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Cryptography.PasswordDeriveBytes> Klasse.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#2](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#2)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#2](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#2)]
 [!code-vb[Cryptography.PasswordDerivedbytes#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der <paramref name="keySize" />-Parameter ist ungültig.  
  
- oder -  
Der Kryptografiedienstanbieter (Cryptographic Service Provider, CSP) kann nicht abgerufen werden.  
  
- oder -  
Der <paramref name="algname" />-Parameter ist kein gültiger Algorithmusname.  
  
- oder -  
Der <paramref name="alghashname" />-Parameter ist kein gültiger Name eines Hashalgorithmus.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="passwordDeriveBytes.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />-Klasse verwendeten nicht verwalteten Ressourcen frei und gibt (optional) auch die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen `Dispose()` Methode und die `Finalize` Methode. `Dispose()` Ruft die geschützte `Dispose(Boolean)` -Methode mit dem `disposing` Parametersatz zu `true`. `Finalize` Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Security.Cryptography.PasswordDeriveBytes> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" />, werden Sie darauf achten, nicht auf Objekte verweisen, die zuvor in einen früheren Aufruf von freigegeben wurden <see langword="Dispose" />. Weitere Informationen zur Implementierung <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  Weitere Informationen zu <see langword="Dispose" /> und <see langword="Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~PasswordDeriveBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!PasswordDeriveBytes ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="passwordDeriveBytes.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.GetBytes(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (cb As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(int cb);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int -&gt; byte[]" Usage="passwordDeriveBytes.GetBytes cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Rfc2898DeriveBytes replaces PasswordDeriveBytes for deriving key material from a password and is preferred in new applications.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">Die Anzahl der zu generierenden pseudozufälligen Schlüsselbytes.</param>
        <summary>Gibt pseudozufällige Schlüsselbytes zurück.</summary>
        <returns>Ein mit pseudozufälligen Schlüsselbytes gefülltes Bytearray.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann eine beliebige Anzahl von pseudo-zufälligen Bytes zu erstellen. Allerdings wird die Stärke des Byte-Sequenz durch die Anzahl der Bytes in der Hashausgabe beschränkt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashName">
      <MemberSignature Language="C#" Value="public string HashName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HashName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.PasswordDeriveBytes.HashName" />
      <MemberSignature Language="VB.NET" Value="Public Property HashName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HashName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HashName : string with get, set" Usage="System.Security.Cryptography.PasswordDeriveBytes.HashName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Hashalgorithmus für die Operation ab oder legt diesen fest.</summary>
        <value>Der Name des Hashalgorithmus für die Operation.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Name des Hashwerts ist unveränderlich. Es wurde versucht, diesen Wert zu ändern.</exception>
      </Docs>
    </Member>
    <Member MemberName="IterationCount">
      <MemberSignature Language="C#" Value="public int IterationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IterationCount" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.PasswordDeriveBytes.IterationCount" />
      <MemberSignature Language="VB.NET" Value="Public Property IterationCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IterationCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IterationCount : int with get, set" Usage="System.Security.Cryptography.PasswordDeriveBytes.IterationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Iterationen für die Operation ab oder legt diese fest.</summary>
        <value>Die Anzahl der Iterationen für die Operation.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Die Anzahl der Iterationen ist unveränderlich. Es wurde versucht, diesen Wert zu ändern.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Eigenschaft kann nicht festgelegt werden, da ihr Wert außerhalb des gültigen Bereichs liegt. Für diese Eigenschaft ist eine nicht negative Zahl erforderlich.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Reset();" />
      <MemberSignature Language="F#" Value="override this.Reset : unit -&gt; unit" Usage="passwordDeriveBytes.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Zustand der Operation zurück.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Salt">
      <MemberSignature Language="C#" Value="public byte[] Salt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Salt" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.PasswordDeriveBytes.Salt" />
      <MemberSignature Language="VB.NET" Value="Public Property Salt As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Salt { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Salt : byte[] with get, set" Usage="System.Security.Cryptography.PasswordDeriveBytes.Salt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Salt-Wert des Schlüssels für die Operation ab oder legt diesen fest.</summary>
        <value>Der Wert der Schlüsselsalt für die Operation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Wörterbuchangriff handelt es sich um einen Angriff, in dem der Angreifer versucht, eine verschlüsselte Nachricht durch einen Vergleich des verschlüsselten Werts mit zuvor berechneten verschlüsselten Werten für die am wahrscheinlichsten Schlüssel entschlüsselt. Dieser Angriff erfolgt durch die Einführung von zufälligen Bytes am Ende des Kennworts vor dem schlüsselableitung sehr viel schwieriger. Diese zufälligen Bytes werden als Salt-Wert bezeichnet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Salt-Wert des Schlüssels ist unveränderlich. Es wurde versucht, diesen Wert zu ändern.</exception>
      </Docs>
    </Member>
  </Members>
</Type>