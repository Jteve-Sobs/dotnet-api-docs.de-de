<Type Name="Rfc2898DeriveBytes" FullName="System.Security.Cryptography.Rfc2898DeriveBytes">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="597390917b804edf9f923f9907a94156a1a347fd" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37630583" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Rfc2898DeriveBytes : System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Rfc2898DeriveBytes extends System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Rfc2898DeriveBytes" />
  <TypeSignature Language="VB.NET" Value="Public Class Rfc2898DeriveBytes&#xA;Inherits DeriveBytes" />
  <TypeSignature Language="C++ CLI" Value="public ref class Rfc2898DeriveBytes : System::Security::Cryptography::DeriveBytes" />
  <TypeSignature Language="F#" Value="type Rfc2898DeriveBytes = class&#xA;    inherit DeriveBytes" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.DeriveBytes</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implements password-based key derivation functionality, PBKDF2, by using a pseudo-random number generator based on <see cref="T:System.Security.Cryptography.HMACSHA1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> nimmt ein Kennwort, einen Salt-Wert und eine Iterationsanzahl und generiert anschließend durch Aufrufen von Schlüssel die <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> Methode.  
  
 RFC 2898 enthält Methoden zum Erstellen von einem Schlüssel und Initialisierungsvektor (IV) aus einem Kennwort und den Salt-Wert. Sie können eine kennwortbasierte Schlüsselableitungsfunktion PBKDF2 zum Ableiten von Schlüsseln, die mit einer Pseudo-random-Funktion, mit dem Schlüssel mit nahezu unbegrenzter Länge generiert werden kann. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basisschlüssel und andere Parameter zu erstellen. Klicken Sie in eine kennwortbasierte Schlüsselableitungsfunktion der Basisschlüssel ist ein Kennwort, und die anderen Parameter sind ein salt-Wert und eine Iterationsanzahl.  
  
 Weitere Informationen zu PBKDF2, finden Sie unter RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," auf die [Request for Comments-Website](http://go.microsoft.com/fwlink/?LinkID=37119). Vollständige Informationen finden Sie in Abschnitt 5.2, "PBKDF2".  
  
> [!IMPORTANT]
>  Niemals hartcodierte ein Kennwort ein, in Ihrem Quellcode.  Fest programmierte Kennwörter können aus einer Assembly abgerufen werden, mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen-Editors oder durch das Öffnen der Assembly in einem Text-Editor, z. B. Notepad.exe.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse zum Erstellen zweier identischer Schlüssel für die <xref:System.Security.Cryptography.TripleDES> Klasse.  Klicken Sie dann verschlüsselt und entschlüsselt Daten, die mit den Schlüsseln.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="password">The password used to derive the key.</param>
        <param name="salt">The key salt used to derive the key.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using a password and salt to derive the key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Saltgröße muss 8 Bytes oder größer.  
  
 RFC 2898 enthält Methoden zum Erstellen von einem Schlüssel und Initialisierungsvektor (IV) aus einem Kennwort und den Salt-Wert. Sie können eine kennwortbasierte Schlüsselableitungsfunktion PBKDF2 zum Ableiten von Schlüsseln, die mit einer Pseudo-random-Funktion, mit dem Schlüssel mit nahezu unbegrenzter Länge generiert werden kann. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basisschlüssel und andere Parameter zu erstellen. Klicken Sie in eine kennwortbasierte Schlüsselableitungsfunktion der Basisschlüssel ist ein Kennwort, und die anderen Parameter sind ein salt-Wert und eine Iterationsanzahl.  
  
 Weitere Informationen zu PBKDF2, finden Sie unter RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," auf die [Request for Comments-Website](http://go.microsoft.com/fwlink/?LinkID=37119). Vollständige Informationen finden Sie in Abschnitt 5.2, "PBKDF2".  
  
> [!IMPORTANT]
>  Niemals hartcodierte ein Kennwort ein, in Ihrem Quellcode.  Fest programmierte Kennwörter können aus einer Assembly abgerufen werden, mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen-Editors oder durch das Öffnen der Assembly in einem Text-Editor, z. B. Notepad.exe.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse zum Erstellen zweier identischer Schlüssel für die <xref:System.Security.Cryptography.TripleDES> Klasse.  Klicken Sie dann verschlüsselt und entschlüsselt Daten, die mit den Schlüsseln.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</exception>
        <exception cref="T:System.ArgumentNullException">The password or salt is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">The password used to derive the key.</param>
        <param name="saltSize">The size of the random salt that you want the class to generate.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using the password and salt size to derive the key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Saltgröße muss 8 Bytes oder größer.  
  
 RFC 2898 enthält Methoden zum Erstellen von einem Schlüssel und Initialisierungsvektor (IV) aus einem Kennwort und den Salt-Wert. Sie können eine kennwortbasierte Schlüsselableitungsfunktion PBKDF2 zum Ableiten von Schlüsseln, die mit einer Pseudo-random-Funktion, mit dem Schlüssel mit nahezu unbegrenzter Länge generiert werden kann. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basisschlüssel und andere Parameter zu erstellen. Klicken Sie in eine kennwortbasierte Schlüsselableitungsfunktion der Basisschlüssel ist ein Kennwort, und die anderen Parameter sind ein salt-Wert und eine Iterationsanzahl.  
  
 Weitere Informationen zu PBKDF2, finden Sie unter RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," auf die [Request for Comments-Website](http://go.microsoft.com/fwlink/?LinkID=37119). Vollständige Informationen finden Sie in Abschnitt 5.2, "PBKDF2".  
  
> [!IMPORTANT]
>  Niemals hartcodierte ein Kennwort ein, in Ihrem Quellcode.  Fest programmierte Kennwörter können aus einer Assembly abgerufen werden, mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen-Editors oder durch das Öffnen der Assembly in einem Text-Editor, z. B. Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The specified salt size is smaller than 8 bytes.</exception>
        <exception cref="T:System.ArgumentNullException">The password or salt is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">The password used to derive the key.</param>
        <param name="salt">The key salt used to derive the key.</param>
        <param name="iterations">The number of iterations for the operation.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using a password, a salt, and number of iterations to derive the key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Saltgröße muss 8 Bytes oder größer und die Anzahl der Iterationen muss größer als 0 (null) sein. Die empfohlene Mindestanzahl von Iterationen ist 1000.  
  
 RFC 2898 enthält Methoden zum Erstellen von einem Schlüssel und Initialisierungsvektor (IV) aus einem Kennwort und den Salt-Wert. Sie können eine kennwortbasierte Schlüsselableitungsfunktion PBKDF2 zum Ableiten von Schlüsseln, die mit einer Pseudo-random-Funktion, mit dem Schlüssel mit nahezu unbegrenzter Länge generiert werden kann. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basisschlüssel und andere Parameter zu erstellen. Klicken Sie in eine kennwortbasierte Schlüsselableitungsfunktion der Basisschlüssel ist ein Kennwort, und die anderen Parameter sind ein salt-Wert und eine Iterationsanzahl.  
  
 Weitere Informationen zu PBKDF2, finden Sie unter RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," auf die [Request for Comments-Website](http://go.microsoft.com/fwlink/?LinkID=37119). Vollständige Informationen finden Sie in Abschnitt 5.2, "PBKDF2".  
  
> [!IMPORTANT]
>  Niemals hartcodierte ein Kennwort ein, in Ihrem Quellcode.  Fest programmierte Kennwörter können aus einer Assembly abgerufen werden, mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen-Editors oder durch das Öffnen der Assembly in einem Text-Editor, z. B. Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</exception>
        <exception cref="T:System.ArgumentNullException">The password or salt is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">The password used to derive the key.</param>
        <param name="salt">The key salt used to derive the key.</param>
        <param name="iterations">The number of iterations for the operation.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using a password, a salt, and number of iterations to derive the key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Saltgröße muss 8 Bytes oder größer und die Anzahl der Iterationen muss größer als 0 (null) sein. Die empfohlene Mindestanzahl von Iterationen ist 1000.  
  
 RFC 2898 enthält Methoden zum Erstellen von einem Schlüssel und Initialisierungsvektor (IV) aus einem Kennwort und den Salt-Wert. Sie können eine kennwortbasierte Schlüsselableitungsfunktion PBKDF2 zum Ableiten von Schlüsseln, die mit einer Pseudo-random-Funktion, mit dem Schlüssel mit nahezu unbegrenzter Länge generiert werden kann. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basisschlüssel und andere Parameter zu erstellen. Klicken Sie in eine kennwortbasierte Schlüsselableitungsfunktion der Basisschlüssel ist ein Kennwort, und die anderen Parameter sind ein salt-Wert und eine Iterationsanzahl.  
  
 Weitere Informationen zu PBKDF2, finden Sie unter RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," auf die [Request for Comments-Website](http://go.microsoft.com/fwlink/?LinkID=37119). Vollständige Informationen finden Sie in Abschnitt 5.2, "PBKDF2".  
  
> [!IMPORTANT]
>  Niemals hartcodierte ein Kennwort ein, in Ihrem Quellcode.  Fest programmierte Kennwörter können aus einer Assembly abgerufen werden, mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen-Editors oder durch das Öffnen der Assembly in einem Text-Editor, z. B. Notepad.exe.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse zum Erstellen zweier identischer Schlüssel für die <xref:System.Security.Cryptography.TripleDES> Klasse.  Klicken Sie dann verschlüsselt und entschlüsselt Daten, die mit den Schlüsseln.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</exception>
        <exception cref="T:System.ArgumentNullException">The password or salt is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">The password used to derive the key.</param>
        <param name="saltSize">The size of the random salt that you want the class to generate.</param>
        <param name="iterations">The number of iterations for the operation.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using a password, a salt size, and number of iterations to derive the key.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Saltgröße muss 8 Bytes oder größer und die Anzahl der Iterationen muss größer als 0 (null) sein. Die empfohlene Mindestanzahl von Iterationen ist 1000.  
  
 RFC 2898 enthält Methoden zum Erstellen von einem Schlüssel und Initialisierungsvektor (IV) aus einem Kennwort und den Salt-Wert. Sie können eine kennwortbasierte Schlüsselableitungsfunktion PBKDF2 zum Ableiten von Schlüsseln, die mit einer Pseudo-random-Funktion, mit dem Schlüssel mit nahezu unbegrenzter Länge generiert werden kann. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basisschlüssel und andere Parameter zu erstellen. Klicken Sie in eine kennwortbasierte Schlüsselableitungsfunktion der Basisschlüssel ist ein Kennwort, und die anderen Parameter sind ein salt-Wert und eine Iterationsanzahl.  
  
 Weitere Informationen zu PBKDF2, finden Sie unter RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," auf die [Request for Comments-Website](http://go.microsoft.com/fwlink/?LinkID=37119). Vollständige Informationen finden Sie in Abschnitt 5.2, "PBKDF2".  
  
> [!IMPORTANT]
>  Niemals hartcodierte ein Kennwort ein, in Ihrem Quellcode.  Fest programmierte Kennwörter können aus einer Assembly abgerufen werden, mithilfe der [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen-Editors oder durch das Öffnen der Assembly in einem Text-Editor, z. B. Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</exception>
        <exception cref="T:System.ArgumentNullException">The password or salt is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="iterations" /> is out of range. This parameter requires a non-negative number.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">The password to use to derive the key.</param>
        <param name="salt">The key salt to use to derive the key.</param>
        <param name="iterations">The number of iterations for the operation.</param>
        <param name="hashAlgorithm">The hash algorithm to use to derive the key.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using the specified password, salt, number of iterations and the hash algorithm name to derive the key.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="saltSize" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> property of <paramref name="hashAlgorithm" /> is either <see langword="null" /> or <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Hash algorithm name is invalid.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">The password to use to derive the key.</param>
        <param name="salt">The key salt to use to derive the key.</param>
        <param name="iterations">The number of iterations for the operation.</param>
        <param name="hashAlgorithm">The hash algorithm to use to derive the key.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using the specified password, salt, number of iterations and the hash algorithm name to derive the key.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> property of <paramref name="hashAlgorithm" /> is either <see langword="null" /> or <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Hash algorithm name is invalid.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">The password to use to derive the key.</param>
        <param name="saltSize">The size of the random salt that you want the class to generate.</param>
        <param name="iterations">The number of iterations for the operation.</param>
        <param name="hashAlgorithm">The hash algorithm to use to derive the key.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using the specified password, salt size, number of iterations and the hash algorithm name to derive the key.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="saltSize" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">The <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> property of <paramref name="hashAlgorithm" /> is either <see langword="null" /> or <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Hash algorithm name is invalid.</exception>
      </Docs>
    </Member>
    <Member MemberName="CryptDeriveKey">
      <MemberSignature Language="C#" Value="public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] CryptDeriveKey(string algname, string alghashname, int32 keySize, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CryptDeriveKey (algname As String, alghashname As String, keySize As Integer, rgbIV As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ CryptDeriveKey(System::String ^ algname, System::String ^ alghashname, int keySize, cli::array &lt;System::Byte&gt; ^ rgbIV);" />
      <MemberSignature Language="F#" Value="member this.CryptDeriveKey : string * string * int * byte[] -&gt; byte[]" Usage="rfc2898DeriveBytes.CryptDeriveKey (algname, alghashname, keySize, rgbIV)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algname" Type="System.String" />
        <Parameter Name="alghashname" Type="System.String" />
        <Parameter Name="keySize" Type="System.Int32" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="algname">The algorithm name for which to derive the key.</param>
        <param name="alghashname">The hash algorithm name to use to derive the key.</param>
        <param name="keySize">The size of the key, in bits, to derive.</param>
        <param name="rgbIV">The initialization vector (IV) to use to derive the key.</param>
        <summary>Derives a cryptographic key from the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> object.</summary>
        <returns>The derived key.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion ist ein Wrapper für die Kryptografie-API-Funktion CryptDeriveKey() und Interoperabilität mit Anwendungen, die mithilfe der Kryptografie-API bieten soll.  
  
 Wenn die `keySize` Parameter auf 0 Bit festgelegt ist, wird die Standard-Schlüsselgröße für den angegebenen Algorithmus verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">The <paramref name="keySize" /> parameter is incorrect.  -or-  The cryptographic service provider (CSP) cannot be acquired.  -or-  The <paramref name="algname" /> parameter is not a valid algorithm name.  -or-  The <paramref name="alghashname" /> parameter is not a valid hash algorithm name.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="rfc2898DeriveBytes.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class and optionally releases the managed resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen `Dispose()` Methode und die `Finalize` Methode. `Dispose()` Ruft die geschützte `Dispose(Boolean)` -Methode mit dem `disposing` Parametersatz zu `true`. `Finalize` Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Security.Cryptography.Rfc2898DeriveBytes> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see langword="Dispose(Boolean)" />, werden Sie darauf achten, nicht auf Objekte verweisen, die zuvor in einen früheren Aufruf von freigegeben wurden <see langword="Dispose" />. Weitere Informationen zur Implementierung <see langword="Dispose(Boolean)" />, finden Sie unter [Implementieren einer Dispose-Method](~/docs/standard/garbage-collection/implementing-dispose.md).  Weitere Informationen zu <see langword="Dispose" /> und <see langword="Finalize" />, finden Sie unter [einrichten nicht verwalteten Resources](~/docs/standard/garbage-collection/unmanaged.md) bereinigen.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (cb As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(int cb);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int -&gt; byte[]" Usage="rfc2898DeriveBytes.GetBytes cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">The number of pseudo-random key bytes to generate.</param>
        <summary>Returns the pseudo-random key for this object.</summary>
        <returns>A byte array filled with pseudo-random key bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse implementiert PBKDF2-Funktion mit einem basierenden Generators für Pseudozufallszahlen auf <xref:System.Security.Cryptography.HMACSHA1>. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse nimmt ein Kennwort, einen Salt-Wert und eine Iterationsanzahl und generiert anschließend durch Aufrufen von Schlüssel die <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> Methode. Wiederholte Aufrufe dieser Methode werden nicht den gleichen Schlüssel generiert. Stattdessen anfügen zwei Aufrufe der der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> -Methode mit einer `cb` Parameterwert `20` ist das Äquivalent eines Aufrufs der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> Methode einmal mit einer `cb` Parameterwert `40`.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> -Methode zum Abrufen des Schlüssels für eine Instanz von <xref:System.Security.Cryptography.Rfc2898DeriveBytes>. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse.  
  
 [!code-cpp[rfc28981#2](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#2)]
 [!code-csharp[rfc28981#2](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#2)]
 [!code-vb[rfc28981#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="cb" /> is out of range. This parameter requires a non-negative number.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.HashAlgorithmName HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.HashAlgorithmName HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HashAlgorithm As HashAlgorithmName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::HashAlgorithmName HashAlgorithm { System::Security::Cryptography::HashAlgorithmName get(); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Security.Cryptography.HashAlgorithmName" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.HashAlgorithmName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IterationCount">
      <MemberSignature Language="C#" Value="public int IterationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IterationCount" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberSignature Language="VB.NET" Value="Public Property IterationCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IterationCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IterationCount : int with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the number of iterations for the operation.</summary>
        <value>Die Anzahl der Iterationen für die Operation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iterationsanzahl ist die Anzahl der Häufigkeit, mit die ein Vorgang ausgeführt wird. Für diese Methode sollte die Anzahl größer als 0 (null) sein. Die empfohlene Mindestanzahl von Iterationen ist 1000.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A> Eigenschaft, um die Anzahl der Iterationen, die in die Generierung des Schlüssels verwendete anzuzeigen. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse.  
  
 [!code-cpp[rfc28981#3](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#3)]
 [!code-csharp[rfc28981#3](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#3)]
 [!code-vb[rfc28981#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The number of iterations is less than 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Reset();" />
      <MemberSignature Language="F#" Value="override this.Reset : unit -&gt; unit" Usage="rfc2898DeriveBytes.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the state of the operation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird automatisch aufgerufen, wenn die Anzahl der Salt-Wert oder der Iteration geändert wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A>-Methode gezeigt. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Security.Cryptography.Rfc2898DeriveBytes> Klasse.  
  
 [!code-cpp[rfc28981#5](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#5)]
 [!code-csharp[rfc28981#5](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#5)]
 [!code-vb[rfc28981#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Salt">
      <MemberSignature Language="C#" Value="public byte[] Salt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Salt" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberSignature Language="VB.NET" Value="Public Property Salt As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Salt { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Salt : byte[] with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the key salt value for the operation.</summary>
        <value>Der Wert der Schlüsselsalt für die Operation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Salt-Wert, eine zufällige Folge von Bytes wird verwendet, um nicht autorisierte Entschlüsseln einer Nachricht, die schwieriger zu machen. Ein Wörterbuchangriff handelt es sich um einen Angriff, in dem der Angreifer versucht, eine verschlüsselte Nachricht durch einen Vergleich des verschlüsselten Werts mit zuvor berechneten verschlüsselten Werten für die am wahrscheinlichsten Schlüssel entschlüsselt. Dieser Angriff erfolgt durch die Einführung der salt und zufälligen Bytes am Ende des Kennworts vor dem schlüsselableitung sehr viel schwieriger.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The specified salt size is smaller than 8 bytes.</exception>
        <exception cref="T:System.ArgumentNullException">The salt is <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>