<Type Name="Rfc2898DeriveBytes" FullName="System.Security.Cryptography.Rfc2898DeriveBytes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e6d778e763c61fb41ed7fd04f388f2b87d25bab1" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75162455" /></Metadata><TypeSignature Language="C#" Value="public class Rfc2898DeriveBytes : System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Rfc2898DeriveBytes extends System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Rfc2898DeriveBytes" />
  <TypeSignature Language="VB.NET" Value="Public Class Rfc2898DeriveBytes&#xA;Inherits DeriveBytes" />
  <TypeSignature Language="C++ CLI" Value="public ref class Rfc2898DeriveBytes : System::Security::Cryptography::DeriveBytes" />
  <TypeSignature Language="F#" Value="type Rfc2898DeriveBytes = class&#xA;    inherit DeriveBytes" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
    <AssemblyVersion>4.3.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.DeriveBytes</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="6cd58-101">Implementiert mithilfe eines auf <see cref="T:System.Security.Cryptography.HMACSHA1" /> basierenden Generators für Pseudozufallszahlen die kennwortbasierte Schlüsselableitungsfunktion PBKDF2.</span><span class="sxs-lookup"><span data-stu-id="6cd58-101">Implements password-based key derivation functionality, PBKDF2, by using a pseudo-random number generator based on <see cref="T:System.Security.Cryptography.HMACSHA1" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-102"><xref:System.Security.Cryptography.Rfc2898DeriveBytes> nimmt ein Kennwort, ein Salt und eine Iterations Anzahl an und generiert dann Schlüssel durch Aufrufe der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>-Methode.</span><span class="sxs-lookup"><span data-stu-id="6cd58-102"><xref:System.Security.Cryptography.Rfc2898DeriveBytes> takes a password, a salt, and an iteration count, and then generates keys through calls to the <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> method.</span></span>  
  
 <span data-ttu-id="6cd58-103">RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-103">RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</span></span> <span data-ttu-id="6cd58-104">Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-104">You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</span></span> <span data-ttu-id="6cd58-105">Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln.</span><span class="sxs-lookup"><span data-stu-id="6cd58-105">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters.</span></span> <span data-ttu-id="6cd58-106">In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.</span><span class="sxs-lookup"><span data-stu-id="6cd58-106">In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</span></span>  
  
 <span data-ttu-id="6cd58-107">Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)".</span><span class="sxs-lookup"><span data-stu-id="6cd58-107">For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the [Request for Comments Web site](https://go.microsoft.com/fwlink/?LinkID=37119).</span></span> <span data-ttu-id="6cd58-108">Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".</span><span class="sxs-lookup"><span data-stu-id="6cd58-108">See section 5.2, "PBKDF2," for complete details.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6cd58-109">Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.</span><span class="sxs-lookup"><span data-stu-id="6cd58-109">Never hard-code a password within your source code.</span></span>  <span data-ttu-id="6cd58-110">Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="6cd58-110">Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6cd58-111">Im folgenden Codebeispiel wird die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse verwendet, um zwei identische Schlüssel für die <xref:System.Security.Cryptography.TripleDES>-Klasse zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="6cd58-111">The following code example uses the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.</span></span>  <span data-ttu-id="6cd58-112">Anschließend werden einige Daten mithilfe der Schlüssel verschlüsselt und entschlüsselt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-112">It then encrypts and decrypts some data using the keys.</span></span>  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="6cd58-113">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="6cd58-113">Cryptographic Services</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6cd58-114">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="6cd58-114">Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="6cd58-115">Das zum Ableiten des Schlüssels verwendete Kennwort.</span><span class="sxs-lookup"><span data-stu-id="6cd58-115">The password used to derive the key.</span></span></param>
        <param name="salt"><span data-ttu-id="6cd58-116">Die zum Ableiten des Schlüssels verwendete Schlüsselsalt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-116">The key salt used to derive the key.</span></span></param>
        <summary><span data-ttu-id="6cd58-117">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts und des Salts zum Ableiten des Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="6cd58-117">Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using a password and salt to derive the key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-118">Die Saltgröße muss 8 Bytes oder größer sein.</span><span class="sxs-lookup"><span data-stu-id="6cd58-118">The salt size must be 8 bytes or larger.</span></span>  
  
 <span data-ttu-id="6cd58-119">RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-119">RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</span></span> <span data-ttu-id="6cd58-120">Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-120">You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</span></span> <span data-ttu-id="6cd58-121">Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln.</span><span class="sxs-lookup"><span data-stu-id="6cd58-121">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters.</span></span> <span data-ttu-id="6cd58-122">In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.</span><span class="sxs-lookup"><span data-stu-id="6cd58-122">In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</span></span>  
  
 <span data-ttu-id="6cd58-123">Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)".</span><span class="sxs-lookup"><span data-stu-id="6cd58-123">For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the [Request for Comments Web site](https://go.microsoft.com/fwlink/?LinkID=37119).</span></span> <span data-ttu-id="6cd58-124">Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".</span><span class="sxs-lookup"><span data-stu-id="6cd58-124">See section 5.2, "PBKDF2," for complete details.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6cd58-125">Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.</span><span class="sxs-lookup"><span data-stu-id="6cd58-125">Never hard-code a password within your source code.</span></span>  <span data-ttu-id="6cd58-126">Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="6cd58-126">Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6cd58-127">Im folgenden Codebeispiel wird die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse verwendet, um zwei identische Schlüssel für die <xref:System.Security.Cryptography.TripleDES>-Klasse zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="6cd58-127">The following code example uses the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.</span></span>  <span data-ttu-id="6cd58-128">Anschließend werden einige Daten mithilfe der Schlüssel verschlüsselt und entschlüsselt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-128">It then encrypts and decrypts some data using the keys.</span></span>  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6cd58-129">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</span><span class="sxs-lookup"><span data-stu-id="6cd58-129">The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6cd58-130">Das Kennwort oder die Salt ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6cd58-130">The password or salt is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="6cd58-131">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="6cd58-131">Cryptographic Services</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="6cd58-132">Das zum Ableiten des Schlüssels verwendete Kennwort.</span><span class="sxs-lookup"><span data-stu-id="6cd58-132">The password used to derive the key.</span></span></param>
        <param name="saltSize"><span data-ttu-id="6cd58-133">Die Größe der Zufallssalt, die von der Klasse generiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cd58-133">The size of the random salt that you want the class to generate.</span></span></param>
        <summary><span data-ttu-id="6cd58-134">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts und der Saltgröße zum Ableiten des Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="6cd58-134">Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using the password and salt size to derive the key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-135">Die Saltgröße muss 8 Bytes oder größer sein.</span><span class="sxs-lookup"><span data-stu-id="6cd58-135">The salt size must be 8 bytes or larger.</span></span>  
  
 <span data-ttu-id="6cd58-136">RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-136">RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</span></span> <span data-ttu-id="6cd58-137">Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-137">You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</span></span> <span data-ttu-id="6cd58-138">Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln.</span><span class="sxs-lookup"><span data-stu-id="6cd58-138">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters.</span></span> <span data-ttu-id="6cd58-139">In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.</span><span class="sxs-lookup"><span data-stu-id="6cd58-139">In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</span></span>  
  
 <span data-ttu-id="6cd58-140">Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)".</span><span class="sxs-lookup"><span data-stu-id="6cd58-140">For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the [Request for Comments Web site](https://go.microsoft.com/fwlink/?LinkID=37119).</span></span> <span data-ttu-id="6cd58-141">Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".</span><span class="sxs-lookup"><span data-stu-id="6cd58-141">See section 5.2, "PBKDF2," for complete details.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6cd58-142">Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.</span><span class="sxs-lookup"><span data-stu-id="6cd58-142">Never hard-code a password within your source code.</span></span>  <span data-ttu-id="6cd58-143">Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="6cd58-143">Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6cd58-144">Die angegebene Saltgröße ist kleiner als 8 Bytes.</span><span class="sxs-lookup"><span data-stu-id="6cd58-144">The specified salt size is smaller than 8 bytes.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6cd58-145">Das Kennwort oder die Salt ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6cd58-145">The password or salt is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="6cd58-146">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="6cd58-146">Cryptographic Services</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="6cd58-147">Das zum Ableiten des Schlüssels verwendete Kennwort.</span><span class="sxs-lookup"><span data-stu-id="6cd58-147">The password used to derive the key.</span></span></param>
        <param name="salt"><span data-ttu-id="6cd58-148">Die zum Ableiten des Schlüssels verwendete Schlüsselsalt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-148">The key salt used to derive the key.</span></span></param>
        <param name="iterations"><span data-ttu-id="6cd58-149">Die Anzahl der Iterationen für die Operation.</span><span class="sxs-lookup"><span data-stu-id="6cd58-149">The number of iterations for the operation.</span></span></param>
        <summary><span data-ttu-id="6cd58-150">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts, der Salt und der Anzahl an Iterationen zum Ableiten des Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="6cd58-150">Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using a password, a salt, and number of iterations to derive the key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-151">Der Salt-Wert muss 8 Bytes oder größer sein, und die Iterations Anzahl muss größer als 0 (null) sein.</span><span class="sxs-lookup"><span data-stu-id="6cd58-151">The salt size must be 8 bytes or larger and the iteration count must be greater than zero.</span></span> <span data-ttu-id="6cd58-152">Die empfohlene Mindestanzahl von Iterationen ist 1000.</span><span class="sxs-lookup"><span data-stu-id="6cd58-152">The minimum recommended number of iterations is 1000.</span></span>  
  
 <span data-ttu-id="6cd58-153">RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-153">RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</span></span> <span data-ttu-id="6cd58-154">Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-154">You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</span></span> <span data-ttu-id="6cd58-155">Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln.</span><span class="sxs-lookup"><span data-stu-id="6cd58-155">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters.</span></span> <span data-ttu-id="6cd58-156">In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.</span><span class="sxs-lookup"><span data-stu-id="6cd58-156">In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</span></span>  
  
 <span data-ttu-id="6cd58-157">Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)".</span><span class="sxs-lookup"><span data-stu-id="6cd58-157">For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the [Request for Comments Web site](https://go.microsoft.com/fwlink/?LinkID=37119).</span></span> <span data-ttu-id="6cd58-158">Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".</span><span class="sxs-lookup"><span data-stu-id="6cd58-158">See section 5.2, "PBKDF2," for complete details.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6cd58-159">Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.</span><span class="sxs-lookup"><span data-stu-id="6cd58-159">Never hard-code a password within your source code.</span></span>  <span data-ttu-id="6cd58-160">Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="6cd58-160">Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6cd58-161">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</span><span class="sxs-lookup"><span data-stu-id="6cd58-161">The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6cd58-162">Das Kennwort oder die Salt ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6cd58-162">The password or salt is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="6cd58-163">Das zum Ableiten des Schlüssels verwendete Kennwort.</span><span class="sxs-lookup"><span data-stu-id="6cd58-163">The password used to derive the key.</span></span></param>
        <param name="salt"><span data-ttu-id="6cd58-164">Die zum Ableiten des Schlüssels verwendete Schlüsselsalt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-164">The key salt used to derive the key.</span></span></param>
        <param name="iterations"><span data-ttu-id="6cd58-165">Die Anzahl der Iterationen für die Operation.</span><span class="sxs-lookup"><span data-stu-id="6cd58-165">The number of iterations for the operation.</span></span></param>
        <summary><span data-ttu-id="6cd58-166">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts, der Salt und der Anzahl an Iterationen zum Ableiten des Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="6cd58-166">Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using a password, a salt, and number of iterations to derive the key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-167">Der Salt-Wert muss 8 Bytes oder größer sein, und die Iterations Anzahl muss größer als 0 (null) sein.</span><span class="sxs-lookup"><span data-stu-id="6cd58-167">The salt size must be 8 bytes or larger and the iteration count must be greater than zero.</span></span> <span data-ttu-id="6cd58-168">Die empfohlene Mindestanzahl von Iterationen ist 1000.</span><span class="sxs-lookup"><span data-stu-id="6cd58-168">The minimum recommended number of iterations is 1000.</span></span>  
  
 <span data-ttu-id="6cd58-169">RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-169">RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</span></span> <span data-ttu-id="6cd58-170">Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-170">You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</span></span> <span data-ttu-id="6cd58-171">Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln.</span><span class="sxs-lookup"><span data-stu-id="6cd58-171">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters.</span></span> <span data-ttu-id="6cd58-172">In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.</span><span class="sxs-lookup"><span data-stu-id="6cd58-172">In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</span></span>  
  
 <span data-ttu-id="6cd58-173">Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)".</span><span class="sxs-lookup"><span data-stu-id="6cd58-173">For more information about PBKDF2, see RFC 2898, "PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the [Request for Comments Web site](https://go.microsoft.com/fwlink/?LinkID=37119).</span></span> <span data-ttu-id="6cd58-174">Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".</span><span class="sxs-lookup"><span data-stu-id="6cd58-174">See section 5.2, "PBKDF2," for complete details.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6cd58-175">Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.</span><span class="sxs-lookup"><span data-stu-id="6cd58-175">Never hard-code a password within your source code.</span></span>  <span data-ttu-id="6cd58-176">Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="6cd58-176">Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6cd58-177">Im folgenden Codebeispiel wird die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse verwendet, um zwei identische Schlüssel für die <xref:System.Security.Cryptography.TripleDES>-Klasse zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="6cd58-177">The following code example uses the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class to create two identical keys for the <xref:System.Security.Cryptography.TripleDES> class.</span></span>  <span data-ttu-id="6cd58-178">Anschließend werden einige Daten mithilfe der Schlüssel verschlüsselt und entschlüsselt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-178">It then encrypts and decrypts some data using the keys.</span></span>  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6cd58-179">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</span><span class="sxs-lookup"><span data-stu-id="6cd58-179">The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6cd58-180">Das Kennwort oder die Salt ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6cd58-180">The password or salt is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="6cd58-181">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="6cd58-181">Cryptographic Services</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="6cd58-182">Das zum Ableiten des Schlüssels verwendete Kennwort.</span><span class="sxs-lookup"><span data-stu-id="6cd58-182">The password used to derive the key.</span></span></param>
        <param name="saltSize"><span data-ttu-id="6cd58-183">Die Größe der Zufallssalt, die von der Klasse generiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cd58-183">The size of the random salt that you want the class to generate.</span></span></param>
        <param name="iterations"><span data-ttu-id="6cd58-184">Die Anzahl der Iterationen für die Operation.</span><span class="sxs-lookup"><span data-stu-id="6cd58-184">The number of iterations for the operation.</span></span></param>
        <summary><span data-ttu-id="6cd58-185">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts, einer Saltgröße und der Anzahl an Iterationen zum Ableiten des Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="6cd58-185">Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using a password, a salt size, and number of iterations to derive the key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-186">Der Salt-Wert muss 8 Bytes oder größer sein, und die Iterations Anzahl muss größer als 0 (null) sein.</span><span class="sxs-lookup"><span data-stu-id="6cd58-186">The salt size must be 8 bytes or larger and the iteration count must be greater than zero.</span></span> <span data-ttu-id="6cd58-187">Die empfohlene Mindestanzahl von Iterationen ist 1000.</span><span class="sxs-lookup"><span data-stu-id="6cd58-187">The minimum recommended number of iterations is 1000.</span></span>  
  
 <span data-ttu-id="6cd58-188">RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-188">RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt.</span></span> <span data-ttu-id="6cd58-189">Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-189">You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated.</span></span> <span data-ttu-id="6cd58-190">Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln.</span><span class="sxs-lookup"><span data-stu-id="6cd58-190">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class can be used to produce a derived key from a base key and other parameters.</span></span> <span data-ttu-id="6cd58-191">In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.</span><span class="sxs-lookup"><span data-stu-id="6cd58-191">In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</span></span>  
  
 <span data-ttu-id="6cd58-192">Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)".</span><span class="sxs-lookup"><span data-stu-id="6cd58-192">For more information on PBKDF2, see RFC 2898,"PKCS #5: Password-Based Cryptography Specification Version 2.0," available on the [Request for Comments Web site](https://go.microsoft.com/fwlink/?LinkID=37119).</span></span> <span data-ttu-id="6cd58-193">Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".</span><span class="sxs-lookup"><span data-stu-id="6cd58-193">See section 5.2, "PBKDF2," for complete details.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6cd58-194">Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.</span><span class="sxs-lookup"><span data-stu-id="6cd58-194">Never hard-code a password within your source code.</span></span>  <span data-ttu-id="6cd58-195">Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="6cd58-195">Hard-coded passwords can be retrieved from an assembly by using the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6cd58-196">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</span><span class="sxs-lookup"><span data-stu-id="6cd58-196">The specified salt size is smaller than 8 bytes or the iteration count is less than 1.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6cd58-197">Das Kennwort oder die Salt ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6cd58-197">The password or salt is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6cd58-198"><paramref name="iterations" /> liegt außerhalb des Bereichs.</span><span class="sxs-lookup"><span data-stu-id="6cd58-198"><paramref name="iterations" /> is out of range.</span></span> <span data-ttu-id="6cd58-199">Für diesen Parameter ist eine nicht negative Zahl erforderlich.</span><span class="sxs-lookup"><span data-stu-id="6cd58-199">This parameter requires a non-negative number.</span></span></exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="6cd58-200">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="6cd58-200">Cryptographic Services</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="salt" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="iterations" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="6cd58-201">Das zum Ableiten des Schlüssels verwendete Kennwort.</span><span class="sxs-lookup"><span data-stu-id="6cd58-201">The password to use to derive the key.</span></span></param>
        <param name="salt"><span data-ttu-id="6cd58-202">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cd58-202">The key salt to use to derive the key.</span></span></param>
        <param name="iterations"><span data-ttu-id="6cd58-203">Die Anzahl der Iterationen für die Operation.</span><span class="sxs-lookup"><span data-stu-id="6cd58-203">The number of iterations for the operation.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="6cd58-204">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cd58-204">The hash algorithm to use to derive the key.</span></span></param>
        <summary><span data-ttu-id="6cd58-205">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse unter Verwendung von Kennwort, Salt, Anzahl der Iterationen und Name des Hashalgorithmus laut Angabe zum Ableiten des Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="6cd58-205">Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using the specified password, salt, number of iterations and the hash algorithm name to derive the key.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6cd58-206"><paramref name="saltSize" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="6cd58-206"><paramref name="saltSize" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6cd58-207">Die <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />-Eigenschaft von <paramref name="hashAlgorithm" /> ist entweder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="6cd58-207">The <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> property of <paramref name="hashAlgorithm" /> is either <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="6cd58-208">Der Hashalgorithmusname ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="6cd58-208">Hash algorithm name is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="salt" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="iterations" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="6cd58-209">Das zum Ableiten des Schlüssels verwendete Kennwort.</span><span class="sxs-lookup"><span data-stu-id="6cd58-209">The password to use to derive the key.</span></span></param>
        <param name="salt"><span data-ttu-id="6cd58-210">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cd58-210">The key salt to use to derive the key.</span></span></param>
        <param name="iterations"><span data-ttu-id="6cd58-211">Die Anzahl der Iterationen für die Operation.</span><span class="sxs-lookup"><span data-stu-id="6cd58-211">The number of iterations for the operation.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="6cd58-212">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cd58-212">The hash algorithm to use to derive the key.</span></span></param>
        <summary><span data-ttu-id="6cd58-213">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse unter Verwendung von Kennwort, Salt, Anzahl der Iterationen und Name des Hashalgorithmus laut Angabe zum Ableiten des Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="6cd58-213">Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using the specified password, salt, number of iterations and the hash algorithm name to derive the key.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6cd58-214">Die <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />-Eigenschaft von <paramref name="hashAlgorithm" /> ist entweder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="6cd58-214">The <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> property of <paramref name="hashAlgorithm" /> is either <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="6cd58-215">Der Hashalgorithmusname ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="6cd58-215">Hash algorithm name is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="saltSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="iterations" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="6cd58-216">Das zum Ableiten des Schlüssels verwendete Kennwort.</span><span class="sxs-lookup"><span data-stu-id="6cd58-216">The password to use to derive the key.</span></span></param>
        <param name="saltSize"><span data-ttu-id="6cd58-217">Die Größe der Zufallssalt, die von der Klasse generiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cd58-217">The size of the random salt that you want the class to generate.</span></span></param>
        <param name="iterations"><span data-ttu-id="6cd58-218">Die Anzahl der Iterationen für die Operation.</span><span class="sxs-lookup"><span data-stu-id="6cd58-218">The number of iterations for the operation.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="6cd58-219">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cd58-219">The hash algorithm to use to derive the key.</span></span></param>
        <summary><span data-ttu-id="6cd58-220">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse unter Verwendung von Kennwort, Saltgröße, Anzahl der Iterationen und Name des Hashalgorithmus laut Angabe zum Ableiten des Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="6cd58-220">Initializes a new instance of the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class using the specified password, salt size, number of iterations and the hash algorithm name to derive the key.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6cd58-221"><paramref name="saltSize" /> ist kleiner als Null.</span><span class="sxs-lookup"><span data-stu-id="6cd58-221"><paramref name="saltSize" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6cd58-222">Die <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />-Eigenschaft von <paramref name="hashAlgorithm" /> ist entweder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</span><span class="sxs-lookup"><span data-stu-id="6cd58-222">The <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> property of <paramref name="hashAlgorithm" /> is either <see langword="null" /> or <see cref="F:System.String.Empty" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="6cd58-223">Der Hashalgorithmusname ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="6cd58-223">Hash algorithm name is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CryptDeriveKey">
      <MemberSignature Language="C#" Value="public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] CryptDeriveKey(string algname, string alghashname, int32 keySize, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CryptDeriveKey (algname As String, alghashname As String, keySize As Integer, rgbIV As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ CryptDeriveKey(System::String ^ algname, System::String ^ alghashname, int keySize, cli::array &lt;System::Byte&gt; ^ rgbIV);" />
      <MemberSignature Language="F#" Value="member this.CryptDeriveKey : string * string * int * byte[] -&gt; byte[]" Usage="rfc2898DeriveBytes.CryptDeriveKey (algname, alghashname, keySize, rgbIV)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="alghashname" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="keySize" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="rgbIV" Type="System.Byte[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="algname"><span data-ttu-id="6cd58-224">Der Name des Algorithmus, für den der Schlüssel abgeleitet werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cd58-224">The algorithm name for which to derive the key.</span></span></param>
        <param name="alghashname"><span data-ttu-id="6cd58-225">Der Name des Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="6cd58-225">The hash algorithm name to use to derive the key.</span></span></param>
        <param name="keySize"><span data-ttu-id="6cd58-226">Die Größe des abzuleitenden Schlüssels in Bits.</span><span class="sxs-lookup"><span data-stu-id="6cd58-226">The size of the key, in bits, to derive.</span></span></param>
        <param name="rgbIV"><span data-ttu-id="6cd58-227">Der zum Ableiten des Schlüssels zu verwendende Initialisierungsvektor.</span><span class="sxs-lookup"><span data-stu-id="6cd58-227">The initialization vector (IV) to use to derive the key.</span></span></param>
        <summary><span data-ttu-id="6cd58-228">Leitet einen kryptografischen Schlüssel vom <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Objekt ab.</span><span class="sxs-lookup"><span data-stu-id="6cd58-228">Derives a cryptographic key from the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> object.</span></span></summary>
        <returns><span data-ttu-id="6cd58-229">Der abgeleitete Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="6cd58-229">The derived key.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-230">Diese Funktion ist ein Wrapper für die kryptografieapi-Funktion "CryptDeriveKey ()" und soll Interoperabilität mit Anwendungen unter Verwendung der kryptografieapi ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="6cd58-230">This function is a wrapper for the Crypto API function CryptDeriveKey(), and is intended to offer interoperability with applications using the Crypto API.</span></span>  
  
 <span data-ttu-id="6cd58-231">Wenn der `keySize`-Parameter auf 0 Bits festgelegt ist, wird die Standard Schlüsselgröße für den angegebenen Algorithmus verwendet.</span><span class="sxs-lookup"><span data-stu-id="6cd58-231">If the `keySize` parameter is set to 0 bits, the default key size for the specified algorithm is used.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="6cd58-232">Der <paramref name="keySize" />-Parameter ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="6cd58-232">The <paramref name="keySize" /> parameter is incorrect.</span></span>  
  
<span data-ttu-id="6cd58-233">- oder -</span><span class="sxs-lookup"><span data-stu-id="6cd58-233">-or-</span></span> 
<span data-ttu-id="6cd58-234">Der Kryptografiedienstanbieter (Cryptographic Service Provider, CSP) kann nicht abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="6cd58-234">The cryptographic service provider (CSP) cannot be acquired.</span></span>  
  
<span data-ttu-id="6cd58-235">- oder -</span><span class="sxs-lookup"><span data-stu-id="6cd58-235">-or-</span></span> 
<span data-ttu-id="6cd58-236">Der <paramref name="algname" />-Parameter ist kein gültiger Algorithmusname.</span><span class="sxs-lookup"><span data-stu-id="6cd58-236">The <paramref name="algname" /> parameter is not a valid algorithm name.</span></span>  
  
<span data-ttu-id="6cd58-237">- oder -</span><span class="sxs-lookup"><span data-stu-id="6cd58-237">-or-</span></span> 
<span data-ttu-id="6cd58-238">Der <paramref name="alghashname" />-Parameter ist kein gültiger Name eines Hashalgorithmus.</span><span class="sxs-lookup"><span data-stu-id="6cd58-238">The <paramref name="alghashname" /> parameter is not a valid hash algorithm name.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="rfc2898DeriveBytes.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="6cd58-239"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="6cd58-239"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="6cd58-240">Gibt die von der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse verwendeten nicht verwalteten Ressourcen frei und gibt (optional) auch die verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="6cd58-240">Releases the unmanaged resources used by the <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> class and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-241">Diese Methode wird von der öffentlichen `Dispose()`-Methode und der `Finalize`-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="6cd58-241">This method is called by the public `Dispose()` method and the `Finalize` method.</span></span> <span data-ttu-id="6cd58-242">`Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="6cd58-242">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="6cd58-243">`Finalize` ruft `Dispose` auf, bei dem `disposing` auf `false`festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="6cd58-243">`Finalize` invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="6cd58-244">Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Security.Cryptography.Rfc2898DeriveBytes> verweist.</span><span class="sxs-lookup"><span data-stu-id="6cd58-244">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Security.Cryptography.Rfc2898DeriveBytes> references.</span></span> <span data-ttu-id="6cd58-245">Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="6cd58-245">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="6cd58-246">
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="6cd58-246">
            <see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="6cd58-247">Wenn Sie <see langword="Dispose(Boolean)" />überschreiben, sollten Sie darauf achten, nicht auf Objekte zu verweisen, die zuvor in einem früheren <see langword="Dispose" />aufgerufen wurden.</span><span class="sxs-lookup"><span data-stu-id="6cd58-247">When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="6cd58-248">Weitere Informationen zum Implementieren von <see langword="Dispose(Boolean)" />finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="6cd58-248">For more information about how to implement <see langword="Dispose(Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="6cd58-249">Weitere Informationen zu <see langword="Dispose" /> und <see langword="Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="6cd58-249">For more information about <see langword="Dispose" /> and <see langword="Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (cb As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(int cb);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int -&gt; byte[]" Usage="rfc2898DeriveBytes.GetBytes cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb"><span data-ttu-id="6cd58-250">Die Anzahl der zu generierenden pseudozufälligen Schlüsselbytes.</span><span class="sxs-lookup"><span data-stu-id="6cd58-250">The number of pseudo-random key bytes to generate.</span></span></param>
        <summary><span data-ttu-id="6cd58-251">Gibt den pseudozufälligen Schlüssel für dieses Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="6cd58-251">Returns the pseudo-random key for this object.</span></span></summary>
        <returns><span data-ttu-id="6cd58-252">Ein mit pseudozufälligen Schlüsselbytes gefülltes Bytearray.</span><span class="sxs-lookup"><span data-stu-id="6cd58-252">A byte array filled with pseudo-random key bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-253">Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse implementiert die PBKDF2-Funktionalität mithilfe eines auf <xref:System.Security.Cryptography.HMACSHA1>basierenden Pseudo Zufalls-Zahlen Generators.</span><span class="sxs-lookup"><span data-stu-id="6cd58-253">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class implements PBKDF2 functionality by using a pseudorandom number generator based on <xref:System.Security.Cryptography.HMACSHA1>.</span></span> <span data-ttu-id="6cd58-254">Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse nimmt ein Kennwort, ein Salt und eine Iterations Anzahl an und generiert dann mithilfe von Aufrufen der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>-Methode Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="6cd58-254">The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class takes a password, a salt, and an iteration count, and then generates keys through calls to the <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> method.</span></span> <span data-ttu-id="6cd58-255">Bei wiederholten Aufrufen dieser Methode wird nicht derselbe Schlüssel generiert. Stattdessen ist das Anfügen von zwei Aufrufen der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>-Methode mit einem `cb` Parameterwert von `20` das Äquivalent zum Aufrufen der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>-Methode einmal mit dem `cb` Parameterwert `40`.</span><span class="sxs-lookup"><span data-stu-id="6cd58-255">Repeated calls to this method will not generate the same key; instead, appending two calls of the <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> method with a `cb` parameter value of `20` is the equivalent of calling the <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> method once with a `cb` parameter value of `40`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6cd58-256">Im folgenden Beispiel wird gezeigt, wie die <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>-Methode verwendet wird, um den Schlüssel für eine Instanz von <xref:System.Security.Cryptography.Rfc2898DeriveBytes>zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="6cd58-256">The following example shows how to use the <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> method to get the key for an instance of <xref:System.Security.Cryptography.Rfc2898DeriveBytes>.</span></span> <span data-ttu-id="6cd58-257">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="6cd58-257">This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.</span></span>  
  
 [!code-cpp[rfc28981#2](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#2)]
 [!code-csharp[rfc28981#2](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#2)]
 [!code-vb[rfc28981#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6cd58-258"><paramref name="cb" /> liegt außerhalb des Bereichs.</span><span class="sxs-lookup"><span data-stu-id="6cd58-258"><paramref name="cb" /> is out of range.</span></span> <span data-ttu-id="6cd58-259">Für diesen Parameter ist eine nicht negative Zahl erforderlich.</span><span class="sxs-lookup"><span data-stu-id="6cd58-259">This parameter requires a non-negative number.</span></span></exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="6cd58-260">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="6cd58-260">Cryptographic Services</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.HashAlgorithmName HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.HashAlgorithmName HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HashAlgorithm As HashAlgorithmName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::HashAlgorithmName HashAlgorithm { System::Security::Cryptography::HashAlgorithmName get(); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Security.Cryptography.HashAlgorithmName" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.HashAlgorithmName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IterationCount">
      <MemberSignature Language="C#" Value="public int IterationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IterationCount" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberSignature Language="VB.NET" Value="Public Property IterationCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IterationCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IterationCount : int with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6cd58-261">Ruft die Anzahl der Iterationen für die Operation ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="6cd58-261">Gets or sets the number of iterations for the operation.</span></span></summary>
        <value><span data-ttu-id="6cd58-262">Die Anzahl der Iterationen für die Operation.</span><span class="sxs-lookup"><span data-stu-id="6cd58-262">The number of iterations for the operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-263">Die Iterations Anzahl gibt an, wie oft ein Vorgang ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="6cd58-263">Iteration count is the number of times an operation is performed.</span></span> <span data-ttu-id="6cd58-264">Bei dieser Methode muss die Anzahl größer als 0 (null) sein.</span><span class="sxs-lookup"><span data-stu-id="6cd58-264">For this method, the count should be greater than zero.</span></span> <span data-ttu-id="6cd58-265">Die empfohlene Mindestanzahl von Iterationen ist 1000.</span><span class="sxs-lookup"><span data-stu-id="6cd58-265">The minimum recommended number of iterations is 1000.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6cd58-266">Im folgenden Beispiel wird gezeigt, wie die <xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A>-Eigenschaft verwendet wird, um die Anzahl der Iterationen anzuzeigen, die bei der Generierung des Schlüssels verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="6cd58-266">The following example shows how to use the <xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A> property to display the number of iterations used in the generation of the key.</span></span> <span data-ttu-id="6cd58-267">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="6cd58-267">This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.</span></span>  
  
 [!code-cpp[rfc28981#3](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#3)]
 [!code-csharp[rfc28981#3](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#3)]
 [!code-vb[rfc28981#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6cd58-268">Die Iterationsanzahl ist kleiner als 1.</span><span class="sxs-lookup"><span data-stu-id="6cd58-268">The number of iterations is less than 1.</span></span></exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="6cd58-269">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="6cd58-269">Cryptographic Services</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Reset();" />
      <MemberSignature Language="F#" Value="override this.Reset : unit -&gt; unit" Usage="rfc2898DeriveBytes.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6cd58-270">Setzt den Zustand der Operation zurück.</span><span class="sxs-lookup"><span data-stu-id="6cd58-270">Resets the state of the operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-271">Diese Methode wird automatisch aufgerufen, wenn die Anzahl der Salt oder Iterationen geändert wird.</span><span class="sxs-lookup"><span data-stu-id="6cd58-271">This method is automatically called if the salt or iteration count is modified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6cd58-272">Im folgenden Beispiel wird die Verwendung der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A>-Methode gezeigt.</span><span class="sxs-lookup"><span data-stu-id="6cd58-272">The following example shows how to use the <xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A> method.</span></span> <span data-ttu-id="6cd58-273">Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="6cd58-273">This code example is part of a larger example provided for the <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class.</span></span>  
  
 [!code-cpp[rfc28981#5](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#5)]
 [!code-csharp[rfc28981#5](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#5)]
 [!code-vb[rfc28981#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="6cd58-274">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="6cd58-274">Cryptographic Services</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Salt">
      <MemberSignature Language="C#" Value="public byte[] Salt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Salt" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberSignature Language="VB.NET" Value="Public Property Salt As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Salt { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Salt : byte[] with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6cd58-275">Ruft den Salt-Wert des Schlüssels für die Operation ab oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="6cd58-275">Gets or sets the key salt value for the operation.</span></span></summary>
        <value><span data-ttu-id="6cd58-276">Der Salt-Wert des Schlüssels für die Operation.</span><span class="sxs-lookup"><span data-stu-id="6cd58-276">The key salt value for the operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6cd58-277">Salt, ein zufälliger Satz von Bytes, wird verwendet, um eine nicht autorisierte Entschlüsselung einer Nachricht zu erschweren.</span><span class="sxs-lookup"><span data-stu-id="6cd58-277">Salt, a random set of bytes, is used to make unauthorized decrypting of a message more difficult.</span></span> <span data-ttu-id="6cd58-278">Ein Wörterbuch Angriff ist ein Angriff, bei dem der Angreifer versucht, eine verschlüsselte Nachricht zu entschlüsseln, indem er den verschlüsselten Wert mit zuvor berechneten verschlüsselten Werten für die wahrscheinlichsten Schlüssel vergleicht.</span><span class="sxs-lookup"><span data-stu-id="6cd58-278">A dictionary attack is an attack in which the attacker attempts to decrypt an encrypted message by comparing the encrypted value with previously computed encrypted values for the most likely keys.</span></span> <span data-ttu-id="6cd58-279">Dieser Angriff wird durch die Einführung von Salt oder zufälligen Bytes am Ende des Kennworts vor der Schlüssel Ableitung erheblich erschwert.</span><span class="sxs-lookup"><span data-stu-id="6cd58-279">This attack is made much more difficult by the introduction of salt, or random bytes, at the end of the password before the key derivation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6cd58-280">Die angegebene Saltgröße ist kleiner als 8 Bytes.</span><span class="sxs-lookup"><span data-stu-id="6cd58-280">The specified salt size is smaller than 8 bytes.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6cd58-281">Die Salt ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="6cd58-281">The salt is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="6cd58-282">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="6cd58-282">Cryptographic Services</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
