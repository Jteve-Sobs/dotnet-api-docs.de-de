<Type Name="Rfc2898DeriveBytes" FullName="System.Security.Cryptography.Rfc2898DeriveBytes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e6d778e763c61fb41ed7fd04f388f2b87d25bab1" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75162455" /></Metadata><TypeSignature Language="C#" Value="public class Rfc2898DeriveBytes : System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Rfc2898DeriveBytes extends System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Rfc2898DeriveBytes" />
  <TypeSignature Language="VB.NET" Value="Public Class Rfc2898DeriveBytes&#xA;Inherits DeriveBytes" />
  <TypeSignature Language="C++ CLI" Value="public ref class Rfc2898DeriveBytes : System::Security::Cryptography::DeriveBytes" />
  <TypeSignature Language="F#" Value="type Rfc2898DeriveBytes = class&#xA;    inherit DeriveBytes" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
    <AssemblyVersion>4.3.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.DeriveBytes</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementiert mithilfe eines auf <see cref="T:System.Security.Cryptography.HMACSHA1" /> basierenden Generators für Pseudozufallszahlen die kennwortbasierte Schlüsselableitungsfunktion PBKDF2.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> nimmt ein Kennwort, ein Salt und eine Iterations Anzahl an und generiert dann Schlüssel durch Aufrufe der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>-Methode.  
  
 RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt. Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln. In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.  
  
 Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)". Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".  
  
> [!IMPORTANT]
>  Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse verwendet, um zwei identische Schlüssel für die <xref:System.Security.Cryptography.TripleDES>-Klasse zu erstellen.  Anschließend werden einige Daten mithilfe der Schlüssel verschlüsselt und entschlüsselt.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
        <param name="salt">Die zum Ableiten des Schlüssels verwendete Schlüsselsalt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts und des Salts zum Ableiten des Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Saltgröße muss 8 Bytes oder größer sein.  
  
 RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt. Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln. In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.  
  
 Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)". Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".  
  
> [!IMPORTANT]
>  Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse verwendet, um zwei identische Schlüssel für die <xref:System.Security.Cryptography.TripleDES>-Klasse zu erstellen.  Anschließend werden einige Daten mithilfe der Schlüssel verschlüsselt und entschlüsselt.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</exception>
        <exception cref="T:System.ArgumentNullException">Das Kennwort oder die Salt ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
        <param name="saltSize">Die Größe der Zufallssalt, die von der Klasse generiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts und der Saltgröße zum Ableiten des Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Saltgröße muss 8 Bytes oder größer sein.  
  
 RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt. Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln. In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.  
  
 Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)". Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".  
  
> [!IMPORTANT]
>  Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes.</exception>
        <exception cref="T:System.ArgumentNullException">Das Kennwort oder die Salt ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
        <param name="salt">Die zum Ableiten des Schlüssels verwendete Schlüsselsalt.</param>
        <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts, der Salt und der Anzahl an Iterationen zum Ableiten des Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Salt-Wert muss 8 Bytes oder größer sein, und die Iterations Anzahl muss größer als 0 (null) sein. Die empfohlene Mindestanzahl von Iterationen ist 1000.  
  
 RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt. Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln. In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.  
  
 Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)". Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".  
  
> [!IMPORTANT]
>  Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</exception>
        <exception cref="T:System.ArgumentNullException">Das Kennwort oder die Salt ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
        <param name="salt">Die zum Ableiten des Schlüssels verwendete Schlüsselsalt.</param>
        <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts, der Salt und der Anzahl an Iterationen zum Ableiten des Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Salt-Wert muss 8 Bytes oder größer sein, und die Iterations Anzahl muss größer als 0 (null) sein. Die empfohlene Mindestanzahl von Iterationen ist 1000.  
  
 RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt. Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln. In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.  
  
 Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)". Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".  
  
> [!IMPORTANT]
>  Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse verwendet, um zwei identische Schlüssel für die <xref:System.Security.Cryptography.TripleDES>-Klasse zu erstellen.  Anschließend werden einige Daten mithilfe der Schlüssel verschlüsselt und entschlüsselt.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</exception>
        <exception cref="T:System.ArgumentNullException">Das Kennwort oder die Salt ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
        <param name="saltSize">Die Größe der Zufallssalt, die von der Klasse generiert werden soll.</param>
        <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse mithilfe des Kennworts, einer Saltgröße und der Anzahl an Iterationen zum Ableiten des Schlüssels.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Salt-Wert muss 8 Bytes oder größer sein, und die Iterations Anzahl muss größer als 0 (null) sein. Die empfohlene Mindestanzahl von Iterationen ist 1000.  
  
 RFC 2898 umfasst Methoden zum Erstellen eines Schlüssels und Initialisierungs Vektors (IV) aus einem Kennwort und Salt. Sie können PBKDF2, eine Funktion für die Kenn Wort basierte Schlüssel Ableitung, verwenden, um Schlüssel mithilfe einer Pseudo Zufallsfunktion abzuleiten, die die Generierung von Schlüsseln mit nahezu unbegrenzter Länge zulässt. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse kann verwendet werden, um einen abgeleiteten Schlüssel aus einem Basis Schlüssel und anderen Parametern zu entwickeln. In einer Kenn Wort basierten Schlüssel abderivations Funktion ist der Basis Schlüssel ein Kennwort, und die anderen Parameter sind ein Salt-Wert und eine Iterations Anzahl.  
  
 Weitere Informationen zu PBKDF2 finden Sie unter RFC 2898, "PKCS #5: Kenn Wort basierte kryptografiespezifikation Version 2,0," auf der [Website "Request for Comments](https://go.microsoft.com/fwlink/?LinkID=37119)". Ausführliche Informationen finden Sie im Abschnitt 5,2, "PBKDF2".  
  
> [!IMPORTANT]
>  Sie sollten niemals ein Kennwort innerhalb Ihres Quellcodes hart codieren.  Hart codierte Kenn Wörter können mithilfe von [Ildasm. exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), mithilfe eines hexadezimalen Editors oder durch einfaches Öffnen der Assembly in einem Text-Editor wie "Notepad. exe" aus einer Assembly abgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes, oder die Iterationsanzahl ist kleiner als 1.</exception>
        <exception cref="T:System.ArgumentNullException">Das Kennwort oder die Salt ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="iterations" /> liegt außerhalb des Bereichs. Für diesen Parameter ist eine nicht negative Zahl erforderlich.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As Byte(), salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(cli::array &lt;System::Byte&gt; ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : byte[] * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="salt" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="iterations" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
        <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse unter Verwendung von Kennwort, Salt, Anzahl der Iterationen und Name des Hashalgorithmus laut Angabe zum Ableiten des Schlüssels.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="saltSize" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />-Eigenschaft von <paramref name="hashAlgorithm" /> ist entweder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Hashalgorithmusname ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, salt As Byte(), iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, cli::array &lt;System::Byte&gt; ^ salt, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * byte[] * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, salt, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="salt" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="iterations" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
        <param name="salt">Der Salt-Wert, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse unter Verwendung von Kennwort, Salt, Anzahl der Iterationen und Name des Hashalgorithmus laut Angabe zum Ableiten des Schlüssels.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />-Eigenschaft von <paramref name="hashAlgorithm" /> ist entweder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Hashalgorithmusname ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (password As String, saltSize As Integer, iterations As Integer, hashAlgorithm As HashAlgorithmName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Rfc2898DeriveBytes(System::String ^ password, int saltSize, int iterations, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Rfc2898DeriveBytes : string * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; System.Security.Cryptography.Rfc2898DeriveBytes" Usage="new System.Security.Cryptography.Rfc2898DeriveBytes (password, saltSize, iterations, hashAlgorithm)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="saltSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="iterations" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="password">Das zum Ableiten des Schlüssels verwendete Kennwort.</param>
        <param name="saltSize">Die Größe der Zufallssalt, die von der Klasse generiert werden soll.</param>
        <param name="iterations">Die Anzahl der Iterationen für die Operation.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse unter Verwendung von Kennwort, Saltgröße, Anzahl der Iterationen und Name des Hashalgorithmus laut Angabe zum Ableiten des Schlüssels.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="saltSize" /> ist kleiner als Null.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" />-Eigenschaft von <paramref name="hashAlgorithm" /> ist entweder <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Hashalgorithmusname ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="CryptDeriveKey">
      <MemberSignature Language="C#" Value="public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] CryptDeriveKey(string algname, string alghashname, int32 keySize, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CryptDeriveKey (algname As String, alghashname As String, keySize As Integer, rgbIV As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ CryptDeriveKey(System::String ^ algname, System::String ^ alghashname, int keySize, cli::array &lt;System::Byte&gt; ^ rgbIV);" />
      <MemberSignature Language="F#" Value="member this.CryptDeriveKey : string * string * int * byte[] -&gt; byte[]" Usage="rfc2898DeriveBytes.CryptDeriveKey (algname, alghashname, keySize, rgbIV)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="alghashname" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="keySize" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="rgbIV" Type="System.Byte[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="algname">Der Name des Algorithmus, für den der Schlüssel abgeleitet werden soll.</param>
        <param name="alghashname">Der Name des Hashalgorithmus, der zum Ableiten des Schlüssels verwendet werden soll.</param>
        <param name="keySize">Die Größe des abzuleitenden Schlüssels in Bits.</param>
        <param name="rgbIV">Der zum Ableiten des Schlüssels zu verwendende Initialisierungsvektor.</param>
        <summary>Leitet einen kryptografischen Schlüssel vom <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Objekt ab.</summary>
        <returns>Der abgeleitete Schlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Funktion ist ein Wrapper für die kryptografieapi-Funktion "CryptDeriveKey ()" und soll Interoperabilität mit Anwendungen unter Verwendung der kryptografieapi ermöglichen.  
  
 Wenn der `keySize`-Parameter auf 0 Bits festgelegt ist, wird die Standard Schlüsselgröße für den angegebenen Algorithmus verwendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der <paramref name="keySize" />-Parameter ist ungültig.  
  
- oder - 
Der Kryptografiedienstanbieter (Cryptographic Service Provider, CSP) kann nicht abgerufen werden.  
  
- oder - 
Der <paramref name="algname" />-Parameter ist kein gültiger Algorithmusname.  
  
- oder - 
Der <paramref name="alghashname" />-Parameter ist kein gültiger Name eines Hashalgorithmus.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="rfc2898DeriveBytes.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von der <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />-Klasse verwendeten nicht verwalteten Ressourcen frei und gibt (optional) auch die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen `Dispose()`-Methode und der `Finalize`-Methode aufgerufen. `Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist. `Finalize` ruft `Dispose` auf, bei dem `disposing` auf `false`festgelegt ist.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Security.Cryptography.Rfc2898DeriveBytes> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Wenn Sie <see langword="Dispose(Boolean)" />überschreiben, sollten Sie darauf achten, nicht auf Objekte zu verweisen, die zuvor in einem früheren <see langword="Dispose" />aufgerufen wurden. Weitere Informationen zum Implementieren von <see langword="Dispose(Boolean)" />finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.  
  
Weitere Informationen zu <see langword="Dispose" /> und <see langword="Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (cb As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(int cb);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int -&gt; byte[]" Usage="rfc2898DeriveBytes.GetBytes cb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">Die Anzahl der zu generierenden pseudozufälligen Schlüsselbytes.</param>
        <summary>Gibt den pseudozufälligen Schlüssel für dieses Objekt zurück.</summary>
        <returns>Ein mit pseudozufälligen Schlüsselbytes gefülltes Bytearray.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse implementiert die PBKDF2-Funktionalität mithilfe eines auf <xref:System.Security.Cryptography.HMACSHA1>basierenden Pseudo Zufalls-Zahlen Generators. Die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse nimmt ein Kennwort, ein Salt und eine Iterations Anzahl an und generiert dann mithilfe von Aufrufen der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>-Methode Schlüssel. Bei wiederholten Aufrufen dieser Methode wird nicht derselbe Schlüssel generiert. Stattdessen ist das Anfügen von zwei Aufrufen der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>-Methode mit einem `cb` Parameterwert von `20` das Äquivalent zum Aufrufen der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>-Methode einmal mit dem `cb` Parameterwert `40`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A>-Methode verwendet wird, um den Schlüssel für eine Instanz von <xref:System.Security.Cryptography.Rfc2898DeriveBytes>zu erhalten. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse bereitgestellt wird.  
  
 [!code-cpp[rfc28981#2](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#2)]
 [!code-csharp[rfc28981#2](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#2)]
 [!code-vb[rfc28981#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="cb" /> liegt außerhalb des Bereichs. Für diesen Parameter ist eine nicht negative Zahl erforderlich.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.HashAlgorithmName HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.HashAlgorithmName HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HashAlgorithm As HashAlgorithmName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::HashAlgorithmName HashAlgorithm { System::Security::Cryptography::HashAlgorithmName get(); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Security.Cryptography.HashAlgorithmName" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.HashAlgorithmName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IterationCount">
      <MemberSignature Language="C#" Value="public int IterationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IterationCount" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberSignature Language="VB.NET" Value="Public Property IterationCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IterationCount { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IterationCount : int with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Iterationen für die Operation ab oder legt diese fest.</summary>
        <value>Die Anzahl der Iterationen für die Operation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Iterations Anzahl gibt an, wie oft ein Vorgang ausgeführt wird. Bei dieser Methode muss die Anzahl größer als 0 (null) sein. Die empfohlene Mindestanzahl von Iterationen ist 1000.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A>-Eigenschaft verwendet wird, um die Anzahl der Iterationen anzuzeigen, die bei der Generierung des Schlüssels verwendet werden. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse bereitgestellt wird.  
  
 [!code-cpp[rfc28981#3](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#3)]
 [!code-csharp[rfc28981#3](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#3)]
 [!code-vb[rfc28981#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Iterationsanzahl ist kleiner als 1.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Reset();" />
      <MemberSignature Language="F#" Value="override this.Reset : unit -&gt; unit" Usage="rfc2898DeriveBytes.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Zustand der Operation zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird automatisch aufgerufen, wenn die Anzahl der Salt oder Iterationen geändert wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A>-Methode gezeigt. Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Security.Cryptography.Rfc2898DeriveBytes>-Klasse bereitgestellt wird.  
  
 [!code-cpp[rfc28981#5](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#5)]
 [!code-csharp[rfc28981#5](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#5)]
 [!code-vb[rfc28981#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName="Salt">
      <MemberSignature Language="C#" Value="public byte[] Salt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Salt" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberSignature Language="VB.NET" Value="Public Property Salt As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Salt { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Salt : byte[] with get, set" Usage="System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Salt-Wert des Schlüssels für die Operation ab oder legt diesen fest.</summary>
        <value>Der Salt-Wert des Schlüssels für die Operation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Salt, ein zufälliger Satz von Bytes, wird verwendet, um eine nicht autorisierte Entschlüsselung einer Nachricht zu erschweren. Ein Wörterbuch Angriff ist ein Angriff, bei dem der Angreifer versucht, eine verschlüsselte Nachricht zu entschlüsseln, indem er den verschlüsselten Wert mit zuvor berechneten verschlüsselten Werten für die wahrscheinlichsten Schlüssel vergleicht. Dieser Angriff wird durch die Einführung von Salt oder zufälligen Bytes am Ende des Kennworts vor der Schlüssel Ableitung erheblich erschwert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die angegebene Saltgröße ist kleiner als 8 Bytes.</exception>
        <exception cref="T:System.ArgumentNullException">Die Salt ist <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
  </Members>
</Type>
