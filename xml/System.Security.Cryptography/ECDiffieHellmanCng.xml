<Type Name="ECDiffieHellmanCng" FullName="System.Security.Cryptography.ECDiffieHellmanCng">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="286bf918255ea8d29ba319f459e569551d533740" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500954" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ECDiffieHellmanCng : System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ECDiffieHellmanCng extends System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellmanCng" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ECDiffieHellmanCng&#xA;Inherits ECDiffieHellman" />
  <TypeSignature Language="C++ CLI" Value="public ref class ECDiffieHellmanCng sealed : System::Security::Cryptography::ECDiffieHellman" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.ECDiffieHellman</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine CNG (Cryptography Next Generation)-Implementierung des ECDH (Elliptic Curve Diffie-Hellman)-Algorithmus bereit. Diese Klasse wird für kryptografische Operationen verwendet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Cryptography.ECDiffieHellmanCng> Klasse ermöglicht zwei Parteien privates Schlüsselmaterial austauschen, auch wenn sie über einen öffentlichen Kanal kommunizieren.  Beide Parteien können denselben geheimen Wert, der so genannte Berechnen der *Geheimvertrag* in den verwalteten Diffie-Hellman-Klassen. Der Geheimvertrag kann dann für verschiedene Zwecke verwenden, einschließlich eines symmetrischen Schlüssels verwendet werden. Jedoch anstelle der Geheimvertrag direkt, Verfügbarmachen der <xref:System.Security.Cryptography.ECDiffieHellmanCng> Klasse ist eine nach der Verarbeitung auf die Vereinbarung, bevor Sie den Wert angeben. Diese Post-Verarbeitung wird als bezeichnet den *Ableitung-Funktion (KDF) für Schlüssel*; Sie können auswählen, welche KDF, die Sie verwenden möchten und legen ihre Parameter durch einen Satz von Eigenschaften für die Instanz des Objekts Diffie-Hellman.  
  
|Schlüsselableitungsfunktion|Eigenschaften|  
|-----------------------------|----------------|  
|<xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash>|<xref:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm%2A> -Der Hashalgorithmus, der zum Verarbeiten der Geheimvertrag verwendet wird.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend%2A> -Ein optionales Bytearray, das Geheimvertrag vor Hashs Bildressourcen vorangestellt wird.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend%2A> -Ein optionales Bytearray, an den Geheimvertrag vor Hashs angefügt werden soll.|  
|<xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac>|<xref:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm%2A> -Der Hashalgorithmus, der zum Verarbeiten der Geheimvertrag verwendet wird.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend%2A>-Ein optionales Bytearray, das Geheimvertrag vor Hashs Bildressourcen vorangestellt wird.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend%2A> -Ein optionales Bytearray, an den Geheimvertrag vor Hashs angefügt werden soll.|  
|<xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls>|<xref:System.Security.Cryptography.ECDiffieHellmanCng.Label%2A> -Die Bezeichnung für die schlüsselableitung.<br /><br /> <xref:System.Security.Cryptography.ECDiffieHellmanCng.Seed%2A> – Der Ausgangswert für die schlüsselableitung.|  
  
 Das Ergebnis der Übergabe der Geheimvertrag über die Schlüsselableitungsfunktion ist ein Bytearray, das als Schlüsselmaterial für Ihre Anwendung verwendet werden kann. Die Anzahl der Bytes von generiertem Schlüsselmaterial ist die Schlüsselableitungsfunktion abhängig. Beispielsweise wird SHA-256 256 Bits Schlüsselmaterial, generieren, wohingegen SHA-512 512 Bits Schlüsselmaterial generiert wird. Die grundlegende Vorgehensweise einen ECDH-Schlüsselaustausch lautet wie folgt:  
  
1.  Alice und Bob Erstellen eines Schlüsselpaars für den Diffie-Hellman-Schlüsselaustauschvorgang verwenden  
  
2.  Alice und Bob konfigurieren die KDF mit Parametern der Stimme zu auf.  
  
3.  Alice sendet Bob ihren öffentlichen Schlüssel.  
  
4.  Bob sendet Alice seinen öffentlichen Schlüssel an.  
  
5.  Alice und Bob jeweils anderen öffentlichen Schlüssel verwenden, um die Geheimvertrag zu generieren, und wenden die KDF auf den Geheimvertrag Schlüsselmaterial zu generieren.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Security.Cryptography.ECDiffieHellmanCng> Klasse zum Herstellen einer Schlüsselaustausch und wie Sie diesen Schlüssel zum Verschlüsseln einer Nachricht, die über einen öffentlichen Kanal gesendet und vom Empfänger entschlüsselt werden können.  
  
 [!code-csharp[ECDiffieHellmanCng#1](~/samples/snippets/csharp/VS_Snippets_CLR/ecdiffiehellmancng/cs/program.cs#1)]
 [!code-vb[ECDiffieHellmanCng#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ecdiffiehellmancng/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />-Klasse mit einem zufällig generierten Schlüsselpaar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die zufällige Schlüsselpaar hat eine standardmäßige Länge des öffentlichen Schlüssels von 521 Bits.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng (int keySize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 keySize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keySize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng(int keySize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keySize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keySize">Die Größe des Schlüssels. Gültige Schlüsselgrößen sind 256, 384 und 521 Bits.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />-Klasse mit einem zufällig erzeugten Schlüsselpaar mit der angegebenen Schlüsselgröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zufälligen Schlüsselpaar wird die Länge des öffentliche Schlüssels von definiert haben die `keySize` Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Die <paramref name="keySize" /> gibt eine ungültige Länge an.</exception>
        <exception cref="T:System.PlatformNotSupportedException">CNG-Klassen (Cryptography Next Generation) werden auf diesem System nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng (System.Security.Cryptography.CngKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.CngKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Security.Cryptography.CngKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As CngKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng(System::Security::Cryptography::CngKey ^ key);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="key" Type="System.Security.Cryptography.CngKey" />
      </Parameters>
      <Docs>
        <param name="key">Der Schlüssel, der als Eingabe für kryptografische Vorgänge verwendet wird, die vom aktuellen Objekt durchgeführt werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />-Klasse unter Verwendung des angegebenen <see cref="T:System.Security.Cryptography.CngKey" />-Objekts.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> gibt keine ECDH (Elliptic Curve Diffie-Hellman)-Algorithmusgruppe an.</exception>
        <exception cref="T:System.PlatformNotSupportedException">CNG-Klassen (Cryptography Next Generation) werden auf diesem System nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ECDiffieHellmanCng (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.#ctor(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ECDiffieHellmanCng(System::Security::Cryptography::ECCurve curve);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" />
      </Parameters>
      <Docs>
        <param name="curve">Die Kurve, die für das Generieren des Paars aus privatem und öffentlichem Schlüssel verwendet wird.</param>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />-Klasse, deren Paar aus öffentlichem und privatem Schlüssel über die angegebene Kurve generiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `curve` Überprüfen müssen (d. h. es muss zurückgegeben werden `true`) bei der Übergabe an die <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> Methode muss eine benannte oder explizite Prime.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="curve" /> führt keine Validierung durch.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHash">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Leitet Bytes ab, die als Schlüssel mit einer Hashfunktion verwendet werden können.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" />
        <Parameter Name="secretAppend" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Der öffentliche Schlüssel der anderen Partei.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</param>
        <param name="secretPrepend">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren vorangestellt wird.</param>
        <param name="secretAppend">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren angefügt wird.</param>
        <summary>Leitet Bytes ab, die mithilfe einer Hashfunktion als Schlüssel verwendet werden können. Der öffentliche Schlüssel einer anderen Partei, der Name des Hashalgorithmus, ein vorangestellter und ein angefügter Wert werden übergeben.</summary>
        <returns>Das Schlüsselmaterial aus dem Schlüsselaustausch mit dem öffentlichen Schlüssel der anderen Partei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert der `secretPrepend` oder `secretAppend` ist `null`, sie werden als leere Arrays behandelt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> ist kein ECDH-Schlüssel, oder es ist nicht die richtige Größe.  
  
 - oder -   
  
 <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Alle anderen Fehler.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHmac">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Leitet Bytes ab, die als Schlüssel mit einem Hash-based Message Authentication Code (HMAC) verwendet werden können.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte(), secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="hmacKey" Type="System.Byte[]" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" />
        <Parameter Name="secretAppend" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Der öffentliche Schlüssel der anderen Partei.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</param>
        <param name="hmacKey">Der Schlüssel für den HMAC.</param>
        <param name="secretPrepend">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren vorangestellt wird.</param>
        <param name="secretAppend">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren angefügt wird.</param>
        <summary>Leitet Bytes ab, die als Schlüssel mit einem Hash-based Message Authentication Code (HMAC) verwendet werden können.</summary>
        <returns>Das Schlüsselmaterial aus dem Schlüsselaustausch mit dem öffentlichen Schlüssel der anderen Partei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert der `secretPrepend` oder `secretAppend` ist `null`, sie werden als leere Arrays behandelt. Wenn der Wert der `hmacKey` ist `null`, wird das Ergebnis des Algorithmus Elliptic Curve Diffie-Hellman (ECDH) der HMAC-Schlüssel verwendet werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> ist kein ECDH-Schlüssel, oder es ist nicht die richtige Größe.  
  
 - oder -   
  
 <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Alle anderen Fehler.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyMaterial">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Leitet das Schlüsselmaterial ab, das aus dem Geheimvertrag zweier Seiten generiert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Algorithmus Elliptic Curve Diffie-Hellman (ECDH) den privaten Schlüssel und ein öffentlicher Schlüssel von der anderen Partei als Eingabe akzeptiert und der Geheimvertrag als Ausgabe erzeugt. Die Schlüsselableitungsfunktion (KDF) klicken Sie dann die Geheimvertrag akzeptiert und das Schlüsselmaterial als Ausgabe erzeugt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyMaterial (System.Security.Cryptography.CngKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.CngKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyMaterial(System.Security.Cryptography.CngKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyMaterial (otherPartyPublicKey As CngKey) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::CngKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.CngKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">En Objekt, das den öffentlichen Teil des ECDH (Elliptic Curve Diffie-Hellman)-Schlüssels der anderen Seite des Schlüsselaustauschs enthält.</param>
        <summary>Leitet das Schlüsselmaterial ab, das aus dem Geheimvertrag zweier Seiten generiert wird, und erwartet ein <see cref="T:System.Security.Cryptography.CngKey" />-Objekt, das den öffentlichen Schlüssel der anderen Seite enthält.</summary>
        <returns>Ein Bytearray mit dem Schlüsselmaterial. Diese Informationen werden aus dem Geheimvertrag generiert, der aus dem privaten Schlüssel des aktuellen Objekts und dem angegebenen öffentlichen Schlüssel berechnet wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> ist ungültig. Entweder ist in dessen <see cref="P:System.Security.Cryptography.CngKey.AlgorithmGroup" />-Eigenschaft nicht <see cref="P:System.Security.Cryptography.CngAlgorithmGroup.ECDiffieHellman" /> angegeben, oder die Schlüsselgröße stimmt nicht mit der Schlüsselgröße dieser Instanz überein.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction" />-Eigenschaft dieses Objekts gibt die <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />-Schlüsselableitungsfunktion an, aber <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" /> oder <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Alle anderen Fehler.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Der öffentliche Schlüssel der anderen Seite des Schlüsselaustauschs.</param>
        <summary>Leitet das Schlüsselmaterial ab, das aus dem Geheimvertrag zweier Seiten generiert wird, und erwartet ein <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />-Objekt, das den öffentlichen Schlüssel der anderen Seite enthält.</summary>
        <returns>Ein Bytearray mit dem Schlüsselmaterial. Diese Informationen werden aus dem Geheimvertrag generiert, der aus dem privaten Schlüssel des aktuellen Objekts und dem angegebenen öffentlichen Schlüssel berechnet wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> ist kein <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" />-Schlüssel.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyTls">
      <MemberSignature Language="C#" Value="public override byte[] DeriveKeyTls (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DeriveKeyTls(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, unsigned int8[] prfLabel, unsigned int8[] prfSeed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DeriveKeyTls (otherPartyPublicKey As ECDiffieHellmanPublicKey, prfLabel As Byte(), prfSeed As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ DeriveKeyTls(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, cli::array &lt;System::Byte&gt; ^ prfLabel, cli::array &lt;System::Byte&gt; ^ prfSeed);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="prfLabel" Type="System.Byte[]" />
        <Parameter Name="prfSeed" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Der öffentliche Schlüssel der anderen Partei.</param>
        <param name="prfLabel">Die ASCII-codierte PRF-Bezeichnung.</param>
        <param name="prfSeed">Der 64-Byte-PRF-Startwert.</param>
        <summary>Leitet Bytes ab, die mithilfe eines Transport Layer Security-Pseudo-Random Function-Ableitungsalgorithmus (TLS, PRF) als Schlüssel verwendet werden können.</summary>
        <returns>Das Schlüsselmaterial aus dem Schlüsselaustausch mit dem öffentlichen Schlüssel der anderen Partei.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="prfLabel" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="prfSeed" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> ist kein ECDH-Schlüssel, oder es ist nicht die richtige Größe.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="prfSeed" /> ist nicht genau 64 Bytes lang.  
  
 - oder -   
  
 Alle anderen kryptografischen Fehler.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveSecretAgreementHandle">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein Handle für den Geheimvertrag ab, der zwischen zwei Seiten generiert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Cryptography.ECDiffieHellmanCng.DeriveSecretAgreementHandle%2A> methodenüberladungen sind für erfahrene Benutzer benötigen ein Handle für die unformatierten Geheimvertrag anstelle des Schlüsselmaterials. Das Handle Geheimvertrag Plattform genutzt werden Plattformaufrufen bei allen Aufgaben, die nicht von umgeben ist die <xref:System.Security.Cryptography.ECDiffieHellmanCng> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveSecretAgreementHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle (System.Security.Cryptography.CngKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle(class System.Security.Cryptography.CngKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveSecretAgreementHandle(System.Security.Cryptography.CngKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveSecretAgreementHandle (otherPartyPublicKey As CngKey) As SafeNCryptSecretHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::SafeHandles::SafeNCryptSecretHandle ^ DeriveSecretAgreementHandle(System::Security::Cryptography::CngKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.CngKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">En Objekt, das den öffentlichen Teil des ECDH (Elliptic Curve Diffie-Hellman)-Schlüssels der anderen Seite des Schlüsselaustauschs enthält.</param>
        <summary>Ruft ein Handle für den Geheimvertrag ab, der zwischen zwei Seiten generiert wird, und erwartet ein <see cref="T:System.Security.Cryptography.CngKey" />-Objekt, das den öffentlichen Schlüssel der anderen Seite enthält.</summary>
        <returns>Ein Handle für den Geheimvertrag. Diese Informationen werden aus dem privaten Schlüssel des aktuellen Objekts und dem angegebenen öffentlichen Schlüssel berechnet.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> ist kein ECDH-Schlüssel, oder es ist nicht die richtige Größe.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Alle anderen Fehler.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Berechtigung zum Aufrufen von nicht verwalteten Codes. "Demand"-Wert: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeriveSecretAgreementHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle DeriveSecretAgreementHandle(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.DeriveSecretAgreementHandle(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveSecretAgreementHandle (otherPartyPublicKey As ECDiffieHellmanPublicKey) As SafeNCryptSecretHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Win32::SafeHandles::SafeNCryptSecretHandle ^ DeriveSecretAgreementHandle(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">Der öffentliche Schlüssel der anderen Seite des Schlüsselaustauschs.</param>
        <summary>Ruft ein Handle für den Geheimvertrag ab, der zwischen zwei Seiten generiert wird, und erwartet ein <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />-Objekt, das den öffentlichen Schlüssel der anderen Seite enthält.</summary>
        <returns>Ein Handle für den Geheimvertrag. Diese Informationen werden aus dem privaten Schlüssel des aktuellen Objekts und dem angegebenen öffentlichen Schlüssel berechnet.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="otherPartyPublicKey" /> ist kein <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" />-Schlüssel.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExportExplicitParameters">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.ECParameters ExportExplicitParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Security.Cryptography.ECParameters ExportExplicitParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ExportExplicitParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ExportExplicitParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Cryptography::ECParameters ExportExplicitParameters(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
        <summary>Exportiert die Schlüssel- und expliziten Kurvenparameter, die vom <see cref="T:System.Security.Cryptography.ECCurve" />-Objekt verwendet werden, in ein <see cref="T:System.Security.Cryptography.ECParameters" />-Objekt.</summary>
        <returns>Die Schlüssel- und expliziten Kurvenparameter, die vom <see cref="T:System.Security.Cryptography.ECCurve" />-Objekt verwendet werden.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Die Methode kann keine Kurvenwerte abrufen.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Der explizite Export wird von dieser Plattform nicht unterstützt. Windows 10 oder höher ist erforderlich.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.ECParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Security.Cryptography.ECParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ExportParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Cryptography::ECParameters ExportParameters(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
        <summary>Exportiert den vom <see cref="T:System.Security.Cryptography.ECCurve" />-Objekt verwendeten Schlüssel in ein <see cref="T:System.Security.Cryptography.ECParameters" />-Objekt.</summary>
        <returns>Die Schlüssel- und die benannten Kurvenparameter, die vom <see cref="T:System.Security.Cryptography.ECCurve" />-Objekt verwendet werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel, als benannte Kurve erstellt wurde, die <xref:System.Security.Cryptography.ECParameters.Curve?displayProperty=nameWithType> Feld enthält die benannte Kurvenzugparameter angegeben werden          Andernfalls enthält es explizite Parametern.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Die Methode kann keine Kurvenwerte abrufen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromXmlString">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Deserialisiert die Schlüsselinformationen aus einer XML-Zeichenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public override void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXmlString(System::String ^ xmlString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlString">Die XML-basierten Schlüsselinformationen, die deserialisiert werden sollten.</param>
        <summary>Diese Methode ist nicht implementiert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie einen XML-Schlüssel zu deserialisieren, der <xref:System.Security.Cryptography.ECDiffieHellmanCng.FromXmlString%28System.String%2CSystem.Security.Cryptography.ECKeyXmlFormat%29> stattdessen überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Diese Methode wurde für diese Instanz nicht überschrieben.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public void FromXmlString (string xml, System.Security.Cryptography.ECKeyXmlFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FromXmlString(string xml, valuetype System.Security.Cryptography.ECKeyXmlFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.FromXmlString(System.String,System.Security.Cryptography.ECKeyXmlFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FromXmlString (xml As String, format As ECKeyXmlFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FromXmlString(System::String ^ xml, System::Security::Cryptography::ECKeyXmlFormat format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xml" Type="System.String" />
        <Parameter Name="format" Type="System.Security.Cryptography.ECKeyXmlFormat" />
      </Parameters>
      <Docs>
        <param name="xml">Die XML-basierten Schlüsselinformationen, die deserialisiert werden sollten.</param>
        <param name="format">Einer der Enumerationswerte, der das Format der XML-Zeichenfolge angibt. Das einzige aktuell akzeptierte Format ist <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</param>
        <summary>Deserialisiert die Schlüsselinformationen aus einer XML-Zeichenfolge mit dem angegebenen Format.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xml" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="xml" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="format" /> gibt ein ungültiges Format an. Der einzige akzeptierte Wert ist <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Alle anderen Fehler.</exception>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public override void GenerateKey (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GenerateKey(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.GenerateKey(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GenerateKey (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GenerateKey(System::Security::Cryptography::ECCurve curve);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" />
      </Parameters>
      <Docs>
        <param name="curve">Die Kurve, die für das Generieren eines kurzlebigen Paars aus privatem und öffentlichem Schlüssel verwendet wird.</param>
        <summary>Generiert ein neues kurzlebiges Paar aus privatem und öffentlichem Schlüssel für die angegebene Kurve.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `curve` Überprüfen müssen (d. h. er "true", bei der Übergabe an zurückgeben muss die <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> Methode) und nicht implizit sein.  
  
 Merkmal-2-Kurven werden unter Windows nicht unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="curve" /> führt keine Validierung durch.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CngAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CngAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As CngAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CngAlgorithm ^ HashAlgorithm { System::Security::Cryptography::CngAlgorithm ^ get(); void set(System::Security::Cryptography::CngAlgorithm ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Hashalgorithmus ab, der zur Generierung des Schlüsselmaterials verwendet wird, oder legt diesen fest.</summary>
        <value>Ein Objekt, das den Hashalgorithmus angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird verwendet, von Cryptography Next Generation (CNG) Objekte nur, wenn die <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash> oder <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac> Wert wird festgelegt, der <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> Eigenschaft.  
  
 Diese Eigenschaft akzeptiert die folgenden Algorithmen: <xref:System.Security.Cryptography.CngAlgorithm.MD5%2A>, <xref:System.Security.Cryptography.CngAlgorithm.Sha1%2A>, <xref:System.Security.Cryptography.CngAlgorithm.Sha256%2A>, <xref:System.Security.Cryptography.CngAlgorithm.Sha384%2A>, und <xref:System.Security.Cryptography.CngAlgorithm.Sha512%2A>.  
  
 Andere benutzerdefinierte Hashalgorithmen können auch verwendet werden.  
  
 Standardmäßig wird der Algorithmus <xref:System.Security.Cryptography.CngAlgorithm.Sha256%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert ist <see langword="null." />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HmacKey">
      <MemberSignature Language="C#" Value="public byte[] HmacKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] HmacKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.HmacKey" />
      <MemberSignature Language="VB.NET" Value="Public Property HmacKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ HmacKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den HMAC (Hash-based Message Authentication Code)-Schlüssel ab, mit dem das Schlüsselmaterial abgeleitet wird, oder legt diesen fest.</summary>
        <value>Der HMAC (Hash-based Message Authentication Code)-Schlüssel, mit dem das Schlüsselmaterial abgeleitet wird, oder legt diesen fest.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gilt nur, wenn die <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac> Wert wird festgelegt, der <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> -Eigenschaft, und die <xref:System.Security.Cryptography.ECDiffieHellmanCng.UseSecretAgreementAsHmacKey%2A> Eigenschaft ist `false`. In der Standardeinstellung ist der Wert `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public override void ImportParameters (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportParameters(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ImportParameters(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportParameters (parameters As ECParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportParameters(System::Security::Cryptography::ECParameters parameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">Die zu importierenden Parameter der Kurve.</param>
        <summary>Importiert die angegebenen Parameter für ein <see cref="T:System.Security.Cryptography.ECCurve" />-Objekt als Schlüssel in die Kurveninstanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Cryptography.ECDiffieHellmanCng.ImportParameters%2A> Methode ersetzt den vorhandenen Schlüssel, mit denen dieses Objekt arbeiten wird durch Erstellen eines neuen <xref:System.Security.Cryptography.CngKey> Objekt. Wenn `parameters` enthält nur die <xref:System.Security.Cryptography.ECParameters.Q> Feld, und klicken Sie dann nur ein öffentlicher Schlüssel importiert wird.         Wenn `parameters` enthält auch <xref:System.Security.Cryptography.ECParameters.D>, und klicken Sie dann ein vollständiges Schlüsselpaar wird importiert werden. Die `parameter` <xref:System.Security.Cryptography.ECParameters.Curve> Wert gibt den Typ der Kurve zu importieren.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="parameters" /> führt keine Validierung durch.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="parameters" /> verweist auf eine Kurve, die nicht importiert werden kann.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <paramref name="parameters" /> verweist auf eine Kurve, die von dieser Plattform nicht unterstützt wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="Key">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CngKey Key { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CngKey Key" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.Key" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Key As CngKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CngKey ^ Key { System::Security::Cryptography::CngKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CngKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den <see cref="T:System.Security.Cryptography.CngKey" /> an, der vom aktuellen Objekt für kryptografische Operationen verwendet wird.</summary>
        <value>Das von diesem Objekt für kryptografische Operationen verwendete Schlüsselpaar.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDerivationFunction">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyDerivationFunction As ECDiffieHellmanKeyDerivationFunction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { System::Security::Cryptography::ECDiffieHellmanKeyDerivationFunction get(); void set(System::Security::Cryptography::ECDiffieHellmanKeyDerivationFunction value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Schlüsselableitungsfunktion für die <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />-Klasse ab oder legt diese fest.</summary>
        <value>Einer der <see cref="T:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction" />-Enumerationswerte: <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />, <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" /> oder <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />. Der Standardwert ist <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt die Schlüsselableitungsfunktion-Funktion, die zum Transformieren der Geheimvertrag in Schlüsselmaterial verwendet wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Enumerationswert liegt außerhalb des Bereichs.</exception>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public byte[] Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Label" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Label { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für die Schlüsselableitung verwendete Bezeichnung ab oder legt diese fest.</summary>
        <value>Der Bezeichnungswert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird für die schlüsselableitung verwendet, wenn die <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls> Wert wird festgelegt, der <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> Eigenschaft. Standardmäßig ist es `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property PublicKey As ECDiffieHellmanPublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Cryptography::ECDiffieHellmanPublicKey ^ PublicKey { System::Security::Cryptography::ECDiffieHellmanPublicKey ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanPublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den öffentlichen Schlüssel ab, der von einem anderen <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />-Objekt zum Generieren eines gemeinsamen Geheimvertrags verwendet werden kann.</summary>
        <value>Der öffentliche Schlüssel, der dieser Instanz des <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />-Objekts zugeordnet ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecretAppend">
      <MemberSignature Language="C#" Value="public byte[] SecretAppend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SecretAppend" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend" />
      <MemberSignature Language="VB.NET" Value="Public Property SecretAppend As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SecretAppend { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der beim Generieren des Schlüsselmaterials an den Geheimvertrag angefügt wird, oder legt diesen Wert fest.</summary>
        <value>Der Wert, der an den Geheimvertrag angefügt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird für die schlüsselableitung verwendet, wenn die <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash> oder <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac> Schlüsselableitungsfunktion (KDF) verwendet wird. Der Wert wird an den Geheimvertrag angefügt, und der kombinierte Wert wird an die KDF zum Generieren des Schlüsselmaterials übergeben. In der Standardeinstellung ist der Wert `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SecretPrepend">
      <MemberSignature Language="C#" Value="public byte[] SecretPrepend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SecretPrepend" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend" />
      <MemberSignature Language="VB.NET" Value="Public Property SecretPrepend As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SecretPrepend { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der beim Ableiten des Schlüsselmaterials am Anfang des Geheimvertrags eingefügt wird, oder legt diesen Wert fest.</summary>
        <value>Der Wert, der bei der Schlüsselableitung am Anfang des Geheimvertrags eingefügt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird für die schlüsselableitung verwendet, wenn die <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> Eigenschaft auf einen der folgenden Werte festgelegt:  
  
-   <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash>  
  
-   <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac>  
  
 Der Wert der Geheimvertrag vorangestellt ist, und der kombinierte Wert wird an die Schlüsselableitungsfunktion (KDF) zum Generieren des Schlüsselmaterials übergeben. In der Standardeinstellung ist der Wert `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seed">
      <MemberSignature Language="C#" Value="public byte[] Seed { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Seed" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" />
      <MemberSignature Language="VB.NET" Value="Public Property Seed As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Seed { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Startwert ab, der zum Ableiten des Schlüsselmaterials verwendet wird, oder legt diesen Wert fest.</summary>
        <value>Der Startwert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird für die schlüsselableitung verwendet, wenn die <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> -Eigenschaftensatz auf <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls>. In der Standardeinstellung ist der Wert `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToXmlString">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serialisiert die Schlüsselinformationen in eine XML-Zeichenfolge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public override string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
        <summary>Diese Methode ist nicht implementiert.</summary>
        <returns>Nicht zutreffend.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um den aktuellen Schlüssel in eine XML-Darstellung zu konvertieren, verwenden die <xref:System.Security.Cryptography.ECDiffieHellmanCng.ToXmlString%28System.Security.Cryptography.ECKeyXmlFormat%29> stattdessen überladen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Diese Methode wurde für diese Instanz nicht überschrieben.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public string ToXmlString (System.Security.Cryptography.ECKeyXmlFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToXmlString(valuetype System.Security.Cryptography.ECKeyXmlFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellmanCng.ToXmlString(System.Security.Cryptography.ECKeyXmlFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToXmlString (format As ECKeyXmlFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToXmlString(System::Security::Cryptography::ECKeyXmlFormat format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.Security.Cryptography.ECKeyXmlFormat" />
      </Parameters>
      <Docs>
        <param name="format">Einer der Enumerationswerte, der das Format der XML-Zeichenfolge angibt. Das einzige aktuell akzeptierte Format ist <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</param>
        <summary>Serialisiert die Schlüsselinformationen in eine XML-Zeichenfolge mit dem angegebenen Format.</summary>
        <returns>Ein Zeichenfolgenobjekt, das die serialisierten Schlüsselinformationen als XML-Zeichenfolge im angeforderten Format enthält.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="format" /> gibt ein ungültiges Format an. Der einzige akzeptierte Wert ist <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSecretAgreementAsHmacKey">
      <MemberSignature Language="C#" Value="public bool UseSecretAgreementAsHmacKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSecretAgreementAsHmacKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellmanCng.UseSecretAgreementAsHmacKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UseSecretAgreementAsHmacKey As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSecretAgreementAsHmacKey { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Geheimvertrag als HMAC (Hash-based Message Authentication Code)-Schlüssel zur Ableitung von Schlüsselmaterial verwendet wird.</summary>
        <value>
          <see langword="true" />, wenn der Geheimvertrag als HMAC-Schlüssel verwendet wird, um Schlüsselmaterial abzuleiten, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Dieser Wert wird für die schlüsselableitung verwendet, wenn die <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> -Eigenschaftensatz auf <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac>. In der Standardeinstellung ist der Wert `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>