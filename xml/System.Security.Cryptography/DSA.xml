<Type Name="DSA" FullName="System.Security.Cryptography.DSA">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0d3ed85953abb0f1cb4fb337c5d3d8a76b134c6c" /><Meta Name="ms.sourcegitcommit" Value="47aee60cbc5001a16d5b9cdd0500df890fb1cdec" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/26/2019" /><Meta Name="ms.locfileid" Value="74529311" /></Metadata><TypeSignature Language="C#" Value="public abstract class DSA : System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DSA extends System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.DSA" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DSA&#xA;Inherits AsymmetricAlgorithm" />
  <TypeSignature Language="C++ CLI" Value="public ref class DSA abstract : System::Security::Cryptography::AsymmetricAlgorithm" />
  <TypeSignature Language="F#" Value="type DSA = class&#xA;    inherit AsymmetricAlgorithm" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.3.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.AsymmetricAlgorithm</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt die abstrakte Basisklasse dar, von der alle Implementierungen des digitalen Signaturalgorithmus (<see cref="T:System.Security.Cryptography.DSA" />) erben müssen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Security.Cryptography.DSA>-Klasse und die abgeleiteten Klassen verwenden, um digitale Signaturen zu erstellen, mit denen die Integrität Ihrer Daten geschützt wird.  Der <xref:System.Security.Cryptography.DSACryptoServiceProvider> stellt eine Implementierung dieser Klasse bereit.  
  
 Um ein öffentliches Schlüsselsystem zum digitalen Signieren einer Nachricht zu verwenden, wendet der Absender zuerst eine Hash Funktion auf die Nachricht an, um einen Nachrichten Digest zu erstellen. Der Absender verschlüsselt den Nachrichten Digest dann mit dem privaten Schlüssel des Absenders, um die persönliche Signatur des Absenders zu erstellen. Beim Empfang der Nachricht und der Signatur entschlüsselt der Empfänger die Signatur mithilfe des öffentlichen Schlüssels des Absenders, um den Nachrichten Digest wiederherzustellen, und erstellt einen Hashwert für die Nachricht mit dem gleichen Hash Algorithmus, den der Absender verwendet hat. Wenn der vom Empfänger genau eingehende Nachrichten Digest mit dem vom Absender empfangenen Nachrichten Digest übereinstimmt, kann der Empfänger annehmen, dass die Nachricht während der Übertragung nicht geändert wurde. Beachten Sie, dass eine Signatur von jedem überprüft werden kann, da der öffentliche Schlüssel des Absenders allgemein bekannt ist.  
  
> [!IMPORTANT]
> Neuere asymmetrische Algorithmen sind verfügbar. Verwenden Sie ggf. die <xref:System.Security.Cryptography.RSA> Klasse oder die Klasse <xref:System.Security.Cryptography.ECDsa> anstelle der Klasse <xref:System.Security.Cryptography.DSA>. Verwenden Sie <xref:System.Security.Cryptography.DSA> nur aus Gründen der Kompatibilität mit Legacy Anwendungen und-Daten.  
  
 Zwei verschiedene Versionen des DSA-Algorithmus sind vorhanden.
Das ursprüngliche Formular, das in der Datei "fps 186-2" beschrieben wird, erfordert die Verwendung von SHA-1 als Hash Algorithmus und unterstützt Schlüssellängen von 512 Bits bis 1024 Bits in Schritten von 64 Bits.
Eine aktualisierte Version des Algorithmus wurde in "fps 186-3" beschrieben, die die Verwendung der SHA-2-Familie von Hash Algorithmen und die Unterstützung von 2048-Bit-Schlüsseln und 3072-Bit-Schlüsseln ermöglichte.
Nicht alle abgeleiteten Implementierungen dieses Typs unterstützen die Erweiterungen von "PPS 186-3" an DSA. Unterstützung kann über die <xref:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes>-Eigenschaft erkannt werden.
 
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DSA ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.#ctor" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DSA();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.DSA" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein Kryptografieobjekt zum Ausführen des asymmetrischen Algorithmus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.DSA Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.DSA Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As DSA" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::DSA ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Security.Cryptography.DSA" Usage="System.Security.Cryptography.DSA.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.DSA</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt das Standardkryptografieobjekt zum Ausführen des asymmetrischen Algorithmus.</summary>
        <returns>Ein Kryptografieobjekt zum Ausführen des asymmetrischen Algorithmus.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.DSA Create (int keySizeInBits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.DSA Create(int32 keySizeInBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.Create(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (keySizeInBits As Integer) As DSA" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::DSA ^ Create(int keySizeInBits);" />
      <MemberSignature Language="F#" Value="static member Create : int -&gt; System.Security.Cryptography.DSA" Usage="System.Security.Cryptography.DSA.Create keySizeInBits" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.DSA</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keySizeInBits" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="keySizeInBits">Die Schlüsselgröße in Bits.</param>
        <summary>Erstellt einen neuen kurzlebigen DSA-Schlüssel mit der angegebenen Schlüsselgröße.</summary>
        <returns>Ein neuer kurzlebiger DSA-Schlüssel mit der angegebenen Schlüsselgröße.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="keySizeInBits" /> wird von <see cref="P:System.Security.Cryptography.AsymmetricAlgorithm.LegalKeySizes" /> nicht zugelassen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.DSA Create (System.Security.Cryptography.DSAParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.DSA Create(valuetype System.Security.Cryptography.DSAParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.Create(System.Security.Cryptography.DSAParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (parameters As DSAParameters) As DSA" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::DSA ^ Create(System::Security::Cryptography::DSAParameters parameters);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.DSAParameters -&gt; System.Security.Cryptography.DSA" Usage="System.Security.Cryptography.DSA.Create parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.DSA</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.DSAParameters" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="parameters">Die Parameter für den <see cref="T:System.Security.Cryptography.DSA" />-Algorithmus.</param>
        <summary>Erstellt einen neuen kurzlebigen DSA-Schlüssel mit den angegebenen DSA-Schlüsselparametern.</summary>
        <returns>Ein neuer kurzlebiger DSA-Schlüssel.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.DSA Create (string algName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.DSA Create(string algName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algName As String) As DSA" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::DSA ^ Create(System::String ^ algName);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Security.Cryptography.DSA" Usage="System.Security.Cryptography.DSA.Create algName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.DSA</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="algName">Der Name der spezifischen Implementierung von <see cref="T:System.Security.Cryptography.DSA" />, die verwendet werden soll.</param>
        <summary>Erstellt das angegebene Kryptografieobjekt zum Ausführen des asymmetrischen Algorithmus.</summary>
        <returns>Ein Kryptografieobjekt zum Ausführen des asymmetrischen Algorithmus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie für <xref:System.Security.Cryptography.DSA>den Namen System. Security. Cryptography. DSA.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName="CreateSignature">
      <MemberSignature Language="C#" Value="public abstract byte[] CreateSignature (byte[] rgbHash);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] CreateSignature(unsigned int8[] rgbHash) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.CreateSignature(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateSignature (rgbHash As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Byte&gt; ^ CreateSignature(cli::array &lt;System::Byte&gt; ^ rgbHash);" />
      <MemberSignature Language="F#" Value="abstract member CreateSignature : byte[] -&gt; byte[]" Usage="dSA.CreateSignature rgbHash" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbHash" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgbHash">Der Hashwert, der signiert werden soll.</param>
        <summary>Erstellt beim Überschreiben in einer abgeleiteten Klasse die <see cref="T:System.Security.Cryptography.DSA" />-Signatur für die angegebenen Hashdaten</summary>
        <returns>Die digitale Signatur für den angegebenen Hashwert.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.DSAParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.DSAParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ExportParameters (includePrivateParameters As Boolean) As DSAParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::Cryptography::DSAParameters ExportParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportParameters : bool -&gt; System.Security.Cryptography.DSAParameters" Usage="dSA.ExportParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.DSAParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
        <summary>Exportiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="T:System.Security.Cryptography.DSAParameters" />.</summary>
        <returns>Die Parameter für <see cref="T:System.Security.Cryptography.DSA" />.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public override void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXmlString(System::String ^ xmlString);" />
      <MemberSignature Language="F#" Value="override this.FromXmlString : string -&gt; unit" Usage="dSA.FromXmlString xmlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlString">Die XML-Zeichenfolge zur Wiederherstellung des <see cref="T:System.Security.Cryptography.DSA" />-Objekts.</param>
        <summary>Stellt ein <see cref="T:System.Security.Cryptography.DSA" />-Objekt aus einer XML-Zeichenfolge wieder her.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="xmlString" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Format des <paramref name="xmlString" />-Parameters ist nicht gültig.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="HashData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet den Hashwert von Binärdaten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HashData">
      <MemberSignature Language="C#" Value="protected virtual byte[] HashData (System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] HashData(class System.IO.Stream data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HashData (data As Stream, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ HashData(System::IO::Stream ^ data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member HashData : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]&#xA;override this.HashData : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="dSA.HashData (data, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data">Der binäre Datenstrom, für den der Hashwert berechnet werden soll.</param>
        <param name="hashAlgorithm">Der Algorithmus, der zum Bestimmen des Hashwerts der Daten verwendet werden soll.</param>
        <summary>Berechnet, falls in einer abgeleiteten Klasse überschrieben, den Hashwert eines angegebenen Binärdatenstroms mithilfe eines angegebenen Hashalgorithmus.</summary>
        <returns>Die Daten, für die der Hashwert berechnet wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashData">
      <MemberSignature Language="C#" Value="protected virtual byte[] HashData (byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] HashData(unsigned int8[] data, int32 offset, int32 count, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HashData (data As Byte(), offset As Integer, count As Integer, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual cli::array &lt;System::Byte&gt; ^ HashData(cli::array &lt;System::Byte&gt; ^ data, int offset, int count, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member HashData : byte[] * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]&#xA;override this.HashData : byte[] * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="dSA.HashData (data, offset, count, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data">Die Daten, für die der Hashwert berechnet werden soll.</param>
        <param name="offset">Der Index des ersten Bytes in <paramref name="data" />, für das der Hashwert berechnet werden soll.</param>
        <param name="count">Die Anzahl der Bytes, für die der Hashwert berechnet werden soll.</param>
        <param name="hashAlgorithm">Der Algorithmus, der zum Bestimmen des Hashwerts der Daten verwendet werden soll.</param>
        <summary>Berechnet, falls in einer abgeleiteten Klasse überschrieben, den Hashwert eines angegebenen Teils eines Bytearrays mithilfe eines angegebenen Hashalgorithmus.</summary>
        <returns>Die Daten, für die der Hashwert berechnet wurde.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">Eine abgeleitete Klasse muss diese Methode überschreiben.</exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (passwordBytes As ReadOnlySpan(Of Byte), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="dSA.ImportEncryptedPkcs8PrivateKey (passwordBytes, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="passwordBytes">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</param>
        <param name="source">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
        <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem bytebasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kenn Wort Bytes werden direkt an die kdf (Key derivations Function) übergeben, die vom Algorithmus verwendet wird, der durch den verschlüsseltedprivatekeyinfo-Inhalt angegeben wird.
Dadurch wird die Kompatibilität mit anderen Systemen ermöglicht, bei denen bei der Verarbeitung von Kenn Wörtern mit PBKDF2 eine andere Text Codierung als UTF-8 verwendet wird (Kenn Wort basierte Schlüssel abderivations Funktion 2).
Diese Methode unterstützt nur die binäre Codierung (ber/CER/der) von "verschlüsseltedprivatekeyinfo".
Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass die anzuwendende Schlüsselableitungsfunktion die Legacy-PKCS#12-KDF ist, die <see cref="T:System.Char" />-basierte Kennwörter erfordert.

- oder -

Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (password As ReadOnlySpan(Of Char), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="dSA.ImportEncryptedPkcs8PrivateKey (password, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="password">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
        <param name="source">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
        <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem zeichenbasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Inhalt `source` einen Algorithmus angibt, der PBKDF1 (Kenn Wort basierte Schlüssel abderivations Funktion 1) oder PBKDF2 (Kenn Wort basierte Schlüssel abderivations Funktion 2) verwendet, wird das Kennwort über die UTF-8-Codierung in Bytes konvertiert.
Diese Methode unterstützt nur die binäre Codierung (ber/CER/der) von "verschlüsseltedprivatekeyinfo".
Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Das Kennwort ist falsch.

- oder -

Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public abstract void ImportParameters (System.Security.Cryptography.DSAParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportParameters(valuetype System.Security.Cryptography.DSAParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.ImportParameters(System.Security.Cryptography.DSAParameters)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ImportParameters (parameters As DSAParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ImportParameters(System::Security::Cryptography::DSAParameters parameters);" />
      <MemberSignature Language="F#" Value="abstract member ImportParameters : System.Security.Cryptography.DSAParameters -&gt; unit" Usage="dSA.ImportParameters parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.DSAParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">Die Parameter für <see cref="T:System.Security.Cryptography.DSA" />.</param>
        <summary>Importiert beim Überschreiben in einer abgeleiteten Klasse die angegebenen <see cref="T:System.Security.Cryptography.DSAParameters" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">In <paramref name="parameters" /> fehlen Pflichtfelder.

- oder -

<paramref name="parameters" /> weist Felder mit inkonsistenten Längen für einen gültigen Schlüssel auf.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="parameters" /> stellt keinen gültigen DSA-Schlüsselparametersatz dar.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName="ImportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportPkcs8PrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="dSA.ImportPkcs8PrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="source">Die Bytes einer PKCS#8-PrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</param>
        <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-PrivateKeyInfo-Struktur nach der Entschlüsselung und ersetzt die Schlüssel für dieses Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nur die binäre Codierung (ber/CER/der) von privatekeyinfo.
Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-PrivateKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
      </Docs>
    </Member>
    <Member MemberName="ImportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override void ImportSubjectPublicKeyInfo (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportSubjectPublicKeyInfo(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportSubjectPublicKeyInfo (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportSubjectPublicKeyInfo(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportSubjectPublicKeyInfo : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="dSA.ImportSubjectPublicKeyInfo (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="source">Die Bytes einer X.509-SubjectPublicKeyInfo-Struktur in der ASN.1-DER-Codierung.</param>
        <param name="bytesRead">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Importiert den öffentlichen Schlüssel aus einer X.509-SubjectPublicKeyInfo-Struktur nach der Entschlüsselung und ersetzt dabei die Schlüssel für dieses Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode unterstützt nur die binäre Codierung (der) von "subjetpublickeyinfo".
Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-DER-codierte X.509-SubjectPublicKeyInfo-Struktur dar.

- oder -

Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.

- oder -

Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.

- oder -

Fehler beim Importieren des algorithmusspezifischen Schlüssels.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Berechnet den Hashwert der angegebenen Daten und signiert ihn.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (byte[] data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(unsigned int8[] data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Function SignData (data As Byte(), hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ SignData(cli::array &lt;System::Byte&gt; ^ data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.SignData : byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="dSA.SignData (data, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data">Die Eingabedaten, für die der Hashwert berechnet werden soll.</param>
        <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
        <summary>Berechnet den Hashwert des angegebenen Bytearrays mithilfe des angegebenen Hashalgorithmus und signiert den resultierenden Hashwert.</summary>
        <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="data" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public virtual byte[] SignData (System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] SignData(class System.IO.Stream data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SignData (data As Stream, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ SignData(System::IO::Stream ^ data, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member SignData : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]&#xA;override this.SignData : System.IO.Stream * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="dSA.SignData (data, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data">Der Eingabedatenstrom, für den der Hashwert berechnet werden soll.</param>
        <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
        <summary>Berechnet den Hashwert des angegebenen Datenstroms mithilfe des angegebenen Hashalgorithmus und signiert den resultierenden Hashwert.</summary>
        <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="data" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public virtual byte[] SignData (byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] SignData(unsigned int8[] data, int32 offset, int32 count, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SignData (data As Byte(), offset As Integer, count As Integer, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ SignData(cli::array &lt;System::Byte&gt; ^ data, int offset, int count, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member SignData : byte[] * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]&#xA;override this.SignData : byte[] * int * int * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="dSA.SignData (data, offset, count, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data">Die Eingabedaten, für die der Hashwert berechnet werden soll.</param>
        <param name="offset">Der Offset im Array, ab dem Daten verwendet werden sollen.</param>
        <param name="count">Die Anzahl der Bytes im Array, die als Daten verwendet werden sollen.</param>
        <param name="hashAlgorithm">Der zum Erstellen des Hashwerts zu verwendende Hashalgorithmus.</param>
        <summary>Berechnet den Hashwert eines Teils des angegebenen Bytearrays mithilfe des angegebenen Hashalgorithmus und signiert den sich ergebenden Hashwert.</summary>
        <returns>Die DSA-Signatur für die angegebenen Daten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="data" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="offset" /> + <paramref name="count" /> – 1 resultiert in einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public override string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="override this.ToXmlString : bool -&gt; string" Usage="dSA.ToXmlString includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</param>
        <summary>Erstellt eine XML-Zeichenfolgendarstellung des aktuellen <see cref="T:System.Security.Cryptography.DSA" />-Objekts und gibt diese zurück.</summary>
        <returns>Eine XML-Zeichenfolgencodierung des aktuellen <see cref="T:System.Security.Cryptography.DSA" />-Objekts.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName="TryCreateSignature">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateSignature (ReadOnlySpan&lt;byte&gt; hash, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateSignature(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; hash, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.TryCreateSignature(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateSignature (hash As ReadOnlySpan(Of Byte), destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateSignature(ReadOnlySpan&lt;System::Byte&gt; hash, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateSignature : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * int -&gt; bool&#xA;override this.TryCreateSignature : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * int -&gt; bool" Usage="dSA.TryCreateSignature (hash, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="hash">Der zu signierende Hash.</param>
        <param name="destination">Die Bytespanne, die die Signatur empfangen soll.</param>
        <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</param>
        <summary>Versucht, die DSA-Signatur für den angegebenen Hash im angegebenen Puffer zu erstellen.</summary>
        <returns><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, das Ergebnis zu empfangen. Andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode besteht darin, <xref:System.Security.Cryptography.DSA.CreateSignature(System.Byte[])> aufzurufen und das Ergebnis in `destination`zu kopieren.
Abgeleitete Typen sollten diese Methode überschreiben, um die Erstellung von zwischen Arrays zu vermeiden.
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Diese Instanz stellt nur einen öffentlichen Schlüssel dar.

- oder -

Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und <paramref name="hash" /> ist kein 20-Byte-Wert.

- oder -

Die Erstellung der Signatur schlägt andernfalls fehl.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; * int -&gt; bool" Usage="dSA.TryExportEncryptedPkcs8PrivateKey (passwordBytes, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="passwordBytes">Die Bytes, die als Kennwort bei der Verschlüsselung des Schlüsselmaterials verwendet werden.</param>
        <param name="pbeParameters">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</param>
        <param name="destination">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</param>
        <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem bytebasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</summary>
        <returns><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kenn Wort Bytes werden direkt an die kdf (Key derivations Function) übergeben, die vom Algorithmus verwendet wird, der durch `pbeParameters`angegeben wird.
Dadurch wird die Kompatibilität mit anderen Systemen ermöglicht, bei denen bei der Verarbeitung von Kenn Wörtern mit PBKDF2 eine andere Text Codierung als UTF-8 verwendet wird (Kenn Wort basierte Schlüssel abderivations Funktion 2).
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.

- oder -

<paramref name="pbeParameters" /> gibt an, dass <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> verwendet werden soll, wofür <see cref="T:System.Char" />-basierte Kennwörter erforderlich sind.</exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; * int -&gt; bool" Usage="dSA.TryExportEncryptedPkcs8PrivateKey (password, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="password">Das Kennwort, das bei der Verschlüsselung des Schlüsselmaterials verwendet werden soll.</param>
        <param name="pbeParameters">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</param>
        <param name="destination">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</param>
        <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem zeichenbasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</summary>
        <returns><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `pbeParameters` einen Algorithmus angibt, der PBKDF2 (Kenn Wort basierte Schlüssel abderivations Funktion 2) verwendet, wird das Kennwort über die UTF-8-Codierung in Bytes konvertiert.
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportPkcs8PrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportPkcs8PrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportPkcs8PrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportPkcs8PrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportPkcs8PrivateKey : Span&lt;byte&gt; * int -&gt; bool" Usage="dSA.TryExportPkcs8PrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">Die Bytespanne, in der die PKCS#8-PrivateKeyInfo-Daten empfangen werden sollen.</param>
        <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Versucht, den aktuellen Schlüssel im PKCS#8-PrivateKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</summary>
        <returns><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override bool TryExportSubjectPublicKeyInfo (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportSubjectPublicKeyInfo(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportSubjectPublicKeyInfo (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportSubjectPublicKeyInfo(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportSubjectPublicKeyInfo : Span&lt;byte&gt; * int -&gt; bool" Usage="dSA.TryExportSubjectPublicKeyInfo (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination">Die Bytespanne, in der die X.509-SubjectPublicKeyInfo-Daten empfangen werden sollen.</param>
        <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Versucht, den aktuellen Schlüssel im X.509-SubjectPublicKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</summary>
        <returns><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Schlüssel konnte nicht exportiert werden.</exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportSubjectPublicKeyInfo" />
      </Docs>
    </Member>
    <Member MemberName="TryHashData">
      <MemberSignature Language="C#" Value="protected virtual bool TryHashData (ReadOnlySpan&lt;byte&gt; data, Span&lt;byte&gt; destination, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryHashData(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.TryHashData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function TryHashData (data As ReadOnlySpan(Of Byte), destination As Span(Of Byte), hashAlgorithm As HashAlgorithmName, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool TryHashData(ReadOnlySpan&lt;System::Byte&gt; data, Span&lt;System::Byte&gt; destination, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryHashData : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * int -&gt; bool&#xA;override this.TryHashData : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * int -&gt; bool" Usage="dSA.TryHashData (data, destination, hashAlgorithm, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="data">Die Daten, für die der Hashwert berechnet werden soll.</param>
        <param name="destination">Die Bytespanne, die den Hashwert empfangen soll.</param>
        <param name="hashAlgorithm">Der Name des zu verwendeten Hash-Algorithmus.</param>
        <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</param>
        <summary>Versucht, den Hashwert der angegebenen Daten in einen angegebenen Puffer zu berechnen.</summary>
        <returns><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, das Ergebnis zu empfangen. Andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Die Standard Implementierung dieser Methode besteht darin, <xref:System.Security.Cryptography.DSA.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)> aufzurufen und das Ergebnis in `destination`zu kopieren.

Abgeleitete Typen sollten diese Methode überschreiben, um die Erstellung von zwischen Arrays zu vermeiden.
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySignData">
      <MemberSignature Language="C#" Value="public virtual bool TrySignData (ReadOnlySpan&lt;byte&gt; data, Span&lt;byte&gt; destination, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySignData(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.Span`1&lt;unsigned int8&gt; destination, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.TrySignData(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySignData (data As ReadOnlySpan(Of Byte), destination As Span(Of Byte), hashAlgorithm As HashAlgorithmName, ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySignData(ReadOnlySpan&lt;System::Byte&gt; data, Span&lt;System::Byte&gt; destination, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TrySignData : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * int -&gt; bool&#xA;override this.TrySignData : ReadOnlySpan&lt;byte&gt; * Span&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * int -&gt; bool" Usage="dSA.TrySignData (data, destination, hashAlgorithm, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="data">Die Daten, die gehasht und signiert werden sollen.</param>
        <param name="destination">Die Bytespanne, die die Signatur empfangen soll.</param>
        <param name="hashAlgorithm">Der Name des zu verwendeten Hash-Algorithmus.</param>
        <param name="bytesWritten">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</param>
        <summary>Versucht, die DSA-Signatur für die angegebenen Daten im angegebenen Puffer zu erstellen.</summary>
        <returns><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, das Ergebnis zu empfangen. Andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VerifyData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Überprüft, ob eine digitale Signatur gültig ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public bool VerifyData (byte[] data, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyData(unsigned int8[] data, unsigned int8[] signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyData (data As Byte(), signature As Byte(), hashAlgorithm As HashAlgorithmName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyData(cli::array &lt;System::Byte&gt; ^ data, cli::array &lt;System::Byte&gt; ^ signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.VerifyData : byte[] * byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; bool" Usage="dSA.VerifyData (data, signature, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="signature" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data">Die signierten Daten.</param>
        <param name="signature">Die zu überprüfenden Signaturdaten.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
        <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert der angegebenen Daten unter Verwendung des angegebenen Hashalgorithmus und durch Vergleichen mit der angegebenen Signatur berechnet wird.</summary>
        <returns><see langword="true" />, wenn die digitale Signatur gültig ist; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="data" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="signature" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashalgorithmus ist nicht SHA-1.

- oder -

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public virtual bool VerifyData (System.IO.Stream data, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool VerifyData(class System.IO.Stream data, unsigned int8[] signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function VerifyData (data As Stream, signature As Byte(), hashAlgorithm As HashAlgorithmName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool VerifyData(System::IO::Stream ^ data, cli::array &lt;System::Byte&gt; ^ signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member VerifyData : System.IO.Stream * byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; bool&#xA;override this.VerifyData : System.IO.Stream * byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; bool" Usage="dSA.VerifyData (data, signature, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="signature" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data">Die signierten Daten.</param>
        <param name="signature">Die zu überprüfenden Signaturdaten.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
        <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert des angegebenen Datenstroms unter Verwendung des angegebenen Hashalgorithmus und durch Vergleichen mit der angegebenen Signatur berechnet wird.</summary>
        <returns><see langword="true" />, wenn die digitale Signatur gültig ist; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="data" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="signature" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashalgorithmus ist nicht SHA-1.

- oder -

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public virtual bool VerifyData (ReadOnlySpan&lt;byte&gt; data, ReadOnlySpan&lt;byte&gt; signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool VerifyData(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.VerifyData(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function VerifyData (data As ReadOnlySpan(Of Byte), signature As ReadOnlySpan(Of Byte), hashAlgorithm As HashAlgorithmName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool VerifyData(ReadOnlySpan&lt;System::Byte&gt; data, ReadOnlySpan&lt;System::Byte&gt; signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member VerifyData : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName -&gt; bool&#xA;override this.VerifyData : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName -&gt; bool" Usage="dSA.VerifyData (data, signature, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="signature" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="data">Die signierten Daten.</param>
        <param name="signature">Die zu überprüfende Signatur.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
        <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert der Daten in einer Bytespanne unter Verwendung des angegebenen Hashalgorithmus und durch Vergleichen mit der angegebenen Signatur berechnet wird.</summary>
        <returns><see langword="true" />, wenn die digitale Signatur gültig ist; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashalgorithmus ist nicht SHA-1.

- oder -

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public virtual bool VerifyData (byte[] data, int offset, int count, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool VerifyData(unsigned int8[] data, int32 offset, int32 count, unsigned int8[] signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function VerifyData (data As Byte(), offset As Integer, count As Integer, signature As Byte(), hashAlgorithm As HashAlgorithmName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool VerifyData(cli::array &lt;System::Byte&gt; ^ data, int offset, int count, cli::array &lt;System::Byte&gt; ^ signature, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="abstract member VerifyData : byte[] * int * int * byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; bool&#xA;override this.VerifyData : byte[] * int * int * byte[] * System.Security.Cryptography.HashAlgorithmName -&gt; bool" Usage="dSA.VerifyData (data, offset, count, signature, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="signature" Type="System.Byte[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="data">Die signierten Daten.</param>
        <param name="offset">Der Startindex, an dem der Hashwert berechnet werden soll.</param>
        <param name="count">Die Anzahl der Bytes, für die der Hashwert berechnet werden soll.</param>
        <param name="signature">Die zu überprüfenden Signaturdaten.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus, der zum Erstellen des Hashwerts der Daten verwendet wird.</param>
        <summary>Überprüft, ob eine digitale Signatur gültig ist, indem der Hashwert der Daten in einem Teil eines Bytearrays unter Verwendung des angegebenen Hashalgorithmus und durch Vergleichen mit der angegebenen Signatur berechnet wird.</summary>
        <returns><see langword="true" />, wenn die digitale Signatur gültig ist; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="data" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="signature" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="count" /> ist kleiner als Null.  
  
- oder - 
 <paramref name="offset" /> + <paramref name="count" /> – 1 resultiert in einem Index, der größer als die Obergrenze von <paramref name="data" /> ist.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashalgorithmus ist nicht SHA-1.

- oder -

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifySignature">
      <MemberSignature Language="C#" Value="public abstract bool VerifySignature (byte[] rgbHash, byte[] rgbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool VerifySignature(unsigned int8[] rgbHash, unsigned int8[] rgbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.VerifySignature(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function VerifySignature (rgbHash As Byte(), rgbSignature As Byte()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool VerifySignature(cli::array &lt;System::Byte&gt; ^ rgbHash, cli::array &lt;System::Byte&gt; ^ rgbSignature);" />
      <MemberSignature Language="F#" Value="abstract member VerifySignature : byte[] * byte[] -&gt; bool" Usage="dSA.VerifySignature (rgbHash, rgbSignature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbHash" Type="System.Byte[]" />
        <Parameter Name="rgbSignature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgbHash">Der Hash der mit <paramref name="rgbSignature" /> signierten Daten.</param>
        <param name="rgbSignature">Die für <c>rgbData</c> zu überprüfende Signatur.</param>
        <summary>Überprüft beim Überschreiben in einer abgeleiteten Klasse die <see cref="T:System.Security.Cryptography.DSA" />-Signatur für die angegebenen Daten.</summary>
        <returns><see langword="true" />, wenn <paramref name="rgbSignature" /> der Signatur entspricht, die mit dem angegebenen Hashalgorithmus und Schlüssel für <paramref name="rgbHash" /> berechnet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashwert ist keine 20 Byte lang.

- oder -

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md">Kryptografische Dienste</related>
      </Docs>
    </Member>
    <Member MemberName="VerifySignature">
      <MemberSignature Language="C#" Value="public virtual bool VerifySignature (ReadOnlySpan&lt;byte&gt; hash, ReadOnlySpan&lt;byte&gt; signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool VerifySignature(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; hash, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.DSA.VerifySignature(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function VerifySignature (hash As ReadOnlySpan(Of Byte), signature As ReadOnlySpan(Of Byte)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool VerifySignature(ReadOnlySpan&lt;System::Byte&gt; hash, ReadOnlySpan&lt;System::Byte&gt; signature);" />
      <MemberSignature Language="F#" Value="abstract member VerifySignature : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; -&gt; bool&#xA;override this.VerifySignature : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; -&gt; bool" Usage="dSA.VerifySignature (hash, signature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="signature" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="hash">Der zu überprüfende Datenhash.</param>
        <param name="signature">Die zu überprüfende Signatur.</param>
        <summary>Überprüft, ob eine digitale Signatur für einen angegebenen Datenhash gültig ist.</summary>
        <returns><see langword="true" />, wenn die digitale Signatur für den Hash gültig ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung dieser Methode ruft <xref:System.Security.Cryptography.DSA.VerifySignature(System.Byte[],System.Byte[])> nach dem Kopieren der spannen auf Arrays auf.
Abgeleitete Typen sollten diese Methode überschreiben, um die Erstellung von zwischen Arrays zu vermeiden.
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Der Implementierungstyp unterstützt nur den Legacy-DSA (Digital Signature Algorithm, Digitaler Signaturalgorithmus) FIPS 186-2, und der Hashwert ist keine 20 Byte lang.

- oder -

Die Verifizierung der Signatur schlägt andernfalls fehl.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
