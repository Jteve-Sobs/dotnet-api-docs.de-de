<Type Name="ECDiffieHellmanKeyDerivationFunction" FullName="System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a12324aa7080800b67a5c188c483c03abd8a7136" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30495394" />
  </Metadata>
  <TypeSignature Language="C#" Value="public enum ECDiffieHellmanKeyDerivationFunction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed ECDiffieHellmanKeyDerivationFunction extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction" />
  <TypeSignature Language="VB.NET" Value="Public Enum ECDiffieHellmanKeyDerivationFunction" />
  <TypeSignature Language="C++ CLI" Value="public enum class ECDiffieHellmanKeyDerivationFunction" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Gibt die Schlüsselableitungsfunktion an, die die <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />-Klasse zum Konvertieren von Geheimverträgen in das Schlüsselmaterial verwendet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction> -Enumeration definiert den Typ des Algorithmus, der verwendet wird, um eine unformatierte Geheimvertrag in Schlüsselmaterial zu transformieren. Der Geheimvertrag ist der Wert, der aus einem privaten Schlüssel und den öffentlichen Schlüssel der anderen Partei als Teil des Schlüsselaustauschs generiert wird. Es ist der Startwert für das Schlüsselmaterial, das von generiert wird die <xref:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyMaterial%2A> Methode.  
  
 Die <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> Eigenschaft verwendet diese Enumeration zum Abrufen der Schlüsselableitungsfunktion für die <xref:System.Security.Cryptography.ECDiffieHellmanCng> Klasse.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Hash">
      <MemberSignature Language="C#" Value="Hash" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction Hash = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />
      <MemberSignature Language="VB.NET" Value="Hash" />
      <MemberSignature Language="C++ CLI" Value="Hash" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Ein Hashalgorithmus wird verwendet, um Schlüsselmaterial zu generieren. Die <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm" />-Eigenschaft gibt den Namen des zu verwendenden Algorithmus an. Wenn der Algorithmusname nicht angegeben ist, wird <see cref="T:System.Security.Cryptography.SHA256" /> als Standardalgorithmus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch angeben, die <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend%2A> und <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend%2A> Eigenschaften, aber sie sind nicht erforderlich.  
  
 Die Menge an Schlüsselmaterial, das generiert wird, entspricht die Größe des den Hashwert für den angegebenen Algorithmus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hmac">
      <MemberSignature Language="C#" Value="Hmac" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction Hmac = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" />
      <MemberSignature Language="VB.NET" Value="Hmac" />
      <MemberSignature Language="C++ CLI" Value="Hmac" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Zum Generieren des Schlüsselmaterials wird ein HMAC (Hash-based Message Authentication Code)-Algorithmus verwendet. Die <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.HmacKey" />-Eigenschaft gibt den zu verwendenden Schlüssel an. Entweder muss diese Eigenschaft oder die <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.UseSecretAgreementAsHmacKey" />-Eigenschaft auf <see langword="true" /> festgelegt werden. Andernfalls wird eine <see cref="T:System.Security.Cryptography.CryptographicException" /> ausgelöst, sobald Sie <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" /> verwenden. Wenn beide Eigenschaften festgelegt sind, wird der Geheimvertrag als HMAC-Schlüssel verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch angeben, die <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend%2A> und <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend%2A> Eigenschaften, aber sie sind nicht erforderlich.  
  
 Die Menge an Schlüsselmaterial, das generiert wird, entspricht die Größe des HMAC-Werts.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tls">
      <MemberSignature Language="C#" Value="Tls" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction Tls = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />
      <MemberSignature Language="VB.NET" Value="Tls" />
      <MemberSignature Language="C++ CLI" Value="Tls" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Zum Generieren des Schlüsselmaterials wird das TLS (Transport Layer Security)-Protokoll verwendet. Die <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" />-Eigenschaft und die <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" />-Eigenschaft müssen festgelegt werden. Andernfalls wird eine <see cref="T:System.Security.Cryptography.CryptographicException" /> ausgelöst, sobald Sie <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" /> verwenden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert generiert 160 Bits Schlüsselmaterial.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>