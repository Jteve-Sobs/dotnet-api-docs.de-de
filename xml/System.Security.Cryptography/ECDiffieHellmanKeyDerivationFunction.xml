<Type Name="ECDiffieHellmanKeyDerivationFunction" FullName="System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fdd8f0c32815a2ae54ce1d4aba2c80d87252fb3c" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52594775" /></Metadata><TypeSignature Language="C#" Value="public enum ECDiffieHellmanKeyDerivationFunction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed ECDiffieHellmanKeyDerivationFunction extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction" />
  <TypeSignature Language="VB.NET" Value="Public Enum ECDiffieHellmanKeyDerivationFunction" />
  <TypeSignature Language="C++ CLI" Value="public enum class ECDiffieHellmanKeyDerivationFunction" />
  <TypeSignature Language="F#" Value="type ECDiffieHellmanKeyDerivationFunction = " />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Cng</AssemblyName>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary>Gibt die Schlüsselableitungsfunktion an, die die <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" />-Klasse zum Konvertieren von Geheimverträgen in das Schlüsselmaterial verwendet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction> -Enumeration definiert den Typ des Algorithmus, der zum Transformieren eines unformatierten Geheimvertrags in das Schlüsselmaterial verwendet wird. Der Geheimvertrag ist der Wert, der als Teil der Schlüsselaustausch über einen privaten Schlüssel und den öffentlichen Schlüssel der anderen Partei, generiert wird. Es ist der Startwert für das Schlüsselmaterial, die vom generierten der <xref:System.Security.Cryptography.ECDiffieHellmanCng.DeriveKeyMaterial%2A> Methode.  
  
 Die <xref:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction%2A> Eigenschaft verwendet diese Enumeration zum Abrufen der Schlüsselableitungsfunktion für die <xref:System.Security.Cryptography.ECDiffieHellmanCng> Klasse.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Hash">
      <MemberSignature Language="C#" Value="Hash" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction Hash = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />
      <MemberSignature Language="VB.NET" Value="Hash" />
      <MemberSignature Language="C++ CLI" Value="Hash" />
      <MemberSignature Language="F#" Value="Hash = 0" Usage="System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Cng</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Ein Hashalgorithmus wird verwendet, um Schlüsselmaterial zu generieren. Die <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm" />-Eigenschaft gibt den Namen des zu verwendenden Algorithmus an. Wenn der Algorithmusname nicht angegeben ist, wird <see cref="T:System.Security.Cryptography.SHA256" /> als Standardalgorithmus verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch angeben, die <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend%2A> und <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend%2A> Eigenschaften, aber sie sind nicht erforderlich.  
  
 Die Menge an das Schlüsselmaterial ab, das generiert wird, entspricht die Größe des Hashwerts für den angegebenen Algorithmus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Hmac">
      <MemberSignature Language="C#" Value="Hmac" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction Hmac = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" />
      <MemberSignature Language="VB.NET" Value="Hmac" />
      <MemberSignature Language="C++ CLI" Value="Hmac" />
      <MemberSignature Language="F#" Value="Hmac = 1" Usage="System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Cng</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Zum Generieren des Schlüsselmaterials wird ein HMAC (Hash-based Message Authentication Code)-Algorithmus verwendet. Die <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.HmacKey" />-Eigenschaft gibt den zu verwendenden Schlüssel an. Entweder muss diese Eigenschaft oder die <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.UseSecretAgreementAsHmacKey" />-Eigenschaft auf <see langword="true" /> festgelegt werden. Andernfalls wird eine <see cref="T:System.Security.Cryptography.CryptographicException" /> ausgelöst, sobald Sie <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" /> verwenden. Wenn beide Eigenschaften festgelegt sind, wird der Geheimvertrag als HMAC-Schlüssel verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können auch angeben, die <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretPrepend%2A> und <xref:System.Security.Cryptography.ECDiffieHellmanCng.SecretAppend%2A> Eigenschaften, aber sie sind nicht erforderlich.  
  
 Die Menge an das Schlüsselmaterial ab, das generiert wird, entspricht die Größe des HMAC-Werts.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tls">
      <MemberSignature Language="C#" Value="Tls" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction Tls = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />
      <MemberSignature Language="VB.NET" Value="Tls" />
      <MemberSignature Language="C++ CLI" Value="Tls" />
      <MemberSignature Language="F#" Value="Tls = 2" Usage="System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Cng</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Zum Generieren des Schlüsselmaterials wird das TLS (Transport Layer Security)-Protokoll verwendet. Die <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" />-Eigenschaft und die <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" />-Eigenschaft müssen festgelegt werden. Andernfalls wird eine <see cref="T:System.Security.Cryptography.CryptographicException" /> ausgelöst, sobald Sie <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" /> verwenden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird generiert, 160 Bits des Schlüsselmaterials.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>