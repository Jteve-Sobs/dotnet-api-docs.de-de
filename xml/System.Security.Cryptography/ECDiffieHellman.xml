<Type Name="ECDiffieHellman" FullName="System.Security.Cryptography.ECDiffieHellman">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9671731e62856b95f63a66b89ef9ed8f02c4b144" /><Meta Name="ms.sourcegitcommit" Value="33529b5cc32683b91d3422992fb4dc422f85782b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/17/2020" /><Meta Name="ms.locfileid" Value="88265318" /></Metadata><TypeSignature Language="C#" Value="public abstract class ECDiffieHellman : System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ECDiffieHellman extends System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ECDiffieHellman&#xA;Inherits AsymmetricAlgorithm" />
  <TypeSignature Language="C++ CLI" Value="public ref class ECDiffieHellman abstract : System::Security::Cryptography::AsymmetricAlgorithm" />
  <TypeSignature Language="F#" Value="type ECDiffieHellman = class&#xA;    inherit AsymmetricAlgorithm" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
    <AssemblyVersion>4.3.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Security.Cryptography.Algorithms" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Security.Cryptography.AsymmetricAlgorithm</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="3ea37-101">Stellt eine abstrakte Basisklasse bereit, von der Implementierungen des ECDH (Elliptic Curve Diffie-Hellman)-Algorithmus abgeleitet werden können.</span><span class="sxs-lookup"><span data-stu-id="3ea37-101">Provides an abstract base class that Elliptic Curve Diffie-Hellman (ECDH) algorithm implementations can derive from.</span></span> <span data-ttu-id="3ea37-102">Diese Klasse stellt einen grundlegenden Satz an Operationen bereit, den alle ECDH-Implementierungen unterstützen müssen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-102">This class provides the basic set of operations that all ECDH implementations must support.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-103">Diese Klasse fungiert als abstrakte Basisklasse für ECDH-Implementierungen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-103">This class serves as the abstract base class for ECDH implementations.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ECDiffieHellman ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ECDiffieHellman();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3ea37-104">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="3ea37-104">Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-105">Dieser Konstruktor wird von Klassen aufgerufen, die von der-Klasse abgeleitet werden <xref:System.Security.Cryptography.ECDiffieHellman> .</span><span class="sxs-lookup"><span data-stu-id="3ea37-105">This constructor is called by classes that derive from the <xref:System.Security.Cryptography.ECDiffieHellman> class.</span></span> <span data-ttu-id="3ea37-106">Die- <xref:System.Security.Cryptography.ECDiffieHellmanCng> Klasse ist die einzige Implementierung, die derzeit in enthalten ist [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="3ea37-106">The <xref:System.Security.Cryptography.ECDiffieHellmanCng> class is the only implementation that is currently included in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span> <span data-ttu-id="3ea37-107">Weitere Informationen zum Erstellen einer neuen Implementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman) finden Sie unter der- <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="3ea37-107">For information about how to create a new implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm, see the <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3ea37-108">Erstellt eine neue Instanz einer Implementierung des ECDH (Elliptic Curve Diffie-Hellman)-Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="3ea37-108">Creates a new instance of an implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3ea37-109">Erstellt eine neue Instanz der Standardimplementierung des ECDH (Elliptic Curve Diffie-Hellman)-Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="3ea37-109">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
        <returns><span data-ttu-id="3ea37-110">Eine neue Instanz der Standardimplementierung dieser Klasse.</span><span class="sxs-lookup"><span data-stu-id="3ea37-110">A new instance of the default implementation of this class.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (curve As ECCurve) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECCurve -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="curve"><span data-ttu-id="3ea37-111">Die Kurve, die für das Generieren eines neuen Paars aus privatem und öffentlichem Schlüssel verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-111">The curve to use to generate a new public/private key-pair.</span></span></param>
        <summary><span data-ttu-id="3ea37-112">Erstellt eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman) mit einem neuen Paar aus öffentlichem und privatem Schlüssel, das über die angegebene Kurve generiert wurde.</span><span class="sxs-lookup"><span data-stu-id="3ea37-112">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with a new public/private key-pair generated over the specified curve.</span></span></summary>
        <returns><span data-ttu-id="3ea37-113">Eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman).</span><span class="sxs-lookup"><span data-stu-id="3ea37-113">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-114">die Kurve muss überprüft werden (d. h., Sie muss "true" zurückgeben, wenn Sie an die <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> Methode</span><span class="sxs-lookup"><span data-stu-id="3ea37-114">curve must validate (that is, it must return true when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="3ea37-115">Merkmal-2-Kurven werden unter Windows nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-115">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-116"><paramref name="curve" /> führt keine Validierung durch.</span><span class="sxs-lookup"><span data-stu-id="3ea37-116"><paramref name="curve" /> does not validate.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (parameters As ECParameters) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECParameters -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="parameters"><span data-ttu-id="3ea37-117">Die Parameter für den ECC-Algorithmus (Elliptic Curve Cryptography)</span><span class="sxs-lookup"><span data-stu-id="3ea37-117">The parameters  for the elliptic curve cryptography (ECC) algorithm.</span></span></param>
        <summary><span data-ttu-id="3ea37-118">Erstellt eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman) mit dem Schlüssel, der im angegebenen <see cref="T:System.Security.Cryptography.ECParameters" />-Objekt beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-118">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with the key described by the specified  <see cref="T:System.Security.Cryptography.ECParameters" /> object.</span></span></summary>
        <returns><span data-ttu-id="3ea37-119">Eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman).</span><span class="sxs-lookup"><span data-stu-id="3ea37-119">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-120">`parameters` muss `true` bei der Übergabe an die-Methode validieren (d. h., Sie muss zurückgegeben werden) <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="3ea37-120">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3ea37-121">Parameter über implizite Kurven werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-121">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="3ea37-122">Merkmal-2-Kurven werden unter Windows nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-122">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-123"><paramref name="parameters" /> führt keine Validierung durch.</span><span class="sxs-lookup"><span data-stu-id="3ea37-123"><paramref name="parameters" /> does not validate.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman? Create (string algorithm);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(string algorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algorithm As String) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::String ^ algorithm);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create algorithm" />
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (string algorithm);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algorithm" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="algorithm"><span data-ttu-id="3ea37-124">Der Name einer Implementierung des ECDH-Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="3ea37-124">The name of an implementation of the ECDH algorithm.</span></span></param>
        <summary><span data-ttu-id="3ea37-125">Erstellt eine neue Instanz der angegebenen Implementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman)</span><span class="sxs-lookup"><span data-stu-id="3ea37-125">Creates a new instance of the specified implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
        <returns><span data-ttu-id="3ea37-126">Eine neue Instanz der angegebenen Implementierung dieser Klasse.</span><span class="sxs-lookup"><span data-stu-id="3ea37-126">A new instance of the specified implementation of this class.</span></span> <span data-ttu-id="3ea37-127">Wenn der angegebene Name des Algorithmus keiner ECDH-Implementierung zugeordnet ist, gibt diese Methode <see langword="null" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="3ea37-127">If the specified algorithm name does not map to an ECDH implementation, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-128">Wenn Sie Ihre eigene Implementierung eines Objekts entwickeln <xref:System.Security.Cryptography.ECDiffieHellman> , können Sie die- <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> Methoden Überladung verwenden, um eine benutzerdefinierte `algorithm` Zeichenfolge zu erstellen, die ihre Implementierung angibt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-128">If you develop your own implementation of an <xref:System.Security.Cryptography.ECDiffieHellman> object, you can use the <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> method overload to create a custom `algorithm` string that specifies your implementation.</span></span>  
  
 <span data-ttu-id="3ea37-129">Der- `algorithm` Parameter gibt den Namen einer Implementierung des ECDH-Algorithmus an.</span><span class="sxs-lookup"><span data-stu-id="3ea37-129">The `algorithm` parameter specifies the name of an implementation of the ECDH algorithm.</span></span> <span data-ttu-id="3ea37-130">Die folgenden Zeichenfolgen verweisen alle auf dieselbe Implementierung, bei der es sich um die einzige aktuell in [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] unterstützte Implementierung handelt:</span><span class="sxs-lookup"><span data-stu-id="3ea37-130">The following strings all refer to the same implementation, which is the only implementation currently supported in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]:</span></span>  
  
-   <span data-ttu-id="3ea37-131">"ECDH"</span><span class="sxs-lookup"><span data-stu-id="3ea37-131">"ECDH"</span></span>  
  
-   <span data-ttu-id="3ea37-132">"ECDiffieHellman"</span><span class="sxs-lookup"><span data-stu-id="3ea37-132">"ECDiffieHellman"</span></span>  
  
-   <span data-ttu-id="3ea37-133">"ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="3ea37-133">"ECDiffieHellmanCng"</span></span>  
  
-   <span data-ttu-id="3ea37-134">"System.Security.Cryptography.ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="3ea37-134">"System.Security.Cryptography.ECDiffieHellmanCng"</span></span>  
  
 <span data-ttu-id="3ea37-135">Sie können auch angeben, den Namen einer benutzerdefinierten ECDH-Implementierung für die `algorithm` Parameter.</span><span class="sxs-lookup"><span data-stu-id="3ea37-135">You can also provide the name of a custom ECDH implementation for the `algorithm` parameter.</span></span> <span data-ttu-id="3ea37-136">Wenn Sie dies tun, <xref:System.Security.Cryptography.CryptoConfig> wird es vom Objekt verwendet, um zu bestimmen, ob ein ECDH-Objekt erstellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="3ea37-136">If you do that, the <xref:System.Security.Cryptography.CryptoConfig> object will use it to determine whether an ECDH object can be created.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3ea37-137">Der <paramref name="algorithm" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-137">The <paramref name="algorithm" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHash">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3ea37-138">Führt die Schlüsselableitung mithilfe eines angegebenen Hashalgorithmus aus</span><span class="sxs-lookup"><span data-stu-id="3ea37-138">Performs key derivation using a specified hash algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="3ea37-139">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="3ea37-139">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="3ea37-140">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="3ea37-140">The hash algorithm to use to derive the key material.</span></span></param>
        <summary><span data-ttu-id="3ea37-141">Führt die Schlüsselableitung mithilfe eines angegebenen Hashalgorithmus aus</span><span class="sxs-lookup"><span data-stu-id="3ea37-141">Performs key derivation using a specified hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="3ea37-142">Der Hash des gemeinsamen geheimen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="3ea37-142">The hash of the shared secret.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-143">Diese Überladung ruft die Methode auf, die als vorangestellt und angefügt werden soll <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> `null` .</span><span class="sxs-lookup"><span data-stu-id="3ea37-143">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3ea37-144">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-144">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span>

<span data-ttu-id="3ea37-145">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-145">-or-</span></span>

<span data-ttu-id="3ea37-146">Der <paramref name="hashAlgorithm" />-Parameter gibt keinen Hash an.</span><span class="sxs-lookup"><span data-stu-id="3ea37-146">The <paramref name="hashAlgorithm" /> parameter does not specify a hash.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3ea37-147"><paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-147"><paramref name="otherPartyPublicKey" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-148">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-148">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="3ea37-149">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-149">-or-</span></span>

<span data-ttu-id="3ea37-150">Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-150">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[]? secretPrepend, byte[]? secretAppend);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm, secretPrepend, secretAppend)" />
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" Index="2" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretAppend" Type="System.Byte[]" Index="3" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="3ea37-151">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="3ea37-151">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="3ea37-152">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="3ea37-152">The hash algorithm to use to derive the key material.</span></span></param>
        <param name="secretPrepend"><span data-ttu-id="3ea37-153">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren vorangestellt wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-153">A value to prepend to the derived secret before hashing.</span></span></param>
        <param name="secretAppend"><span data-ttu-id="3ea37-154">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren angefügt wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-154">A value to append to the derived secret before hashing.</span></span></param>
        <summary><span data-ttu-id="3ea37-155">Führt die Schlüsselableitung bei der Implementierung in einer abgeleiteten Klasse mithilfe eines angegebenen Hashalgorithmus mit optionalen vorangestellten oder angefügten Daten aus.</span><span class="sxs-lookup"><span data-stu-id="3ea37-155">When implemented in a derived class, performs key derivation using a specified hash algorithm with optional prepended or appended data.</span></span></summary>
        <returns><span data-ttu-id="3ea37-156">Der Hash des gemeinsamen geheimen Schlüssels nach dem Voranstellen oder Anfügen von Daten wie angefordert.</span><span class="sxs-lookup"><span data-stu-id="3ea37-156">The hash of the shared secret after prepending or appending data as requested.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="3ea37-157">Diese Methode führt intern die elliptische Kurve Diffie-Hellman-Schlüssel Übereinstimmung aus, um den gemeinsamen geheimen Schlüssel () zu erhalten `z` .</span><span class="sxs-lookup"><span data-stu-id="3ea37-157">This method internally performs the Elliptic Curve Diffie-Hellman key agreement to produce the shared secret (`z`).</span></span>
<span data-ttu-id="3ea37-158">Der Rückgabewert dieser Methode ist das Ergebnis der `HASH(secretPrepend || z || secretAppend)` Verwendung des angegebenen Hash Algorithmus, wobei die `||` Verkettung angibt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-158">The return value from this method is the result of `HASH(secretPrepend || z || secretAppend)` using the specified hash algorithm, where `||` signifies concatenation.</span></span>

<span data-ttu-id="3ea37-159">Wenn der Wert von `secretPrepend` oder `secretAppend` ist `null` , werden Sie als leere Arrays behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-159">If the value of `secretPrepend` or `secretAppend` is `null`, they are treated as empty arrays.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3ea37-160">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3ea37-160">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3ea37-161">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-161">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span>

<span data-ttu-id="3ea37-162">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-162">-or-</span></span>

<span data-ttu-id="3ea37-163">Der <paramref name="hashAlgorithm" />-Parameter gibt keinen Hash an.</span><span class="sxs-lookup"><span data-stu-id="3ea37-163">The <paramref name="hashAlgorithm" /> parameter does not specify a hash.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3ea37-164"><paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-164"><paramref name="otherPartyPublicKey" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-165">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-165">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="3ea37-166">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-166">-or-</span></span>

<span data-ttu-id="3ea37-167">Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-167">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHmac">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3ea37-168">Führt die Schlüsselableitung mithilfe eines angegebenen HMAC-Algorithmus (Hash-based Message Authentication Code, Hash-Nachrichtenauthentifizierungscode) aus.</span><span class="sxs-lookup"><span data-stu-id="3ea37-168">Performs key derivation using a specified HMAC (Hash-based Message Authentication Code) algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[]? hmacKey);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey)" />
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hmacKey" Type="System.Byte[]" Index="2" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="3ea37-169">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="3ea37-169">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="3ea37-170">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="3ea37-170">The hash algorithm to use to derive the key material.</span></span></param>
        <param name="hmacKey"><span data-ttu-id="3ea37-171">Der Schlüssel für den HMAC.</span><span class="sxs-lookup"><span data-stu-id="3ea37-171">The key for the HMAC.</span></span></param>
        <summary><span data-ttu-id="3ea37-172">Führt die Schlüsselableitung mithilfe eines angegebenen HMAC-Algorithmus (Hash-based Message Authentication Code, Hash-Nachrichtenauthentifizierungscode) aus.</span><span class="sxs-lookup"><span data-stu-id="3ea37-172">Performs key derivation using a specified HMAC (Hash-based Message Authentication Code) algorithm.</span></span></summary>
        <returns><span data-ttu-id="3ea37-173">Der HMAC des gemeinsamen geheimen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="3ea37-173">The HMAC of the shared secret.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-174">Diese Überladung ruft die Methode auf, die als vorangestellt und angefügt werden soll <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> `null` .</span><span class="sxs-lookup"><span data-stu-id="3ea37-174">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3ea37-175">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-175">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span>

<span data-ttu-id="3ea37-176">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-176">-or-</span></span>

<span data-ttu-id="3ea37-177">Der <paramref name="hashAlgorithm" />-Parameter gibt keinen Hash an.</span><span class="sxs-lookup"><span data-stu-id="3ea37-177">The <paramref name="hashAlgorithm" /> parameter does not specify a hash.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3ea37-178"><paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-178"><paramref name="otherPartyPublicKey" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-179">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-179">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="3ea37-180">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-180">-or-</span></span>

<span data-ttu-id="3ea37-181">Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-181">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public virtual byte[]? DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey? otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte(), secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey, secretPrepend, secretAppend)" />
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hmacKey" Type="System.Byte[]" Index="2" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" Index="3" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretAppend" Type="System.Byte[]" Index="4" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="3ea37-182">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="3ea37-182">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="3ea37-183">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="3ea37-183">The hash algorithm to use to derive the key material.</span></span></param>
        <param name="hmacKey"><span data-ttu-id="3ea37-184">Der Schlüssel für den HMAC.</span><span class="sxs-lookup"><span data-stu-id="3ea37-184">The key for the HMAC.</span></span></param>
        <param name="secretPrepend"><span data-ttu-id="3ea37-185">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren vorangestellt wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-185">A value to prepend to the derived secret before hashing.</span></span></param>
        <param name="secretAppend"><span data-ttu-id="3ea37-186">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren angefügt wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-186">A value to append to the derived secret before hashing.</span></span></param>
        <summary><span data-ttu-id="3ea37-187">Führt die Schlüsselableitung bei der Implementierung in einer abgeleiteten Klasse mithilfe eines angegebenen HMAC-Algorithmus (Hash-based Message Authentication Code, Hash-Nachrichtenauthentifizierungscode) mit optionalen vorangestellten oder angefügten Daten aus.</span><span class="sxs-lookup"><span data-stu-id="3ea37-187">When implemented in a derived class, performs key derivation using a specified HMAC (Hash-based Message Authentication Code) algorithm with optional prepended or appended data.</span></span></summary>
        <returns><span data-ttu-id="3ea37-188">Der HMAC des gemeinsamen geheimen Schlüssels nach dem Voranstellen oder Anfügen von Daten wie angefordert.</span><span class="sxs-lookup"><span data-stu-id="3ea37-188">The HMAC of the shared secret after prepending or appending data as requested.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="3ea37-189">Diese Methode führt intern die elliptische Kurve Diffie-Hellman-Schlüssel Übereinstimmung aus, um den gemeinsamen geheimen Schlüssel () zu erhalten `z` .</span><span class="sxs-lookup"><span data-stu-id="3ea37-189">This method internally performs the Elliptic Curve Diffie-Hellman key agreement to produce the shared secret (`z`).</span></span>

<span data-ttu-id="3ea37-190">Wenn `hmacKey` den `null` Wert hat, ist der Rückgabewert dieser Methode das Ergebnis der `HMAC-HASH(z, secretPrepend || z || secretAppend)` Verwendung des angegebenen HMAC-Algorithmus, wobei die `||` Verkettung angibt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-190">When `hmacKey` is `null`, the return value from this method is the result of `HMAC-HASH(z, secretPrepend || z || secretAppend)` using the specified HMAC algorithm, where `||` signifies concatenation.</span></span> <span data-ttu-id="3ea37-191">Andernfalls ist der Rückgabewert aus dieser Methode das Ergebnis von `HMAC-HASH(hmacKey, secretPrepend || z || secretAppend)` .</span><span class="sxs-lookup"><span data-stu-id="3ea37-191">Otherwise, the return value from this method is the result of `HMAC-HASH(hmacKey, secretPrepend || z || secretAppend)`.</span></span>

<span data-ttu-id="3ea37-192">Wenn der Wert von `secretPrepend` oder `secretAppend` ist `null` , werden Sie als leere Arrays behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-192">If the value of `secretPrepend` or `secretAppend` is `null`, they are treated as empty arrays.</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3ea37-193">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3ea37-193">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3ea37-194">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-194">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span>

<span data-ttu-id="3ea37-195">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-195">-or-</span></span>

<span data-ttu-id="3ea37-196">Der <paramref name="hashAlgorithm" />-Parameter gibt keinen Hash an.</span><span class="sxs-lookup"><span data-stu-id="3ea37-196">The <paramref name="hashAlgorithm" /> parameter does not specify a hash.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3ea37-197"><paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-197"><paramref name="otherPartyPublicKey" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-198">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-198">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="3ea37-199">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-199">-or-</span></span>

<span data-ttu-id="3ea37-200">Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-200">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]&#xA;override this.DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyMaterial otherPartyPublicKey" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public abstract byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyMaterial otherPartyPublicKey" FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="3ea37-201">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="3ea37-201">The other party's public key.</span></span></param>
        <summary><span data-ttu-id="3ea37-202">Führt bei der Implementierung in einer abgeleiteten Klasse eine Schlüsselableitung für den gemeinsamen geheimen Schlüssel durch.</span><span class="sxs-lookup"><span data-stu-id="3ea37-202">When implemented in a derived class, performs a key derivation on the shared secret.</span></span></summary>
        <returns><span data-ttu-id="3ea37-203">Das Ergebnis der Schlüsselableitungsfunktion, wobei der gemeinsame geheime Schlüssel als Eingabe verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-203">The result of the key derivation function, using the shared secret as an input.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="3ea37-204">Das Standardverhalten dieser Methode entspricht dem Aufruf der <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> Angabe von SHA-256 als Hash Algorithmus ohne vorangestellte oder angefügende Werte.</span><span class="sxs-lookup"><span data-stu-id="3ea37-204">The default behavior of this method is equivalent to calling <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> specifying SHA-256 as the hash algorithm with no prepend or append values.</span></span>
<span data-ttu-id="3ea37-205">Einige Implementierungen ermöglichen es, das Verhalten dieser Methode zu ändern, und Aufrufer werden angewiesen, eine beliebige Methode aufzurufen, um explizit zu sagen, dass Sie die erforderliche Schlüssel Ableitung ausführt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-205">Some implementations allow the behavior of this method to be changed, and callers are advised to call whichever method explicitly says it performs the key derivation they need.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3ea37-206">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-206">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3ea37-207"><paramref name="otherPartyPublicKey" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-207"><paramref name="otherPartyPublicKey" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-208">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-208">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="3ea37-209">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-209">-or-</span></span>

<span data-ttu-id="3ea37-210">Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-210">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyTls">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyTls (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyTls(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, unsigned int8[] prfLabel, unsigned int8[] prfSeed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyTls (otherPartyPublicKey As ECDiffieHellmanPublicKey, prfLabel As Byte(), prfSeed As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyTls(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, cli::array &lt;System::Byte&gt; ^ prfLabel, cli::array &lt;System::Byte&gt; ^ prfSeed);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyTls (otherPartyPublicKey, prfLabel, prfSeed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="prfLabel" Type="System.Byte[]" Index="1" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="prfSeed" Type="System.Byte[]" Index="2" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="3ea37-211">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="3ea37-211">The other party's public key.</span></span></param>
        <param name="prfLabel"><span data-ttu-id="3ea37-212">Die ASCII-codierte PRF-Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-212">The ASCII-encoded PRF label.</span></span></param>
        <param name="prfSeed"><span data-ttu-id="3ea37-213">Der 64-Byte-PRF-Startwert.</span><span class="sxs-lookup"><span data-stu-id="3ea37-213">The 64-byte PRF seed.</span></span></param>
        <summary><span data-ttu-id="3ea37-214">Führt eine Schlüsselableitung bei der Implementierung in einer abgeleiteten Klasse mithilfe der Pseudozufallsfunktion von TLS 1.1 (Transport Layer Security) durch.</span><span class="sxs-lookup"><span data-stu-id="3ea37-214">When implemented in a derived class, performs key derivation using the TLS (Transport Layer Security) 1.1 PRF (Pseudo-Random Function).</span></span></summary>
        <returns><span data-ttu-id="3ea37-215">Die ersten 48 Bytes der Pseudozufallsfunktion von TLS 1.1, wobei der gemeinsame geheime Schlüssel als Schlüssel verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-215">The first 48 bytes from the TLS 1.1 PRF, using the shared secret as the key.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="3ea37-216">Diese Methode führt intern die elliptische Kurve Diffie-Hellman-Schlüssel Übereinstimmung aus, um den gemeinsamen geheimen Schlüssel () zu erhalten `z` .</span><span class="sxs-lookup"><span data-stu-id="3ea37-216">This method internally performs the Elliptic Curve Diffie-Hellman key agreement to produce the shared secret (`z`).</span></span>

<span data-ttu-id="3ea37-217">Der Rückgabewert dieser Methode ist eine 48-Byte-Ausgabe der TLS 1,1 PRF (Pseudo Zufallsfunktion) `PRF(z, prfLabel, prfSeed)` .</span><span class="sxs-lookup"><span data-stu-id="3ea37-217">The return value of this method is a 48 byte output of the TLS 1.1 PRF (Pseudo-Random Function), `PRF(z, prfLabel, prfSeed)`.</span></span>

<span data-ttu-id="3ea37-218">Weitere Informationen finden Sie unter [IETF RFC 4346, Abschnitt 5](https://tools.ietf.org/html/rfc4346#section-5).</span><span class="sxs-lookup"><span data-stu-id="3ea37-218">For more information, see [IETF RFC 4346, section 5](https://tools.ietf.org/html/rfc4346#section-5).</span></span>

]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3ea37-219">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3ea37-219">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3ea37-220">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve hat eine andere Größe als die Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-220">The curve used by <paramref name="otherPartyPublicKey" /> has a different size than the curve from this key.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3ea37-221"><paramref name="otherPartyPublicKey" />, <paramref name="prfLabel" /> oder <paramref name="prfSeed" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-221"><paramref name="otherPartyPublicKey" />, <paramref name="prfLabel" /> or <paramref name="prfSeed" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-222"><paramref name="prfSeed" /> ist nicht genau 64 Bytes lang.</span><span class="sxs-lookup"><span data-stu-id="3ea37-222"><paramref name="prfSeed" /> is not exactly 64 bytes in length.</span></span>

<span data-ttu-id="3ea37-223">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-223">-or-</span></span>

<span data-ttu-id="3ea37-224">Die von <paramref name="otherPartyPublicKey" /> verwendete Kurve unterscheidet sich von der Kurve aus diesem Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-224">The curve used by <paramref name="otherPartyPublicKey" /> is different than the curve from this key.</span></span>

<span data-ttu-id="3ea37-225">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-225">-or-</span></span>

<span data-ttu-id="3ea37-226">Diese Instanz stellt nur einen öffentlichen Schlüssel dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-226">This instance represents only a public key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual byte[] ExportECPrivateKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportECPrivateKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportECPrivateKey () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ExportECPrivateKey();" />
      <MemberSignature Language="F#" Value="abstract member ExportECPrivateKey : unit -&gt; byte[]&#xA;override this.ExportECPrivateKey : unit -&gt; byte[]" Usage="eCDiffieHellman.ExportECPrivateKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3ea37-227">Exportiert den aktuellen Schlüssel im ECPrivateKey-Format.</span><span class="sxs-lookup"><span data-stu-id="3ea37-227">Exports the current key in the ECPrivateKey format.</span></span></summary>
        <returns><span data-ttu-id="3ea37-228">Ein Bytearray mit der ECPrivateKey-Darstellung dieses Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="3ea37-228">A byte array containing the ECPrivateKey representation of this key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-229">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-229">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="ExportExplicitParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportExplicitParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportExplicitParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportExplicitParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportExplicitParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportExplicitParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="3ea37-230"><see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-230"><see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3ea37-231">Exportiert beim Überschreiben in einer abgeleiteten Klasse Informationen zum öffentlichen oder zum öffentlichen und privaten Schlüssel unter Verwendung der expliziten Kurvenform aus einem verwendeten <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Schlüssel in eine <see cref="T:System.Security.Cryptography.ECParameters" />-Struktur, damit sie an die <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />-Methode übergeben werden können.</span><span class="sxs-lookup"><span data-stu-id="3ea37-231">When overridden in a derived class, exports either the public or the public and private key information using the explicit curve form from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></summary>
        <returns><span data-ttu-id="3ea37-232">Ein Objekt, das unter Verwendung des expliziten Kurvenformats den Punkt auf der Kurve für diesen Schlüssel darstellt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-232">An object that represents the point on the curve for this key, using the explicit curve format.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3ea37-233">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3ea37-233">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="3ea37-234"><see langword="true" />, um private Parameter einzuschließen, oder <see langword="false" />, um nur die öffentlichen Parameter einzuschließen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-234"><see langword="true" /> to include private parameters; otherwise, <see langword="false" /> to include public parameters only.</span></span></param>
        <summary><span data-ttu-id="3ea37-235">Exportiert beim Überschreiben in einer abgeleiteten Klasse Informationen zum öffentlichen oder zum öffentlichen und privaten Schlüssel aus einem verwendeten <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Schlüssel in eine <see cref="T:System.Security.Cryptography.ECParameters" />-Struktur, damit sie an die <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />-Methode übergeben werden können.</span><span class="sxs-lookup"><span data-stu-id="3ea37-235">When overridden in a derived class, exports either the public or the public and private key information from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></summary>
        <returns><span data-ttu-id="3ea37-236">Ein Objekt, das den Punkt auf der Kurve für diesen Schlüssel darstellt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-236">An object that represents the point on the curve for this key.</span></span> <span data-ttu-id="3ea37-237">Es kann an die <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />-Methode übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-237">It can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-238">Wenn die Kurve einen Namen hat, <xref:System.Security.Cryptography.ECParameters.Curve> enthält die Eigenschaft benannte Kurven Parameter, andernfalls enthält Sie explizite Parameter.</span><span class="sxs-lookup"><span data-stu-id="3ea37-238">If the curve has a name, the <xref:System.Security.Cryptography.ECParameters.Curve> property contains named curve parameters; otherwise, it will contain explicit parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3ea37-239">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3ea37-239">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public override void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXmlString(System::String ^ xmlString);" />
      <MemberSignature Language="F#" Value="override this.FromXmlString : string -&gt; unit" Usage="eCDiffieHellman.FromXmlString xmlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="xmlString"><span data-ttu-id="3ea37-240">Die XML-Zeichenfolge zur Wiederherstellung des <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="3ea37-240">The XML string to use to reconstruct the <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> object.</span></span></param>
        <summary><span data-ttu-id="3ea37-241">Diese Methode löst in allen Fällen aus.</span><span class="sxs-lookup"><span data-stu-id="3ea37-241">This method throws in all cases.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3ea37-242">In allen Fällen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-242">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public virtual void GenerateKey (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateKey(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateKey (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateKey(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="abstract member GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit&#xA;override this.GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit" Usage="eCDiffieHellman.GenerateKey curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="curve"><span data-ttu-id="3ea37-243">Die Kurve, die für das Generieren eines kurzlebigen Paars aus privatem und öffentlichem Schlüssel verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-243">The curve used to generate an ephemeral public/private key pair.</span></span></param>
        <summary><span data-ttu-id="3ea37-244">Generiert beim Überschreiben in einer abgeleiteten Klasse ein neues kurzlebiges Paar aus privatem und öffentlichem Schlüssel für die angegebene Kurve.</span><span class="sxs-lookup"><span data-stu-id="3ea37-244">When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-245">`curve` muss bei der Übergabe an die-Methode validieren (d. h., er muss zurückgeben `true` ) <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> und darf nicht implizit sein.</span><span class="sxs-lookup"><span data-stu-id="3ea37-245">`curve` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method) and must not be implicit.</span></span>  
  
 <span data-ttu-id="3ea37-246">Merkmal-2-Kurven werden unter Windows nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-246">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-247"><paramref name="curve" /> führt keine Validierung durch.</span><span class="sxs-lookup"><span data-stu-id="3ea37-247"><paramref name="curve" /> does not validate.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3ea37-248">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3ea37-248">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual void ImportECPrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportECPrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportECPrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportECPrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="abstract member ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; * int -&gt; unit&#xA;override this.ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDiffieHellman.ImportECPrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3ea37-249">Die Bytes einer ECPrivateKey-Struktur in der ASN.1-BER-Codierung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-249">The bytes of an ECPrivateKey structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="3ea37-250">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-250">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="3ea37-251">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-251">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="3ea37-252">Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer ECPrivateKey-Struktur und ersetzt dabei die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-252">Imports the public/private keypair from an ECPrivateKey structure, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="3ea37-253">Diese Methode unterstützt nur die binäre Codierung (ber/CER/der) von ecprivatekey.</span><span class="sxs-lookup"><span data-stu-id="3ea37-253">This method only supports the binary (BER/CER/DER) encoding of ECPrivateKey.</span></span>
<span data-ttu-id="3ea37-254">Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.</span><span class="sxs-lookup"><span data-stu-id="3ea37-254">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-255">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-ECPrivateKey-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-255">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 ECPrivateKey structure.</span></span>

<span data-ttu-id="3ea37-256">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-256">-or-</span></span>

<span data-ttu-id="3ea37-257">Fehler beim Schlüsselimport.</span><span class="sxs-lookup"><span data-stu-id="3ea37-257">The key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (passwordBytes As ReadOnlySpan(Of Byte), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDiffieHellman.ImportEncryptedPkcs8PrivateKey (passwordBytes, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="passwordBytes"><span data-ttu-id="3ea37-258">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-258">The bytes to use as a password when decrypting the key material.</span></span></param>
        <param name="source"><span data-ttu-id="3ea37-259">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-259">The bytes of a PKCS#8 EncryptedPrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="3ea37-260">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-260">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="3ea37-261">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-261">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="3ea37-262">Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem bytebasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-262">Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a byte-based password, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

 <span data-ttu-id="3ea37-263">Die Kenn Wort Bytes werden direkt an die kdf (Key derivations Function) übergeben, die vom Algorithmus verwendet wird, der durch den verschlüsseltedprivatekeyinfo-Inhalt angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-263">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by the EncryptedPrivateKeyInfo contents.</span></span>
<span data-ttu-id="3ea37-264">Dadurch wird die Kompatibilität mit anderen Systemen ermöglicht, bei denen bei der Verarbeitung von Kenn Wörtern mit PBKDF2 eine andere Text Codierung als UTF-8 verwendet wird (Kenn Wort basierte Schlüssel abderivations Funktion 2).</span><span class="sxs-lookup"><span data-stu-id="3ea37-264">This enables compatibility with other systems which use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>
<span data-ttu-id="3ea37-265">Diese Methode unterstützt nur die binäre Codierung (ber/CER/der) von "verschlüsseltedprivatekeyinfo".</span><span class="sxs-lookup"><span data-stu-id="3ea37-265">This method only supports the binary (BER/CER/DER) encoding of EncryptedPrivateKeyInfo.</span></span>
<span data-ttu-id="3ea37-266">Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.</span><span class="sxs-lookup"><span data-stu-id="3ea37-266">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-267">Das Kennwort ist falsch.</span><span class="sxs-lookup"><span data-stu-id="3ea37-267">The password is incorrect.</span></span>

<span data-ttu-id="3ea37-268">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-268">-or-</span></span>

<span data-ttu-id="3ea37-269">Der Inhalt von <paramref name="source" /> gibt an, dass die anzuwendende Schlüsselableitungsfunktion die Legacy-PKCS#12-KDF ist, die <see cref="T:System.Char" />-basierte Kennwörter erfordert.</span><span class="sxs-lookup"><span data-stu-id="3ea37-269">The contents of <paramref name="source" /> indicate the Key Derivation Function (KDF) to apply is the legacy PKCS#12 KDF, which requires <see cref="T:System.Char" />-based passwords.</span></span>

<span data-ttu-id="3ea37-270">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-270">-or-</span></span>

<span data-ttu-id="3ea37-271">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-271">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="3ea37-272">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-272">-or-</span></span>

<span data-ttu-id="3ea37-273">Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-273">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="3ea37-274">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-274">-or-</span></span>

<span data-ttu-id="3ea37-275">Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-275">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="3ea37-276">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-276">-or-</span></span>

<span data-ttu-id="3ea37-277">Fehler beim Importieren des algorithmusspezifischen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="3ea37-277">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (password As ReadOnlySpan(Of Char), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDiffieHellman.ImportEncryptedPkcs8PrivateKey (password, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="3ea37-278">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="3ea37-278">The password to use for decrypting the key material.</span></span></param>
        <param name="source"><span data-ttu-id="3ea37-279">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-279">The bytes of a PKCS#8 EncryptedPrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="3ea37-280">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-280">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="3ea37-281">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-281">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="3ea37-282">Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem zeichenbasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-282">Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a char-based password, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-283">Wenn der Inhalt von `source` einen Algorithmus angibt, der PBKDF1 (Kenn Wort basierte Schlüssel abderivations Funktion 1) oder PBKDF2 (Kenn Wort basierte Schlüssel abderivations Funktion 2) verwendet, wird das Kennwort über die UTF-8-Codierung in Bytes konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3ea37-283">When the contents of `source` indicate an algorithm that uses PBKDF1 (Password-Based Key Derivation Function 1) or PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>
<span data-ttu-id="3ea37-284">Diese Methode unterstützt nur die binäre Codierung (ber/CER/der) von "verschlüsseltedprivatekeyinfo".</span><span class="sxs-lookup"><span data-stu-id="3ea37-284">This method only supports the binary (BER/CER/DER) encoding of EncryptedPrivateKeyInfo.</span></span>
<span data-ttu-id="3ea37-285">Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.</span><span class="sxs-lookup"><span data-stu-id="3ea37-285">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-286">Das Kennwort ist falsch.</span><span class="sxs-lookup"><span data-stu-id="3ea37-286">The password is incorrect.</span></span>

<span data-ttu-id="3ea37-287">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-287">-or-</span></span>

<span data-ttu-id="3ea37-288">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-288">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="3ea37-289">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-289">-or-</span></span>

<span data-ttu-id="3ea37-290">Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-290">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="3ea37-291">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-291">-or-</span></span>

<span data-ttu-id="3ea37-292">Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-292">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="3ea37-293">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-293">-or-</span></span>

<span data-ttu-id="3ea37-294">Fehler beim Importieren des algorithmusspezifischen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="3ea37-294">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportFromEncryptedPem">
      <MemberSignature Language="C#" Value="public override void ImportFromEncryptedPem (ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;byte&gt; passwordBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportFromEncryptedPem(valuetype System.ReadOnlySpan`1&lt;char&gt; input, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportFromEncryptedPem (input As ReadOnlySpan(Of Char), passwordBytes As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;System::Byte&gt; passwordBytes);" />
      <MemberSignature Language="F#" Value="override this.ImportFromEncryptedPem : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="eCDiffieHellman.ImportFromEncryptedPem (input, passwordBytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="3ea37-295">Der PEM-Text des verschlüsselten Schlüssels, der importiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="3ea37-295">The PEM text of the encrypted key to import.</span></span></param>
        <param name="passwordBytes"><span data-ttu-id="3ea37-296">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-296">The bytes to use as a password when decrypting the key material.</span></span></param>
        <summary><span data-ttu-id="3ea37-297">Importiert einen verschlüsselten, mit RFC 7468 PEM-codierten privaten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-297">Imports an encrypted RFC 7468 PEM-encoded private key, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="3ea37-298">Die Kenn Wort Bytes werden direkt an die kdf (Key derivations Function) übergeben, die von dem durch angegeben Algorithmus verwendet werden `pbeParameters` .</span><span class="sxs-lookup"><span data-stu-id="3ea37-298">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by `pbeParameters`.</span></span> <span data-ttu-id="3ea37-299">Dies ermöglicht die Kompatibilität mit anderen Systemen, die eine andere Text Codierung als UTF-8 verwenden, wenn Kenn Wörter mit PBKDF2 verarbeitet werden (Kenn Wort basierte Schlüssel abderivations Funktion 2).</span><span class="sxs-lookup"><span data-stu-id="3ea37-299">This enables compatibility with other systems that use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>
 

 <span data-ttu-id="3ea37-300">Nicht unterstützte oder falsch formatierte PEM-codierte Objekte werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="3ea37-300">Unsupported or malformed PEM-encoded objects will be ignored.</span></span> <span data-ttu-id="3ea37-301">Wenn mehrere unterstützte PEM-Bezeichnungen gefunden werden, wird eine Ausnahme ausgelöst, um das Importieren eines Schlüssels zu verhindern, wenn der Schlüssel mehrdeutig ist.</span><span class="sxs-lookup"><span data-stu-id="3ea37-301">If multiple supported PEM labels are found, an exception is thrown to prevent importing a key when the key is ambiguous.</span></span>
 

<span data-ttu-id="3ea37-302">Diese Methode unterstützt die `ENCRYPTED PRIVATE KEY` PEM-Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-302">This method supports the `ENCRYPTED PRIVATE KEY` PEM label.</span></span>



          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3ea37-303"><paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-303"><paramref name="input" /> does not contain a PEM-encoded key with a recognized label.</span></span>

<span data-ttu-id="3ea37-304">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-304">-or-</span></span>

<span data-ttu-id="3ea37-305"><paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-305"><paramref name="input" /> contains multiple PEM-encoded keys with a recognized label.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-306">Das Kennwort ist falsch.</span><span class="sxs-lookup"><span data-stu-id="3ea37-306">The password is incorrect.</span></span>

<span data-ttu-id="3ea37-307">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-307">-or-</span></span>

<span data-ttu-id="3ea37-308">Der Base-64-decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt keine ASN.1-BER-codierte PKCS#8 EncryptedPrivateKeyInfo-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-308">The base-64 decoded contents of the PEM text from <paramref name="input" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="3ea37-309">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-309">-or-</span></span>

<span data-ttu-id="3ea37-310">Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-310">The base-64 decoded contents of the PEM text from <paramref name="input" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="3ea37-311">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-311">-or-</span></span>

<span data-ttu-id="3ea37-312">Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-312">The base-64 decoded contents of the PEM text from <paramref name="input" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="3ea37-313">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-313">-or-</span></span>

<span data-ttu-id="3ea37-314">Fehler beim Importieren des algorithmusspezifischen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="3ea37-314">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportFromEncryptedPem">
      <MemberSignature Language="C#" Value="public override void ImportFromEncryptedPem (ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportFromEncryptedPem(valuetype System.ReadOnlySpan`1&lt;char&gt; input, valuetype System.ReadOnlySpan`1&lt;char&gt; password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportFromEncryptedPem(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportFromEncryptedPem (input As ReadOnlySpan(Of Char), password As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportFromEncryptedPem(ReadOnlySpan&lt;char&gt; input, ReadOnlySpan&lt;char&gt; password);" />
      <MemberSignature Language="F#" Value="override this.ImportFromEncryptedPem : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="eCDiffieHellman.ImportFromEncryptedPem (input, password)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="3ea37-315">Der PEM-Text des verschlüsselten Schlüssels, der importiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="3ea37-315">The PEM text of the encrypted key to import.</span></span></param>
        <param name="password"><span data-ttu-id="3ea37-316">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="3ea37-316">The password to use for decrypting the key material.</span></span></param>
        <summary><span data-ttu-id="3ea37-317">Importiert einen verschlüsselten, mit RFC 7468 PEM-codierten privaten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-317">Imports an encrypted RFC 7468 PEM-encoded private key, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="3ea37-318">Wenn der von Base-64 decodierte Inhalt von `input` einen Algorithmus angibt, der PBKDF1 (Kenn Wort basierte Schlüssel abzurufende Funktion 1) oder PBKDF2 (Kenn Wort basierte Schlüssel abderivations Funktion 2) verwendet, wird das Kennwort über die UTF-8-Codierung in Bytes konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3ea37-318">When the base-64 decoded contents of `input` indicate an algorithm that uses PBKDF1 (Password-Based Key Derivation Function 1) or PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>
 

 <span data-ttu-id="3ea37-319">Nicht unterstützte oder falsch formatierte PEM-codierte Objekte werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="3ea37-319">Unsupported or malformed PEM-encoded objects will be ignored.</span></span> <span data-ttu-id="3ea37-320">Wenn mehrere unterstützte PEM-Bezeichnungen gefunden werden, wird eine Ausnahme ausgelöst, um das Importieren eines Schlüssels zu verhindern, wenn der Schlüssel mehrdeutig ist.</span><span class="sxs-lookup"><span data-stu-id="3ea37-320">If multiple supported PEM labels are found, an exception is thrown to prevent importing a key when the key is ambiguous.</span></span>
 

<span data-ttu-id="3ea37-321">Diese Methode unterstützt die `ENCRYPTED PRIVATE KEY` PEM-Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-321">This method supports the `ENCRYPTED PRIVATE KEY` PEM label.</span></span>



          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3ea37-322"><paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-322"><paramref name="input" /> does not contain a PEM-encoded key with a recognized label.</span></span>

<span data-ttu-id="3ea37-323">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-323">-or-</span></span>

<span data-ttu-id="3ea37-324"><paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-324"><paramref name="input" /> contains multiple PEM-encoded keys with a recognized label.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-325">Das Kennwort ist falsch.</span><span class="sxs-lookup"><span data-stu-id="3ea37-325">The password is incorrect.</span></span>

<span data-ttu-id="3ea37-326">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-326">-or-</span></span>

<span data-ttu-id="3ea37-327">Der Base-64-decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt keine ASN.1-BER-codierte PKCS#8 EncryptedPrivateKeyInfo-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-327">The base-64 decoded contents of the PEM text from <paramref name="input" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="3ea37-328">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-328">-or-</span></span>

<span data-ttu-id="3ea37-329">Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-329">The base-64 decoded contents of the PEM text from <paramref name="input" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="3ea37-330">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-330">-or-</span></span>

<span data-ttu-id="3ea37-331">Der Base-64 decodierte Inhalt des PEM-Texts aus <paramref name="input" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-331">The base-64 decoded contents of the PEM text from <paramref name="input" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="3ea37-332">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-332">-or-</span></span>

<span data-ttu-id="3ea37-333">Fehler beim Importieren des algorithmusspezifischen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="3ea37-333">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportFromPem">
      <MemberSignature Language="C#" Value="public override void ImportFromPem (ReadOnlySpan&lt;char&gt; input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportFromPem(valuetype System.ReadOnlySpan`1&lt;char&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportFromPem(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportFromPem (input As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportFromPem(ReadOnlySpan&lt;char&gt; input);" />
      <MemberSignature Language="F#" Value="override this.ImportFromPem : ReadOnlySpan&lt;char&gt; -&gt; unit" Usage="eCDiffieHellman.ImportFromPem input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="input"><span data-ttu-id="3ea37-334">Der PEM-Text des Schlüssels, der importiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="3ea37-334">The PEM text of the key to import.</span></span></param>
        <summary><span data-ttu-id="3ea37-335">Importiert einen mit RFC 7468 PEM-codierten Schlüssel und ersetzt die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-335">Imports an RFC 7468 PEM-encoded key, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="3ea37-336">Nicht unterstützte oder falsch formatierte PEM-codierte Objekte werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="3ea37-336">Unsupported or malformed PEM-encoded objects will be ignored.</span></span> <span data-ttu-id="3ea37-337">Wenn mehrere unterstützte PEM-Bezeichnungen gefunden werden, wird eine Ausnahme ausgelöst, um das Importieren eines Schlüssels zu verhindern, wenn der Schlüssel mehrdeutig ist.</span><span class="sxs-lookup"><span data-stu-id="3ea37-337">If multiple supported PEM labels are found, an exception is raised to prevent importing a key when the key is ambiguous.</span></span>
 

 <span data-ttu-id="3ea37-338">Diese Methode unterstützt die folgenden PEM-Bezeichnungen:</span><span class="sxs-lookup"><span data-stu-id="3ea37-338">This method supports the following PEM labels:</span></span>
 
 - <span data-ttu-id="3ea37-339">ÖFFENTLICHER SCHLÜSSEL</span><span class="sxs-lookup"><span data-stu-id="3ea37-339">PUBLIC KEY</span></span>
 - <span data-ttu-id="3ea37-340">privater Schlüssel</span><span class="sxs-lookup"><span data-stu-id="3ea37-340">PRIVATE KEY</span></span>
 - <span data-ttu-id="3ea37-341">privater Schlüssel für EC</span><span class="sxs-lookup"><span data-stu-id="3ea37-341">EC PRIVATE KEY</span></span>


          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3ea37-342"><paramref name="input" /> enthält keinen PEM-codierten Schlüssel mit einer erkannten Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-342"><paramref name="input" /> does not contain a PEM-encoded key with a recognized label.</span></span>

<span data-ttu-id="3ea37-343">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-343">-or-</span></span>

<span data-ttu-id="3ea37-344"><paramref name="input" /> enthält mehrere PEM-codierte Schlüssel mit einer erkannten Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-344"><paramref name="input" /> contains multiple PEM-encoded keys with a recognized label.</span></span>

<span data-ttu-id="3ea37-345">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-345">-or-</span></span>

<span data-ttu-id="3ea37-346"><paramref name="input" /> enthält einen verschlüsselten PEM-codierten Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="3ea37-346"><paramref name="input" /> contains an encrypted PEM-encoded key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public virtual void ImportParameters (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportParameters(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportParameters (parameters As ECParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportParameters(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="abstract member ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit&#xA;override this.ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit" Usage="eCDiffieHellman.ImportParameters parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="parameters"><span data-ttu-id="3ea37-347">Die zu importierenden Parameter der Kurve.</span><span class="sxs-lookup"><span data-stu-id="3ea37-347">The curve's parameters to import.</span></span></param>
        <summary><span data-ttu-id="3ea37-348">Importiert beim Überschreiben in einer abgeleiteten Klasse die angegebenen Parameter für eine <see cref="T:System.Security.Cryptography.ECCurve" /> als einen kurzlebigen Schlüssel in das aktuelle <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-348">When overridden in a derived class, imports the specified parameters for an <see cref="T:System.Security.Cryptography.ECCurve" /> as an ephemeral key into the current <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-349">`parameters` muss `true` bei der Übergabe an die-Methode validieren (d. h., Sie muss zurückgegeben werden) <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="3ea37-349">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3ea37-350">Parameter über implizite Kurven werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-350">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="3ea37-351">Merkmal-2-Kurven werden unter Windows nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-351">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-352"><paramref name="parameters" /> führt keine Validierung durch.</span><span class="sxs-lookup"><span data-stu-id="3ea37-352"><paramref name="parameters" /> does not validate.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3ea37-353">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="3ea37-353">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportPkcs8PrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDiffieHellman.ImportPkcs8PrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3ea37-354">Die Bytes einer PKCS#8-PrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-354">The bytes of a PKCS#8 PrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="3ea37-355">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-355">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="3ea37-356">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-356">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="3ea37-357">Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-PrivateKeyInfo-Struktur nach der Entschlüsselung und ersetzt die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-357">Imports the public/private keypair from a PKCS#8 PrivateKeyInfo structure after decryption, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-358">Diese Methode unterstützt nur die binäre Codierung (ber/CER/der) von privatekeyinfo.</span><span class="sxs-lookup"><span data-stu-id="3ea37-358">This method only supports the binary (BER/CER/DER) encoding of PrivateKeyInfo.</span></span>
<span data-ttu-id="3ea37-359">Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.</span><span class="sxs-lookup"><span data-stu-id="3ea37-359">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-360">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-PrivateKeyInfo-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-360">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 PrivateKeyInfo structure.</span></span>

<span data-ttu-id="3ea37-361">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-361">-or-</span></span>

<span data-ttu-id="3ea37-362">Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-362">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="3ea37-363">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-363">-or-</span></span>

<span data-ttu-id="3ea37-364">Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-364">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="3ea37-365">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-365">-or-</span></span>

<span data-ttu-id="3ea37-366">Fehler beim Importieren des algorithmusspezifischen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="3ea37-366">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override void ImportSubjectPublicKeyInfo (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportSubjectPublicKeyInfo(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportSubjectPublicKeyInfo (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportSubjectPublicKeyInfo(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportSubjectPublicKeyInfo : ReadOnlySpan&lt;byte&gt; * int -&gt; unit" Usage="eCDiffieHellman.ImportSubjectPublicKeyInfo (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="3ea37-367">Die Bytes einer X.509-SubjectPublicKeyInfo-Struktur in der ASN.1-DER-Codierung.</span><span class="sxs-lookup"><span data-stu-id="3ea37-367">The bytes of an X.509 SubjectPublicKeyInfo structure in the ASN.1-DER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="3ea37-368">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-368">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="3ea37-369">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-369">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="3ea37-370">Importiert den öffentlichen Schlüssel aus einer X.509-SubjectPublicKeyInfo-Struktur nach der Entschlüsselung und ersetzt dabei die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-370">Imports the public key from an X.509 SubjectPublicKeyInfo structure after decryption, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-371">Diese Methode unterstützt nur die binäre Codierung (der) von "subjetpublickeyinfo".</span><span class="sxs-lookup"><span data-stu-id="3ea37-371">This method only supports the binary (DER) encoding of SubjectPublicKeyInfo.</span></span>
<span data-ttu-id="3ea37-372">Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.</span><span class="sxs-lookup"><span data-stu-id="3ea37-372">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-373">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-DER-codierte X.509-SubjectPublicKeyInfo-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="3ea37-373">The contents of <paramref name="source" /> do not represent an ASN.1-DER-encoded X.509 SubjectPublicKeyInfo structure.</span></span>

<span data-ttu-id="3ea37-374">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-374">-or-</span></span>

<span data-ttu-id="3ea37-375">Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-375">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="3ea37-376">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-376">-or-</span></span>

<span data-ttu-id="3ea37-377">Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-377">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="3ea37-378">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-378">-or-</span></span>

<span data-ttu-id="3ea37-379">Fehler beim Importieren des algorithmusspezifischen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="3ea37-379">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public override string KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property KeyExchangeAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ KeyExchangeAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3ea37-380">Ruft den Namen des Algorithmus für den Schlüsselaustausch ab.</span><span class="sxs-lookup"><span data-stu-id="3ea37-380">Gets the name of the key exchange algorithm.</span></span></summary>
        <value><span data-ttu-id="3ea37-381">Der Name des Algorithmus für den Schlüsselaustausch.</span><span class="sxs-lookup"><span data-stu-id="3ea37-381">The name of the key exchange algorithm.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-382">Die Standard Implementierung (nicht überschriebene) dieser Eigenschaft gibt die Zeichenfolge "ECDiffieHellman" zurück.</span><span class="sxs-lookup"><span data-stu-id="3ea37-382">The default (non-overridden) implementation of this property returns the string "ECDiffieHellman".</span></span>  
  
 <span data-ttu-id="3ea37-383">Diese Eigenschaft wird von der- <xref:System.Security.Cryptography.AsymmetricAlgorithm> Basisklasse geerbt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-383">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PublicKey As ECDiffieHellmanPublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Security::Cryptography::ECDiffieHellmanPublicKey ^ PublicKey { System::Security::Cryptography::ECDiffieHellmanPublicKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PublicKey : System.Security.Cryptography.ECDiffieHellmanPublicKey" Usage="System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanPublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3ea37-384">Ruft den öffentlichen Schlüssel ab, der von der aktuellen ECDH (Elliptic Curve Diffie-Hellman)-Instanz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-384">Gets the public key that is being used by the current Elliptic Curve Diffie-Hellman (ECDH) instance.</span></span></summary>
        <value><span data-ttu-id="3ea37-385">Der öffentliche Teil des ECDH-Schlüsselpaares, der von dieser <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Instanz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="3ea37-385">The public part of the ECDH key pair that is being used by this <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> instance.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public override string? SignatureAlgorithm { get; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SignatureAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SignatureAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberSignature Language="C#" Value="public override string SignatureAlgorithm { get; }" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3ea37-386">Ruft den Namen des Signaturalgorithmus ab.</span><span class="sxs-lookup"><span data-stu-id="3ea37-386">Gets the name of the signature algorithm.</span></span></summary>
        <value><span data-ttu-id="3ea37-387">Immer <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-387">Always <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-388">Diese Eigenschaft wird von der- <xref:System.Security.Cryptography.AsymmetricAlgorithm> Basisklasse geerbt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-388">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 <span data-ttu-id="3ea37-389">Der ECDH-Algorithmus (Elliptic Curve Diffie-Hellman) wird für die Schlüssel Ableitung verwendet, nicht für die Generierung digitaler Signaturen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-389">The Elliptic Curve Diffie-Hellman (ECDH) algorithm is used for key derivation, not digital signature generation.</span></span> <span data-ttu-id="3ea37-390">Daher gibt diese Eigenschaft zurück `null` .</span><span class="sxs-lookup"><span data-stu-id="3ea37-390">Therefore, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public override string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="override this.ToXmlString : bool -&gt; string" Usage="eCDiffieHellman.ToXmlString includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="3ea37-391"><see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-391"><see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3ea37-392">Diese Methode löst in allen Fällen aus.</span><span class="sxs-lookup"><span data-stu-id="3ea37-392">This method throws in all cases.</span></span></summary>
        <returns><span data-ttu-id="3ea37-393">Diese Methode gibt keinen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="3ea37-393">This method does not return a value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3ea37-394">In allen Fällen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-394">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual bool TryExportECPrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryExportECPrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryExportECPrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryExportECPrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryExportECPrivateKey : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.TryExportECPrivateKey : Span&lt;byte&gt; * int -&gt; bool" Usage="eCDiffieHellman.TryExportECPrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3ea37-395">Die Bytespanne, die die <see langword="ECPrivateKey" />-Daten empfangen soll.</span><span class="sxs-lookup"><span data-stu-id="3ea37-395">The byte span to receive the <see langword="ECPrivateKey" /> data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="3ea37-396">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-396">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="3ea37-397">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-397">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="3ea37-398">Versucht, den aktuellen Schlüssel im <see langword="ECPrivateKey" />-Format in einen bereitgestellten Puffer zu exportieren.</span><span class="sxs-lookup"><span data-stu-id="3ea37-398">Attempts to export the current key in the <see langword="ECPrivateKey" /> format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="3ea37-399"><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-399"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-400">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-400">The key could not be exported.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters? pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportEncryptedPkcs8PrivateKey (passwordBytes As ReadOnlySpan(Of Byte), pbeParameters As PbeParameters, destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; * int -&gt; bool" Usage="eCDiffieHellman.TryExportEncryptedPkcs8PrivateKey (passwordBytes, pbeParameters, destination, bytesWritten)" />
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="passwordBytes"><span data-ttu-id="3ea37-401">Die Bytes, die als Kennwort bei der Verschlüsselung des Schlüsselmaterials verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-401">The bytes to use as a password when encrypting the key material.</span></span></param>
        <param name="pbeParameters"><span data-ttu-id="3ea37-402">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-402">The password-based encryption (PBE) parameters to use when encrypting the key material.</span></span></param>
        <param name="destination"><span data-ttu-id="3ea37-403">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-403">The byte span to receive the PKCS#8 EncryptedPrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="3ea37-404">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-404">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="3ea37-405">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-405">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="3ea37-406">Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem bytebasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</span><span class="sxs-lookup"><span data-stu-id="3ea37-406">Attempts to export the current key in the PKCS#8 EncryptedPrivateKeyInfo format into a provided buffer, using a byte-based password.</span></span></summary>
        <returns><span data-ttu-id="3ea37-407"><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-407"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-408">Die Kenn Wort Bytes werden direkt an die kdf (Key derivations Function) übergeben, die von dem durch angegeben Algorithmus verwendet werden `pbeParameters` .</span><span class="sxs-lookup"><span data-stu-id="3ea37-408">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by `pbeParameters`.</span></span>
<span data-ttu-id="3ea37-409">Dadurch wird die Kompatibilität mit anderen Systemen ermöglicht, bei denen bei der Verarbeitung von Kenn Wörtern mit PBKDF2 eine andere Text Codierung als UTF-8 verwendet wird (Kenn Wort basierte Schlüssel abderivations Funktion 2).</span><span class="sxs-lookup"><span data-stu-id="3ea37-409">This enables compatibility with other systems which use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-410">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-410">The key could not be exported.</span></span>

<span data-ttu-id="3ea37-411">- oder -</span><span class="sxs-lookup"><span data-stu-id="3ea37-411">-or-</span></span>

<span data-ttu-id="3ea37-412"><paramref name="pbeParameters" /> gibt an, dass <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> verwendet werden soll, wofür <see cref="T:System.Char" />-basierte Kennwörter erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="3ea37-412"><paramref name="pbeParameters" /> indicates that <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> should be used, which requires <see cref="T:System.Char" />-based passwords.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters? pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportEncryptedPkcs8PrivateKey (password As ReadOnlySpan(Of Char), pbeParameters As PbeParameters, destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; * int -&gt; bool" Usage="eCDiffieHellman.TryExportEncryptedPkcs8PrivateKey (password, pbeParameters, destination, bytesWritten)" />
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="3ea37-413">Das Kennwort, das bei der Verschlüsselung des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="3ea37-413">The password to use when encrypting the key material.</span></span></param>
        <param name="pbeParameters"><span data-ttu-id="3ea37-414">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-414">The password-based encryption (PBE) parameters to use when encrypting the key material.</span></span></param>
        <param name="destination"><span data-ttu-id="3ea37-415">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-415">The byte span to receive the PKCS#8 EncryptedPrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="3ea37-416">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-416">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="3ea37-417">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-417">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="3ea37-418">Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem zeichenbasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</span><span class="sxs-lookup"><span data-stu-id="3ea37-418">Attempts to export the current key in the PKCS#8 EncryptedPrivateKeyInfo format into a provided buffer, using a char-based password.</span></span></summary>
        <returns><span data-ttu-id="3ea37-419"><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-419"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3ea37-420">Wenn `pbeParameters` einen Algorithmus angibt, der PBKDF2 (Kenn Wort basierte Schlüssel abderivations Funktion 2) verwendet, wird das Kennwort über die UTF-8-Codierung in Bytes konvertiert.</span><span class="sxs-lookup"><span data-stu-id="3ea37-420">When `pbeParameters` indicates an algorithm that uses PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-421">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-421">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportPkcs8PrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportPkcs8PrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportPkcs8PrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportPkcs8PrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportPkcs8PrivateKey : Span&lt;byte&gt; * int -&gt; bool" Usage="eCDiffieHellman.TryExportPkcs8PrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3ea37-422">Die Bytespanne, in der die PKCS#8-PrivateKeyInfo-Daten empfangen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-422">The byte span to receive the PKCS#8 PrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="3ea37-423">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-423">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="3ea37-424">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-424">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="3ea37-425">Versucht, den aktuellen Schlüssel im PKCS#8-PrivateKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</span><span class="sxs-lookup"><span data-stu-id="3ea37-425">Attempts to export the current key in the PKCS#8 PrivateKeyInfo format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="3ea37-426"><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-426"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-427">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-427">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override bool TryExportSubjectPublicKeyInfo (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportSubjectPublicKeyInfo(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportSubjectPublicKeyInfo (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportSubjectPublicKeyInfo(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportSubjectPublicKeyInfo : Span&lt;byte&gt; * int -&gt; bool" Usage="eCDiffieHellman.TryExportSubjectPublicKeyInfo (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="3ea37-428">Die Bytespanne, in der die X.509-SubjectPublicKeyInfo-Daten empfangen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="3ea37-428">The byte span to receive the X.509 SubjectPublicKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="3ea37-429">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-429">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="3ea37-430">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="3ea37-430">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="3ea37-431">Versucht, den aktuellen Schlüssel im X.509-SubjectPublicKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</span><span class="sxs-lookup"><span data-stu-id="3ea37-431">Attempts to export the current key in the X.509 SubjectPublicKeyInfo format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="3ea37-432"><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3ea37-432"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="3ea37-433">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="3ea37-433">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportSubjectPublicKeyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>
