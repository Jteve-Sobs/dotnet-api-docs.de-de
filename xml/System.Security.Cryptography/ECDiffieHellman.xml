<Type Name="ECDiffieHellman" FullName="System.Security.Cryptography.ECDiffieHellman">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bff461656b1e3fe8b75f6ecbb004997a6719d009" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69083243" /></Metadata><TypeSignature Language="C#" Value="public abstract class ECDiffieHellman : System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ECDiffieHellman extends System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ECDiffieHellman&#xA;Inherits AsymmetricAlgorithm" />
  <TypeSignature Language="C++ CLI" Value="public ref class ECDiffieHellman abstract : System::Security::Cryptography::AsymmetricAlgorithm" />
  <TypeSignature Language="F#" Value="type ECDiffieHellman = class&#xA;    inherit AsymmetricAlgorithm" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.AsymmetricAlgorithm</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="53c23-101">Stellt eine abstrakte Basisklasse bereit, von der Implementierungen des ECDH (Elliptic Curve Diffie-Hellman)-Algorithmus abgeleitet werden können.</span><span class="sxs-lookup"><span data-stu-id="53c23-101">Provides an abstract base class that Elliptic Curve Diffie-Hellman (ECDH) algorithm implementations can derive from.</span></span> <span data-ttu-id="53c23-102">Diese Klasse stellt einen grundlegenden Satz an Operationen bereit, den alle ECDH-Implementierungen unterstützen müssen.</span><span class="sxs-lookup"><span data-stu-id="53c23-102">This class provides the basic set of operations that all ECDH implementations must support.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-103">Diese Klasse fungiert als abstrakte Basisklasse für ECDH-Implementierungen.</span><span class="sxs-lookup"><span data-stu-id="53c23-103">This class serves as the abstract base class for ECDH implementations.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ECDiffieHellman ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ECDiffieHellman();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="53c23-104">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="53c23-104">Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-105">Dieser Konstruktor wird von Klassen aufgerufen, die von der <xref:System.Security.Cryptography.ECDiffieHellman> -Klasse abgeleitet werden.</span><span class="sxs-lookup"><span data-stu-id="53c23-105">This constructor is called by classes that derive from the <xref:System.Security.Cryptography.ECDiffieHellman> class.</span></span> <span data-ttu-id="53c23-106">Die <xref:System.Security.Cryptography.ECDiffieHellmanCng> -Klasse ist die einzige Implementierung, die derzeit [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]in enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="53c23-106">The <xref:System.Security.Cryptography.ECDiffieHellmanCng> class is the only implementation that is currently included in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span> <span data-ttu-id="53c23-107">Weitere Informationen zum Erstellen einer neuen Implementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman) finden Sie unter der <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> -Methode.</span><span class="sxs-lookup"><span data-stu-id="53c23-107">For information about how to create a new implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm, see the <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="53c23-108">Erstellt eine neue Instanz einer Implementierung des ECDH (Elliptic Curve Diffie-Hellman)-Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="53c23-108">Creates a new instance of an implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="53c23-109">Erstellt eine neue Instanz der Standardimplementierung des ECDH (Elliptic Curve Diffie-Hellman)-Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="53c23-109">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
        <returns><span data-ttu-id="53c23-110">Eine neue Instanz der Standardimplementierung dieser Klasse.</span><span class="sxs-lookup"><span data-stu-id="53c23-110">A new instance of the default implementation of this class.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (curve As ECCurve) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECCurve -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="curve"><span data-ttu-id="53c23-111">Die Kurve, die für das Generieren eines neuen Paars aus privatem und öffentlichem Schlüssel verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-111">The curve to use to generate a new public/private key-pair.</span></span></param>
        <summary><span data-ttu-id="53c23-112">Erstellt eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman) mit einem neuen Paar aus öffentlichem und privatem Schlüssel, das über die angegebene Kurve generiert wurde.</span><span class="sxs-lookup"><span data-stu-id="53c23-112">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with a new public/private key-pair generated over the specified curve.</span></span></summary>
        <returns><span data-ttu-id="53c23-113">Eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman).</span><span class="sxs-lookup"><span data-stu-id="53c23-113">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-114">die Kurve muss überprüft werden (d. h., Sie muss "true <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> " zurückgeben, wenn Sie an die Methode</span><span class="sxs-lookup"><span data-stu-id="53c23-114">curve must validate (that is, it must return true when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="53c23-115">Merkmal-2-Kurven werden unter Windows nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="53c23-115">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-116"><paramref name="curve" /> führt keine Validierung durch.</span><span class="sxs-lookup"><span data-stu-id="53c23-116"><paramref name="curve" /> does not validate.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (parameters As ECParameters) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECParameters -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="parameters"><span data-ttu-id="53c23-117">Die Parameter für den ECC-Algorithmus (Elliptic Curve Cryptography)</span><span class="sxs-lookup"><span data-stu-id="53c23-117">The parameters  for the elliptic curve cryptography (ECC) algorithm.</span></span></param>
        <summary><span data-ttu-id="53c23-118">Erstellt eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman) mit dem Schlüssel, der im angegebenen <see cref="T:System.Security.Cryptography.ECParameters" />-Objekt beschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-118">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with the key described by the specified  <see cref="T:System.Security.Cryptography.ECParameters" /> object.</span></span></summary>
        <returns><span data-ttu-id="53c23-119">Eine neue Instanz der Standardimplementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman).</span><span class="sxs-lookup"><span data-stu-id="53c23-119">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-120">`parameters`muss bei der Übergabe an die `true` <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> -Methode validieren (d. h., Sie muss zurückgegeben werden).</span><span class="sxs-lookup"><span data-stu-id="53c23-120">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="53c23-121">Parameter über implizite Kurven werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="53c23-121">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="53c23-122">Merkmal-2-Kurven werden unter Windows nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="53c23-122">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-123"><paramref name="parameters" /> führt keine Validierung durch.</span><span class="sxs-lookup"><span data-stu-id="53c23-123"><paramref name="parameters" /> does not validate.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (string algorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(string algorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algorithm As String) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::String ^ algorithm);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create algorithm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algorithm" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="algorithm"><span data-ttu-id="53c23-124">Der Name einer Implementierung des ECDH-Algorithmus.</span><span class="sxs-lookup"><span data-stu-id="53c23-124">The name of an implementation of the ECDH algorithm.</span></span></param>
        <summary><span data-ttu-id="53c23-125">Erstellt eine neue Instanz der angegebenen Implementierung des ECDH-Algorithmus (Elliptic Curve Diffie-Hellman)</span><span class="sxs-lookup"><span data-stu-id="53c23-125">Creates a new instance of the specified implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span></span></summary>
        <returns><span data-ttu-id="53c23-126">Eine neue Instanz der angegebenen Implementierung dieser Klasse.</span><span class="sxs-lookup"><span data-stu-id="53c23-126">A new instance of the specified implementation of this class.</span></span> <span data-ttu-id="53c23-127">Wenn der angegebene Name des Algorithmus keiner ECDH-Implementierung zugeordnet ist, gibt diese Methode <see langword="null" /> zurück.</span><span class="sxs-lookup"><span data-stu-id="53c23-127">If the specified algorithm name does not map to an ECDH implementation, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-128">Wenn Sie Ihre eigene Implementierung eines <xref:System.Security.Cryptography.ECDiffieHellman> Objekts entwickeln, können Sie die <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> -Methoden Überladung verwenden, um eine `algorithm` benutzerdefinierte Zeichenfolge zu erstellen, die ihre Implementierung angibt.</span><span class="sxs-lookup"><span data-stu-id="53c23-128">If you develop your own implementation of an <xref:System.Security.Cryptography.ECDiffieHellman> object, you can use the <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> method overload to create a custom `algorithm` string that specifies your implementation.</span></span>  
  
 <span data-ttu-id="53c23-129">Der `algorithm` -Parameter gibt den Namen einer Implementierung des ECDH-Algorithmus an.</span><span class="sxs-lookup"><span data-stu-id="53c23-129">The `algorithm` parameter specifies the name of an implementation of the ECDH algorithm.</span></span> <span data-ttu-id="53c23-130">Die folgenden Zeichenfolgen verweisen alle auf dieselbe Implementierung, bei der es sich um die einzige aktuell in [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] unterstützte Implementierung handelt:</span><span class="sxs-lookup"><span data-stu-id="53c23-130">The following strings all refer to the same implementation, which is the only implementation currently supported in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]:</span></span>  
  
-   <span data-ttu-id="53c23-131">"ECDH"</span><span class="sxs-lookup"><span data-stu-id="53c23-131">"ECDH"</span></span>  
  
-   <span data-ttu-id="53c23-132">"ECDiffieHellman"</span><span class="sxs-lookup"><span data-stu-id="53c23-132">"ECDiffieHellman"</span></span>  
  
-   <span data-ttu-id="53c23-133">"ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="53c23-133">"ECDiffieHellmanCng"</span></span>  
  
-   <span data-ttu-id="53c23-134">"System.Security.Cryptography.ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="53c23-134">"System.Security.Cryptography.ECDiffieHellmanCng"</span></span>  
  
 <span data-ttu-id="53c23-135">Sie können auch angeben, den Namen einer benutzerdefinierten ECDH-Implementierung für die `algorithm` Parameter.</span><span class="sxs-lookup"><span data-stu-id="53c23-135">You can also provide the name of a custom ECDH implementation for the `algorithm` parameter.</span></span> <span data-ttu-id="53c23-136">Wenn Sie dies tun, wird <xref:System.Security.Cryptography.CryptoConfig> es vom Objekt verwendet, um zu bestimmen, ob ein ECDH-Objekt erstellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="53c23-136">If you do that, the <xref:System.Security.Cryptography.CryptoConfig> object will use it to determine whether an ECDH object can be created.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="53c23-137">Der <paramref name="algorithm" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="53c23-137">The <paramref name="algorithm" /> parameter is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHash">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="53c23-138">Leitet Bytes ab, die als Schlüssel mit einer Hashfunktion verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="53c23-138">Derives bytes that can be used as a key using a hash function .</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="53c23-139">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-139">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="53c23-140">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="53c23-140">The hash algorithm  to use to derive the key material.</span></span></param>
        <summary><span data-ttu-id="53c23-141">Leitet Bytes ab, die mithilfe einer Hashfunktion als Schlüssel verwendet werden können. Der öffentliche Schlüssel einer anderen Partei und der Name des Hashalgorithmus werden übergeben.</span><span class="sxs-lookup"><span data-stu-id="53c23-141">Derives bytes that can be used as a key using a hash function, given another party's public key and hash algorithm's name.</span></span></summary>
        <returns><span data-ttu-id="53c23-142">Das Schlüsselmaterial aus dem Schlüsselaustausch mit dem öffentlichen Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-142">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-143">Diese Überladung ruft <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> die `null` Methode auf, die als vorangestellt und angefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="53c23-143">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="53c23-144"><paramref name="otherPartyPublicKey" /> befindet sich über einer anderen Kurve als dieser Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="53c23-144"><paramref name="otherPartyPublicKey" /> is over a different curve than this key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm, secretPrepend, secretAppend)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretAppend" Type="System.Byte[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="53c23-145">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-145">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="53c23-146">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="53c23-146">The hash algorithm  to use to derive the key material.</span></span></param>
        <param name="secretPrepend"><span data-ttu-id="53c23-147">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren vorangestellt wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-147">A value to prepend to the derived secret before hashing.</span></span></param>
        <param name="secretAppend"><span data-ttu-id="53c23-148">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren angefügt wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-148">A value to append to the derived secret before hashing.</span></span></param>
        <summary><span data-ttu-id="53c23-149">Leitet bei Implementierung in einer abgeleiteten Klasse Bytes ab, die mithilfe einer Hashfunktion als Schlüssel verwendet werden können. Der öffentliche Schlüssel einer anderen Partei, der Name des Hashalgorithmus, ein vorangestellter und ein angefügter Wert werden übergeben.</span><span class="sxs-lookup"><span data-stu-id="53c23-149">When implemented in a derived class, derives bytes that can be used as a key using a hash function, given another party's public key, hash algorithm's name, a prepend value and an append value.</span></span></summary>
        <returns><span data-ttu-id="53c23-150">Das Schlüsselmaterial aus dem Schlüsselaustausch mit dem öffentlichen Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-150">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="53c23-151">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="53c23-151">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="53c23-152"><paramref name="otherPartyPublicKey" /> befindet sich über einer anderen Kurve als dieser Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="53c23-152"><paramref name="otherPartyPublicKey" /> is over a different curve than this key.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHmac">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="53c23-153">Leitet Bytes ab, die als Schlüssel mit einem Hash-based Message Authentication Code (HMAC) verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="53c23-153">Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hmacKey" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="53c23-154">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-154">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="53c23-155">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="53c23-155">The hash algorithm to use to derive the key material.</span></span></param>
        <param name="hmacKey"><span data-ttu-id="53c23-156">Der Schlüssel für den HMAC.</span><span class="sxs-lookup"><span data-stu-id="53c23-156">The key for the HMAC.</span></span></param>
        <summary><span data-ttu-id="53c23-157">Leitet Bytes ab, die als Schlüssel mit einem Hash-based Message Authentication Code (HMAC) verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="53c23-157">Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span></span></summary>
        <returns><span data-ttu-id="53c23-158">Das Schlüsselmaterial aus dem Schlüsselaustausch mit dem öffentlichen Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-158">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-159">Diese Überladung ruft <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> die `null` Methode auf, die als vorangestellt und angefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="53c23-159">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="53c23-160"><paramref name="otherPartyPublicKey" /> befindet sich über einer anderen Kurve als dieser Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="53c23-160"><paramref name="otherPartyPublicKey" /> is over a different curve than this key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte(), secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey, secretPrepend, secretAppend)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="hmacKey" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="secretAppend" Type="System.Byte[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="53c23-161">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-161">The other party's public key.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="53c23-162">Der Hashalgorithmus, der zum Ableiten des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="53c23-162">The hash algorithm to use to derive the key material.</span></span></param>
        <param name="hmacKey"><span data-ttu-id="53c23-163">Der Schlüssel für den HMAC.</span><span class="sxs-lookup"><span data-stu-id="53c23-163">The key for the HMAC.</span></span></param>
        <param name="secretPrepend"><span data-ttu-id="53c23-164">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren vorangestellt wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-164">A value to prepend to the derived secret before hashing.</span></span></param>
        <param name="secretAppend"><span data-ttu-id="53c23-165">Ein Wert, der dem abgeleiteten geheimen Schlüssel vor dem Hashverfahren angefügt wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-165">A value to append to the derived secret before hashing.</span></span></param>
        <summary><span data-ttu-id="53c23-166">Leitet bei Implementierung in eine abgeleitete Klasse Bytes ab, die mit einem Hash-based Message Authentication Code (HMAC) als Schlüssel verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="53c23-166">When implemented in a derived class, derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span></span></summary>
        <returns><span data-ttu-id="53c23-167">Das Schlüsselmaterial aus dem Schlüsselaustausch mit dem öffentlichen Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-167">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="53c23-168">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="53c23-168">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="53c23-169"><paramref name="otherPartyPublicKey" /> befindet sich über einer anderen Kurve als dieser Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="53c23-169"><paramref name="otherPartyPublicKey" /> is over a different curve than this key.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]&#xA;override this.DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyMaterial otherPartyPublicKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="53c23-170">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-170">The other party's public key.</span></span></param>
        <summary><span data-ttu-id="53c23-171">Leitet aus dem öffentlichen Schlüssel eines anderen Benutzers Bytes ab, die als Schlüssel verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="53c23-171">Derives bytes that can be used as a key, given another party's public key.</span></span></summary>
        <returns><span data-ttu-id="53c23-172">Das Schlüsselmaterial aus dem Schlüsselaustausch mit dem öffentlichen Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-172">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-173">Weitere Informationen zu öffentlichen Schlüsseln finden Sie in der <xref:System.Security.Cryptography.ECDiffieHellmanPublicKey> -Klasse.</span><span class="sxs-lookup"><span data-stu-id="53c23-173">For more information about public keys, see the <xref:System.Security.Cryptography.ECDiffieHellmanPublicKey> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyTls">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyTls (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyTls(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, unsigned int8[] prfLabel, unsigned int8[] prfSeed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyTls (otherPartyPublicKey As ECDiffieHellmanPublicKey, prfLabel As Byte(), prfSeed As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyTls(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, cli::array &lt;System::Byte&gt; ^ prfLabel, cli::array &lt;System::Byte&gt; ^ prfSeed);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyTls (otherPartyPublicKey, prfLabel, prfSeed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="prfLabel" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
        <Parameter Name="prfSeed" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey"><span data-ttu-id="53c23-174">Der öffentliche Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-174">The other party's public key.</span></span></param>
        <param name="prfLabel"><span data-ttu-id="53c23-175">Die ASCII-codierte PRF-Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="53c23-175">The ASCII-encoded PRF label.</span></span></param>
        <param name="prfSeed"><span data-ttu-id="53c23-176">Der 64-Byte-PRF-Startwert.</span><span class="sxs-lookup"><span data-stu-id="53c23-176">The 64-byte PRF seed.</span></span></param>
        <summary><span data-ttu-id="53c23-177">Leitet bei Implementierung in einer abgeleiteten Klasse Bytes ab, die mithilfe eines Transport Layer Security-Pseudo-Random Function-Ableitungsalgorithmus (TLS, PRF) als Schlüssel verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="53c23-177">When implemented in a derived class, derives bytes that can be used as a key using a Transport Layer Security (TLS) Pseudo-Random Function (PRF) derivation algorithm.</span></span></summary>
        <returns><span data-ttu-id="53c23-178">Das Schlüsselmaterial aus dem Schlüsselaustausch mit dem öffentlichen Schlüssel der anderen Partei.</span><span class="sxs-lookup"><span data-stu-id="53c23-178">The key material from the key exchange with the other party's public key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="53c23-179">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="53c23-179">A derived class must override this method.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="53c23-180"><paramref name="otherPartyPublicKey" /> befindet sich über einer anderen Kurve als dieser Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="53c23-180"><paramref name="otherPartyPublicKey" /> is over a different curve than this key.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="53c23-181"><paramref name="prfLabel" /> oder <paramref name="prfSeed" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="53c23-181"><paramref name="prfLabel" /> or <paramref name="prfSeed" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-182"><paramref name="prfSeed" /> ist nicht genau 64 Bytes lang.</span><span class="sxs-lookup"><span data-stu-id="53c23-182"><paramref name="prfSeed" /> is not exactly 64 bytes in length.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual byte[] ExportECPrivateKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportECPrivateKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportECPrivateKey () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ExportECPrivateKey();" />
      <MemberSignature Language="F#" Value="abstract member ExportECPrivateKey : unit -&gt; byte[]&#xA;override this.ExportECPrivateKey : unit -&gt; byte[]" Usage="eCDiffieHellman.ExportECPrivateKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="53c23-183">Exportiert den aktuellen Schlüssel im ECPrivateKey-Format.</span><span class="sxs-lookup"><span data-stu-id="53c23-183">Exports the current key in the ECPrivateKey format.</span></span></summary>
        <returns><span data-ttu-id="53c23-184">Ein Bytearray mit der ECPrivateKey-Darstellung dieses Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="53c23-184">A byte array containing the ECPrivateKey representation of this key.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-185">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="53c23-185">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="ExportExplicitParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportExplicitParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportExplicitParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportExplicitParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportExplicitParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportExplicitParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="53c23-186"><see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="53c23-186"><see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="53c23-187">Exportiert beim Überschreiben in einer abgeleiteten Klasse Informationen zum öffentlichen oder zum öffentlichen und privaten Schlüssel unter Verwendung der expliziten Kurvenform aus einem verwendeten <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Schlüssel in eine <see cref="T:System.Security.Cryptography.ECParameters" />-Struktur, damit sie an die <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />-Methode übergeben werden können.</span><span class="sxs-lookup"><span data-stu-id="53c23-187">When overridden in a derived class, exports either the public or the public and private key information using the explicit curve form from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></summary>
        <returns><span data-ttu-id="53c23-188">Ein Objekt, das unter Verwendung des expliziten Kurvenformats den Punkt auf der Kurve für diesen Schlüssel darstellt.</span><span class="sxs-lookup"><span data-stu-id="53c23-188">An object that represents the point on the curve for this key, using the explicit curve format.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="53c23-189">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="53c23-189">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="53c23-190"><see langword="true" />, um private Parameter einzuschließen, oder <see langword="false" />, um nur die öffentlichen Parameter einzuschließen.</span><span class="sxs-lookup"><span data-stu-id="53c23-190"><see langword="true" /> to include private parameters; otherwise, <see langword="false" /> to include public parameters only.</span></span></param>
        <summary><span data-ttu-id="53c23-191">Exportiert beim Überschreiben in einer abgeleiteten Klasse Informationen zum öffentlichen oder zum öffentlichen und privaten Schlüssel aus einem verwendeten <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Schlüssel in eine <see cref="T:System.Security.Cryptography.ECParameters" />-Struktur, damit sie an die <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />-Methode übergeben werden können.</span><span class="sxs-lookup"><span data-stu-id="53c23-191">When overridden in a derived class, exports either the public or the public and private key information from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></summary>
        <returns><span data-ttu-id="53c23-192">Ein Objekt, das den Punkt auf der Kurve für diesen Schlüssel darstellt.</span><span class="sxs-lookup"><span data-stu-id="53c23-192">An object that represents the point on the curve for this key.</span></span> <span data-ttu-id="53c23-193">Es kann an die <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />-Methode übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="53c23-193">It can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-194">Wenn die Kurve einen Namen hat, enthält <xref:System.Security.Cryptography.ECParameters.Curve> die Eigenschaft benannte Kurven Parameter, andernfalls enthält Sie explizite Parameter.</span><span class="sxs-lookup"><span data-stu-id="53c23-194">If the curve has a name, the <xref:System.Security.Cryptography.ECParameters.Curve> property contains named curve parameters; otherwise, it will contain explicit parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="53c23-195">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="53c23-195">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public override void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXmlString(System::String ^ xmlString);" />
      <MemberSignature Language="F#" Value="override this.FromXmlString : string -&gt; unit" Usage="eCDiffieHellman.FromXmlString xmlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="xmlString"><span data-ttu-id="53c23-196">Die XML-Zeichenfolge zur Wiederherstellung des <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" />-Objekts.</span><span class="sxs-lookup"><span data-stu-id="53c23-196">The XML string to use to reconstruct the <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> object.</span></span></param>
        <summary><span data-ttu-id="53c23-197">Diese Methode löst in allen Fällen aus.</span><span class="sxs-lookup"><span data-stu-id="53c23-197">This method throws in all cases.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="System.NotImplementedException"><span data-ttu-id="53c23-198">In allen Fällen.</span><span class="sxs-lookup"><span data-stu-id="53c23-198">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public virtual void GenerateKey (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateKey(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateKey (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateKey(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="abstract member GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit&#xA;override this.GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit" Usage="eCDiffieHellman.GenerateKey curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="curve"><span data-ttu-id="53c23-199">Die Kurve, die für das Generieren eines kurzlebigen Paars aus privatem und öffentlichem Schlüssel verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-199">The curve used to generate an ephemeral public/private key pair.</span></span></param>
        <summary><span data-ttu-id="53c23-200">Generiert beim Überschreiben in einer abgeleiteten Klasse ein neues kurzlebiges Paar aus privatem und öffentlichem Schlüssel für die angegebene Kurve.</span><span class="sxs-lookup"><span data-stu-id="53c23-200">When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-201">`curve`muss bei der Übergabe an die `true` <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> -Methode validieren (d. h., er muss zurückgeben) und darf nicht implizit sein.</span><span class="sxs-lookup"><span data-stu-id="53c23-201">`curve` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method) and must not be implicit.</span></span>  
  
 <span data-ttu-id="53c23-202">Merkmal-2-Kurven werden unter Windows nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="53c23-202">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-203"><paramref name="curve" /> führt keine Validierung durch.</span><span class="sxs-lookup"><span data-stu-id="53c23-203"><paramref name="curve" /> does not validate.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="53c23-204">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="53c23-204">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual void ImportECPrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportECPrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportECPrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportECPrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportECPrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="abstract member ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; *  -&gt; unit&#xA;override this.ImportECPrivateKey : ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="eCDiffieHellman.ImportECPrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="53c23-205">Die Bytes einer ECPrivateKey-Struktur in der ASN.1-BER-Codierung.</span><span class="sxs-lookup"><span data-stu-id="53c23-205">The bytes of an ECPrivateKey structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="53c23-206">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="53c23-206">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="53c23-207">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="53c23-207">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="53c23-208">Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer ECPrivateKey-Struktur und ersetzt dabei die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="53c23-208">Imports the public/private keypair from an ECPrivateKey structure, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-209">Diese Methode unterstützt nur die binäre Codierung (ber/CER/der) von ecprivatekey.</span><span class="sxs-lookup"><span data-stu-id="53c23-209">This method only supports the binary (BER/CER/DER) encoding of ECPrivateKey.</span></span>
<span data-ttu-id="53c23-210">Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.</span><span class="sxs-lookup"><span data-stu-id="53c23-210">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-211">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-ECPrivateKey-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="53c23-211">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 ECPrivateKey structure.</span></span>

<span data-ttu-id="53c23-212">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-212">-or-</span></span>

<span data-ttu-id="53c23-213">Fehler beim Schlüsselimport.</span><span class="sxs-lookup"><span data-stu-id="53c23-213">The key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (passwordBytes As ReadOnlySpan(Of Byte), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="eCDiffieHellman.ImportEncryptedPkcs8PrivateKey (passwordBytes, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="passwordBytes"><span data-ttu-id="53c23-214">Die Bytes, die als Kennwort bei der Entschlüsselung des Schlüsselmaterials verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="53c23-214">The bytes to use as a password when decrypting the key material.</span></span></param>
        <param name="source"><span data-ttu-id="53c23-215">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</span><span class="sxs-lookup"><span data-stu-id="53c23-215">The bytes of a PKCS#8 EncryptedPrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="53c23-216">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="53c23-216">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="53c23-217">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="53c23-217">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="53c23-218">Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem bytebasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="53c23-218">Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a byte-based password, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-219">Die Kenn Wort Bytes werden direkt an die kdf (Key derivations Function) übergeben, die vom Algorithmus verwendet wird, der durch den verschlüsseltedprivatekeyinfo-Inhalt angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-219">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by the EncryptedPrivateKeyInfo contents.</span></span>
<span data-ttu-id="53c23-220">Dadurch wird die Kompatibilität mit anderen Systemen ermöglicht, bei denen bei der Verarbeitung von Kenn Wörtern mit PBKDF2 eine andere Text Codierung als UTF-8 verwendet wird (Kenn Wort basierte Schlüssel abderivations Funktion 2).</span><span class="sxs-lookup"><span data-stu-id="53c23-220">This enables compatibility with other systems which use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>
<span data-ttu-id="53c23-221">Diese Methode unterstützt nur die binäre Codierung (ber/CER/der) von "verschlüsseltedprivatekeyinfo".</span><span class="sxs-lookup"><span data-stu-id="53c23-221">This method only supports the binary (BER/CER/DER) encoding of EncryptedPrivateKeyInfo.</span></span>
<span data-ttu-id="53c23-222">Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.</span><span class="sxs-lookup"><span data-stu-id="53c23-222">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-223">Das Kennwort ist falsch.</span><span class="sxs-lookup"><span data-stu-id="53c23-223">The password is incorrect.</span></span>

<span data-ttu-id="53c23-224">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-224">-or-</span></span>

<span data-ttu-id="53c23-225">Der Inhalt von <paramref name="source" /> gibt an, dass die anzuwendende Schlüsselableitungsfunktion die Legacy-PKCS#12-KDF ist, die <see cref="T:System.Char" />-basierte Kennwörter erfordert.</span><span class="sxs-lookup"><span data-stu-id="53c23-225">The contents of <paramref name="source" /> indicate the Key Derivation Function (KDF) to apply is the legacy PKCS#12 KDF, which requires <see cref="T:System.Char" />-based passwords.</span></span>

<span data-ttu-id="53c23-226">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-226">-or-</span></span>

<span data-ttu-id="53c23-227">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="53c23-227">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="53c23-228">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-228">-or-</span></span>

<span data-ttu-id="53c23-229">Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.</span><span class="sxs-lookup"><span data-stu-id="53c23-229">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="53c23-230">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-230">-or-</span></span>

<span data-ttu-id="53c23-231">Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-231">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="53c23-232">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-232">-or-</span></span>

<span data-ttu-id="53c23-233">Fehler beim Importieren des algorithmusspezifischen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="53c23-233">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportEncryptedPkcs8PrivateKey (password As ReadOnlySpan(Of Char), source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="eCDiffieHellman.ImportEncryptedPkcs8PrivateKey (password, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="53c23-234">Das Kennwort, das bei der Entschlüsselung des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="53c23-234">The password to use for decrypting the key material.</span></span></param>
        <param name="source"><span data-ttu-id="53c23-235">Die Bytes einer PKCS#8-EncryptedPrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</span><span class="sxs-lookup"><span data-stu-id="53c23-235">The bytes of a PKCS#8 EncryptedPrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="53c23-236">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="53c23-236">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="53c23-237">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="53c23-237">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="53c23-238">Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-EncryptedPrivateKeyInfo-Struktur nach der Entschlüsselung mit einem zeichenbasierten Kennwort und ersetzt die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="53c23-238">Imports the public/private keypair from a PKCS#8 EncryptedPrivateKeyInfo structure after decrypting with a char-based password, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-239">Wenn der Inhalt von `source` einen Algorithmus angibt, der PBKDF1 (Kenn Wort basierte Schlüssel abderivations Funktion 1) oder PBKDF2 (Kenn Wort basierte Schlüssel abderivations Funktion 2) verwendet, wird das Kennwort über die UTF-8-Codierung in Bytes konvertiert.</span><span class="sxs-lookup"><span data-stu-id="53c23-239">When the contents of `source` indicate an algorithm that uses PBKDF1 (Password-Based Key Derivation Function 1) or PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>
<span data-ttu-id="53c23-240">Diese Methode unterstützt nur die binäre Codierung (ber/CER/der) von "verschlüsseltedprivatekeyinfo".</span><span class="sxs-lookup"><span data-stu-id="53c23-240">This method only supports the binary (BER/CER/DER) encoding of EncryptedPrivateKeyInfo.</span></span>
<span data-ttu-id="53c23-241">Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.</span><span class="sxs-lookup"><span data-stu-id="53c23-241">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-242">Das Kennwort ist falsch.</span><span class="sxs-lookup"><span data-stu-id="53c23-242">The password is incorrect.</span></span>

<span data-ttu-id="53c23-243">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-243">-or-</span></span>

<span data-ttu-id="53c23-244">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-EncryptedPrivateKeyInfo-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="53c23-244">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 EncryptedPrivateKeyInfo structure.</span></span>

<span data-ttu-id="53c23-245">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-245">-or-</span></span>

<span data-ttu-id="53c23-246">Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.</span><span class="sxs-lookup"><span data-stu-id="53c23-246">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="53c23-247">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-247">-or-</span></span>

<span data-ttu-id="53c23-248">Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-248">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="53c23-249">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-249">-or-</span></span>

<span data-ttu-id="53c23-250">Fehler beim Importieren des algorithmusspezifischen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="53c23-250">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public virtual void ImportParameters (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportParameters(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportParameters (parameters As ECParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportParameters(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="abstract member ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit&#xA;override this.ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit" Usage="eCDiffieHellman.ImportParameters parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="parameters"><span data-ttu-id="53c23-251">Die zu importierenden Parameter der Kurve.</span><span class="sxs-lookup"><span data-stu-id="53c23-251">The curve's parameters to import.</span></span></param>
        <summary><span data-ttu-id="53c23-252">Importiert beim Überschreiben in einer abgeleiteten Klasse die angegebenen Parameter für eine <see cref="T:System.Security.Cryptography.ECCurve" /> als einen kurzlebigen Schlüssel in das aktuelle <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="53c23-252">When overridden in a derived class, imports the specified parameters for an <see cref="T:System.Security.Cryptography.ECCurve" /> as an ephemeral key into the current <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-253">`parameters`muss bei der Übergabe an die `true` <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> -Methode validieren (d. h., Sie muss zurückgegeben werden).</span><span class="sxs-lookup"><span data-stu-id="53c23-253">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="53c23-254">Parameter über implizite Kurven werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="53c23-254">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="53c23-255">Merkmal-2-Kurven werden unter Windows nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="53c23-255">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-256"><paramref name="parameters" /> führt keine Validierung durch.</span><span class="sxs-lookup"><span data-stu-id="53c23-256"><paramref name="parameters" /> does not validate.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="53c23-257">Eine abgeleitete Klasse muss diese Methode überschreiben.</span><span class="sxs-lookup"><span data-stu-id="53c23-257">A derived class must override this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override void ImportPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportPkcs8PrivateKey (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="eCDiffieHellman.ImportPkcs8PrivateKey (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="53c23-258">Die Bytes einer PKCS#8-PrivateKeyInfo-Struktur in der ASN.1-BER-Codierung.</span><span class="sxs-lookup"><span data-stu-id="53c23-258">The bytes of a PKCS#8 PrivateKeyInfo structure in the ASN.1-BER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="53c23-259">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="53c23-259">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="53c23-260">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="53c23-260">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="53c23-261">Importiert das Paar aus öffentlichem und privatem Schlüssel aus einer PKCS#8-PrivateKeyInfo-Struktur nach der Entschlüsselung und ersetzt die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="53c23-261">Imports the public/private keypair from a PKCS#8 PrivateKeyInfo structure after decryption, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-262">Diese Methode unterstützt nur die binäre Codierung (ber/CER/der) von privatekeyinfo.</span><span class="sxs-lookup"><span data-stu-id="53c23-262">This method only supports the binary (BER/CER/DER) encoding of PrivateKeyInfo.</span></span>
<span data-ttu-id="53c23-263">Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.</span><span class="sxs-lookup"><span data-stu-id="53c23-263">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-264">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-BER-codierte PKCS#8-PrivateKeyInfo-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="53c23-264">The contents of <paramref name="source" /> do not represent an ASN.1-BER-encoded PKCS#8 PrivateKeyInfo structure.</span></span>

<span data-ttu-id="53c23-265">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-265">-or-</span></span>

<span data-ttu-id="53c23-266">Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.</span><span class="sxs-lookup"><span data-stu-id="53c23-266">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="53c23-267">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-267">-or-</span></span>

<span data-ttu-id="53c23-268">Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-268">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="53c23-269">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-269">-or-</span></span>

<span data-ttu-id="53c23-270">Fehler beim Importieren des algorithmusspezifischen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="53c23-270">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ImportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override void ImportSubjectPublicKeyInfo (ReadOnlySpan&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportSubjectPublicKeyInfo(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportSubjectPublicKeyInfo(System.ReadOnlySpan{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ImportSubjectPublicKeyInfo (source As ReadOnlySpan(Of Byte), ByRef bytesRead As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ImportSubjectPublicKeyInfo(ReadOnlySpan&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="override this.ImportSubjectPublicKeyInfo : ReadOnlySpan&lt;byte&gt; *  -&gt; unit" Usage="eCDiffieHellman.ImportSubjectPublicKeyInfo (source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="53c23-271">Die Bytes einer X.509-SubjectPublicKeyInfo-Struktur in der ASN.1-DER-Codierung.</span><span class="sxs-lookup"><span data-stu-id="53c23-271">The bytes of an X.509 SubjectPublicKeyInfo structure in the ASN.1-DER encoding.</span></span></param>
        <param name="bytesRead"><span data-ttu-id="53c23-272">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die aus <paramref name="source" /> gelesen wurden.</span><span class="sxs-lookup"><span data-stu-id="53c23-272">When this method returns, contains a value that indicates the number of bytes read from <paramref name="source" />.</span></span> <span data-ttu-id="53c23-273">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="53c23-273">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="53c23-274">Importiert den öffentlichen Schlüssel aus einer X.509-SubjectPublicKeyInfo-Struktur nach der Entschlüsselung und ersetzt dabei die Schlüssel für dieses Objekt.</span><span class="sxs-lookup"><span data-stu-id="53c23-274">Imports the public key from an X.509 SubjectPublicKeyInfo structure after decryption, replacing the keys for this object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-275">Diese Methode unterstützt nur die binäre Codierung (der) von "subjetpublickeyinfo".</span><span class="sxs-lookup"><span data-stu-id="53c23-275">This method only supports the binary (DER) encoding of SubjectPublicKeyInfo.</span></span>
<span data-ttu-id="53c23-276">Wenn der Wert Base64-codiert ist oder im PEM-Textformat vorliegt, muss der Aufrufer den Inhalt vor dem Aufrufen dieser Methode Base64-decodieren.</span><span class="sxs-lookup"><span data-stu-id="53c23-276">If the value is Base64-encoded or in the PEM text format, the caller must Base64-decode the contents before calling this method.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-277">Der Inhalt von <paramref name="source" /> stellt keine ASN.1-DER-codierte X.509-SubjectPublicKeyInfo-Struktur dar.</span><span class="sxs-lookup"><span data-stu-id="53c23-277">The contents of <paramref name="source" /> do not represent an ASN.1-DER-encoded X.509 SubjectPublicKeyInfo structure.</span></span>

<span data-ttu-id="53c23-278">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-278">-or-</span></span>

<span data-ttu-id="53c23-279">Der Inhalt von <paramref name="source" /> gibt an, dass der Schlüssel für einen anderen Algorithmus als den von dieser Instanz dargestellten Algorithmus gilt.</span><span class="sxs-lookup"><span data-stu-id="53c23-279">The contents of <paramref name="source" /> indicate the key is for an algorithm other than the algorithm represented by this instance.</span></span>

<span data-ttu-id="53c23-280">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-280">-or-</span></span>

<span data-ttu-id="53c23-281">Der Inhalt von <paramref name="source" /> stellt den Schlüssel in einem Format dar, das nicht unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-281">The contents of <paramref name="source" /> represent the key in a format that is not supported.</span></span>

<span data-ttu-id="53c23-282">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-282">-or-</span></span>

<span data-ttu-id="53c23-283">Fehler beim Importieren des algorithmusspezifischen Schlüssels.</span><span class="sxs-lookup"><span data-stu-id="53c23-283">The algorithm-specific key import failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public override string KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property KeyExchangeAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ KeyExchangeAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53c23-284">Ruft den Namen des Algorithmus für den Schlüsselaustausch ab.</span><span class="sxs-lookup"><span data-stu-id="53c23-284">Gets the name of the key exchange algorithm.</span></span></summary>
        <value><span data-ttu-id="53c23-285">Der Name des Algorithmus für den Schlüsselaustausch.</span><span class="sxs-lookup"><span data-stu-id="53c23-285">The name of the key exchange algorithm.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-286">Die Standard Implementierung (nicht überschriebene) dieser Eigenschaft gibt die Zeichenfolge "ECDiffieHellman" zurück.</span><span class="sxs-lookup"><span data-stu-id="53c23-286">The default (non-overridden) implementation of this property returns the string "ECDiffieHellman".</span></span>  
  
 <span data-ttu-id="53c23-287">Diese Eigenschaft wird von der <xref:System.Security.Cryptography.AsymmetricAlgorithm> -Basisklasse geerbt.</span><span class="sxs-lookup"><span data-stu-id="53c23-287">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PublicKey As ECDiffieHellmanPublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Security::Cryptography::ECDiffieHellmanPublicKey ^ PublicKey { System::Security::Cryptography::ECDiffieHellmanPublicKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PublicKey : System.Security.Cryptography.ECDiffieHellmanPublicKey" Usage="System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanPublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53c23-288">Ruft den öffentlichen Schlüssel ab, der von der aktuellen ECDH (Elliptic Curve Diffie-Hellman)-Instanz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-288">Gets the public key that is being used by the current Elliptic Curve Diffie-Hellman (ECDH) instance.</span></span></summary>
        <value><span data-ttu-id="53c23-289">Der öffentliche Teil des ECDH-Schlüsselpaares, der von dieser <see cref="T:System.Security.Cryptography.ECDiffieHellman" />-Instanz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="53c23-289">The public part of the ECDH key pair that is being used by this <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> instance.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public override string SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SignatureAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SignatureAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="53c23-290">Ruft den Namen des Signaturalgorithmus ab.</span><span class="sxs-lookup"><span data-stu-id="53c23-290">Gets the name of the signature algorithm.</span></span></summary>
        <value><span data-ttu-id="53c23-291">Immer <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="53c23-291">Always <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-292">Diese Eigenschaft wird von der <xref:System.Security.Cryptography.AsymmetricAlgorithm> -Basisklasse geerbt.</span><span class="sxs-lookup"><span data-stu-id="53c23-292">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 <span data-ttu-id="53c23-293">Der ECDH-Algorithmus (Elliptic Curve Diffie-Hellman) wird für die Schlüssel Ableitung verwendet, nicht für die Generierung digitaler Signaturen.</span><span class="sxs-lookup"><span data-stu-id="53c23-293">The Elliptic Curve Diffie-Hellman (ECDH) algorithm is used for key derivation, not digital signature generation.</span></span> <span data-ttu-id="53c23-294">Daher gibt diese Eigenschaft zurück `null`.</span><span class="sxs-lookup"><span data-stu-id="53c23-294">Therefore, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public override string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="override this.ToXmlString : bool -&gt; string" Usage="eCDiffieHellman.ToXmlString includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters"><span data-ttu-id="53c23-295"><see langword="true" />, wenn private Parameter angegeben werden sollen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="53c23-295"><see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="53c23-296">Diese Methode löst in allen Fällen aus.</span><span class="sxs-lookup"><span data-stu-id="53c23-296">This method throws in all cases.</span></span></summary>
        <returns><span data-ttu-id="53c23-297">Diese Methode gibt keinen Wert zurück.</span><span class="sxs-lookup"><span data-stu-id="53c23-297">This method does not return a value.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="System.NotImplementedException"><span data-ttu-id="53c23-298">In allen Fällen.</span><span class="sxs-lookup"><span data-stu-id="53c23-298">In all cases.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryExportECPrivateKey">
      <MemberSignature Language="C#" Value="public virtual bool TryExportECPrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryExportECPrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportECPrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryExportECPrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryExportECPrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="abstract member TryExportECPrivateKey : Span&lt;byte&gt; *  -&gt; bool&#xA;override this.TryExportECPrivateKey : Span&lt;byte&gt; *  -&gt; bool" Usage="eCDiffieHellman.TryExportECPrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="53c23-299">Die Bytespanne, die die ECPrivateKey-Daten empfangen soll.</span><span class="sxs-lookup"><span data-stu-id="53c23-299">The byte span to receive the ECPrivateKey data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="53c23-300">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="53c23-300">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="53c23-301">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="53c23-301">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="53c23-302">Versucht, den aktuellen Schlüssel im ECPrivateKey-Format in einen bereitgestellten Puffer zu exportieren.</span><span class="sxs-lookup"><span data-stu-id="53c23-302">Attempts to export the current key in the ECPrivateKey format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="53c23-303"><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="53c23-303"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-304">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="53c23-304">The key could not be exported.</span></span></exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey()" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; *  -&gt; bool" Usage="eCDiffieHellman.TryExportEncryptedPkcs8PrivateKey (passwordBytes, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="passwordBytes"><span data-ttu-id="53c23-305">Die Bytes, die als Kennwort bei der Verschlüsselung des Schlüsselmaterials verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="53c23-305">The bytes to use as a password when encrypting the key material.</span></span></param>
        <param name="pbeParameters"><span data-ttu-id="53c23-306">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="53c23-306">The password-based encryption (PBE) parameters to use when encrypting the key material.</span></span></param>
        <param name="destination"><span data-ttu-id="53c23-307">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="53c23-307">The byte span to receive the PKCS#8 EncryptedPrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="53c23-308">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="53c23-308">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="53c23-309">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="53c23-309">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="53c23-310">Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem bytebasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</span><span class="sxs-lookup"><span data-stu-id="53c23-310">Attempts to export the current key in the PKCS#8 EncryptedPrivateKeyInfo format into a provided buffer, using a byte-based password.</span></span></summary>
        <returns><span data-ttu-id="53c23-311"><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="53c23-311"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-312">Die Kenn Wort Bytes werden direkt an die kdf (Key derivations Function) übergeben, die von dem durch `pbeParameters`angegeben Algorithmus verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="53c23-312">The password bytes are passed directly into the Key Derivation Function (KDF) used by the algorithm indicated by `pbeParameters`.</span></span>
<span data-ttu-id="53c23-313">Dadurch wird die Kompatibilität mit anderen Systemen ermöglicht, bei denen bei der Verarbeitung von Kenn Wörtern mit PBKDF2 eine andere Text Codierung als UTF-8 verwendet wird (Kenn Wort basierte Schlüssel abderivations Funktion 2).</span><span class="sxs-lookup"><span data-stu-id="53c23-313">This enables compatibility with other systems which use a text encoding other than UTF-8 when processing passwords with PBKDF2 (Password-Based Key Derivation Function 2).</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-314">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="53c23-314">The key could not be exported.</span></span>

<span data-ttu-id="53c23-315">- oder -</span><span class="sxs-lookup"><span data-stu-id="53c23-315">-or-</span></span>

<span data-ttu-id="53c23-316"><paramref name="pbeParameters" /> gibt an, dass <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> verwendet werden soll, wofür <see cref="T:System.Char" />-basierte Kennwörter erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="53c23-316"><paramref name="pbeParameters" /> indicates that <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> should be used, which requires <see cref="T:System.Char" />-based passwords.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportEncryptedPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportEncryptedPkcs8PrivateKey (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportEncryptedPkcs8PrivateKey(valuetype System.ReadOnlySpan`1&lt;char&gt; password, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan&lt;char&gt; password, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportEncryptedPkcs8PrivateKey : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; *  -&gt; bool" Usage="eCDiffieHellman.TryExportEncryptedPkcs8PrivateKey (password, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="password"><span data-ttu-id="53c23-317">Das Kennwort, das bei der Verschlüsselung des Schlüsselmaterials verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="53c23-317">The password to use when encrypting the key material.</span></span></param>
        <param name="pbeParameters"><span data-ttu-id="53c23-318">Die Parameter der kennwortbasierten Verschlüsselung, die bei der Verschlüsselung des Schlüsselmaterials verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="53c23-318">The password-based encryption (PBE) parameters to use when encrypting the key material.</span></span></param>
        <param name="destination"><span data-ttu-id="53c23-319">Die Bytespanne, in der die PKCS#8-EncryptedPrivateKeyInfo-Daten empfangen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="53c23-319">The byte span to receive the PKCS#8 EncryptedPrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="53c23-320">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="53c23-320">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="53c23-321">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="53c23-321">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="53c23-322">Versucht, den aktuellen Schlüssel im PKCS#8-EncryptedPrivateKeyInfo-Format mit einem zeichenbasierten Kennwort in einen bereitgestellten Puffer zu exportieren.</span><span class="sxs-lookup"><span data-stu-id="53c23-322">Attempts to export the current key in the PKCS#8 EncryptedPrivateKeyInfo format into a provided buffer, using a char-based password.</span></span></summary>
        <returns><span data-ttu-id="53c23-323"><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="53c23-323"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="53c23-324">Wenn `pbeParameters` einen Algorithmus angibt, der PBKDF2 (Kenn Wort basierte Schlüssel abderivations Funktion 2) verwendet, wird das Kennwort über die UTF-8-Codierung in Bytes konvertiert.</span><span class="sxs-lookup"><span data-stu-id="53c23-324">When `pbeParameters` indicates an algorithm that uses PBKDF2 (Password-Based Key Derivation Function 2), the password is converted to bytes via the UTF-8 encoding.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-325">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="53c23-325">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportPkcs8PrivateKey">
      <MemberSignature Language="C#" Value="public override bool TryExportPkcs8PrivateKey (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportPkcs8PrivateKey(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportPkcs8PrivateKey(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportPkcs8PrivateKey (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportPkcs8PrivateKey(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportPkcs8PrivateKey : Span&lt;byte&gt; *  -&gt; bool" Usage="eCDiffieHellman.TryExportPkcs8PrivateKey (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="53c23-326">Die Bytespanne, in der die PKCS#8-PrivateKeyInfo-Daten empfangen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="53c23-326">The byte span to receive the PKCS#8 PrivateKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="53c23-327">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="53c23-327">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="53c23-328">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="53c23-328">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="53c23-329">Versucht, den aktuellen Schlüssel im PKCS#8-PrivateKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</span><span class="sxs-lookup"><span data-stu-id="53c23-329">Attempts to export the current key in the PKCS#8 PrivateKeyInfo format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="53c23-330"><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="53c23-330"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-331">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="53c23-331">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="TryExportSubjectPublicKeyInfo">
      <MemberSignature Language="C#" Value="public override bool TryExportSubjectPublicKeyInfo (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool TryExportSubjectPublicKeyInfo(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.TryExportSubjectPublicKeyInfo(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function TryExportSubjectPublicKeyInfo (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool TryExportSubjectPublicKeyInfo(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryExportSubjectPublicKeyInfo : Span&lt;byte&gt; *  -&gt; bool" Usage="eCDiffieHellman.TryExportSubjectPublicKeyInfo (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="53c23-332">Die Bytespanne, in der die X.509-SubjectPublicKeyInfo-Daten empfangen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="53c23-332">The byte span to receive the X.509 SubjectPublicKeyInfo data.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="53c23-333">In der Rückgabe dieser Methode ist die Anzahl der Bytes enthalten, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="53c23-333">When this method returns, contains a value that indicates the number of bytes written to <paramref name="destination" />.</span></span> <span data-ttu-id="53c23-334">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="53c23-334">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="53c23-335">Versucht, den aktuellen Schlüssel im X.509-SubjectPublicKeyInfo-Format in einen bereitgestellten Puffer zu exportieren.</span><span class="sxs-lookup"><span data-stu-id="53c23-335">Attempts to export the current key in the X.509 SubjectPublicKeyInfo format into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="53c23-336"><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um die Ausgabe zu empfangen; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="53c23-336"><see langword="true" /> if <paramref name="destination" /> is big enough to receive the output; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><span data-ttu-id="53c23-337">Der Schlüssel konnte nicht exportiert werden.</span><span class="sxs-lookup"><span data-stu-id="53c23-337">The key could not be exported.</span></span></exception>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ExportSubjectPublicKeyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>
