<Type Name="PemEncoding" FullName="System.Security.Cryptography.PemEncoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4013121a306ecfaac8e22b5e0c6f15bb1b0ffe7c" /><Meta Name="ms.sourcegitcommit" Value="33529b5cc32683b91d3422992fb4dc422f85782b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/17/2020" /><Meta Name="ms.locfileid" Value="88267099" /></Metadata><TypeSignature Language="C#" Value="public static class PemEncoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit PemEncoding extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.PemEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class PemEncoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class PemEncoding abstract sealed" />
  <TypeSignature Language="F#" Value="type PemEncoding = class" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="f1625-101">Stellt Methoden zum Lesen und Schreiben der IETF RFC 7468-Teilmenge von PEM-Textcodierungen (Privacy-Enhanced Mail) bereit.</span><span class="sxs-lookup"><span data-stu-id="f1625-101">Provides methods for reading and writing the IETF RFC 7468 subset of PEM (Privacy-Enhanced Mail) textual encodings.</span></span>
<span data-ttu-id="f1625-102">Diese Klasse kann nicht vererbt werden.</span><span class="sxs-lookup"><span data-stu-id="f1625-102">This class cannot be inherited.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.PemFields Find (ReadOnlySpan&lt;char&gt; pemData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Security.Cryptography.PemFields Find(valuetype System.ReadOnlySpan`1&lt;char&gt; pemData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PemEncoding.Find(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find (pemData As ReadOnlySpan(Of Char)) As PemFields" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::PemFields Find(ReadOnlySpan&lt;char&gt; pemData);" />
      <MemberSignature Language="F#" Value="static member Find : ReadOnlySpan&lt;char&gt; -&gt; System.Security.Cryptography.PemFields" Usage="System.Security.Cryptography.PemEncoding.Find pemData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.PemFields</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pemData" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="pemData"><span data-ttu-id="f1625-103">Der Text, der die PEM-codierten Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="f1625-103">The text containing the PEM-encoded data.</span></span></param>
        <summary><span data-ttu-id="f1625-104">Sucht nach den ersten PEM-codierten Daten.</span><span class="sxs-lookup"><span data-stu-id="f1625-104">Finds the first PEM-encoded data.</span></span></summary>
        <returns><span data-ttu-id="f1625-105">Ein Wert, der den Speicherort, die Bezeichnung und den Datenspeicherort der codierten Daten angibt.</span><span class="sxs-lookup"><span data-stu-id="f1625-105">A value that specifies the location, label, and data location of the encoded data.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1625-106">IETF RFC 7468 gestattet verschiedene Decodierungs Regeln.</span><span class="sxs-lookup"><span data-stu-id="f1625-106">IETF RFC 7468 permits different decoding rules.</span></span> <span data-ttu-id="f1625-107">Diese Methode verwendet immer Lax-Regeln.</span><span class="sxs-lookup"><span data-stu-id="f1625-107">This method always uses lax rules.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1625-108"><paramref name="pemData" /> enthält keinen wohlgeformten PEM-codierten Wert.</span><span class="sxs-lookup"><span data-stu-id="f1625-108"><paramref name="pemData" /> does not contain a well-formed PEM-encoded value.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEncodedSize">
      <MemberSignature Language="C#" Value="public static int GetEncodedSize (int labelLength, int dataLength);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetEncodedSize(int32 labelLength, int32 dataLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PemEncoding.GetEncodedSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodedSize (labelLength As Integer, dataLength As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetEncodedSize(int labelLength, int dataLength);" />
      <MemberSignature Language="F#" Value="static member GetEncodedSize : int * int -&gt; int" Usage="System.Security.Cryptography.PemEncoding.GetEncodedSize (labelLength, dataLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="labelLength" Type="System.Int32" />
        <Parameter Name="dataLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="labelLength"><span data-ttu-id="f1625-109">Die Länge der Bezeichnung in Zeichen.</span><span class="sxs-lookup"><span data-stu-id="f1625-109">The length of the label, in characters.</span></span></param>
        <param name="dataLength"><span data-ttu-id="f1625-110">Die Länge der Daten in Bytes.</span><span class="sxs-lookup"><span data-stu-id="f1625-110">The length of the data, in bytes.</span></span></param>
        <summary><span data-ttu-id="f1625-111">Bestimmt die Länge eines PEM-codierten Werts (in Zeichen), wenn die Länge einer Bezeichnung und Binärdaten angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="f1625-111">Determines the length of a PEM-encoded value, in characters, given the length of a label and binary data.</span></span></summary>
        <returns><span data-ttu-id="f1625-112">Die Anzahl der Zeichen in der codierten PEM.</span><span class="sxs-lookup"><span data-stu-id="f1625-112">The number of characters in the encoded PEM.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f1625-113"><paramref name="labelLength" /> ist eine negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="f1625-113"><paramref name="labelLength" /> is a negative value.</span></span>

<span data-ttu-id="f1625-114">- oder -</span><span class="sxs-lookup"><span data-stu-id="f1625-114">-or-</span></span>

<span data-ttu-id="f1625-115"><paramref name="dataLength" /> ist eine negativer Wert.</span><span class="sxs-lookup"><span data-stu-id="f1625-115"><paramref name="dataLength" /> is a negative value.</span></span>

<span data-ttu-id="f1625-116">- oder -</span><span class="sxs-lookup"><span data-stu-id="f1625-116">-or-</span></span>

<span data-ttu-id="f1625-117"><paramref name="labelLength" /> überschreitet die maximal mögliche Bezeichnungslänge.</span><span class="sxs-lookup"><span data-stu-id="f1625-117"><paramref name="labelLength" /> exceeds the maximum possible label length.</span></span>

<span data-ttu-id="f1625-118">- oder -</span><span class="sxs-lookup"><span data-stu-id="f1625-118">-or-</span></span>

<span data-ttu-id="f1625-119"><paramref name="dataLength" /> überschreitet die maximal zulässige Länge codierter Daten.</span><span class="sxs-lookup"><span data-stu-id="f1625-119"><paramref name="dataLength" /> exceeds the maximum possible encoded data length.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1625-120">Die Länge des PEM-codierten Werts ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="f1625-120">The length of the PEM-encoded value is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryFind">
      <MemberSignature Language="C#" Value="public static bool TryFind (ReadOnlySpan&lt;char&gt; pemData, out System.Security.Cryptography.PemFields fields);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryFind(valuetype System.ReadOnlySpan`1&lt;char&gt; pemData, [out] valuetype System.Security.Cryptography.PemFields&amp; fields) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PemEncoding.TryFind(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PemFields@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFind (pemData As ReadOnlySpan(Of Char), ByRef fields As PemFields) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryFind(ReadOnlySpan&lt;char&gt; pemData, [Runtime::InteropServices::Out] System::Security::Cryptography::PemFields % fields);" />
      <MemberSignature Language="F#" Value="static member TryFind : ReadOnlySpan&lt;char&gt; * PemFields -&gt; bool" Usage="System.Security.Cryptography.PemEncoding.TryFind (pemData, fields)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pemData" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="fields" Type="System.Security.Cryptography.PemFields" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pemData"><span data-ttu-id="f1625-121">Der Text, der die PEM-codierten Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="f1625-121">The text containing the PEM-encoded data.</span></span></param>
        <param name="fields"><span data-ttu-id="f1625-122">Die Rückgabe dieser Methode ist ein Wert, der den Speicherort, die Bezeichnung und den Datenspeicherort der codierten Daten angibt. Wenn keine PEM-codierten Daten gefunden werden, wird ein Wert zurückgegeben, der diese Speicherorte als leer angibt.</span><span class="sxs-lookup"><span data-stu-id="f1625-122">When this method returns, contains a value that specifies the location, label, and data location of the encoded data; or, if no PEM-encoded data is found, a value that specifies those locations as empty.</span></span>

          <span data-ttu-id="f1625-123">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="f1625-123">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f1625-124">Versucht, die ersten PEM-codierten Daten zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="f1625-124">Attempts to find the first PEM-encoded data.</span></span></summary>
        <returns><span data-ttu-id="f1625-125"><see langword="true" />, wenn PEM-codierte Daten gefunden wurden, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f1625-125"><see langword="true" /> if PEM-encoded data was found; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1625-126">IETF RFC 7468 gestattet verschiedene Decodierungs Regeln.</span><span class="sxs-lookup"><span data-stu-id="f1625-126">IETF RFC 7468 permits different decoding rules.</span></span> <span data-ttu-id="f1625-127">Diese Methode verwendet immer Lax-Regeln.</span><span class="sxs-lookup"><span data-stu-id="f1625-127">This method always uses lax rules.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWrite">
      <MemberSignature Language="C#" Value="public static bool TryWrite (ReadOnlySpan&lt;char&gt; label, ReadOnlySpan&lt;byte&gt; data, Span&lt;char&gt; destination, out int charsWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryWrite(valuetype System.ReadOnlySpan`1&lt;char&gt; label, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PemEncoding.TryWrite(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryWrite (label As ReadOnlySpan(Of Char), data As ReadOnlySpan(Of Byte), destination As Span(Of Char), ByRef charsWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryWrite(ReadOnlySpan&lt;char&gt; label, ReadOnlySpan&lt;System::Byte&gt; data, Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten);" />
      <MemberSignature Language="F#" Value="static member TryWrite : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * int -&gt; bool" Usage="System.Security.Cryptography.PemEncoding.TryWrite (label, data, destination, charsWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="label"><span data-ttu-id="f1625-128">Die zu schreibende Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="f1625-128">The label to write.</span></span></param>
        <param name="data"><span data-ttu-id="f1625-129">Die zu schreibenden Daten.</span><span class="sxs-lookup"><span data-stu-id="f1625-129">The data to write.</span></span></param>
        <param name="destination"><span data-ttu-id="f1625-130">Der Puffer, der den PEM-codierten Text empfangen soll.</span><span class="sxs-lookup"><span data-stu-id="f1625-130">The buffer to receive the PEM-encoded text.</span></span></param>
        <param name="charsWritten"><span data-ttu-id="f1625-131">Nach dem Beenden dieser Methode enthält dieser Parameter die Anzahl der Zeichen, die in <paramref name="destination" /> geschrieben wurden.</span><span class="sxs-lookup"><span data-stu-id="f1625-131">When this method returns, this parameter contains the number of characters written to <paramref name="destination" />.</span></span> <span data-ttu-id="f1625-132">Dieser Parameter wird nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="f1625-132">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="f1625-133">Versucht, die bereitgestellten Daten und die Bezeichnung als PEM-codierte Daten in einen bereitgestellten Puffer zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="f1625-133">Tries to write the provided data and label as PEM-encoded data into a provided buffer.</span></span></summary>
        <returns><span data-ttu-id="f1625-134"><see langword="true" />, wenn <paramref name="destination" /> groß genug ist, um den PEM-codierten Text zu enthalten, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="f1625-134"><see langword="true" /> if <paramref name="destination" /> is large enough to contain the PEM-encoded text, otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1625-135">Diese Methode umschließt den Base64 64-codierten Text stets in 64 Zeichen gemäß der empfohlenen Umbrüche von IETF RFC 7468.</span><span class="sxs-lookup"><span data-stu-id="f1625-135">This method always wraps the base-64 encoded text to 64 characters, per the recommended wrapping of IETF RFC 7468.</span></span> <span data-ttu-id="f1625-136">Zeilenenden im Unix-Stil werden für Zeilenumbrüche verwendet.</span><span class="sxs-lookup"><span data-stu-id="f1625-136">Unix-style line endings are used for line breaks.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f1625-137"><paramref name="label" /> überschreitet die maximal mögliche Bezeichnungslänge.</span><span class="sxs-lookup"><span data-stu-id="f1625-137"><paramref name="label" /> exceeds the maximum possible label length.</span></span>

<span data-ttu-id="f1625-138">- oder -</span><span class="sxs-lookup"><span data-stu-id="f1625-138">-or-</span></span>

<span data-ttu-id="f1625-139"><paramref name="data" /> überschreitet die maximal zulässige Länge codierter Daten.</span><span class="sxs-lookup"><span data-stu-id="f1625-139"><paramref name="data" /> exceeds the maximum possible encoded data length.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1625-140">Der sich ergebende PEM-codierte Text ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="f1625-140">The resulting PEM-encoded text is larger than <see cref="F:System.Int32.MaxValue" />.</span></span>

<span data-ttu-id="f1625-141">- oder -</span><span class="sxs-lookup"><span data-stu-id="f1625-141">-or-</span></span>

<span data-ttu-id="f1625-142"><paramref name="label" /> enthält ungültige Zeichen.</span><span class="sxs-lookup"><span data-stu-id="f1625-142"><paramref name="label" /> contains invalid characters.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static char[]? Write (ReadOnlySpan&lt;char&gt; label, ReadOnlySpan&lt;byte&gt; data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char[] Write(valuetype System.ReadOnlySpan`1&lt;char&gt; label, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PemEncoding.Write(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Write (label As ReadOnlySpan(Of Char), data As ReadOnlySpan(Of Byte)) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;char&gt; ^ Write(ReadOnlySpan&lt;char&gt; label, ReadOnlySpan&lt;System::Byte&gt; data);" />
      <MemberSignature Language="F#" Value="static member Write : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;byte&gt; -&gt; char[]" Usage="System.Security.Cryptography.PemEncoding.Write (label, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Encoding</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="label"><span data-ttu-id="f1625-143">Die zu codierende Bezeichnung.</span><span class="sxs-lookup"><span data-stu-id="f1625-143">The label to encode.</span></span></param>
        <param name="data"><span data-ttu-id="f1625-144">Die zu codierenden Daten.</span><span class="sxs-lookup"><span data-stu-id="f1625-144">The data to encode.</span></span></param>
        <summary><span data-ttu-id="f1625-145">Erstellt eine codierte PEM mit der angegebenen Bezeichnung und den angegebenen Daten.</span><span class="sxs-lookup"><span data-stu-id="f1625-145">Creates an encoded PEM with the given label and data.</span></span></summary>
        <returns><span data-ttu-id="f1625-146">Ein Zeichenarray des codierten PEM.</span><span class="sxs-lookup"><span data-stu-id="f1625-146">A character array of the encoded PEM.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="f1625-147">Diese Methode umschließt 64 den Base64-codierten Text stets in 64 Zeichen gemäß der empfohlenen Umbrüche von RFC-7468.</span><span class="sxs-lookup"><span data-stu-id="f1625-147">This method always wraps the base-64 encoded text to 64 characters, per the recommended wrapping of RFC-7468.</span></span> <span data-ttu-id="f1625-148">Zeilenenden im Unix-Stil werden für Zeilenumbrüche verwendet.</span><span class="sxs-lookup"><span data-stu-id="f1625-148">Unix-style line endings are used for line breaks.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f1625-149"><paramref name="label" /> überschreitet die maximal mögliche Bezeichnungslänge.</span><span class="sxs-lookup"><span data-stu-id="f1625-149"><paramref name="label" /> exceeds the maximum possible label length.</span></span>

<span data-ttu-id="f1625-150">- oder -</span><span class="sxs-lookup"><span data-stu-id="f1625-150">-or-</span></span>

<span data-ttu-id="f1625-151"><paramref name="data" /> überschreitet die maximal zulässige Länge codierter Daten.</span><span class="sxs-lookup"><span data-stu-id="f1625-151"><paramref name="data" /> exceeds the maximum possible encoded data length.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f1625-152">Der sich ergebende PEM-codierte Text ist größer als <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="f1625-152">The resulting PEM-encoded text is larger than <see cref="F:System.Int32.MaxValue" />.</span></span>

<span data-ttu-id="f1625-153">- oder -</span><span class="sxs-lookup"><span data-stu-id="f1625-153">-or-</span></span>

<span data-ttu-id="f1625-154"><paramref name="label" /> enthält ungültige Zeichen.</span><span class="sxs-lookup"><span data-stu-id="f1625-154"><paramref name="label" /> contains invalid characters.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
