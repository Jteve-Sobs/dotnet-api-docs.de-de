<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IncrementalHash.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac58b2e239864865d83ed8aa588b335299d1a4f81c1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8b2e239864865d83ed8aa588b335299d1a4f81c1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.7.1,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Security.Cryptography.IncrementalHash">
          <source>Provides support for computing a hash or Hash-based Message Authentication Code (HMAC) value incrementally across several segments.</source>
          <target state="translated">Stellt Unterstützung für die Berechnung eines Hash- oder eines auf einem Hash basierenden HMAC-Werts (Hash-based Message Authentication Code) inkrementell über mehrere Segmente hinweg bereit.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.IncrementalHash.AlgorithmName">
          <source>Gets the name of the algorithm being performed.</source>
          <target state="translated">Ruft den Namen des Algorithmus ab, der ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="P:System.Security.Cryptography.IncrementalHash.AlgorithmName">
          <source>HMAC algorithms are prepended with "HMAC" to distinguish them from an unkeyed digest.</source>
          <target state="translated">HMAC-Algorithmen wird „HMAC“ vorangestellt, um sie von einem unverschlüsselten Digest zu unterscheiden.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Security.Cryptography.IncrementalHash.AlgorithmName">
          <source>The name of the algorithm being performed.</source>
          <target state="translated">Der Name des Algorithmus, der ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
          <source>The data to process.</source>
          <target state="translated">Die zu verarbeitenden Daten.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
          <source>Appends the specified data to the data already processed in the hash or HMAC.</source>
          <target state="translated">Fügt die angegebenen Daten den Daten hinzu, die bereits im Hash oder HMAC verarbeitet wurden.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="data" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> object has already been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph>-Objekt wurde bereits entfernt.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>The data to process.</source>
          <target state="translated">Die zu verarbeitenden Daten.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>The offset into the byte array from which to begin using data.</source>
          <target state="translated">Der Offset im Bytearray, ab dem Daten verwendet werden sollen.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to use from <bpt id="p1">&lt;c&gt;</bpt>data<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Die Anzahl der Bytes, die aus <bpt id="p1">&lt;c&gt;</bpt>data<ept id="p1">&lt;/c&gt;</ept> verwendet werden sollen.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>Appends the specified number of bytes from the specified data, starting at the specified offset, to the data already processed in the hash or Hash-based Message Authentication Code (HMAC).</source>
          <target state="translated">Fügt die angegebene Zahl an Bytes aus den angegebenen Daten in die bereits verarbeiteten im Hash oder HMAC (Hash-basierter Nachrichtenauthentifizierungscode) ein, beginnend mit dem angegebenen Offset.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="data" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="data" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> oder <ph id="ph2">&lt;paramref name="offset" /&gt;</ph> ist ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is larger than the length of <ph id="ph2">&lt;paramref name="data" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="data" /&gt;</ph> lang ist.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is larger than the data length.</source>
          <target state="translated">Die Summe aus <ph id="ph1">&lt;paramref name="offset" /&gt;</ph> und <ph id="ph2">&lt;paramref name="count" /&gt;</ph> ist größer als die Datenlänge.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> object has already been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph>-Objekt wurde bereits entfernt.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source>The name of the hash algorithm to perform.</source>
          <target state="translated">Der Name des Hashalgorithmus, der ausgeführt werden soll.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> for the specified algorithm.</source>
          <target state="translated">Erstellt einen <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> für den angegebenen Algorithmus.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> instance ready to compute the hash algorithm specified by <ph id="ph2">&lt;paramref name="hashAlgorithm" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph>-Instanz, die bereit ist, den von <ph id="ph2">&lt;paramref name="hashAlgorithm" /&gt;</ph> angegebenen Hashalgorithmus zu berechnen.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph>.<ph id="ph2">&lt;see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph>.<ph id="ph2">&lt;see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source>is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an empty string.</source>
          <target state="translated">ist <ph id="ph1">&lt;see langword="null" /&gt;</ph> oder eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)">
          <source><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph> is not a known hash algorithm.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph> ist kein bekannter Hashalgorithmus.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>The name of the hash algorithm to perform within the HMAC.</source>
          <target state="translated">Der Name des Hashalgorithmus, der im HMAC ausgeführt werden soll.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>The secret key for the HMAC.</source>
          <target state="translated">Der geheime Schlüssel für den HMAC.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>The key can be of any length, but a key longer than the output size of the specified hash algorithm will be hashed to derive a correctly-sized key.</source>
          <target state="translated">Der Schlüssel kann von beliebiger Länge sein, doch ein Schlüssel, der länger als die Ausgabegröße des angegebenen Hashalgorithmus ist, wird mit eindeutigem Hashwert berechnet, um den Schlüssel mit richtiger Größe abzuleiten.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>Therefore, the recommended size of the secret key is the output size of the specified hash algorithm.</source>
          <target state="translated">Daher ist die empfohlene Größe des geheimen Schlüssels die Ausgabegröße des angegebenen Hashalgorithmus.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>Creates an <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> for the Hash-based Message Authentication Code (HMAC) algorithm using the specified hash algorithm and key.</source>
          <target state="translated">Erstellt <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> für den Algorithmus des hashbasierten Nachrichtenauthentifizierungscodes (HMAC, Hash-based Message Authentication Code) mithilfe des angegebenen Hashalgorithmus und Schlüssels.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>An instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> class ready to compute the specified hash algorithm.</source>
          <target state="translated">Eine Instanz der <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph>-Klasse, die den angegebenen Hashalgorithmus berechnen kann.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="key" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="key" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph>.<ph id="ph2">&lt;see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph>.<ph id="ph2">&lt;see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source>is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an empty string.</source>
          <target state="translated">ist <ph id="ph1">&lt;see langword="null" /&gt;</ph> oder eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph> is not a known hash algorithm.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="hashAlgorithm" /&gt;</ph> ist kein bekannter Hashalgorithmus.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.Dispose">
          <source>Releases the resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> class.</source>
          <target state="translated">Gibt alle von der aktuellen Instanz der <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph>-Klasse verwendeten Ressourcen frei.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset">
          <source>Retrieves the hash or Hash-based Message Authentication Code (HMAC) for the data accumulated from prior calls to the <ph id="ph1">&lt;see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])" /&gt;</ph> method,  and resets the object to its initial state.</source>
          <target state="translated">Ruft den Hash oder HMAC für die Daten ab, die von früheren Aufrufen der <ph id="ph1">&lt;see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])" /&gt;</ph>-Methode gesammelt wurden, und setzt das Objekt auf seinen ursprünglichen Zustand zurück.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset">
          <source>The computed hash or HMAC.</source>
          <target state="translated">Der berechnete Hash oder HMAC.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Security.Cryptography.IncrementalHash.GetHashAndReset">
          <source>The <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph> object has already been disposed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Security.Cryptography.IncrementalHash" /&gt;</ph>-Objekt wurde bereits entfernt.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>