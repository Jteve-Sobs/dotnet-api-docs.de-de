<Type Name="HMACSHA512" FullName="System.Security.Cryptography.HMACSHA512">
  <Metadata><Meta Name="ms.openlocfilehash" Value="99565d9b67bb126c0c35b87d6fc46a7b7dd05475" /><Meta Name="ms.sourcegitcommit" Value="8b09499854b5b7b909802126edc1f1fca0054c10" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/01/2020" /><Meta Name="ms.locfileid" Value="76958779" /></Metadata><TypeSignature Language="C#" Value="public class HMACSHA512 : System.Security.Cryptography.HMAC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit HMACSHA512 extends System.Security.Cryptography.HMAC" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.HMACSHA512" />
  <TypeSignature Language="VB.NET" Value="Public Class HMACSHA512&#xA;Inherits HMAC" />
  <TypeSignature Language="C++ CLI" Value="public ref class HMACSHA512 : System::Security::Cryptography::HMAC" />
  <TypeSignature Language="F#" Value="type HMACSHA512 = class&#xA;    inherit HMAC" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
    <AssemblyVersion>4.3.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.HMAC</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="61e25-101">Berechnet unter Verwendung der <see cref="T:System.Security.Cryptography.SHA512" />-Hashfunktion einen Hash-Nachrichtenauthentifizierungscode (HMAC, Hash-based Message Authentication Code).</span><span class="sxs-lookup"><span data-stu-id="61e25-101">Computes a Hash-based Message Authentication Code (HMAC) using the <see cref="T:System.Security.Cryptography.SHA512" /> hash function.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61e25-102"><xref:System.Security.Cryptography.HMACSHA512> ist ein Typ eines Schlüssel gebundenen Hash Algorithmus, der aus der SHA-512-Hash Funktion erstellt und als Hash basiertes Nachrichtenauthentifizierungscode (HMAC) verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="61e25-102"><xref:System.Security.Cryptography.HMACSHA512> is a type of keyed hash algorithm that is constructed from the SHA-512 hash function and used as a Hash-based Message Authentication Code (HMAC).</span></span> <span data-ttu-id="61e25-103">Der HMAC-Prozess mischt einen geheimen Schlüssel mit den Nachrichten Daten und Hashs das Ergebnis.</span><span class="sxs-lookup"><span data-stu-id="61e25-103">The HMAC process mixes a secret key with the message data and hashes the result.</span></span> <span data-ttu-id="61e25-104">Der Hashwert wird erneut mit dem geheimen Schlüssel gemischt und dann ein zweites Mal mit einem Hashwert versehen.</span><span class="sxs-lookup"><span data-stu-id="61e25-104">The hash value is mixed with the secret key again, and then hashed a second time.</span></span> <span data-ttu-id="61e25-105">Der Ausgabe Hash beträgt 512 Bits.</span><span class="sxs-lookup"><span data-stu-id="61e25-105">The output hash is 512 bits in length.</span></span>  
  
 <span data-ttu-id="61e25-106">Ein HMAC kann verwendet werden, um zu bestimmen, ob eine Nachricht, die über einen unsicheren Kanal gesendet wurde, manipuliert wurde, vorausgesetzt, dass der Absender und der Empfänger einen geheimen Schlüssel gemeinsam nutzen.</span><span class="sxs-lookup"><span data-stu-id="61e25-106">An HMAC can be used to determine whether a message sent over a nonsecure channel has been tampered with, provided that the sender and receiver share a secret key.</span></span> <span data-ttu-id="61e25-107">Der Absender berechnet den Hashwert für die ursprünglichen Daten und sendet die ursprünglichen Daten und den Hashwert als einzelne Nachricht.</span><span class="sxs-lookup"><span data-stu-id="61e25-107">The sender computes the hash value for the original data and sends both the original data and hash value as a single message.</span></span> <span data-ttu-id="61e25-108">Der Empfänger berechnet den Hashwert für die empfangene Nachricht neu und überprüft, ob der berechnete HMAC mit dem übertragenen HMAC übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="61e25-108">The receiver recalculates the hash value on the received message and checks that the computed HMAC matches the transmitted HMAC.</span></span>  
  
 <span data-ttu-id="61e25-109">Wenn der ursprüngliche und der berechnete Hashwert entsprechen, wird die Nachricht authentifiziert.</span><span class="sxs-lookup"><span data-stu-id="61e25-109">If the original and computed hash values match, the message is authenticated.</span></span> <span data-ttu-id="61e25-110">Wenn Sie nicht identisch sind, wurden entweder die Daten oder der Hashwert geändert.</span><span class="sxs-lookup"><span data-stu-id="61e25-110">If they do not match, either the data or the hash value has been changed.</span></span> <span data-ttu-id="61e25-111">HMACs bieten Sicherheit gegen Manipulationen, da das Wissen des geheimen Schlüssels erforderlich ist, um die Nachricht zu ändern und den korrekten Hashwert zu reproduzieren.</span><span class="sxs-lookup"><span data-stu-id="61e25-111">HMACs provide security against tampering because knowledge of the secret key is required to change the message and reproduce the correct hash value.</span></span>  
  
 <span data-ttu-id="61e25-112"><xref:System.Security.Cryptography.HMACSHA512> akzeptiert Schlüssel beliebiger Größe und erzeugt eine Hash Sequenz der Länge 512 Bits.</span><span class="sxs-lookup"><span data-stu-id="61e25-112"><xref:System.Security.Cryptography.HMACSHA512> accepts keys of any size, and produces a hash sequence of length 512 bits.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="61e25-113">Im folgenden Beispiel wird gezeigt, wie Sie eine Datei mit dem <xref:System.Security.Cryptography.HMACSHA512>-Objekt Signieren und dann die Datei überprüfen.</span><span class="sxs-lookup"><span data-stu-id="61e25-113">The following example shows how to sign a file by using the <xref:System.Security.Cryptography.HMACSHA512> object and then how to verify the file.</span></span>  
  
 [!code-cpp[HMACSHA512#1](~/samples/snippets/cpp/VS_Snippets_CLR/HMACSHA512/CPP/hmacsha512.cpp#1)]
 [!code-csharp[HMACSHA512#1](~/samples/snippets/csharp/VS_Snippets_CLR/HMACSHA512/CS/hmacsha512.cs#1)]
 [!code-vb[HMACSHA512#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/HMACSHA512/vb/hmacsha512.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="61e25-114">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="61e25-114">Cryptographic Services</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="61e25-115">Initialisiert eine neue Instanz der Klasse <see cref="T:System.Security.Cryptography.HMACSHA512" />.</span><span class="sxs-lookup"><span data-stu-id="61e25-115">Initializes a new instance of the <see cref="T:System.Security.Cryptography.HMACSHA512" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HMACSHA512 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HMACSHA512.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HMACSHA512();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61e25-116">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACSHA512" />-Klasse mit einem zufällig erzeugten Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="61e25-116">Initializes a new instance of the <see cref="T:System.Security.Cryptography.HMACSHA512" /> class with a randomly generated key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61e25-117">Mit diesem Konstruktor wird ein nach dem Zufallsprinzip generierter 64-Byte-Schlüssel verwendet.</span><span class="sxs-lookup"><span data-stu-id="61e25-117">With this constructor, a 64-byte, randomly generated key is used.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="61e25-118">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="61e25-118">Cryptographic Services</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HMACSHA512 (byte[] key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HMACSHA512.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HMACSHA512(cli::array &lt;System::Byte&gt; ^ key);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.HMACSHA512 : byte[] -&gt; System.Security.Cryptography.HMACSHA512" Usage="new System.Security.Cryptography.HMACSHA512 key" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="key" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="61e25-119">Der geheime Schlüssel für die <see cref="T:System.Security.Cryptography.HMACSHA512" />-Verschlüsselung.</span><span class="sxs-lookup"><span data-stu-id="61e25-119">The secret key for <see cref="T:System.Security.Cryptography.HMACSHA512" /> encryption.</span></span> <span data-ttu-id="61e25-120">Der Schlüssel kann eine beliebige Länge aufweisen.</span><span class="sxs-lookup"><span data-stu-id="61e25-120">The key can be any length.</span></span> <span data-ttu-id="61e25-121">Allerdings ist die empfohlene Größe 128 Bytes.</span><span class="sxs-lookup"><span data-stu-id="61e25-121">However, the recommended size is 128 bytes.</span></span> <span data-ttu-id="61e25-122">Wenn der Schlüssel eine Länge von mehr als 128 Byte aufweist, wird aus ihm jedoch unter Verwendung des SHA-512-Hashalgorithmus ein 128-Byte-Schlüssel abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="61e25-122">If the key is more than 128 bytes long, it is hashed (using SHA-512) to derive a 128-byte key.</span></span> <span data-ttu-id="61e25-123">Wenn kürzer als 128 Byte, wird sie auf 128 Byte aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="61e25-123">If it is less than 128 bytes long, it is padded to 128 bytes.</span></span></param>
        <summary><span data-ttu-id="61e25-124">Initialisiert eine neue Instanz der <see cref="T:System.Security.Cryptography.HMACSHA512" />-Klasse mit den angegebenen Schlüsseldaten.</span><span class="sxs-lookup"><span data-stu-id="61e25-124">Initializes a new instance of the <see cref="T:System.Security.Cryptography.HMACSHA512" /> class with the specified key data.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="61e25-125">Ein Beispiel für die Verwendung dieses Konstruktors finden Sie in der <xref:System.Security.Cryptography.HMACSHA512>-Klasse.</span><span class="sxs-lookup"><span data-stu-id="61e25-125">For an example of how to use this constructor, see the <xref:System.Security.Cryptography.HMACSHA512> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="61e25-126">Der Parameter <paramref name="key" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="61e25-126">The <paramref name="key" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="61e25-127">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="61e25-127">Cryptographic Services</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HMACSHA512.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="hMACSHA512.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="61e25-128"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="61e25-128"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="61e25-129">Gibt die von <see cref="T:System.Security.Cryptography.HMACSHA512" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="61e25-129">Releases the unmanaged resources used by the <see cref="T:System.Security.Cryptography.HMACSHA512" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashCore">
      <MemberSignature Language="C#" Value="protected override void HashCore (ReadOnlySpan&lt;byte&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void HashCore(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HMACSHA512.HashCore(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub HashCore (source As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void HashCore(ReadOnlySpan&lt;System::Byte&gt; source);" />
      <MemberSignature Language="F#" Value="override this.HashCore : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="hMACSHA512.HashCore source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="source"><span data-ttu-id="61e25-130">Die Eingabe, für die der HMAC berechnet wird.</span><span class="sxs-lookup"><span data-stu-id="61e25-130">The input to compute the HMAC for.</span></span></param>
        <summary><span data-ttu-id="61e25-131">Leitet in das Objekt geschriebene Daten in den HMAC-Algorithmus für die Berechnung vom HMAC weiter.</span><span class="sxs-lookup"><span data-stu-id="61e25-131">Routes data written to the object into the HMAC algorithm for computing the HMAC.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashCore">
      <MemberSignature Language="C#" Value="protected override void HashCore (byte[] rgb, int ib, int cb);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void HashCore(unsigned int8[] rgb, int32 ib, int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HMACSHA512.HashCore(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub HashCore (rgb As Byte(), ib As Integer, cb As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void HashCore(cli::array &lt;System::Byte&gt; ^ rgb, int ib, int cb);" />
      <MemberSignature Language="F#" Value="override this.HashCore : byte[] * int * int -&gt; unit" Usage="hMACSHA512.HashCore (rgb, ib, cb)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
        <Parameter Name="ib" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
        <Parameter Name="cb" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rgb"><span data-ttu-id="61e25-132">Die Eingabe, für die der HMAC berechnet wird.</span><span class="sxs-lookup"><span data-stu-id="61e25-132">The input to compute the HMAC for.</span></span></param>
        <param name="ib"><span data-ttu-id="61e25-133">Der Offset im Bytearray, ab dem Daten verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="61e25-133">The offset into the byte array from which to begin using data.</span></span></param>
        <param name="cb"><span data-ttu-id="61e25-134">Die Anzahl der Bytes im Bytearray, die als Daten verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="61e25-134">The number of bytes in the byte array to use as data.</span></span></param>
        <summary><span data-ttu-id="61e25-135">Leitet in das Objekt geschriebene Daten in den HMAC-Algorithmus für die Berechnung vom HMAC weiter.</span><span class="sxs-lookup"><span data-stu-id="61e25-135">Routes data written to the object into the HMAC algorithm for computing the HMAC.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashFinal">
      <MemberSignature Language="C#" Value="protected override byte[] HashFinal ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance unsigned int8[] HashFinal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HMACSHA512.HashFinal" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HashFinal () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override cli::array &lt;System::Byte&gt; ^ HashFinal();" />
      <MemberSignature Language="F#" Value="override this.HashFinal : unit -&gt; byte[]" Usage="hMACSHA512.HashFinal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61e25-136">Schließt die HMAC-Berechnung ab, nachdem die letzten Daten vom Algorithmus verarbeitet wurden.</span><span class="sxs-lookup"><span data-stu-id="61e25-136">Finalizes the HMAC computation after the last data is processed by the algorithm.</span></span></summary>
        <returns><span data-ttu-id="61e25-137">Der berechnete HMAC-Wert in einem Bytearray.</span><span class="sxs-lookup"><span data-stu-id="61e25-137">The computed HMAC value in a byte array.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashSize">
      <MemberSignature Language="C#" Value="public override int HashSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HashSize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HMACSHA512.HashSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HashSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int HashSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HashSize : int" Usage="System.Security.Cryptography.HMACSHA512.HashSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="61e25-138">Ruft die Größe des berechneten HMAC-Werts in Bits ab.</span><span class="sxs-lookup"><span data-stu-id="61e25-138">Gets the size, in bits, of the computed HMAC.</span></span></summary>
        <value><span data-ttu-id="61e25-139">Die Größe des berechneten HMAC in Bits.</span><span class="sxs-lookup"><span data-stu-id="61e25-139">The size, in bits, of the computed HMAC.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public override void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HMACSHA512.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Initialize();" />
      <MemberSignature Language="F#" Value="override this.Initialize : unit -&gt; unit" Usage="hMACSHA512.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61e25-140">Setzt den Hashalgorithmus auf seinen Anfangszustand zurück.</span><span class="sxs-lookup"><span data-stu-id="61e25-140">Resets the hash algorithm to its initial state.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Key">
      <MemberSignature Language="C#" Value="public override byte[] Key { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Key" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HMACSHA512.Key" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Key As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;System::Byte&gt; ^ Key { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Key : byte[] with get, set" Usage="System.Security.Cryptography.HMACSHA512.Key" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="61e25-141">Ruft den Schlüssel für die HMAC-Berechnung ab oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="61e25-141">Gets or sets the key to use in the HMAC calculation.</span></span></summary>
        <value><span data-ttu-id="61e25-142">Der Schlüssel, der bei der HMAC-Berechnung verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="61e25-142">The key to use in the HMAC calculation.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProduceLegacyHmacValues">
      <MemberSignature Language="C#" Value="public bool ProduceLegacyHmacValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProduceLegacyHmacValues" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.HMACSHA512.ProduceLegacyHmacValues" />
      <MemberSignature Language="VB.NET" Value="Public Property ProduceLegacyHmacValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ProduceLegacyHmacValues { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ProduceLegacyHmacValues : bool with get, set" Usage="System.Security.Cryptography.HMACSHA512.ProduceLegacyHmacValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="61e25-143">Stellt eine Methode zur Umgehung des Problems mit der [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]-Implementierung des <see cref="T:System.Security.Cryptography.HMACSHA512" />-Algorithmus bereit, die mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]-Implementierung nicht übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="61e25-143">Provides a workaround for the [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] implementation of the <see cref="T:System.Security.Cryptography.HMACSHA512" /> algorithm, which is inconsistent with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] implementation.</span></span></summary>
        <value><span data-ttu-id="61e25-144"><see langword="true" />, um [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]-Anwendungen für die Interaktion mit [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]-Anwendungen zu aktivieren; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="61e25-144"><see langword="true" /> to enable [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] applications to interact with [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] applications; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61e25-145">Der Zweck der <xref:System.Security.Cryptography.HMACSHA512.ProduceLegacyHmacValues%2A> booleschen Eigenschaft besteht darin, [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] Anwendungen die Interaktion mit [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] Anwendungen zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="61e25-145">The purpose of the <xref:System.Security.Cryptography.HMACSHA512.ProduceLegacyHmacValues%2A> Boolean property is to enable [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] applications to interact with [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] applications.</span></span> <span data-ttu-id="61e25-146">Wenn Sie diese Eigenschaft auf `true`festlegen, erzeugt das <xref:System.Security.Cryptography.HMACSHA512>-Objektwerte, die den vom [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]erzeugten Werten entsprechen.</span><span class="sxs-lookup"><span data-stu-id="61e25-146">When you set this property to `true`, the <xref:System.Security.Cryptography.HMACSHA512> object produces values that match the values produced by the [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].</span></span> <span data-ttu-id="61e25-147">Sie sollten diese Eigenschaft nur einmal festlegen, nachdem Sie das HMAC-Objekt erstellt haben.</span><span class="sxs-lookup"><span data-stu-id="61e25-147">You should set this property only once after you create your HMAC object.</span></span> <span data-ttu-id="61e25-148">Sie müssen den Schlüssel anschließend zurücksetzen, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="61e25-148">You will need to reset your key afterwards, as shown in the following example.</span></span>  
  
```csharp
public static void Test()
{  
    var hmac = new HMACSHA512();  
    hmac.ProduceLegacyHmacValues = true;  
    hmac.Key = // ...Get the HMAC key.  
    // ...  
    // Use the HMAC algorithm.  
    // ...
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="61e25-149">Kryptografische Dienste</span><span class="sxs-lookup"><span data-stu-id="61e25-149">Cryptographic Services</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryHashFinal">
      <MemberSignature Language="C#" Value="protected override bool TryHashFinal (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool TryHashFinal(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.HMACSHA512.TryHashFinal(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function TryHashFinal (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool TryHashFinal(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="override this.TryHashFinal : Span&lt;byte&gt; * int -&gt; bool" Usage="hMACSHA512.TryHashFinal (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
        <AssemblyVersion>4.3.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="61e25-150">Der Puffer, der den HMAC-Wert empfangen soll.</span><span class="sxs-lookup"><span data-stu-id="61e25-150">The buffer to receive the HMAC value.</span></span></param>
        <param name="bytesWritten"><span data-ttu-id="61e25-151">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="61e25-151">When this method returns, the total number of bytes written into <paramref name="destination" />.</span></span> <span data-ttu-id="61e25-152">Dieser Parameter wird als nicht initialisiert behandelt.</span><span class="sxs-lookup"><span data-stu-id="61e25-152">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="61e25-153">Versucht, die HMAC-Berechnung abzuschließen, nachdem die letzten Daten vom HMAC-Algorithmus verarbeitet wurden.</span><span class="sxs-lookup"><span data-stu-id="61e25-153">Attempts to finalize the HMAC computation after the last data is processed by the HMAC algorithm.</span></span></summary>
        <returns><span data-ttu-id="61e25-154"><see langword="true" />, wenn <paramref name="destination" /> zum Empfangen des HMAC-Werts lang genug ist. Andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="61e25-154"><see langword="true" /> if <paramref name="destination" /> is long enough to receive the HMAC value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
