<Type Name="GrammarBuilder" FullName="System.Speech.Recognition.GrammarBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e0d9bfa62675c9e59e6fa12e0bf36c839258e976" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69231354" /></Metadata><TypeSignature Language="C#" Value="public class GrammarBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit GrammarBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.GrammarBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class GrammarBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class GrammarBuilder" />
  <TypeSignature Language="F#" Value="type GrammarBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{DebugSummary}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Mechanismus für das programmgesteuerte Erstellen von Einschränkungen für eine Spracherkennungsgrammatik bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprach Erkennungs Grammatiken werden häufig in dem XML-Format erstellt, das in der [sprach Erkennungs Grammatik-Spezifikation (SRGS), Version 1,0](https://go.microsoft.com/fwlink/?LinkId=201761), definiert ist. Wenn Sie mit SRGS vertraut sind, die Grammatiken aber Programm gesteuert generieren möchten, können Sie den <xref:System.Speech.Recognition.SrgsGrammar> -Namespace verwenden, dessen Member genau den Elementen und Attributen entsprechen, die von SRGS definiert werden. Wenn Sie mit SRGS nicht vertraut sind oder einen einfachen, programmgesteuerten Ansatz zur Erstellung von Grammatiken wünschen, mit denen Sie viele gängige Szenarien effizient erledigen können. Sie können die- <xref:System.Speech.Recognition.GrammarBuilder> Klasse <xref:System.Speech.Recognition.Choices> und die-Klasse verwenden.  
  
 Verwenden <xref:System.Speech.Recognition.GrammarBuilder> Sie-Objekte, um eine hierarchische <xref:System.Speech.Recognition.Choices> Struktur zu erstellen, die aus Objekten besteht, die Alternative Ausdrücke enthalten, die mit Präambel und Post-sprechenden Ausdrücken an jedem Knoten kombiniert werden, und mit semantischen Werten, die die Bedeutung zurück vermitteln, an den Asyl.  
  
 Verwenden Sie die <xref:System.Speech.Recognition.GrammarBuilder> folgenden Schritte, <xref:System.Speech.Recognition.Grammar> um ein-Objekt zum Erstellen eines-Objekts zu verwenden.  
  
1.  Erstellen eines <xref:System.Speech.Recognition.GrammarBuilder>-Objekts  
  
2.  Fügen <xref:System.Speech.Recognition.GrammarBuilder>Sie Einschränkungen an, <xref:System.String> z. b. Objekte <xref:System.Speech.Recognition.Choices>, <xref:System.Speech.Recognition.SemanticResultKey>, <xref:System.Speech.Recognition.SemanticResultValue>, <xref:System.Speech.Recognition.DictationGrammar>, und andere <xref:System.Speech.Recognition.GrammarBuilder> Objekte, die die Einschränkungen für die Grammatik definieren.  
  
3.  Verwenden Sie einen der <xref:System.Speech.Recognition.Grammar.%23ctor%2A> -Konstruktoren, um <xref:System.Speech.Recognition.Grammar> ein-Objekt aus <xref:System.Speech.Recognition.GrammarBuilder> der abgeschlossenen Grammatik zu erstellen.  
  
 Die Erstellung <xref:System.Speech.Recognition.GrammarBuilder> mit eignet sich am besten für Grammatiken, die eine einzelne Regel mit Listen oder vielleicht Listen von Listen aufweisen. Wenn Sie Grammatiken Programm gesteuert erstellen möchten, die über mehrere Regeln verfügen oder interne Regel Verweise erstellen müssen, verwenden Sie die Klassen <xref:System.Speech.Recognition.SrgsGrammar> des-Namespace.  
  
 Instanzen von <xref:System.Speech.Recognition.GrammarBuilder> können auch durch implizite Konvertierungen von bestimmten anderen Klassen oder durch Kombinieren eines <xref:System.Speech.Recognition.GrammarBuilder> mit einem zweiten Objekt abgerufen werden, das Einschränkungen für eine Grammatik enthält. Weitere Informationen finden Sie unter den <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren und <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> und <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> den-Methoden.  
  
 Um <xref:System.Speech.Recognition.GrammarBuilder>einer vorhandenen Regeln hinzuzufügen, verwenden Sie <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>die <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>Methoden <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>, <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>,, <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> und.  
  
> [!IMPORTANT]
>  Die Spracherkennung kann eine Ausnahme auslösen, wenn eine sprach Erkennungs Grammatik verwendet wird, die doppelte Semantik Elemente mit demselben Schlüsselnamen oder mehreren semantischen Elementen enthält, die den Wert desselben semantischen Elements wiederholt ändern können. 
  
 Um das Debuggen zu <xref:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases%2A> unterstützen, gibt die-Eigenschaft <xref:System.Speech.Recognition.GrammarBuilder> den aktuellen Status von als Zeichenfolge zurück.  
  
 Weitere Informationen zum Erstellen und Verwenden von sprach Erkennungs Grammatiken finden Sie unter [Spracherkennung](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) und [Erstellen](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)von Grammatiken für Grammatiken.  
  
   
  
## Examples  
 Im folgenden Beispiel werden <xref:System.Speech.Recognition.GrammarBuilder> - <xref:System.Speech.Recognition.Choices> und-Objekte verwendet, um eine Grammatik zu erstellen, die einen der beiden Ausdrücke, "Make background *colorchoice*" oder "Set Background on *colorchoice*", erkennen kann.  
  
 Im Beispiel wird ein <xref:System.Speech.Recognition.Choices> -Objekt verwendet, um eine Liste zulässiger Werte für *colorchoice* aus einem <xref:System.String> Array von-Objekten zu erstellen. Ein <xref:System.Speech.Recognition.Choices> -Objekt ist analog `one-of` zum-Element in der SRGS-Spezifikation und enthält eine Reihe alternativer Ausdrücke, von denen jedes beim sprechen erkannt werden kann. Im Beispiel wird auch ein <xref:System.Speech.Recognition.Choices> -Objekt verwendet, um ein Array <xref:System.Speech.Recognition.GrammarBuilder> von zwei-Objekten in ein paar alternativer Ausdrücke zu gruppieren, die die resultierende Grammatik erkennen kann. Alternative Wörter oder Ausdrücke sind eine Komponente der meisten Grammatiken, und das <xref:System.Speech.Recognition.Choices> -Objekt stellt diese Funktionalität für Grammatiken bereit <xref:System.Speech.Recognition.GrammarBuilder>, die mit erstellt wurden.  
  
 Im Beispiel wird schließlich ein <xref:System.Speech.Recognition.Grammar> -Objekt aus <xref:System.Speech.Recognition.GrammarBuilder> einem erstellt, <xref:System.Speech.Recognition.Choices> das aus einem-Objekt erstellt wurde.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.Choices" />
    <altmember cref="T:System.Speech.Recognition.Grammar" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Instanzen dieser Klasse können auch durch implizite Konvertierungen von anderen Klassen oder durch Kombinieren eines <xref:System.Speech.Recognition.GrammarBuilder> -Objekts mit einem zweiten-Objekt von einem neuen <xref:System.Speech.Recognition.GrammarBuilder>abgerufen werden. Weitere Informationen finden Sie unter den <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Methoden <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> und.  
  
 Zum Hinzufügen von Einschränkungen zu <xref:System.Speech.Recognition.GrammarBuilder>einer vorhandenen verwenden <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>Sie <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>die <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>Methoden <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>,, <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> , und und den <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> -Operator.  
  
> [!IMPORTANT]
>  Die Spracherkennung kann eine Ausnahme auslösen, wenn eine sprach Erkennungs Grammatik verwendet wird, die doppelte Semantik Elemente mit demselben Schlüsselnamen oder mehreren semantischen Elementen enthält, die den Wert desselben semantischen Elements wiederholt ändern können.
  
 Weitere Informationen zum Erstellen und Verwenden von sprach Erkennungs Grammatiken finden Sie unter [Spracherkennung](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) und [Erstellen](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)von Grammatiken für Grammatiken.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue leere Instanz der <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Hinzufügen von Regeln zu <xref:System.Speech.Recognition.GrammarBuilder> einem vorhandenen Objekt verwenden <xref:System.Speech.Recognition.GrammarBuilder.Add%2A>Sie <xref:System.Speech.Recognition.GrammarBuilder.Append%2A>die <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A>Methoden <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A>,, <xref:System.Speech.Recognition.GrammarBuilder.AppendWildcard%2A> , und und den <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> -Operator.  
  
> [!IMPORTANT]
>  Die Spracherkennung kann eine Ausnahme auslösen, wenn eine sprach Erkennungs Grammatik verwendet wird, die doppelte Semantik Elemente mit demselben Schlüsselnamen oder mehreren semantischen Elementen enthält, die den Wert desselben semantischen Elements wiederholt ändern können.
  
   
  
## Examples  
 Im folgenden Beispiel werden <xref:System.Speech.Recognition.GrammarBuilder> - <xref:System.Speech.Recognition.Choices> und-Objekte verwendet, um eine Grammatik zu erstellen, die einen der beiden Ausdrücke, "Make background *colorchoice*" oder "Set Background on *colorchoice*", erkennen kann.  
  
 Im Beispiel wird ein <xref:System.Speech.Recognition.Choices> -Objekt verwendet, um eine Liste zulässiger Werte für *colorchoice* aus einem <xref:System.String> Array von-Objekten zu erstellen. Ein <xref:System.Speech.Recognition.Choices> -Objekt ist analog `one-of` zum-Element in der SRGS-Spezifikation und enthält eine Reihe alternativer Ausdrücke, von denen jedes beim sprechen erkannt werden kann. Im Beispiel wird auch ein <xref:System.Speech.Recognition.Choices> -Objekt verwendet, um ein Array <xref:System.Speech.Recognition.GrammarBuilder> von zwei-Objekten in ein paar alternativer Ausdrücke zu gruppieren, die die resultierende Grammatik erkennen kann. Alternative Wörter oder Ausdrücke sind eine Komponente der meisten Grammatiken, und das <xref:System.Speech.Recognition.Choices> -Objekt stellt diese Funktionalität für Grammatiken bereit <xref:System.Speech.Recognition.GrammarBuilder>, die mit erstellt wurden.  
  
 Im Beispiel wird schließlich ein <xref:System.Speech.Recognition.Grammar> -Objekt aus <xref:System.Speech.Recognition.GrammarBuilder> einem erstellt, <xref:System.Speech.Recognition.Choices> das aus einem-Objekt erstellt wurde.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  GrammarBuilder bothPhrases = new GrammarBuilder();  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  bothPhrases.Append(bothChoices);  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder alternateChoices" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Der Satz von Alternativen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Klasse aus einer Gruppe von Alternativen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Erstellen einer sprach Erkennungs Grammatik, die Alternativen enthält, finden [Sie unter Verwenden von Auswahlmöglichkeiten zum Erstellen einer grammatigrammgrammatik](https://msdn.microsoft.com/library/5b18db18-a5f6-46a3-aa77-6d3141544efd).  
  
   
  
## Examples  
 Im folgenden Beispiel werden <xref:System.Speech.Recognition.GrammarBuilder> - <xref:System.Speech.Recognition.Choices> und-Objekte verwendet, um eine Grammatik zu erstellen, die einen der beiden Ausdrücke, "Make background *colorchoice*" oder "Set Background on *colorchoice*", erkennen kann.  
  
 Im Beispiel wird ein <xref:System.Speech.Recognition.Choices> -Objekt verwendet, um eine Liste zulässiger Werte für *colorchoice* aus einem <xref:System.String> Array von-Objekten zu erstellen. Ein <xref:System.Speech.Recognition.Choices> -Objekt ist analog `one-of` zum-Element in der SRGS-Spezifikation und enthält eine Reihe alternativer Ausdrücke, von denen jedes beim sprechen erkannt werden kann. Im Beispiel wird auch ein <xref:System.Speech.Recognition.Choices> -Objekt verwendet, um ein Array <xref:System.Speech.Recognition.GrammarBuilder> von zwei-Objekten in ein paar alternativer Ausdrücke zu gruppieren, die die resultierende Grammatik erkennen kann. Alternative Wörter oder Ausdrücke sind eine Komponente der meisten Grammatiken, und das <xref:System.Speech.Recognition.Choices> -Objekt stellt diese Funktionalität für Grammatiken bereit <xref:System.Speech.Recognition.GrammarBuilder>, die mit erstellt wurden.  
  
 Im Beispiel wird schließlich ein <xref:System.Speech.Recognition.Grammar> -Objekt aus <xref:System.Speech.Recognition.GrammarBuilder> einem erstellt, <xref:System.Speech.Recognition.Choices> das aus einem-Objekt erstellt wurde.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder key" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Der semantische Schlüssel.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Klasse aus einem semantischen Schlüssel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie aus einem <xref:System.Speech.Recognition.GrammarBuilder> <xref:System.Speech.Recognition.SemanticResultValue> -Objekt eine-Instanz erstellen, fügen Sie der Grammatik Semantik Informationen hinzu, die im Erkennungs Ergebnis zurückgegeben werden können. Sie können auf die semantischen Informationen im Erkennungs Ergebnis zugreifen, <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> indem Sie <xref:System.Speech.Recognition.RecognizedPhrase>die-Eigenschaft von verwenden, die im- `SpeechRecognized` Handler für das-Ereignis verfügbar ist. Wenn eine <xref:System.Speech.Recognition.GrammarBuilder> <xref:System.Speech.Recognition.SemanticResultKey>definiert, kann diese verwendet werden, um die semantischen Informationen in einem Erkennungs Ergebnis abzurufen, das dem Schlüssel zugeordnet ist. Weitere Informationen finden Sie <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>im Beispiel für und <xref:System.Speech.Recognition.SemanticResultValue> unter <xref:System.Speech.Recognition.SemanticResultKey>und.  
  
> [!IMPORTANT]
>  Wenn Sie <xref:System.Speech.Recognition.GrammarBuilder> Objekte erstellen, die- <xref:System.Speech.Recognition.SemanticResultKey> oder-Instanzen enthalten <xref:System.Speech.Recognition.SemanticResultValue> , stellen Sie sicher, dass Sie keine doppelten semantischen Elemente mit dem gleichen Schlüsselnamen oder mehreren semantischen Elementen erstellen, die die <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft eines <xref:System.Speech.Recognition.SemanticValue> -Objekts. Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt. 
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, die die beiden Ausdrücke "Make background *colorchoice*" und "Set Background on *colorchoice*" erkennen kann, wobei *colorchoice* aus einer Reihe von Farben ausgewählt wird. Die Grammatik ermöglicht einem Benutzer, einen von mehreren Farbnamen zu sprechen, und gibt semantische Informationen über den erkannten Farbnamen an die Anwendung zurück.  
  
 Im Beispiel wird ein einzelnes <xref:System.Speech.Recognition.SemanticResultKey> verwendet, mit dem Sie das <xref:System.Speech.Recognition.SemanticValue> abrufen können, das mit der vom Benutzer gesprochenen Farbe verknüpft ist. Wenn die Eingabe z. b. den Ausdruck "Hintergrund auf Rot festlegen" enthält, enthält das Erkennungs Ergebnis den semantischen Wert "#FF0000", den Sie mithilfe eines Handlers für das `SpeechRecognized` Ereignis abrufen können.  
  
 Im Beispiel werden <xref:System.String>die-, <xref:System.Speech.Recognition.SemanticResultValue>-,-,-und- <xref:System.Speech.Recognition.GrammarBuilder> `bothPhrases`Objekte verwendet <xref:System.Speech.Recognition.Choices> <xref:System.Speech.Recognition.SemanticResultKey>, um die Einschränkungen zu <xref:System.Speech.Recognition.GrammarBuilder> erstellen, die alle im letzten-Objekt enthalten sind. Schließlich wird in diesem Beispiel ein <xref:System.Speech.Recognition.Grammar> -Objekt aus abgeschlossen <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices object for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the Grammar object from the GrammarBuilder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Der semantische Wert oder das Name/Wert-Paar.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Klasse aus einem semantischen Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie aus einem <xref:System.Speech.Recognition.GrammarBuilder> <xref:System.Speech.Recognition.SemanticResultValue> -Objekt eine-Instanz erstellen, fügen Sie der Grammatik Semantik Informationen hinzu, die im Erkennungs Ergebnis zurückgegeben werden können. Sie können auf die semantischen Informationen im Erkennungs Ergebnis zugreifen, <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> indem Sie <xref:System.Speech.Recognition.RecognizedPhrase>die-Eigenschaft von verwenden, die im- `SpeechRecognized` Handler für das-Ereignis verfügbar ist. Wenn eine <xref:System.Speech.Recognition.GrammarBuilder> <xref:System.Speech.Recognition.SemanticResultKey>definiert, kann diese verwendet werden, um die semantischen Informationen in einem Erkennungs Ergebnis abzurufen, das dem Schlüssel zugeordnet ist. Weitere Informationen finden Sie <xref:System.Speech.Recognition.GrammarBuilder.Append%28System.Speech.Recognition.SemanticResultKey%29>im Beispiel für und <xref:System.Speech.Recognition.SemanticResultValue> unter <xref:System.Speech.Recognition.SemanticResultKey>und.  
  
> [!IMPORTANT]
>  Wenn Sie <xref:System.Speech.Recognition.GrammarBuilder> Objekte erstellen, die- <xref:System.Speech.Recognition.SemanticResultKey> oder-Instanzen enthalten <xref:System.Speech.Recognition.SemanticResultValue> , stellen Sie sicher, dass Sie keine doppelten semantischen Elemente mit dem gleichen Schlüsselnamen oder mehreren semantischen Elementen erstellen, die die <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft eines <xref:System.Speech.Recognition.SemanticValue> -Objekts. Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt. 
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, die die beiden Ausdrücke "Make background *colorchoice*" und "Set Background on *colorchoice*" erkennen kann, wobei *colorchoice* aus einer Reihe von Farben ausgewählt wird. Die Grammatik ermöglicht einem Benutzer, einen von mehreren Farbnamen zu sprechen, und gibt semantische Informationen über den erkannten Farbnamen an die Anwendung zurück.  
  
 Im Beispiel wird ein einzelnes <xref:System.Speech.Recognition.SemanticResultKey> verwendet, mit dem Sie das <xref:System.Speech.Recognition.SemanticValue> abrufen können, das mit der vom Benutzer gesprochenen Farbe verknüpft ist. Wenn die Eingabe z. b. den Ausdruck "Hintergrund auf Rot festlegen" enthält, enthält das Erkennungs Ergebnis den semantischen Wert "#FF0000", den Sie mithilfe eines Handlers für das `SpeechRecognized` Ereignis abrufen können.  
  
 Im Beispiel werden <xref:System.String>die-, <xref:System.Speech.Recognition.SemanticResultValue>-,-,-und- <xref:System.Speech.Recognition.GrammarBuilder> `bothPhrases`Objekte verwendet <xref:System.Speech.Recognition.Choices> <xref:System.Speech.Recognition.SemanticResultKey>, um die Einschränkungen zu <xref:System.Speech.Recognition.GrammarBuilder> erstellen, die alle im letzten-Objekt enthalten sind. Schließlich wird in diesem Beispiel ein <xref:System.Speech.Recognition.Grammar> -Objekt aus abgeschlossen <xref:System.Speech.Recognition.GrammarBuilder>.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  // Include semantic information about each of the colors.  
  Choices colorChoice = new Choices();  
  
  GrammarBuilder colorBuilder = new GrammarBuilder("red");  
  SemanticResultValue colorValue =  
    new SemanticResultValue(colorBuilder, "#FF0000");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("green");  
  colorValue = new SemanticResultValue(colorBuilder, "#00FF00");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  colorBuilder = new GrammarBuilder("blue");  
  colorValue = new SemanticResultValue(colorBuilder, "#0000FF");  
  colorChoice.Add(new GrammarBuilder(colorValue));  
  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  // Create the semantic key for referencing the color information.  
  SemanticResultKey colorKey =  
    new SemanticResultKey("ColorCode", bothPhrases);  
  bothPhrases = new GrammarBuilder(colorKey);  
  
  // Construct the grammar from the grammar builder.  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder phrase" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Die Wortsequenz.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Klasse aus einer Sequenz von Wörtern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Ausdruck stellt einen exakten gesprochenen Ausdruck dar, der von der sprach Erkennungs Grammatik erkannt werden kann. Weitere Informationen zum Erstellen einer sprach Erkennungs Grammatik, die Zeichen folgen enthält, finden Sie unter Verwenden von Zeichen folgen [zum Erstellen einer grammatigrammgrammatik](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 Im folgenden Beispiel werden <xref:System.Speech.Recognition.GrammarBuilder> - <xref:System.Speech.Recognition.Choices> und-Objekte verwendet, um eine Grammatik zu erstellen, die einen der beiden Ausdrücke, "Make background *colorchoice*" oder "Set Background on *colorchoice*", erkennen kann.  
  
 Nachdem Sie eine Liste zulässiger Werte für *colorchoice* mithilfe eines <xref:System.Speech.Recognition.Choices> -Objekts erstellt haben, werden im <xref:System.Speech.Recognition.GrammarBuilder> Beispiel zwei `makePhrase` - `setPhrase`Objekte, und, mit einer Zeichenfolge als Argument initialisiert.  
  
 Das Beispiel erstellt schließlich ein <xref:System.Speech.Recognition.Grammar> -Objekt aus <xref:System.Speech.Recognition.Choices> einem-Objekt, <xref:System.Speech.Recognition.GrammarBuilder> das in ein-Objekt umgewandelt wird.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
        <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * System.Speech.Recognition.SubsetMatchingMode -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, subsetMatchingCriteria)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Die Wortsequenz.</param>
        <param name="subsetMatchingCriteria">Der entsprechende Modus, den die Spracherkennungsgrammatik verwendet, um den Ausdruck zu erkennen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Klasse für eine Teilmenge einer Sequenz von Wörtern.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `phrase` -Parameter stellt den Ausdruck dar, der von der sprach Erkennungs Grammatik erkannt werden kann. Der `subsetMatchingMode` -Parameter gibt eine Teilmenge des Ausdrucks an, der gesprochen werden kann, um eine erfolgreiche Erkennung des gesamten Ausdrucks zu erzielen. Sie können dies verwenden, um eine Grammatik mit einer Liste von Einträgen mit langen Namen zu erstellen, ohne dass die Benutzer einen vollständigen Namen zum Abgleichen eines Elements sprechen müssen.  
  
 Weitere Informationen zu den entsprechenden Modi finden <xref:System.Speech.Recognition.SubsetMatchingMode>Sie unter. Weitere Informationen zum Erstellen einer sprach Erkennungs Grammatik, die Zeichen folgen enthält, finden Sie unter Verwenden von Zeichen folgen [zum Erstellen einer grammatigrammgrammatik](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik für jeden <xref:System.Speech.Recognition.SubsetMatchingMode> Wert und eine Grammatik für die Wahl zwischen den entsprechenden modusgrammatiken erstellt. Wenn der Wert von `phrase` "1 2 3 4 5 6 7" ist, erkennt die unter Sequenz Grammatik die Eingabe "2 3 4", aber nicht die Eingabe "1 3 5". Die geordnete Teilmenge erkennt jedoch beide Eingaben.  
  
```csharp  
  
private static IEnumerable<Grammar>  
  CreateMatchingModeGrammars(string phrase)  
{  
  List<Grammar> grammars = new List<Grammar>(5);  
  
  Choices modeChoice = new Choices();  
  Type enumType = typeof(SubsetMatchingMode);  
  foreach (SubsetMatchingMode mode in Enum.GetValues(enumType))  
  {  
    string modeName = Enum.GetName(enumType, mode);  
    modeName = BreakAtCaps(modeName);  
  
    GrammarBuilder builder = new GrammarBuilder(phrase, mode);  
    Grammar modeGrammar = new Grammar(builder);  
    modeGrammar.Name = modeName;  
    modeGrammar.Enabled = false;  
    grammars.Add(modeGrammar);  
  
    modeChoice.Add(modeName);  
  }  
  
  Grammar choiceGrammar = new Grammar(modeChoice);  
  choiceGrammar.Name = "choice";  
  grammars.Add(choiceGrammar);  
  
  return grammars;  
}  
  
// Insert spaces preceding each uppercase letter in a string.   
private static string BreakAtCaps(string item)  
{  
  if (item == null || item.Length == 0)  
  {  
    return item;  
  }  
  
  StringBuilder sb = new StringBuilder(item[0].ToString());  
  for (int i = 1; i < item.Length; i++)  
  {  
    char c = item[i];  
    if (char.IsUpper(c))  
    {  
      sb.Append(" ");  
    }  
    sb.Append(c);  
  }  
  
  return sb.ToString();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.SubsetMatchingMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : System.Speech.Recognition.GrammarBuilder * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (builder, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Das wiederholte Element.</param>
        <param name="minRepeat">Die minimale Wiederholungsrate für eine Übereinstimmung der Eingabe mit dem durch <paramref name="builder" /> definierten Element, nach der eine Übereinstimmung anerkannt wird.</param>
        <param name="maxRepeat">Die maximale Wiederholungsrate für eine Übereinstimmung der Eingabe mit dem durch <paramref name="builder" /> definierten Element, nach der eine Übereinstimmung anerkannt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Klasse aus einem wiederholten Element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert von `minRepeat` 0 ist, stellt das neue <xref:System.Speech.Recognition.GrammarBuilder> ein optionales-Element dar.  
  
 Der Wert von `minRepeat` muss größer als oder gleich 0 und kleiner als oder gleich dem Wert von `maxRepeat`sein.  
  
> [!IMPORTANT]
>  Wenn Sie für <xref:System.Speech.Recognition.GrammarBuilder> Objekte, die-Instanzen <xref:System.Speech.Recognition.SemanticResultValue> oder <xref:System.Speech.Recognition.SemanticResultKey> -Instanzen enthalten, Wiederholungen angeben, achten Sie darauf, doppelte Semantik Elemente mit demselben Schlüsselnamen oder mehreren semantischen Elementen zu erstellen, die die <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft eines <xref:System.Speech.Recognition.SemanticValue> -Objekts. Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt. 
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik zum Bestellen einer Pizza erstellt. Er beginnt mit einem optionalen, öffnenden Ausdruck, gefolgt von einem bis vier Unterordnungen und schließt mit dem Wort "Pizza".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object from a string array of alternative toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GrammarBuilder (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GrammarBuilder(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.GrammarBuilder : string * int * int -&gt; System.Speech.Recognition.GrammarBuilder" Usage="new System.Speech.Recognition.GrammarBuilder (phrase, minRepeat, maxRepeat)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Die wiederholte Wortsequenz.</param>
        <param name="minRepeat">Die minimale Wiederholungsrate für eine Übereinstimmung der Eingabe mit der Phrase, nach der eine Übereinstimmung anerkannt wird.</param>
        <param name="maxRepeat">Die maximale Wiederholungsrate für eine Übereinstimmung der Eingabe mit der Phrase, nach der eine Übereinstimmung anerkannt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Klasse aus der Sequenz von Wörtern in einem <see cref="T:System.String" /> und gibt an, wie oft der <see cref="T:System.String" /> wiederholt werden kann.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert von `minRepeat` 0 ist, stellt das neue <xref:System.Speech.Recognition.GrammarBuilder> ein optionales-Element dar.  
  
 Der Wert von `minRepeat` muss größer als oder gleich 0 und kleiner als oder gleich dem Wert von `maxRepeat`sein. Weitere Informationen zum Erstellen einer sprach Erkennungs Grammatik, die Zeichen folgen enthält, finden Sie unter Verwenden von Zeichen folgen [zum Erstellen einer grammatigrammgrammatik](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik zum Bestellen einer Pizza erstellt. Er beginnt mit einem optionalen, öffnenden Ausdruck, gefolgt von einem bis vier Unterordnungen und schließt mit dem Wort "Pizza".  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Choices" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein neuen <see cref="T:System.Speech.Recognition.GrammarBuilder" />, der eine Sequenz aus zwei Grammatikelementen enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die statischen <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> Methoden stellen einen weiteren Mechanismus bereit, mit dem Sie verschiedene Typen kombinieren können, um Vielfalt und Flexibilität in <xref:System.Speech.Recognition.GrammarBuilder>Grammatiken zu erstellen, die mit erstellt wurden. Diese Methoden entsprechen den statischen <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> -Methoden, die auch für die <xref:System.Speech.Recognition.GrammarBuilder> -Klasse definiert werden. Die Reihenfolge der Parameter bestimmt die Reihenfolge der Elemente in der neuen <xref:System.Speech.Recognition.GrammarBuilder>.  
  
 Ein <xref:System.Speech.Recognition.GrammarBuilder> kann auch <xref:System.Speech.Recognition.Choices> aus<xref:System.Speech.Recognition.SemanticResultValue>-,-,-und-Zeichen folgen Objekten abgerufen werden. [](https://go.microsoft.com/fwlink/?LinkId=159733) <xref:System.Speech.Recognition.SemanticResultKey> Weitere Informationen finden Sie unter den <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren und <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> .  
  
> [!IMPORTANT]
>  Die Spracherkennung kann eine Ausnahme auslösen, wenn eine sprach Erkennungs Grammatik verwendet wird, die doppelte Semantik Elemente mit demselben Schlüsselnamen oder mehreren semantischen Elementen enthält, die den Wert desselben semantischen Elements wiederholt ändern können. 
  
 Weitere Informationen zum Erstellen und Verwenden von sprach Erkennungs Grammatiken finden Sie unter [Spracherkennung](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) und [Erstellen](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)von Grammatiken für Grammatiken.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (choices, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Das erste Grammatikelement, das einen Satz von Alternativen darstellt.</param>
        <param name="builder">Das zweite Grammatikelement.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Speech.Recognition.GrammarBuilder" />, der ein <see cref="T:System.Speech.Recognition.Choices" />-Objekt gefolgt von einem <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekt enthält.</summary>
        <returns>Ein <see cref="T:System.Speech.Recognition.GrammarBuilder" /> für die Sequenz des <paramref name="choices" />-Elements gefolgt vom <paramref name="builder" />-Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>unterstützt implizite Konvertierungen aus den folgenden Klassen:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Diese Methode akzeptiert die oben aufgeführten Objekte für den `builder` -Parameter.  
  
 Weitere Informationen finden Sie unter den <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren und <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> .  
  
> [!IMPORTANT]
>  Wenn Sie- <xref:System.Speech.Recognition.Choices> und-Objekte Kombi <xref:System.Speech.Recognition.SemanticResultValue> Nieren <xref:System.Speech.Recognition.SemanticResultKey> , die-oder- <xref:System.Speech.Recognition.GrammarBuilder> Instanzen enthalten, stellen Sie sicher, dass Sie keine doppelten semantischen Elemente mit dem gleichen Schlüsselnamen oder mehreren semantischen Elementen erstellen, die die <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft eines-Objekts<xref:System.Speech.Recognition.SemanticValue> . Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt. Weitere Informationen zum Entwickeln einer sprach Erkennungs Grammatik, die semantische Informationen enthält, finden [Sie unter Hinzufügen einer Semantik zu einer Grammatiken-Grammatik](https://msdn.microsoft.com/library/hh361581.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, choices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Das erste Grammatikelement.</param>
        <param name="choices">Das zweite Grammatikelement, das einen Satz von Alternativen darstellt.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Speech.Recognition.GrammarBuilder" />, der ein <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekt gefolgt von einem <see cref="T:System.Speech.Recognition.Choices" />-Objekt enthält.</summary>
        <returns>Ein <see cref="T:System.Speech.Recognition.GrammarBuilder" /> für die Sequenz des <paramref name="builder" />-Elements gefolgt vom <paramref name="choices" />-Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>unterstützt implizite Konvertierungen aus den folgenden Klassen:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Diese Methode akzeptiert die oben aufgeführten Objekte für den `builder` -Parameter.  
  
 Weitere Informationen finden Sie unter den <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren und <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> .  
  
> [!IMPORTANT]
>  Beim Kombinieren <xref:System.Speech.Recognition.Choices> von <xref:System.Speech.Recognition.GrammarBuilder> -und-Objekten <xref:System.Speech.Recognition.SemanticResultKey> , die-oder-Instanzen mit anderen Grammatik Elementen enthalten <xref:System.Speech.Recognition.SemanticResultValue> , achten Sie darauf, dass Sie keine doppelten semantischen Elemente mit demselben Schlüsselnamen oder mehreren semantischen Elementen erstellen, die die <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft <xref:System.Speech.Recognition.SemanticValue> eines-Objekts kann wiederholt geändert werden. Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt. 
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, mit der die beiden Ausdrücke "Hintergrund *Farbe*festlegen" und "Hintergrundfarbe festlegen **" erkannt werden können, wobei *Farbe* aus einer Reihe von Farben ausgewählt wird. Verschiedene Typen werden verwendet, um die endgültige Grammatik zu erstellen, z. <xref:System.Speech.Recognition.Choices>b. <xref:System.Speech.Recognition.GrammarBuilder> [Zeichen](https://go.microsoft.com/fwlink/?LinkId=159733)folgen-,-und-Objekte. Die expliziten Umwandlungs Operatoren in den <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> Aufrufen der-Methoden sind optional.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder1, builder2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Das erste Grammatikelement.</param>
        <param name="builder2">Das zweite Grammatikelement.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Speech.Recognition.GrammarBuilder" />, der eine Sequenz aus zwei <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekten enthält.</summary>
        <returns>Ein <see cref="T:System.Speech.Recognition.GrammarBuilder" /> für die Sequenz des <paramref name="builder1" />-Elements gefolgt vom <paramref name="builder2" />-Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>unterstützt implizite Konvertierungen aus den folgenden Klassen:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Diese Methode akzeptiert die oben aufgeführten Objekte für den `builder1` - `builder2` Parameter oder den-Parameter.  
  
 Weitere Informationen finden Sie unter den <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren und <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> .  
  
> [!IMPORTANT]
>  Beim Kombinieren <xref:System.Speech.Recognition.Choices> von <xref:System.Speech.Recognition.GrammarBuilder> -und-Objekten <xref:System.Speech.Recognition.SemanticResultKey> , die-oder-Instanzen mit anderen Grammatik Elementen enthalten <xref:System.Speech.Recognition.SemanticResultValue> , achten Sie darauf, dass Sie keine doppelten semantischen Elemente mit demselben Schlüsselnamen oder mehreren semantischen Elementen erstellen, die die <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft <xref:System.Speech.Recognition.SemanticValue> eines-Objekts kann wiederholt geändert werden. Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt. 
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, mit der die beiden Ausdrücke "Hintergrund *Farbe*festlegen" und "Hintergrundfarbe festlegen **" erkannt werden können, wobei *Farbe* aus einer Reihe von Farben ausgewählt wird. Verschiedene Typen werden verwendet, um die endgültige Grammatik zu erstellen, z. <xref:System.Speech.Recognition.Choices>b. <xref:System.Speech.Recognition.GrammarBuilder> [Zeichen](https://go.microsoft.com/fwlink/?LinkId=159733)folgen-,-und-Objekte. Die expliziten Umwandlungs Operatoren in den <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> Aufrufen der-Methoden sind optional.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member Add : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (builder, phrase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Das erste Grammatikelement.</param>
        <param name="phrase">Das zweite Grammatikelement, das eine Sequenz von Wörtern darstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Speech.Recognition.GrammarBuilder" />, das ein <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekt gefolgt von einem Begriff enthält.</summary>
        <returns>Ein <see cref="T:System.Speech.Recognition.GrammarBuilder" /> für die Sequenz des <paramref name="builder" />-Elements gefolgt vom <paramref name="phrase" />-Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>unterstützt implizite Konvertierungen aus den folgenden Klassen:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Diese Methode akzeptiert die oben aufgeführten Objekte für den `builder` -Parameter.  
  
 Weitere Informationen finden Sie unter den <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren und <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, mit der die beiden Ausdrücke "Hintergrund *Farbe*festlegen" und "Hintergrundfarbe festlegen **" erkannt werden können, wobei *Farbe* aus einer Reihe von Farben ausgewählt wird. Verschiedene Typen werden verwendet, um die endgültige Grammatik zu erstellen, z. <xref:System.Speech.Recognition.Choices>b. <xref:System.Speech.Recognition.GrammarBuilder> [Zeichen](https://go.microsoft.com/fwlink/?LinkId=159733)folgen-,-und-Objekte. Die expliziten Umwandlungs Operatoren in den <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> Aufrufen der-Methoden sind optional.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder Add (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Speech.Recognition.GrammarBuilder Add(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Add(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ Add(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member Add : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.Add (phrase, builder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Das erste Grammatikelement, das eine Sequenz von Wörtern darstellt.</param>
        <param name="builder">Das zweite Grammatikelement.</param>
        <summary>Erstellt ein neues <see cref="T:System.Speech.Recognition.GrammarBuilder" />, das einen Begriff gefolgt von einem <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekt enthält.</summary>
        <returns>Ein <see cref="T:System.Speech.Recognition.GrammarBuilder" /> für die Sequenz des <paramref name="phrase" />-Elements gefolgt vom <paramref name="builder" />-Element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>unterstützt implizite Konvertierungen aus den folgenden Klassen:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Diese Methode akzeptiert die oben aufgeführten Objekte für den `builder` -Parameter.  
  
 Weitere Informationen finden Sie unter den <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren und <xref:System.Speech.Recognition.GrammarBuilder.op_Addition%2A> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, mit der die beiden Ausdrücke "Hintergrund *Farbe*festlegen" und "Hintergrundfarbe festlegen **" erkannt werden können, wobei *Farbe* aus einer Reihe von Farben ausgewählt wird. Verschiedene Typen werden verwendet, um die endgültige Grammatik zu erstellen, z. <xref:System.Speech.Recognition.Choices>b. <xref:System.Speech.Recognition.GrammarBuilder> [Zeichen](https://go.microsoft.com/fwlink/?LinkId=159733)folgen-,-und-Objekte. Die expliziten Umwandlungs Operatoren in den <xref:System.Speech.Recognition.GrammarBuilder.Add%2A> Aufrufen der-Methoden sind optional.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    GrammarBuilder.Add((GrammarBuilder)"Make background", colorChoice);  
  GrammarBuilder setPhrase =  
    GrammarBuilder.Add("Set background to", (GrammarBuilder)colorChoice);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen eine Diktatgrammatik an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methoden, um Grammatik Elemente an eine vorhandene <xref:System.Speech.Recognition.GrammarBuilder>anzufügen. Wenn Sie Grammatik Elemente erstellen, können Sie Sie an den vorhandenen Generator anfügen, um die Einschränkungen für eine sprach Erkennungs Grammatik progressiv zu entwickeln. Jedes Element wird am Ende der aktuellen Sequenz von Elementen hinzugefügt.  
  
 Diese Methode verfügt über über Ladungen zum Anhängen <xref:System.Speech.Recognition.GrammarBuilder> <xref:System.Speech.Recognition.SemanticResultKey> <xref:System.String> <xref:System.Speech.Recognition.Choices>von-,-, <xref:System.Speech.Recognition.SemanticResultValue> -,-und-Objekten.  
  
> [!IMPORTANT]
>  Die Spracherkennung kann eine Ausnahme auslösen, wenn eine sprach Erkennungs Grammatik verwendet wird, die doppelte Semantik Elemente mit demselben Schlüsselnamen oder mehreren semantischen Elementen enthält, die den Wert desselben semantischen Elements wiederholt ändern können. 
  
 Weitere Informationen zum Erstellen und Verwenden von sprach Erkennungs Grammatiken finden Sie unter [Spracherkennung](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) und [Erstellen](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)von Grammatiken für Grammatiken.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.Choices alternateChoices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.Choices alternateChoices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (alternateChoices As Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::Choices ^ alternateChoices);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.Choices -&gt; unit" Usage="grammarBuilder.Append alternateChoices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alternateChoices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="alternateChoices">Der Satz von Alternativen, die angefügt werden sollen.</param>
        <summary>Fügt einen Satz von Alternativen zur aktuellen Sequenz von Grammatikelementen an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `alternateChoices`wird am Ende der aktuellen Sequenz von Elementen hinzugefügt.  
  
> [!IMPORTANT]
>  Wenn Sie <xref:System.Speech.Recognition.Choices> Objekte, die-oder <xref:System.Speech.Recognition.SemanticResultValue> <xref:System.Speech.Recognition.SemanticResultKey> -Instanzen enthalten, <xref:System.Speech.Recognition.GrammarBuilder> an ein-Objekt anfügen, stellen Sie sicher, dass Sie keine doppelten semantischen Elemente mit dem gleichen Schlüsselnamen oder mehreren semantischen Elementen erstellen, die wiederholt Ändern Sie <xref:System.Speech.Recognition.SemanticValue.Value%2A> die-Eigenschaft <xref:System.Speech.Recognition.SemanticValue> eines-Objekts. Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt.
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik für Ausdrücke wie "calljames at Work" und "callanne on your Cell Phone" erstellt, wobei das Wort "Phone" optional ist. Im Beispiel wird die Verwendung <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> der-Methode hervorgehoben.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder -&gt; unit" Usage="grammarBuilder.Append builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Das anzufügende Grammatikelement.</param>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen eine Diktatgrammatik an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `builder`wird am Ende der aktuellen Sequenz von Grammatik Elementen hinzugefügt.  
  
> [!NOTE]
>  Wenn Sie <xref:System.Speech.Recognition.GrammarBuilder> Objekte, die-oder <xref:System.Speech.Recognition.SemanticResultValue> <xref:System.Speech.Recognition.SemanticResultKey> -Instanzen enthalten, <xref:System.Speech.Recognition.GrammarBuilder> an ein-Objekt anfügen, stellen Sie sicher, dass Sie keine doppelten semantischen Elemente mit dem gleichen Schlüsselnamen oder mehreren semantischen Elementen erstellen, die wiederholt Ändern Sie <xref:System.Speech.Recognition.SemanticValue.Value%2A> die-Eigenschaft <xref:System.Speech.Recognition.SemanticValue> eines-Objekts. Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt. 
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik für Ausdrücke wie "calljames at Work" und "callanne on your Cell Phone" erstellt, wobei das Wort "Phone" optional ist. <xref:System.Speech.Recognition.GrammarBuilder>- <xref:System.Speech.Recognition.Choices> und-Objekte werden verwendet, um die Grammatik zu konstruieren. Im Beispiel wird die Verwendung <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> der-Methode hervorgehoben.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (key As SemanticResultKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultKey -&gt; unit" Usage="grammarBuilder.Append key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="key">Der semantische Schlüssel, der angefügt werden soll.</param>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen einen semantischen Schlüssel an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `key`wird am Ende der aktuellen Sequenz von Elementen hinzugefügt.  
  
> [!IMPORTANT]
>  Wenn Sie- <xref:System.Speech.Recognition.SemanticResultValue> oder <xref:System.Speech.Recognition.SemanticResultKey> -Instanzen an ein <xref:System.Speech.Recognition.GrammarBuilder> -Objekt anfügen, stellen Sie sicher, dass Sie keine doppelten semantischen Elemente mit dem gleichen Schlüsselnamen oder mehreren semantischen Elementen erstellen, die die <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft eines <xref:System.Speech.Recognition.SemanticValue> -Objekt. Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt.
  
   
  
## Examples  
 Das folgende Beispiel ist Teil einer Konsolenanwendung, mit der die Ursprungs-und Zielstädte für einen Flug ausgewählt werden. Die Anwendung erkennt Ausdrücke, z. b. "Ich möchte von Miami nach Chicago fliegen." Der Handler für das <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> -Ereignis verwendet <xref:System.Speech.Recognition.SemanticResultKey> das, um den in der <xref:System.Speech.Recognition.SemanticResultValue> für die Ursprungs-und Zielort angegebenen Flughafencode zu extrahieren.  
  
```csharp  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create a Choices object and add  cities and airport codes  
        // using SemanticResultValue objects.  
        Choices cities = new Choices();  
        cities.Add(new SemanticResultValue("Chicago", "ORD"));  
        cities.Add(new SemanticResultValue("Boston", "BOS"));  
        cities.Add(new SemanticResultValue("Miami", "MIA"));  
        cities.Add(new SemanticResultValue("Dallas", "DFW"));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.SemanticResultValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.SemanticResultValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.SemanticResultValue)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (value As SemanticResultValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::SemanticResultValue ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.SemanticResultValue -&gt; unit" Usage="grammarBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="value">Der anzufügende semantische Wert.</param>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen einen semantischen Schlüssel an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`wird am Ende der aktuellen Sequenz von Elementen hinzugefügt.  
  
> [!IMPORTANT]
>  Wenn Sie- <xref:System.Speech.Recognition.SemanticResultValue> oder <xref:System.Speech.Recognition.SemanticResultKey> -Instanzen an ein <xref:System.Speech.Recognition.GrammarBuilder> -Objekt anfügen, stellen Sie sicher, dass Sie keine doppelten semantischen Elemente mit dem gleichen Schlüsselnamen oder mehreren semantischen Elementen erstellen, die die <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft eines <xref:System.Speech.Recognition.SemanticValue> -Objekt. Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt.
  
   
  
## Examples  
 Das folgende Beispiel ist Teil einer Konsolenanwendung, mit der die Ursprungs-und Zielstädte für einen Flug ausgewählt werden. Die Anwendung erkennt Ausdrücke, z. b. "Ich möchte von Miami nach Chicago fliegen." Der Handler für das <xref:System.Speech.Recognition.SpeechRecognitionEngine.SpeechRecognized> -Ereignis verwendet <xref:System.Speech.Recognition.SemanticResultKey> das, um den in der <xref:System.Speech.Recognition.SemanticResultValue> für die Ursprungs-und Zielort angegebenen Flughafencode zu extrahieren.  
  
```csharp  
  
using System;  
using System.Speech.Recognition;  
  
namespace SampleRecognition  
{  
  class Program  
  {  
    static void Main(string[] args)  
  
    // Initialize an in-process speech recognition engine.  
    {  
      using (SpeechRecognitionEngine recognizer =  
         new SpeechRecognitionEngine())  
      {  
  
        // Create GrammarBuilder objects and append SemanticResultValue objects   
        // that contain cities and airport codes.  
  
        GrammarBuilder chicago = new GrammarBuilder();  
        chicago.Append(new SemanticResultValue("Chicago", "ORD"));  
  
        GrammarBuilder boston = new GrammarBuilder();  
        boston.Append(new SemanticResultValue("Boston", "BOS"));  
  
        GrammarBuilder miami = new GrammarBuilder();  
        miami.Append(new SemanticResultValue("Miami", "MIA"));  
  
        GrammarBuilder dallas = new GrammarBuilder();  
        dallas.Append(new SemanticResultValue("Dallas", "DFW"));  
  
        // Create a Choices object and add the cities using implicit conversion from   
        // SemanticResultValue to GrammarBuilder.  
        Choices cities = new Choices();  
        cities.Add(new Choices(new GrammarBuilder[] { chicago, boston, miami, dallas }));  
  
        // Build the phrase and add SemanticResultKeys.  
        GrammarBuilder chooseCities = new GrammarBuilder();  
        chooseCities.Append("I want to fly from");  
        chooseCities.Append(new SemanticResultKey("origin", cities));  
        chooseCities.Append("to");  
        chooseCities.Append(new SemanticResultKey("destination", cities));  
  
        // Build a Grammar object from the GrammarBuilder.  
        Grammar bookFlight = new Grammar(chooseCities);  
        bookFlight.Name = "Book Flight";  
  
        // Add a handler for the LoadGrammarCompleted event.  
        recognizer.LoadGrammarCompleted +=   
          new EventHandler<LoadGrammarCompletedEventArgs>(recognizer_LoadGrammarCompleted);  
  
        // Add a handler for the SpeechRecognized event.  
        recognizer.SpeechRecognized +=   
          new EventHandler<SpeechRecognizedEventArgs>(recognizer_SpeechRecognized);  
  
        // Configure the input to the recognizer.  
        recognizer.SetInputToDefaultAudioDevice();  
  
        // Load the grammar object and start recognition.  
        recognizer.LoadGrammarAsync(bookFlight);  
        recognizer.RecognizeAsync();  
  
        // Keep the console window open.  
        Console.ReadLine();  
      }  
    }  
    // Handle the LoadGrammarCompleted event.  
    static void recognizer_LoadGrammarCompleted(object sender, LoadGrammarCompletedEventArgs e)  
    {  
      Console.WriteLine("Grammar loaded: " + e.Grammar.Name);  
      Console.WriteLine();  
    }  
  
    // Handle the SpeechRecognized event.  
    static void recognizer_SpeechRecognized(object sender, SpeechRecognizedEventArgs e)  
    {  
      Console.WriteLine("Speech recognized:  " + e.Result.Text);  
      Console.WriteLine();  
      Console.WriteLine("Semantic results:");  
      Console.WriteLine("  The flight origin is " + e.Result.Semantics["origin"].Value);  
      Console.WriteLine("  The flight destination is " + e.Result.Semantics["destination"].Value);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; unit" Usage="grammarBuilder.Append phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Die anzufügende Wortsequenz.</param>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen einen Ausdruck an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `phrase`wird am Ende der aktuellen Sequenz von Elementen hinzugefügt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, valuetype System.Speech.Recognition.SubsetMatchingMode subsetMatchingCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Speech.Recognition.SubsetMatchingMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, subsetMatchingCriteria As SubsetMatchingMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, System::Speech::Recognition::SubsetMatchingMode subsetMatchingCriteria);" />
      <MemberSignature Language="F#" Value="member this.Append : string * System.Speech.Recognition.SubsetMatchingMode -&gt; unit" Usage="grammarBuilder.Append (phrase, subsetMatchingCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="subsetMatchingCriteria" Type="System.Speech.Recognition.SubsetMatchingMode" />
      </Parameters>
      <Docs>
        <param name="phrase">Die anzufügende Wortsequenz.</param>
        <param name="subsetMatchingCriteria">Der entsprechende Modus, den die Grammatik verwendet, um den Ausdruck zu erkennen.</param>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen ein Element für eine Teilmenge eines Ausdrucks an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das untergeordnete Element wird am Ende der aktuellen Sequenz von Elementen hinzugefügt. Weitere Informationen zum Erstellen einer sprach Erkennungs Grammatik mithilfe von Zeichen folgen finden Sie unter Verwenden von Zeichen folgen [zum Erstellen einer grammatigrammgrammatik](https://msdn.microsoft.com/library/0d87b445-a342-4369-9b3f-91d07fd7e114).  
  
 Ausführliche Informationen zur Verwendung von untergeordneten Vergleichs Modi finden <xref:System.Speech.Recognition.SubsetMatchingMode?displayProperty=nameWithType>Sie unter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik für jeden <xref:System.Speech.Recognition.SubsetMatchingMode> Wert erstellt. Die generierte Grammatik `OrderedSubset` erkennt z. b. die Ausdrücke "3 4 5" und "1 3 5", und die Grammatik `Subsequence` erkennt den Ausdruck "3 4 5", aber nicht den Ausdruck "1 3 5".  
  
```csharp  
  
private Grammar[] CreateSubsetMatchTest()  
{  
  List<Grammar> grammars = new List<Grammar>(4);  
  
  string phrase = "one two three four five six";  
  foreach (SubsetMatchingMode mode in  
    Enum.GetValues(typeof(SubsetMatchingMode)))  
  {  
    GrammarBuilder gb = new GrammarBuilder();  
    gb.Append(phrase, mode);  
  
    Grammar grammar = new Grammar(gb);  
    grammar.Name = mode.ToString();  
    grammars.Add(grammar);  
  }  
  
  return grammars.ToArray();  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Speech.Recognition.GrammarBuilder builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Speech.Recognition.GrammarBuilder builder, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.GrammarBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (builder As GrammarBuilder, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Speech::Recognition::GrammarBuilder ^ builder, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Speech.Recognition.GrammarBuilder * int * int -&gt; unit" Usage="grammarBuilder.Append (builder, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="builder">Das wiederholte anzufügende Grammatikelement.</param>
        <param name="minRepeat">Die minimale Wiederholungsrate für eine Übereinstimmung der Eingabe mit dem durch <paramref name="builder" /> definierten Element, nach der eine Übereinstimmung anerkannt wird.</param>
        <param name="maxRepeat">Die maximale Wiederholungsrate für eine Übereinstimmung der Eingabe mit dem durch <paramref name="builder" /> definierten Element, nach der eine Übereinstimmung anerkannt wird.</param>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen eine wiederholte Grammatik an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert von `minRepeat` muss größer als oder gleich 0 und kleiner als oder gleich dem Wert von `maxRepeat`sein.  
  
> [!IMPORTANT]
>  Wenn Sie <xref:System.Speech.Recognition.GrammarBuilder> Objekte, die-oder <xref:System.Speech.Recognition.SemanticResultValue> <xref:System.Speech.Recognition.SemanticResultKey> -Instanzen enthalten, <xref:System.Speech.Recognition.GrammarBuilder> an ein-Objekt anfügen, stellen Sie sicher, dass Sie keine doppelten semantischen Elemente mit dem gleichen Schlüsselnamen oder mehreren semantischen Elementen erstellen, die wiederholt Ändern Sie <xref:System.Speech.Recognition.SemanticValue.Value%2A> die-Eigenschaft <xref:System.Speech.Recognition.SemanticValue> eines-Objekts. Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt.
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik für Ausdrücke wie "calljames at Work" und "callanne on your Cell Phone" erstellt, wobei das Wort "Phone" optional ist. <xref:System.Speech.Recognition.GrammarBuilder>- <xref:System.Speech.Recognition.Choices> und-Objekte werden verwendet, um die Grammatik zu konstruieren. Im Beispiel wird die Verwendung <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> der-Methode hervorgehoben.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (string phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(string phrase, int32 minRepeat, int32 maxRepeat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (phrase As String, minRepeat As Integer, maxRepeat As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::String ^ phrase, int minRepeat, int maxRepeat);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; unit" Usage="grammarBuilder.Append (phrase, minRepeat, maxRepeat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="minRepeat" Type="System.Int32" />
        <Parameter Name="maxRepeat" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="phrase">Die wiederholte anzufügende Wortsequenz.</param>
        <param name="minRepeat">Die minimale Wiederholungsrate für eine Übereinstimmung der Eingabe mit <paramref name="phrase" />, nach der eine Übereinstimmung anerkannt wird.</param>
        <param name="maxRepeat">Die maximale Wiederholungsrate für eine Übereinstimmung der Eingabe mit <paramref name="phrase" />, nach der eine Übereinstimmung anerkannt wird.</param>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen einen wiederholten Ausdruck an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert von `minRepeat` muss größer als oder gleich 0 und kleiner als oder gleich dem Wert von `maxRepeat`sein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik für Ausdrücke wie "calljames at Work" und "callanne on your Cell Phone" erstellt, wobei das Wort "Phone" optional ist. <xref:System.Speech.Recognition.GrammarBuilder>- <xref:System.Speech.Recognition.Choices> und-Objekte werden verwendet, um die Grammatik zu konstruieren. Im Beispiel wird die Verwendung <xref:System.Speech.Recognition.GrammarBuilder.Append%2A> der-Methode hervorgehoben.  
  
```csharp  
  
public static Grammar CreatePhonePhrase()  
{  
  // Create alternatives for person names, locations, devices, and pronouns.  
  Choices personChoice = new Choices(new string[] {"Anne", "James", "Mary", "Sam"});  
  Choices locationChoice = new Choices(new string[] {"home", "work"});  
  Choices deviceChoice = new Choices(new string[] {"home", "work", "cell"});  
  Choices pronounChoice = new Choices(new string[] {"his", "her"});  
  
  // Create a phrase for the receiving device, which optionally contains the word "phone".  
  GrammarBuilder devicePhrase = new GrammarBuilder(pronounChoice);  
  devicePhrase.Append(deviceChoice);  
  devicePhrase.Append("phone", 0, 1);  
  
  // Create alternatives for phrases specifying a device or a location.  
  GrammarBuilder atLocation = new GrammarBuilder("at");  
  atLocation.Append(locationChoice);  
  
  GrammarBuilder onDevice = new GrammarBuilder("on");  
  onDevice.Append(devicePhrase);  
  
  Choices howChoice = new Choices(new GrammarBuilder[] {atLocation, onDevice});  
  
  // Build the final phrase.  
  GrammarBuilder callWho = new GrammarBuilder("Call");  
  callWho.Append(personChoice);  
  callWho.Append(howChoice);  
  
  // Create the Grammar object.  
  Grammar callGrammar = new Grammar(callWho);  
  callGrammar.Name = "Call Grammar";  
  
  return callGrammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendDictation">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen eine Diktatgrammatik an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Speech.Recognition.GrammarBuilder.AppendDictation%2A> -Methoden ermöglichen es Ihnen, eine Diktat Grammatik als Regel an einen <xref:System.Speech.Recognition.GrammarBuilder>anzufügen.  
  
 Weitere Informationen zu Diktat Grammatiken finden <xref:System.Speech.Recognition.DictationGrammar>Sie unter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation();" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : unit -&gt; unit" Usage="grammarBuilder.AppendDictation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen eine Standarddiktatgrammatik an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Diktat Grammatiken finden <xref:System.Speech.Recognition.DictationGrammar>Sie unter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, die Diktat enthält.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation();  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendDictation">
      <MemberSignature Language="C#" Value="public void AppendDictation (string category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendDictation(string category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendDictation(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendDictation (category As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendDictation(System::String ^ category);" />
      <MemberSignature Language="F#" Value="member this.AppendDictation : string -&gt; unit" Usage="grammarBuilder.AppendDictation category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="category">Die Kategorie der anzufügenden Diktatgrammatik.</param>
        <summary>Fügt eine angegebene Diktatgrammatik der aktuellen Sequenz von Grammatikelementen an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Rechtschreibprüfung zu verwenden, legen Sie `category` auf `spelling`fest.  
  
 Weitere Informationen zu Diktat Grammatiken finden <xref:System.Speech.Recognition.DictationGrammar>Sie unter.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, die die Grammatikregeln für Rechtschreibprüfung enthält.  
  
```csharp  
  
GrammarBuilder builder = new GrammarBuilder();  
builder.Append("begin");  
builder.AppendDictation("spelling");  
builder.Append("end");  
Grammar grammarWithDictation = new Grammar(builder);  
grammarWithDictation.Name = "Grammar with Dictation";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.DictationGrammar" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendRuleReference">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen eine Grammatikdatei oder eine Grammatikregel an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> -Methoden können eine Grammatik Datei oder eine Grammatik Regel aus einer Datei anfügen. Diese Methoden ermöglichen Anwendungen die Verwendung von vorab bereitgestellten oder öffentlich verfügbaren Grammatikregeln. Die Anwendung muss Lesezugriff auf den Speicherort der angegebenen Grammatik Dateien haben.  
  
 Diese Methoden können eine sprach Erkennungs Grammatik aus den folgenden Formaten lesen.  
  
-   XML-Format Dateien, die der W3C- [Spezifikation für die sprach Erkennungs Grammatik (SRGS), Version 1,0](https://go.microsoft.com/fwlink/?LinkId=201761) , entsprechen  
  
-   Binärdateien, die dem Binär Format der Microsoft-sprach Erkennungs Grammatik (. cfg-Dateierweiterung) entsprechen  
  
 Das Kompilieren einer SRGS-Grammatik Datei im XML-Format in eine binäre Grammatik Datei mit der Erweiterung ". cfg" kann die von Such Vorgängen verbrauchte Zeit verringern, insbesondere dann, wenn die Grammatik eine Erkennung einer großen Anzahl von Wörtern und Ausdrücken erfordert. Informationen zum Kompilieren von SRGS-Grammatiken in das cfg-Binärformat <xref:System.Speech.Recognition.SrgsGrammar.SrgsGrammarCompiler>finden Sie unter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string -&gt; unit" Usage="grammarBuilder.AppendRuleReference path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad oder der URI (Universal Resource Identifier) der Datei, die eine Spracherkennungsgrammatik in einem unterstützten Format beschreibt.</param>
        <summary>Fügt der aktuellen Sequenz von Grammatikelementen eine Grammatikdefinitionsdatei an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der URI, der vom `path` -Argument bereitgestellt wird, ist möglicherweise local oder Remote. Die Anwendung muss Lesezugriff auf den Speicherort der angegebenen Grammatik Dateien haben.  
  
 Eine SRGS-Darstellung (W3C Speech Recognition Grammar Specification) kann eine Stamm Regel definieren. Diese Methode fügt die Grammatik, beginnend mit ihrer Stamm Regel, an die aktuelle Sequenz von Grammatik Elementen an. Verwenden Sie die <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> -Methode, um eine bestimmte Grammatik Regel anzufügen.  
  
   
  
## Examples  
 Im folgenden C# Beispiel wird eine sprach Erkennungs Grammatik erstellt, die die Regel `Cities` mit dem Namen in einer lokalen SRGS-Datei "Cities. grxml" verwendet. Der Inhalt der Datei Cities. grxml wird unterhalb des C# Code Beispiels angezeigt.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar1()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.AppendRuleReference("file://c:/temp/cities.grxml");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 1";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-16" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendRuleReference">
      <MemberSignature Language="C#" Value="public void AppendRuleReference (string path, string rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendRuleReference(string path, string rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendRuleReference (path As String, rule As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendRuleReference(System::String ^ path, System::String ^ rule);" />
      <MemberSignature Language="F#" Value="member this.AppendRuleReference : string * string -&gt; unit" Usage="grammarBuilder.AppendRuleReference (path, rule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rule" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Dateipfad oder der URI (Universal Resource Identifier) der Datei, der eine Spracherkennungsgrammatik in einem unterstützten Format beschreibt.</param>
        <param name="rule">Der Bezeichner der Regel, die anzuwenden ist, oder <see langword="null" />, um die standardmäßige Stammregel der Grammatikdatei anzuwenden.</param>
        <summary>Fügt die angegebene Regel einer Grammatikdefinitionsdatei der aktuellen Sequenz von Grammatikelementen an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der URI, der vom `path` -Argument bereitgestellt wird, ist möglicherweise local oder Remote. Die Anwendung muss Lesezugriff auf den Speicherort der angegebenen Grammatik Dateien haben.  
  
 Mithilfe der- <xref:System.Speech.Recognition.GrammarBuilder.AppendRuleReference%2A> Methode können Sie eine Grammatik Datei mit ihrer Stamm Regel anfügen.  
  
   
  
## Examples  
 Im folgenden C# Beispiel wird eine sprach Erkennungs Grammatik erstellt, die die Regel `Cities` mit dem Namen in einer lokalen SRGS-Datei "Cities. grxml" verwendet. Der Inhalt der Datei Cities. grxml wird unterhalb des C# Code Beispiels angezeigt.  
  
```csharp  
  
private static Grammar CreateCitiesGrammar2()  
{  
  GrammarBuilder builder = new GrammarBuilder();  
  builder.Append("Does");  
  builder.AppendRuleReference(@"c:\temp\cities.grxml", "Cities");  
  builder.Append("have a shuttle");  
  
  Grammar citiesGrammar = new Grammar(builder);  
  citiesGrammar.Name = "Cities Grammar 2";  
  return citiesGrammar;  
}  
```  
  
```xml  
  
<?xml version="1.0" encoding="UTF-8" ?>  
<grammar version="1.0" xml:lang="en-US"  
         xmlns="http://www.w3.org/2001/06/grammar"  
         tag-format="semantics/1.0" root="Main">  
  
  <!-- cities.grxml:   
    Defines an SRGS grammar for requesting a flight. This grammar includes  
    a Cities rule that lists the cities that can be used for departures  
    and destinations. -->  
  
  <rule id="Main">  
    <item>  
      I would like to fly from <ruleref uri="#Cities"/>  
      to <ruleref uri="#Cities"/>  
    </item>  
  </rule>  
  
  <rule id="Cities" scope="public">  
    <one-of>  
      <item> Seattle </item>  
      <item> Los Angeles </item>  
      <item> New York </item>  
      <item> Miami </item>  
    </one-of>  
  </rule>  
</grammar>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
        <altmember cref="T:System.Speech.Recognition.Grammar" />
      </Docs>
    </Member>
    <Member MemberName="AppendWildcard">
      <MemberSignature Language="C#" Value="public void AppendWildcard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendWildcard() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.AppendWildcard" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendWildcard ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendWildcard();" />
      <MemberSignature Language="F#" Value="member this.AppendWildcard : unit -&gt; unit" Usage="grammarBuilder.AppendWildcard " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fügt ein Anerkennungsgrammatikelement an, das jeder Eingabe in die aktuelle Sequenz von Grammatikelementen entspricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Platzhalter Element wird am Ende der aktuellen Sequenz von Elementen hinzugefügt.  
  
 Das Platzhalter Element stimmt mit jedem gesprochenen Wort überein. Es entspricht nicht dem Hintergrundrauschen oder-Ruhe Vorgang.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Grammatik erstellt, die die Kenn Wort Eingabe als Platzhalter akzeptiert. Im Beispiel wird ein <xref:System.Speech.Recognition.Grammar.SpeechRecognized?displayProperty=nameWithType> -Ereignishandler an die Grammatik angefügt, die die Kenn Wort Eingabe überprüft.  
  
```csharp  
private Grammar CreatePasswordGrammar()  
{  
  GrammarBuilder wildcardBuilder = new GrammarBuilder();  
  wildcardBuilder.AppendWildcard();  
  SemanticResultKey passwordKey =  
    new SemanticResultKey("Password", wildcardBuilder);  
  
  GrammarBuilder passwordBuilder =  
    new GrammarBuilder("My Password is");  
  passwordBuilder.Append(passwordKey);  
  
  Grammar passwordGrammar = new Grammar(passwordBuilder);  
  passwordGrammar.Name = "Password input";  
  
  passwordGrammar.SpeechRecognized +=  
    new EventHandler<SpeechRecognizedEventArgs>(  
      PasswordInputHandler);  
  
  return passwordGrammar;  
}  
  
// Handle the SpeechRecognized event for the password grammar.  
private void PasswordInputHandler(object sender, SpeechRecognizedEventArgs e)  
{  
  if (e.Result == null) return;  
  
  RecognitionResult result = e.Result;  
  SemanticValue semantics = e.Result.Semantics;  
  
  if (semantics.ContainsKey("Password"))  
  {  
    RecognizedAudio passwordAudio =  
      result.GetAudioForWordRange(  
        result.Words[3], result.Words[result.Words.Count - 1]);  
  
    if (IsValidPassword(passwordAudio))  
    {  
      Console.WriteLine("Password accepted.");  
  
      // Add code to handle a valid password here.  
    }  
    else  
    {  
      Console.WriteLine("Invalid password.");  
  
      // Add code to handle an invalid password here.  
    }  
  }  
}  
  
// Validate the password input.   
private bool IsValidPassword(RecognizedAudio passwordAudio)  
{  
  Console.WriteLine("Validating password.");  
  
  // Add password validation code here.  
  
  return false;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Append(System.Speech.Recognition.Choices)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendDictation" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.AppendRuleReference(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : System.Globalization.CultureInfo with get, set" Usage="System.Speech.Recognition.GrammarBuilder.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Kultur der Spracherkennungsgrammatik auf oder legt diese fest.</summary>
        <value>Die Kultur des <see cref="T:System.Speech.Recognition.GrammarBuilder" />. Der Standard ist die <see cref="P:System.Threading.Thread.CurrentUICulture" />-Eigenschaft des ausführenden Threads.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Speech.Recognition.Grammar.%23ctor%2A> -Konstruktor erstellt <xref:System.Speech.Recognition.Grammar> ein-Objekt, das von einer Spracherkennung der entsprechenden Kultur verwendet werden kann. Nur die <xref:System.Speech.Recognition.GrammarBuilder.Culture%2A> -Eigenschaft <xref:System.Speech.Recognition.GrammarBuilder> der, die als Parameter für den Grammatik-Konstruktor bereitgestellt wird, wird verwendet, um die Kultur der resultierenden sprach Erkennungs Grammatik festzulegen.  
  
 Microsoft Windows und die System. Speech-API akzeptieren alle gültigen sprach Ländercodes. Um die Spracherkennung mithilfe der in der `Culture` -Eigenschaft angegebenen Sprache durchzuführen, muss eine sprach Erkennungs-Engine installiert werden, die diesen Sprachen-Ländercode unterstützt. Die Spracherkennungs-Engines, die mit Microsoft Windows 7 ausgeliefert wurden, funktionieren mit den folgenden Programmiersprachen.  
  
-   en-GB. Englisch (Vereinigtes Königreich)  
  
-   en-US. Englisch (USA)  
  
-   de-de. Deutsch (Deutschland)  
  
-   es-es. Spanisch (Spanien)  
  
-   fr-FR. Französisch (Frankreich)  
  
-   ja-JP. Japanisch (Japan)  
  
-   zh-CN. Chinesisch (China)  
  
-   zh-tw. Chinesisch (Taiwan)  
  
 Sprachcodes mit zwei Buchstaben, z. b. "en", "fr" oder "es", sind ebenfalls zulässig.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, um eine Pizza mit bis zu vier Unterordnungen zu bestellen. Dadurch wird die Kultur <xref:System.Speech.Recognition.GrammarBuilder> des Objekts ausdrücklich auf Englisch (USA) festgelegt.  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Speech.Recognition.Grammar" />
        <altmember cref="T:System.Speech.Recognition.RecognizerInfo" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognitionEngine" />
        <altmember cref="T:System.Speech.Recognition.SpeechRecognizer" />
      </Docs>
    </Member>
    <Member MemberName="DebugShowPhrases">
      <MemberSignature Language="C#" Value="public string DebugShowPhrases { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DebugShowPhrases" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DebugShowPhrases As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DebugShowPhrases { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DebugShowPhrases : string" Usage="System.Speech.Recognition.GrammarBuilder.DebugShowPhrases" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolge ab, die den Inhalt und die Struktur der Grammatik angezeigt, die in <see cref="T:System.Speech.Recognition.GrammarBuilder" /> enthalten ist.</summary>
        <value>Der aktuelle Inhalt und die aktuelle Struktur von <see cref="T:System.Speech.Recognition.GrammarBuilder" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, um eine Pizza mit bis zu vier Unterordnungen zu bestellen. Vor dem Erstellen der Grammatik wird <xref:System.Speech.Recognition.GrammarBuilder> der Status von in die Konsole geschrieben. Mit dieser Methode wird die folgende Ausgabe generiert:  
  
-   `GrammarBuilder status: I would like a [cheese,mushroom,tomato,onion,anchovy,chic ken,pepperoni] and [cheese,mushroom,tomato,onion,anchovy,chicken,pepperoni] pizza`  
  
```csharp  
  
private static Grammar CreatePizzaGrammar()  
{  
  
  // Create a Choices object with alternatives for toppings.  
  Choices toppings = new Choices(new string[] {  
    "cheese", "mushroom", "tomato", "onion",  
    "anchovy", "chicken", "pepperoni"});  
  
  // Create a GrammarBuilder and append the Choices object.  
  GrammarBuilder andToppings = new GrammarBuilder("and", 0, 1);  
  andToppings.Append(toppings);  
  
  // Construct the phrase.  
  GrammarBuilder gb = new GrammarBuilder("I would like a", 0, 1);  
  gb.Append(toppings);  
  gb.Append(new GrammarBuilder(andToppings, 0, 3));  
  gb.Append("pizza");  
  
  // Write the contents and structure of the GrammarBuilder to the console.  
  Console.WriteLine("Grammar content and structure: {0}", gb.DebugShowPhrases);  
  
  // Create the Grammar from the GrammarBuilder.  
  Grammar grammar = new Grammar(gb);  
  grammar.Name = "Pizza Order";  
  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361640(v%3doffice.14)">Erstellen von Grammatiken mithilfe von grammatimarbuilder</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Speech.Recognition.GrammarBuilder" />, der einer Sequenz von zwei Grammatikelementen entspricht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Reihenfolge der Operanden bestimmt die Reihenfolge der Elemente in der neuen <xref:System.Speech.Recognition.GrammarBuilder>.  
  
> [!IMPORTANT]
>  Vorsicht wird empfohlen, wenn <xref:System.Speech.Recognition.Choices> - <xref:System.Speech.Recognition.GrammarBuilder> oder-Objekte <xref:System.Speech.Recognition.SemanticResultValue> kombiniert <xref:System.Speech.Recognition.SemanticResultKey> werden, die-oder-Instanzen mit anderen Grammatik Elementen enthalten. Die Spracherkennung kann eine Ausnahme auslösen, wenn eine sprach Erkennungs Grammatik verwendet wird, die doppelte Semantik Elemente mit demselben Schlüsselnamen oder mehreren semantischen Elementen enthält, die den Wert desselben semantischen Elements wiederholt ändern können. 
  
 Weitere Informationen zum Erstellen und Verwenden von sprach Erkennungs Grammatiken finden Sie unter [Spracherkennung](https://docs.microsoft.com/previous-versions/office/developer/speech-technologies/hh361633(v=office.14)) und [Erstellen](https://msdn.microsoft.com/library/7e2cc577-cb05-4318-9da3-7c8675d3d9ae)von Grammatiken für Grammatiken.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.Choices choices, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.Choices choices, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::Choices ^ choices, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.Choices * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="choices + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="choices">Das erste Grammatikelement, das einen Satz von Alternativen darstellt.</param>
        <param name="builder">Das zweite Grammatikelement.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Speech.Recognition.GrammarBuilder" />, der ein <see cref="T:System.Speech.Recognition.Choices" />-Objekt gefolgt von einem <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekt enthält.</summary>
        <returns>Gibt einen <see cref="T:System.Speech.Recognition.GrammarBuilder" /> für die Sequenz des <paramref name="choices" />-Parameters zurück, gefolgt vom Parameter <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>unterstützt Konvertierungen aus den folgenden Klassen.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Diese Methode akzeptiert die oben aufgeführten Objekte für den `builder` -Parameter. Weitere Informationen finden Sie unter <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren.  
  
> [!IMPORTANT]
>  Wenn Sie- <xref:System.Speech.Recognition.Choices> und-Objekte Kombi <xref:System.Speech.Recognition.SemanticResultValue> Nieren <xref:System.Speech.Recognition.SemanticResultKey> , die-oder- <xref:System.Speech.Recognition.GrammarBuilder> Instanzen enthalten, stellen Sie sicher, dass Sie keine doppelten semantischen Elemente mit dem gleichen Schlüsselnamen oder mehreren semantischen Elementen erstellen, die die <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft eines-Objekts<xref:System.Speech.Recognition.SemanticValue> . Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt.
  
 Die äquivalente Methode für diesen Operator ist.<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.Choices%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.Choices)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="builder">Das erste Grammatikelement.</param>
        <param name="choices">Das zweite Grammatikelement, das einen Satz von alternativen Elementen darstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Speech.Recognition.GrammarBuilder" />, das einen <see cref="T:System.Speech.Recognition.GrammarBuilder" /> gefolgt von einem <see cref="T:System.Speech.Recognition.Choices" /> enthält.</summary>
        <returns>Gibt einen <see cref="T:System.Speech.Recognition.GrammarBuilder" /> für die Sequenz des <paramref name="builder" />-Parameters zurück, gefolgt vom Parameter <paramref name="choices" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>unterstützt Konvertierungen aus den folgenden Klassen:  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Diese Methode akzeptiert die oben aufgeführten Objekte für den `builder` -Parameter. Weitere Informationen finden Sie unter <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren.  
  
> [!IMPORTANT]
>  Wenn Sie- <xref:System.Speech.Recognition.Choices> und-Objekte Kombi <xref:System.Speech.Recognition.SemanticResultValue> Nieren <xref:System.Speech.Recognition.SemanticResultKey> , die-oder- <xref:System.Speech.Recognition.GrammarBuilder> Instanzen enthalten, stellen Sie sicher, dass Sie keine doppelten semantischen Elemente mit dem gleichen Schlüsselnamen oder mehreren semantischen Elementen erstellen, die die <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft eines-Objekts<xref:System.Speech.Recognition.SemanticValue> . Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt.
  
 Die äquivalente Methode für diesen Operator ist.<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, mit der die beiden Ausdrücke "Hintergrund *Farbe*festlegen" und "Hintergrundfarbe festlegen **" erkannt werden können, wobei *Farbe* aus einer Reihe von Farben ausgewählt wird. Verschiedene Typen werden verwendet, um die endgültige Grammatik zu erstellen, z. <xref:System.Speech.Recognition.Choices>b. <xref:System.Speech.Recognition.GrammarBuilder> [Zeichen](https://go.microsoft.com/fwlink/?LinkId=159733)folgen-,-und-Objekte.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the grammar from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder1, System.Speech.Recognition.GrammarBuilder builder2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder1, class System.Speech.Recognition.GrammarBuilder builder2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder1 As GrammarBuilder, builder2 As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder1, System::Speech::Recognition::GrammarBuilder ^ builder2);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder1 + builder2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder1" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="builder2" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="builder1">Das erste Grammatikelement.</param>
        <param name="builder2">Das zweite Grammatikelement.</param>
        <summary>Erstellt einen neuen <see cref="T:System.Speech.Recognition.GrammarBuilder" />, der eine Sequenz aus zwei <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekten enthält.</summary>
        <returns>Gibt einen <see cref="T:System.Speech.Recognition.GrammarBuilder" /> für die Sequenz des <paramref name="builder1" />-Parameters zurück, gefolgt vom Parameter <paramref name="builder2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>unterstützt Konvertierungen aus den folgenden Klassen.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Diese Methode akzeptiert die oben aufgeführten Objekte für den `builder1` - `builder2` Parameter und den-Parameter. Weitere Informationen finden Sie unter <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren.  
  
> [!IMPORTANT]
>  Stellen Sie beim <xref:System.Speech.Recognition.GrammarBuilder> kombinieren von <xref:System.Speech.Recognition.SemanticResultValue> Objekten <xref:System.Speech.Recognition.SemanticResultKey> , die-oder-Instanzen enthalten, sicher, dass Sie keine doppelten semantischen Elemente mit dem gleichen Schlüsselnamen oder mehreren <xref:System.Speech.Recognition.SemanticValue.Value%2A> semantischen Elementen erstellen, die die -Eigenschaft eines <xref:System.Speech.Recognition.SemanticValue> -Objekts. Die Spracherkennung kann eine Ausnahme auslösen, wenn Sie auf diese Umstände stößt.
  
 Die äquivalente Methode für diesen Operator ist.<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (System.Speech.Recognition.GrammarBuilder builder, string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(class System.Speech.Recognition.GrammarBuilder builder, string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.Speech.Recognition.GrammarBuilder,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (builder As GrammarBuilder, phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::Speech::Recognition::GrammarBuilder ^ builder, System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Speech.Recognition.GrammarBuilder * string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="builder + phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="builder">Das erste Grammatikelement.</param>
        <param name="phrase">Das zweite Grammatikelement, das eine Sequenz von Wörtern darstellt.</param>
        <summary>Erstellt ein neues <see cref="T:System.Speech.Recognition.GrammarBuilder" />, das einen <see cref="T:System.Speech.Recognition.GrammarBuilder" /> gefolgt von einem Bergriff enthält.</summary>
        <returns>Gibt einen <see cref="T:System.Speech.Recognition.GrammarBuilder" /> für die Sequenz des <paramref name="builder" />-Parameters zurück, gefolgt vom Parameter <paramref name="phrase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>unterstützt Konvertierungen aus den folgenden Klassen.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Diese Methode akzeptiert die oben aufgeführten Objekte für den `builder` -Parameter. Weitere Informationen finden Sie unter <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren.  
  
 Die äquivalente Methode für diesen Operator ist.<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.Speech.Recognition.GrammarBuilder%2CSystem.String%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Speech.Recognition.GrammarBuilder operator + (string phrase, System.Speech.Recognition.GrammarBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Addition(string phrase, class System.Speech.Recognition.GrammarBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Addition(System.String,System.Speech.Recognition.GrammarBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (phrase As String, builder As GrammarBuilder) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Speech::Recognition::GrammarBuilder ^ operator +(System::String ^ phrase, System::Speech::Recognition::GrammarBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="static member ( + ) : string * System.Speech.Recognition.GrammarBuilder -&gt; System.Speech.Recognition.GrammarBuilder" Usage="phrase + builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
        <Parameter Name="builder" Type="System.Speech.Recognition.GrammarBuilder" />
      </Parameters>
      <Docs>
        <param name="phrase">Das erste Grammatikelement, das eine Sequenz von Wörtern darstellt.</param>
        <param name="builder">Das zweite Grammatikelement.</param>
        <summary>Erstellt ein neues <see cref="T:System.Speech.Recognition.GrammarBuilder" />, das einen Begriff gefolgt von einem <see cref="T:System.Speech.Recognition.GrammarBuilder" /> enthält.</summary>
        <returns>Gibt einen <see cref="T:System.Speech.Recognition.GrammarBuilder" /> für die Sequenz des <paramref name="phrase" />-Parameters zurück, gefolgt vom Parameter <paramref name="builder" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Recognition.GrammarBuilder>unterstützt Konvertierungen aus den folgenden Klassen.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Diese Methode akzeptiert die oben aufgeführten Objekte für den `builder` -Parameter. Weitere Informationen finden Sie unter <xref:System.Speech.Recognition.GrammarBuilder.op_Implicit%2A> Operatoren.  
  
 Die äquivalente Methode für diesen Operator ist.<xref:System.Speech.Recognition.GrammarBuilder.Add%28System.String%2CSystem.Speech.Recognition.GrammarBuilder%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, mit der die beiden Ausdrücke "Hintergrund *Farbe*festlegen" und "Hintergrundfarbe festlegen **" erkannt werden können, wobei *Farbe* aus einer Reihe von Farben ausgewählt wird. Verschiedene Typen werden verwendet, um die endgültige Grammatik zu erstellen, z. <xref:System.Speech.Recognition.Choices>b. <xref:System.Speech.Recognition.GrammarBuilder> [Zeichen](https://go.microsoft.com/fwlink/?LinkId=159733)folgen-,-und-Objekte.  
  
```csharp  
  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] { "red", "green", "blue" });  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase =  
    (GrammarBuilder)"Make background" + colorChoice;  
  GrammarBuilder setPhrase =  
    "Set background to" + (GrammarBuilder)colorChoice;  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] { makePhrase, setPhrase });  
  GrammarBuilder bothPhrases = new GrammarBuilder(bothChoices);  
  
  Grammar grammar = new Grammar(bothPhrases);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.Add(System.Speech.Recognition.Choices,System.Speech.Recognition.GrammarBuilder)" />
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert einen anderen Typ in ein <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der impliziten Konvertierung wird eine neue <xref:System.Speech.Recognition.GrammarBuilder>Instanz von erstellt. Sie können jede der folgenden Klassen in einen <xref:System.Speech.Recognition.GrammarBuilder>umwandeln.  
  
-   <xref:System.Speech.Recognition.Choices>  
  
-   <xref:System.Speech.Recognition.SemanticResultKey>  
  
-   <xref:System.Speech.Recognition.SemanticResultValue>  
  
-   <xref:System.String>  
  
 Jede der impliziten Umwandlungen entspricht dem Aufrufen des Konstruktors.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.Choices choices);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.Choices choices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.Choices)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::Choices ^ choices);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.Choices -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit choices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="choices" Type="System.Speech.Recognition.Choices" />
      </Parameters>
      <Docs>
        <param name="choices">Der Satz zum Alternativen, die konvertiert werden sollen.</param>
        <summary>Konvertiert ein <see cref="T:System.Speech.Recognition.Choices" />-Objekt in ein <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekt.</summary>
        <returns>Das konvertierte <see cref="T:System.Speech.Recognition.Choices" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der impliziten Konvertierung wird eine neue <xref:System.Speech.Recognition.GrammarBuilder>Instanz von erstellt. Dieser Konvertierungs Operator entspricht dem Aufrufen <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> von und `choices` der Angabe `alternateChoices`von für den.  
  
 Die äquivalente Methode für diesen Operator ist.<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.Choices%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, die eine Antwort auf die Frage "yes" oder "No" erkennen kann. Der implizite Konvertierungs Operator wird bei der Erstellung <xref:System.Speech.Recognition.SemanticResultValue> eines-Objekts aus einem <xref:System.Speech.Recognition.Choices> -Objekt, <xref:System.Speech.Recognition.Choices> bei der Erstellung eines-Objekts aus <xref:System.Speech.Recognition.SemanticResultValue> zwei-Objekten und bei der Erstellung <xref:System.Speech.Recognition.Grammar> eines-Objekts aus einer verwendet.<xref:System.Speech.Recognition.SemanticResultKey> -Objekt.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultKey semanticKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultKey semanticKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultKey)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticKey As SemanticResultKey) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultKey ^ semanticKey);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultKey -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticKey" Type="System.Speech.Recognition.SemanticResultKey" />
      </Parameters>
      <Docs>
        <param name="semanticKey">Der zu konvertierende semantische Schlüssel.</param>
        <summary>Konvertiert ein <see cref="T:System.Speech.Recognition.SemanticResultKey" />-Objekt in ein <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekt.</summary>
        <returns>Das konvertierte <see cref="T:System.Speech.Recognition.SemanticResultKey" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der impliziten Konvertierung wird eine neue <xref:System.Speech.Recognition.GrammarBuilder>Instanz von erstellt. Dieser Konvertierungs Operator entspricht dem Aufrufen <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> von und `semanticKey` der Angabe `key`von für den.  
  
 Die äquivalente Methode für diesen Operator ist.<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultKey%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, die eine Antwort auf die Frage "yes" oder "No" erkennen kann. Der implizite Konvertierungs Operator wird bei der Erstellung <xref:System.Speech.Recognition.SemanticResultValue> eines-Objekts aus einem <xref:System.Speech.Recognition.Choices> -Objekt, <xref:System.Speech.Recognition.Choices> bei der Erstellung eines-Objekts aus <xref:System.Speech.Recognition.SemanticResultValue> zwei-Objekten und bei der Erstellung <xref:System.Speech.Recognition.Grammar> eines-Objekts aus einer verwendet.<xref:System.Speech.Recognition.SemanticResultKey> -Objekt.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (System.Speech.Recognition.SemanticResultValue semanticValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(class System.Speech.Recognition.SemanticResultValue semanticValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.Speech.Recognition.SemanticResultValue)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (semanticValue As SemanticResultValue) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::Speech::Recognition::SemanticResultValue ^ semanticValue);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Speech.Recognition.SemanticResultValue -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit semanticValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semanticValue" Type="System.Speech.Recognition.SemanticResultValue" />
      </Parameters>
      <Docs>
        <param name="semanticValue">Das zu konvertierende <see cref="T:System.Speech.Recognition.SemanticResultValue" />-Objekt.</param>
        <summary>Konvertiert ein <see cref="T:System.Speech.Recognition.SemanticResultValue" />-Objekt in ein <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekt.</summary>
        <returns>Das konvertierte <see cref="T:System.Speech.Recognition.SemanticResultValue" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der impliziten Konvertierung wird eine neue <xref:System.Speech.Recognition.GrammarBuilder>Instanz von erstellt. Dieser Konvertierungs Operator entspricht dem Aufrufen <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> von und `semanticValue` der Angabe `value`von für den.  
  
 Die äquivalente Methode für diesen Operator ist.<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.Speech.Recognition.SemanticResultValue%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Beispiel wird eine sprach Erkennungs Grammatik erstellt, die eine Antwort auf die Frage "yes" oder "No" erkennen kann. Der implizite Konvertierungs Operator wird bei der Erstellung <xref:System.Speech.Recognition.SemanticResultValue> eines-Objekts aus einem <xref:System.Speech.Recognition.Choices>-Objekt, <xref:System.Speech.Recognition.Choices> bei der Erstellung eines-Objekts aus <xref:System.Speech.Recognition.SemanticResultValue> zwei-Objekten und bei der Erstellung <xref:System.Speech.Recognition.Grammar> eines-Objekts aus einer verwendet.<xref:System.Speech.Recognition.SemanticResultKey> -Objekt.  
  
```csharp  
Choices yesChoices = new Choices(new string[] {"yes", "yup", "yah"});  
SemanticResultValue yesValue =  
  new SemanticResultValue(yesChoices, true);  
  
Choices noChoices = new Choices(new string[] { "no", "nope", "nah" });  
SemanticResultValue noValue =  
  new SemanticResultValue(noChoices, false);  
  
SemanticResultKey yesnoKey =  
  new SemanticResultKey("yesno", new Choices(new GrammarBuilder[] { yesValue, noValue }));  
  
Grammar yesnoGrammar = new Grammar(yesnoKey);  
yesnoGrammar.Name = "yesno";  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Speech.Recognition.GrammarBuilder (string phrase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Speech.Recognition.GrammarBuilder op_Implicit(string phrase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.GrammarBuilder.op_Implicit(System.String)~System.Speech.Recognition.GrammarBuilder" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (phrase As String) As GrammarBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Speech::Recognition::GrammarBuilder ^(System::String ^ phrase);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Speech.Recognition.GrammarBuilder" Usage="System.Speech.Recognition.GrammarBuilder.op_Implicit phrase" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.GrammarBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="phrase" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="phrase">Die zu konvertierende Zeichenfolge.</param>
        <summary>Konvertiert eine Zeichenfolge in ein <see cref="T:System.Speech.Recognition.GrammarBuilder" />-Objekt.</summary>
        <returns>Die konvertierte Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der impliziten Konvertierung wird eine neue <xref:System.Speech.Recognition.GrammarBuilder>Instanz von erstellt. Dieser Konvertierungs Operator entspricht dem Aufrufen <xref:System.Speech.Recognition.GrammarBuilder.%23ctor%2A> von und der Angabe `phrase`desselben.  
  
 Die äquivalente Methode für diesen Operator ist.<xref:System.Speech.Recognition.GrammarBuilder.%23ctor%28System.String%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Beispiel werden <xref:System.Speech.Recognition.GrammarBuilder> - <xref:System.Speech.Recognition.Choices> und-Objekte verwendet, um eine Grammatik zu erstellen, die einen der beiden Ausdrücke, "Make background *colorchoice*" oder "Set Background on *colorchoice*", erkennen kann.  
  
 Nachdem Sie eine Liste zulässiger Werte für *colorchoice* mithilfe eines <xref:System.Speech.Recognition.Choices> -Objekts erstellt haben, werden im <xref:System.Speech.Recognition.GrammarBuilder> Beispiel zwei `makePhrase` - `setPhrase`Objekte und mithilfe der impliziten Konvertierung von Zeichen folgen Objekten initialisiert.  
  
 Das Beispiel erstellt schließlich ein <xref:System.Speech.Recognition.Grammar> -Objekt aus <xref:System.Speech.Recognition.Choices> einem-Objekt, <xref:System.Speech.Recognition.GrammarBuilder> das in ein-Objekt umgewandelt wird.  
  
```csharp  
private Grammar CreateColorGrammar()  
{  
  
  // Create a set of color choices.  
  Choices colorChoice = new Choices(new string[] {"red", "green", "blue"});  
  GrammarBuilder colorElement = new GrammarBuilder(colorChoice);  
  
  // Create grammar builders for the two versions of the phrase.  
  GrammarBuilder makePhrase = new GrammarBuilder("Make background");  
  makePhrase.Append(colorElement);  
  GrammarBuilder setPhrase = new GrammarBuilder("Set background to");  
  setPhrase.Append(colorElement);  
  
  // Create a Choices for the two alternative phrases, convert the Choices  
  // to a GrammarBuilder, and construct the Grammar object from the result.  
  Choices bothChoices = new Choices(new GrammarBuilder[] {makePhrase, setPhrase});  
  Grammar grammar = new Grammar((GrammarBuilder)bothChoices);  
  grammar.Name = "backgroundColor";  
  return grammar;  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Recognition.GrammarBuilder.#ctor" />
      </Docs>
    </Member>
  </Members>
</Type>
