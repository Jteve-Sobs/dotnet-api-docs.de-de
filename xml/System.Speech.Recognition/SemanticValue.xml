<Type Name="SemanticValue" FullName="System.Speech.Recognition.SemanticValue">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a3512d3f365cea9b23f79251fe18457403d1417a" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70560251" /></Metadata><TypeSignature Language="C#" Value="public sealed class SemanticValue : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;string,System.Speech.Recognition.SemanticValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit SemanticValue extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Recognition.SemanticValue" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SemanticValue&#xA;Implements ICollection(Of KeyValuePair(Of String, SemanticValue)), IDictionary(Of String, SemanticValue), IEnumerable(Of KeyValuePair(Of String, SemanticValue))" />
  <TypeSignature Language="C++ CLI" Value="public ref class SemanticValue sealed : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;, System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type SemanticValue = class&#xA;    interface IDictionary&lt;string, SemanticValue&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;string, SemanticValue&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;string, SemanticValue&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("'{_keyName}'= {Value}  -  Children = {_dictionary.Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Speech.Recognition.SemanticValue/SemanticValueDebugDisplay))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a1600-101">Stellt die semantische Organisation eines erkannten Ausdrucks dar.</span><span class="sxs-lookup"><span data-stu-id="a1600-101">Represents the semantic organization of a recognized phrase.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1600-102"><xref:System.Speech.Recognition.SemanticValue>ist das primäre Objekt, das die Semantik Technologie in System. Speech implementiert.</span><span class="sxs-lookup"><span data-stu-id="a1600-102"><xref:System.Speech.Recognition.SemanticValue> is the primary object that implements the semantic technology in System.Speech.</span></span> <span data-ttu-id="a1600-103">Mithilfe der semantischen Interpretation können Grammatiken Regeln definieren, die von einer Erkennungs-Engine verwendet werden, um Audioeingaben ordnungsgemäß zu interpretieren.</span><span class="sxs-lookup"><span data-stu-id="a1600-103">Semantic interpretation allows grammars to define rules for use by a recognition engine to correctly interpret audio input.</span></span> <span data-ttu-id="a1600-104">Mithilfe der semantischen Interpretation können Erkennungs Module ihre Ergebnisse auch so organisieren, dass Sie leichter verarbeitet werden können, anstatt nur erkannte Wörter und Wörter Sequenzen zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="a1600-104">Semantic interpretation also enables recognition engines to organize their results so that they can be more easily processed, rather than returning only recognized words and sequences of words.</span></span>  
  
 <span data-ttu-id="a1600-105">So müsste z. b. die Erkennungs-Engine-Ausgabe "Hintergrund in Rot ändern" analysiert und von einer Anwendung interpretiert werden, bevor Sie bearbeitet werden kann.</span><span class="sxs-lookup"><span data-stu-id="a1600-105">For example, the recognition engine output "Change background to red" would have to be parsed and interpreted by an application before it could be acted upon.</span></span> <span data-ttu-id="a1600-106">Ein <xref:System.Speech.Recognition.Grammar> -Objekt kann eine semantische Interpretation angeben, um die Verarbeitung klarer zu gestalten, indem angegeben wird, dass der Ausdruck über zwei semantische Unterstrukturen verfügt, eine für die Auswahl von background oder Vordergrund (dargestellt durch den Text "Background") und die andere für die Auswahl Farbe (dargestellt durch den Text "Red").</span><span class="sxs-lookup"><span data-stu-id="a1600-106">A <xref:System.Speech.Recognition.Grammar> object can specify a semantic interpretation to make processing clearer by specifying that the phrase has two semantic substructures, one for selecting background or foreground (represented by the text "background"), and the other for selecting color (represented by the text "red").</span></span>  
  
 <span data-ttu-id="a1600-107">System. Speech stellt die Semantik eines Erkennungs Vorgangs in einer Struktur von <xref:System.Speech.Recognition.SemanticValue> Objekten dar.</span><span class="sxs-lookup"><span data-stu-id="a1600-107">System.Speech represents the semantics of a recognition operation in a tree of <xref:System.Speech.Recognition.SemanticValue> objects.</span></span>  
  
 <span data-ttu-id="a1600-108">Jede <xref:System.Speech.Recognition.SemanticValue> Instanz umfasst Folgendes:</span><span class="sxs-lookup"><span data-stu-id="a1600-108">Each <xref:System.Speech.Recognition.SemanticValue> instance includes the following:</span></span>  
  
-   <span data-ttu-id="a1600-109">Eine <xref:System.Object>, auf die über die <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft zugegriffen wird, die zum <xref:System.Speech.Recognition.SemanticValue>Schlüssel der-Instanz verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="a1600-109">An <xref:System.Object>, accessed by means of the <xref:System.Speech.Recognition.SemanticValue.Value%2A> property, used to key the instance of the <xref:System.Speech.Recognition.SemanticValue>.</span></span>  
  
-   <span data-ttu-id="a1600-110">Ein Measure der Genauigkeit der semantischen Verarbeitung, das von der <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> -Eigenschaft zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="a1600-110">A measure of the accuracy of semantic parsing, returned by the <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> property.</span></span>  
  
-   <span data-ttu-id="a1600-111">Eine Auflistung von Name-Wert-Paaren<xref:System.Collections.Generic.KeyValuePair%602>() von untergeordneten-Objekten, <xref:System.Speech.Recognition.SemanticValue> die ebenfalls-Instanzen sind.</span><span class="sxs-lookup"><span data-stu-id="a1600-111">A collection of name/value pairs (<xref:System.Collections.Generic.KeyValuePair%602>) of child objects, which are also <xref:System.Speech.Recognition.SemanticValue> instances.</span></span> <span data-ttu-id="a1600-112">Auf untergeordnete Knoten kann über <xref:System.Speech.Recognition.SemanticValue> die Implementierung <xref:System.Collections.Generic.IDictionary%602> von zugegriffen werden, indem ein Schlüssel für <xref:System.Speech.Recognition.SemanticValue> die Zeichen folgen Suche und eine-Instanz verwendet wird, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="a1600-112">Child nodes are accessible through the <xref:System.Speech.Recognition.SemanticValue> implementation of <xref:System.Collections.Generic.IDictionary%602> using a string lookup key and a <xref:System.Speech.Recognition.SemanticValue> instance, as in the following example.</span></span>  
  
    ```csharp  
    foreach (KeyValuePair<String, SemanticValue> child in semantics)   
    {  
      Utils.CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
    }  
    ```  
  
 <span data-ttu-id="a1600-113">Erkennungs-Engines, die auf System. Speech basieren, <xref:System.Speech.Recognition.SemanticValue> stellen gültige Instanzen von für alle Ausgaben von der Erkennung bereit, selbst für Ausdrücke ohne explizite Semantik Struktur.</span><span class="sxs-lookup"><span data-stu-id="a1600-113">Recognition engines based on System.Speech provide valid instances of <xref:System.Speech.Recognition.SemanticValue> for all output from recognition, even for phrases with no explicit semantic structure.</span></span>  
  
 <span data-ttu-id="a1600-114">Die <xref:System.Speech.Recognition.SemanticValue> -Instanz für einen Ausdruck wird mithilfe der <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> -Eigenschaft für <xref:System.Speech.Recognition.RecognizedPhrase> das-Objekt abgerufen (oder die- <xref:System.Speech.Recognition.RecognitionResult>Objekte, die davon erben, z. b.).</span><span class="sxs-lookup"><span data-stu-id="a1600-114">The <xref:System.Speech.Recognition.SemanticValue> instance for a phrase is obtained using the <xref:System.Speech.Recognition.RecognizedPhrase.Semantics%2A> property on the <xref:System.Speech.Recognition.RecognizedPhrase> object (or objects that inherit from it, such as <xref:System.Speech.Recognition.RecognitionResult>).</span></span>  
  
 <span data-ttu-id="a1600-115"><xref:System.Speech.Recognition.SemanticValue>Objekte, die für erkannte Ausdrücke ohne semantische Struktur abgerufen werden, sind gekennzeichnet durch:</span><span class="sxs-lookup"><span data-stu-id="a1600-115"><xref:System.Speech.Recognition.SemanticValue> objects obtained for recognized phrases without semantic structure are characterized by:</span></span>  
  
-   <span data-ttu-id="a1600-116">Der Mangel an untergeordneten<xref:System.Speech.Recognition.SemanticValue.Count%2A> Elementen (ist 0).</span><span class="sxs-lookup"><span data-stu-id="a1600-116">The lack of children (<xref:System.Speech.Recognition.SemanticValue.Count%2A> is 0).</span></span>  
  
-   <span data-ttu-id="a1600-117">Die <xref:System.Speech.Recognition.SemanticValue.Value%2A>-Eigenschaft ist `null`.</span><span class="sxs-lookup"><span data-stu-id="a1600-117">The <xref:System.Speech.Recognition.SemanticValue.Value%2A> property is `null`.</span></span>  
  
-   <span data-ttu-id="a1600-118">Ein künstlicher semantischer Vertrauensgrad von 1,0 (zurück <xref:System.Speech.Recognition.SemanticValue.Confidence%2A>gegeben von).</span><span class="sxs-lookup"><span data-stu-id="a1600-118">An artificial semantic confidence level of 1.0 (returned by <xref:System.Speech.Recognition.SemanticValue.Confidence%2A>).</span></span>  
  
 <span data-ttu-id="a1600-119">Normal <xref:System.Speech.Recognition.SemanticValue> erweise erstellen Anwendungen Instanzen indirekt, indem <xref:System.Speech.Recognition.Grammar> Sie Sie Objekten mithilfe <xref:System.Speech.Recognition.SemanticResultValue> von- <xref:System.Speech.Recognition.SemanticResultKey> und-Instanzen in Verbindung <xref:System.Speech.Recognition.Choices> mit <xref:System.Speech.Recognition.GrammarBuilder> -und-Objekten hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="a1600-119">Typically, applications create <xref:System.Speech.Recognition.SemanticValue> instances indirectly, adding them to <xref:System.Speech.Recognition.Grammar> objects by using <xref:System.Speech.Recognition.SemanticResultValue> and <xref:System.Speech.Recognition.SemanticResultKey> instances,  in conjunction with  <xref:System.Speech.Recognition.Choices> and <xref:System.Speech.Recognition.GrammarBuilder> objects.</span></span>  
  
 <span data-ttu-id="a1600-120">Die direkte Erstellung einer <xref:System.Speech.Recognition.SemanticValue> -Instanz ist während der Erstellung stark typisierter Grammatiken nützlich.</span><span class="sxs-lookup"><span data-stu-id="a1600-120">Direct construction of a <xref:System.Speech.Recognition.SemanticValue> instance is useful during the creation of strongly-typed grammars.</span></span>  
  
 <span data-ttu-id="a1600-121"><xref:System.Speech.Recognition.SemanticValue>implementiert die <xref:System.Collections.Generic.IDictionary%602>Schnitt <xref:System.Collections.Generic.ICollection%601>stellen, <xref:System.Collections.Generic.IEnumerable%601> und.</span><span class="sxs-lookup"><span data-stu-id="a1600-121"><xref:System.Speech.Recognition.SemanticValue> implements the <xref:System.Collections.Generic.IDictionary%602>, <xref:System.Collections.Generic.ICollection%601>, and <xref:System.Collections.Generic.IEnumerable%601> interfaces.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1600-122">Das folgende Beispiel zeigt einen Handler für ein <xref:System.Speech.Recognition.Grammar.SpeechRecognized> -Ereignis, das zum Behandeln von Befehlen zum Ändern der Vordergrund-und Hintergrundfarbe entworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="a1600-122">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="a1600-123">Der-Handler identifiziert erkannte Ausdrücke, die keine zugrunde liegende Semantik Struktur <xref:System.Speech.Recognition.SemanticValue.Count%2A> aufweisen, indem Sie <xref:System.Speech.Recognition.SemanticValue.Value%2A> einen `null`von 0 (null) und einen von erkennen</span><span class="sxs-lookup"><span data-stu-id="a1600-123">The handler identifies recognized phrases that have no underlying semantic structure by detecting a <xref:System.Speech.Recognition.SemanticValue.Count%2A> of zero and a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null`.</span></span> <span data-ttu-id="a1600-124">Diese Erkennungs Ausgabe wird dann direkt verarbeitet, indem der Rohtext verarbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="a1600-124">This recognition output is then processed directly by parsing the raw text.</span></span>  
  
 <span data-ttu-id="a1600-125">In anderen Fällen verwendet der Handler Schlüssel zum Abrufen der RGB-Komponenten eines Farbnamens, um zu bestimmen, ob der Befehl den Vordergrund oder den Hintergrund ändert, oder um anzugeben, dass kein gültiger Schlüssel gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="a1600-125">In other cases, the handler uses keys to obtain the RGB components of a color name, to determine whether the command will change the foreground or background, or to indicate that no valid key was found.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        // and search for "background" or "foreground" in the input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
  
      // Make sure that text is readable regardless of the background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Speech.Recognition.SemanticResultValue" />
    <altmember cref="T:System.Speech.Recognition.SemanticResultKey" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a1600-126">Initialisiert eine neue Instanz der <see cref="T:System.Speech.Recognition.SemanticValue" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="a1600-126">Initializes a new instance of the <see cref="T:System.Speech.Recognition.SemanticValue" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1600-127">In der Regel werden Objekte nicht <xref:System.Speech.Recognition.SemanticValue> explizit erstellt, es sei denn, Sie unterstützen die Erstellung stark typisierter Grammatiken.</span><span class="sxs-lookup"><span data-stu-id="a1600-127">Typically, you will not create <xref:System.Speech.Recognition.SemanticValue> objects explicitly, except to support the building of strongly-typed grammars.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemanticValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemanticValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.SemanticValue : obj -&gt; System.Speech.Recognition.SemanticValue" Usage="new System.Speech.Recognition.SemanticValue value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="a1600-128">Die Informationen, die im <see cref="T:System.Speech.Recognition.SemanticValue" />-Objekt gespeichert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="a1600-128">The information to be stored in the <see cref="T:System.Speech.Recognition.SemanticValue" /> object.</span></span></param>
        <summary><span data-ttu-id="a1600-129">Initialisiert eine neue Instanz der <see cref="T:System.Speech.Recognition.SemanticValue" />-Klasse und gibt einen semantischen Wert an.</span><span class="sxs-lookup"><span data-stu-id="a1600-129">Initializes a new instance of the <see cref="T:System.Speech.Recognition.SemanticValue" /> class and specifies a semantic value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1600-130">Es gibt keine Einschränkungen für den Typ von `value` , der gespeichert werden soll.</span><span class="sxs-lookup"><span data-stu-id="a1600-130">There are no restrictions on the type of `value` to be stored.</span></span>  
  
 <span data-ttu-id="a1600-131">Eine Anwendung kann mithilfe `value` der <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft für eine <xref:System.Speech.Recognition.SemanticValue> -Instanz abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="a1600-131">An application can retrieve `value` by using the <xref:System.Speech.Recognition.SemanticValue.Value%2A> property on a <xref:System.Speech.Recognition.SemanticValue> instance.</span></span>  
  
 <span data-ttu-id="a1600-132">Der Wert der <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> -Eigenschaft für die <xref:System.Speech.Recognition.SemanticValue> -Instanz wird auf-1 festgelegt.</span><span class="sxs-lookup"><span data-stu-id="a1600-132">The value of the <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> property for the <xref:System.Speech.Recognition.SemanticValue> instance will be set to -1.</span></span>  
  
 <span data-ttu-id="a1600-133">Auf <xref:System.Speech.Recognition.SemanticValue> einen, der mit dieser Methode erstellt wurde, kann nicht anhand des Schlüssel namens verwiesen werden</span><span class="sxs-lookup"><span data-stu-id="a1600-133">A <xref:System.Speech.Recognition.SemanticValue> constructed with this method cannot be referenced by key name.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemanticValue (string keyName, object value, float confidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string keyName, object value, float32 confidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.#ctor(System.String,System.Object,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keyName As String, value As Object, confidence As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SemanticValue(System::String ^ keyName, System::Object ^ value, float confidence);" />
      <MemberSignature Language="F#" Value="new System.Speech.Recognition.SemanticValue : string * obj * single -&gt; System.Speech.Recognition.SemanticValue" Usage="new System.Speech.Recognition.SemanticValue (keyName, value, confidence)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="confidence" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="keyName"><span data-ttu-id="a1600-134">Ein Schlüssel, der verwendet werden kann, um auf diese <see cref="T:System.Speech.Recognition.SemanticValue" />-Instanz zu verweisen.</span><span class="sxs-lookup"><span data-stu-id="a1600-134">A key that can be used to reference this <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span></span></param>
        <param name="value"><span data-ttu-id="a1600-135">Ein Objekt, das Informationen enthält, die im <see cref="T:System.Speech.Recognition.SemanticValue" />-Objekt gespeichert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="a1600-135">An object containing information to be stored in the <see cref="T:System.Speech.Recognition.SemanticValue" /> object.</span></span></param>
        <param name="confidence"><span data-ttu-id="a1600-136">Ein <see langword="float" />, das eine Schätzung der Sicherheit der semantischen Analyse enthält.</span><span class="sxs-lookup"><span data-stu-id="a1600-136">A <see langword="float" /> containing an estimate of the certainty of semantic analysis.</span></span></param>
        <summary><span data-ttu-id="a1600-137">Initialisiert eine neue Instanz der <see cref="T:System.Speech.Recognition.SemanticValue" />-Klasse und gibt einen semantischen Wert, einen Schlüsselnamen und einen Confidence Level an.</span><span class="sxs-lookup"><span data-stu-id="a1600-137">Initializes a new instance of the <see cref="T:System.Speech.Recognition.SemanticValue" /> class and specifies a semantic value, a key name, and a confidence level.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1600-138">Es gibt keine Einschränkungen für den Typ von `value` , der gespeichert werden soll.</span><span class="sxs-lookup"><span data-stu-id="a1600-138">There are no restrictions on the type of `value` to be stored.</span></span>  
  
 <span data-ttu-id="a1600-139">Eine Anwendung kann mithilfe `value` der <xref:System.Speech.Recognition.SemanticValue.Value%2A> -Eigenschaft für eine <xref:System.Speech.Recognition.SemanticValue> -Instanz abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="a1600-139">An application can retrieve `value` by using the <xref:System.Speech.Recognition.SemanticValue.Value%2A> property on a <xref:System.Speech.Recognition.SemanticValue> instance.</span></span>  
  
 <span data-ttu-id="a1600-140">Der `confidence` -Parameter (der von <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> der-Eigenschaft <xref:System.Speech.Recognition.SemanticValue> für eine-Instanz zurückgegeben wird) sollte zwischen 0,0 und 1,0 liegen.</span><span class="sxs-lookup"><span data-stu-id="a1600-140">The `confidence` parameter (returned by the <xref:System.Speech.Recognition.SemanticValue.Confidence%2A> property on a <xref:System.Speech.Recognition.SemanticValue> instance), should be between 0.0 and 1.0.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Confidence">
      <MemberSignature Language="C#" Value="public float Confidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 Confidence" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Confidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Confidence As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float Confidence { float get(); };" />
      <MemberSignature Language="F#" Value="member this.Confidence : single" Usage="System.Speech.Recognition.SemanticValue.Confidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1600-141">Gibt ein relatives Maß der Sicherheit hinsichtlich der Korrektheit der semantischen Analyse zurück, die die aktuelle Instanz von <see cref="T:System.Speech.Recognition.SemanticValue" /> zurückgegeben hat.</span><span class="sxs-lookup"><span data-stu-id="a1600-141">Returns a relative measure of the certainty as to the correctness of the semantic parsing that returned the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></summary>
        <value><span data-ttu-id="a1600-142">Gibt <see langword="float" /> zurück, das das relative Maß der Sicherheit der semantischen Analyse ist, die die aktuelle Instanz von <see cref="T:System.Speech.Recognition.SemanticValue" /> zurückgegeben hat.</span><span class="sxs-lookup"><span data-stu-id="a1600-142">Returns a <see langword="float" /> that is a relative measure of the certainty of semantic parsing that returned the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1600-143">Die <xref:System.Speech.Recognition.SemanticValue.Confidence%2A?displayProperty=nameWithType> -Eigenschaft, die ein Measure der Richtigkeit der semantischen Verarbeitung zurückgibt, sollte nicht mit der <xref:System.Speech.Recognition.RecognizedPhrase.Confidence%2A?displayProperty=nameWithType> -Eigenschaft verwechselt werden, die ein Measure der Genauigkeit der Spracherkennung zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="a1600-143">The <xref:System.Speech.Recognition.SemanticValue.Confidence%2A?displayProperty=nameWithType> property, which returns a measure of the correctness of semantic parsing, should not be confused with the <xref:System.Speech.Recognition.RecognizedPhrase.Confidence%2A?displayProperty=nameWithType> property, which returns a measure of the accuracy of speech recognition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1600-144">Das folgende Beispiel wird verwendet, um Informationen (einschließlich des Konfidenz) <xref:System.Windows.Forms.TreeNodeCollection>rekursiv zu durchlaufen, oder als die Knoten, die die Struktur der Semantik bilden, die zum Erkennen eines Ausdrucks verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="a1600-144">The following example is used to recursively traverse and then display information (including confidence) as a <xref:System.Windows.Forms.TreeNodeCollection>, or as the nodes making up the tree structure of the semantics used to recognize a phrase.</span></span>  
  
```csharp  
internal static void CreateSemanticsTreeNodes(  
        TreeNodeCollection nodes,  
        SemanticValue semantics,  
        String name)   
{  
  string semanticsText =   
      String.Format("  {0}  (Confidence {1})", name,semantics.Confidence);  
  
  // Format integers as hexadecimal.  
  if (semantics.Value == null )  
  {  
    semanticsText = semanticsText + " = null";  
  }  
  else if (semantics.Value.GetType() == typeof(int))   
  {  
    semanticsText = String.Format("{0} = {1:X} ", semanticsText, semantics.Value);  
  }   
  else   
  {  
    semanticsText = semanticsText + " = " + semantics.Value.ToString();  
  }  
  
  TreeNode semanticsNode = new TreeNode(semanticsText);  
  foreach (KeyValuePair<String, SemanticValue> child in semantics)   
  {  
    CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
  }  
  nodes.Add(semanticsNode);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As KeyValuePair(Of String, SemanticValue)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : System.Collections.Generic.KeyValuePair&lt;string, System.Speech.Recognition.SemanticValue&gt; -&gt; bool&#xA;override this.Contains : System.Collections.Generic.KeyValuePair&lt;string, System.Speech.Recognition.SemanticValue&gt; -&gt; bool" Usage="semanticValue.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="a1600-145">Eine Instanz von <see cref="T:System.Collections.Generic.KeyValuePair`2" />, die für einen angegebenen Wert einer Schlüsselzeichenfolge und der <see cref="T:System.Speech.Recognition.SemanticValue" />-Instanz instanziiert wird.</span><span class="sxs-lookup"><span data-stu-id="a1600-145">An instance of <see cref="T:System.Collections.Generic.KeyValuePair`2" /> instantiated for a given value of a key string and a <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span></span></param>
        <summary><span data-ttu-id="a1600-146">Gibt an, ob die aktuelle <see cref="T:System.Speech.Recognition.SemanticValue" />-Instanzauflistung einen bestimmten Schlüssel und eine bestimmte Instanz von <see cref="T:System.Speech.Recognition.SemanticValue" /> enthält, die als Schlüssel-Wert-Paar ausgedrückt werden.</span><span class="sxs-lookup"><span data-stu-id="a1600-146">Indicates whether the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance collection contains a specific key and a specific instance of <see cref="T:System.Speech.Recognition.SemanticValue" /> expressed as a key/value pair.</span></span></summary>
        <returns><span data-ttu-id="a1600-147">Gibt <see langword="bool" /> zurück, das <see langword="true" /> ist, wenn der aktuelle <see cref="T:System.Speech.Recognition.SemanticValue" /> eine Instanz von <c>KeyValuePair&lt;String, SemanticValue&gt;</c> für einen angegebenen Wert der Schlüsselzeichenfolge und des <see cref="T:System.Speech.Recognition.SemanticValue" /> enthält.</span><span class="sxs-lookup"><span data-stu-id="a1600-147">Returns a <see langword="bool" /> which is <see langword="true" /> if the current <see cref="T:System.Speech.Recognition.SemanticValue" /> contains an instance of <c>KeyValuePair&lt;String, SemanticValue&gt;</c> for a specified value of the key string and the <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span> <span data-ttu-id="a1600-148">Andernfalls wird <see langword="false" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a1600-148">Otherwise, <see langword="false" /> is returned.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.ContainsKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::String ^ key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : string -&gt; bool&#xA;override this.ContainsKey : string -&gt; bool" Usage="semanticValue.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a1600-149">Die <see cref="T:System.String" />, welche die Schlüsselzeichenfolge enthält, die zur Identifizierung einer untergeordneten Instanz von <see cref="T:System.Speech.Recognition.SemanticValue" /> verwendet wird unter der aktuellen <see cref="T:System.Speech.Recognition.SemanticValue" />.</span><span class="sxs-lookup"><span data-stu-id="a1600-149"><see cref="T:System.String" /> containing the key string used to identify a child instance of <see cref="T:System.Speech.Recognition.SemanticValue" /> under the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></param>
        <summary><span data-ttu-id="a1600-150">Gibt an, ob die aktuelle <see cref="T:System.Speech.Recognition.SemanticValue" />-Instanzauflistung eine untergeordnete <see cref="T:System.Speech.Recognition.SemanticValue" />-Instanz mit einer angegebenen Schlüsselzeichenfolge enthält.</span><span class="sxs-lookup"><span data-stu-id="a1600-150">Indicates whether the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance collection contains a child <see cref="T:System.Speech.Recognition.SemanticValue" /> instance with a given key string.</span></span></summary>
        <returns><span data-ttu-id="a1600-151">Gibt <see langword="bool" />, <see langword="true" /> zurück, wenn eine untergeordnete Instanz <see cref="T:System.Speech.Recognition.SemanticValue" />, die mit der Zeichenfolge <paramref name="key" /> markiert wird, gefunden wird. Wenn nicht, wird <see langword="false" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="a1600-151">Returns a <see langword="bool" />, <see langword="true" /> if a child instance <see cref="T:System.Speech.Recognition.SemanticValue" /> tagged with the string <paramref name="key" /> is found, <see langword="false" /> if not.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1600-152">Sie können zur Laufzeit nur auf Daten nach Schlüsselwert zugreifen, z. b *. um Semantic ["MyKey"] zu überprüfen. , Und*Hierdurch wird eine Ausnahme generiert.</span><span class="sxs-lookup"><span data-stu-id="a1600-152">You can only access data by key value at runtime, for example to check *semantic["myKey"].Value*, and this generates an exception.</span></span> <span data-ttu-id="a1600-153">Es wird empfohlen, dass Sie das- <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> Objekt mit <xref:System.Speech.Recognition.SemanticValue.Item%2A> Abfragen, bevor Sie mit <xref:System.Speech.Recognition.SemanticValue>einer bestimmten Instanz von verwenden.</span><span class="sxs-lookup"><span data-stu-id="a1600-153">We recommend that you query the object with <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> before using <xref:System.Speech.Recognition.SemanticValue.Item%2A> with a given instance of <xref:System.Speech.Recognition.SemanticValue>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1600-154">Das folgende Beispiel zeigt einen Handler für ein <xref:System.Speech.Recognition.Grammar.SpeechRecognized> -Ereignis, das zum Behandeln von Befehlen zum Ändern der Vordergrund-und Hintergrundfarbe entworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="a1600-154">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="a1600-155">Nach der Verarbeitung von Ausdrücken, die erkannt werden, aber keine semantische Struktur aufweisen, prüft der Handler, ob <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> geeignete`applyChgToBackground`Schlüssel `colorRGBValueList`mit ( `colorStringList)`, oder) vorhanden sind, und verarbeitet dann die semantisch organisierten Daten.</span><span class="sxs-lookup"><span data-stu-id="a1600-155">After handling phrases that are recognized but have no semantic structure, the handler checks for the presence of appropriate keys using <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`, `colorRGBValueList`, or `colorStringList)`,  and then processes the semantically organized data.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        // searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Speech.Recognition.SemanticValue.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1600-156">Gibt die Anzahl der untergeordneten <see cref="T:System.Speech.Recognition.SemanticValue" />-Objekte unter der aktuellen <see cref="T:System.Speech.Recognition.SemanticValue" />-Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="a1600-156">Returns the number of child <see cref="T:System.Speech.Recognition.SemanticValue" /> objects under the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span></span></summary>
        <value><span data-ttu-id="a1600-157">Die Anzahl der <see cref="T:System.Speech.Recognition.SemanticValue" />-Objekte, die dem aktuellen <see cref="T:System.Speech.Recognition.SemanticValue" /> untergeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="a1600-157">The number of child <see cref="T:System.Speech.Recognition.SemanticValue" /> objects under the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1600-158">Erkennungsergebnisse, die die semantische Verarbeitung nicht verwenden, haben <xref:System.Speech.Recognition.SemanticValue.Count%2A> immer den Wert 0 (null) und einen <xref:System.Speech.Recognition.SemanticValue.Value%2A> von `null`.</span><span class="sxs-lookup"><span data-stu-id="a1600-158">Recognition results that do not make use of semantic parsing always have a <xref:System.Speech.Recognition.SemanticValue.Count%2A> value of zero, as well as a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1600-159">Das folgende Beispiel zeigt einen Handler für ein <xref:System.Speech.Recognition.Grammar.SpeechRecognized> -Ereignis, das zum Behandeln von Befehlen zum Ändern der Vordergrund-und Hintergrundfarbe entworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="a1600-159">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="a1600-160">Der-Handler identifiziert erkannte Ausdrücke, die keine zugrunde liegende Semantik Struktur <xref:System.Speech.Recognition.SemanticValue.Count%2A> aufweisen, indem Sie <xref:System.Speech.Recognition.SemanticValue.Value%2A> einen `null`von 0 (null) und einen von erkennen</span><span class="sxs-lookup"><span data-stu-id="a1600-160">The handler identifies recognized phrases that have no underlying semantic structure by detecting a <xref:System.Speech.Recognition.SemanticValue.Count%2A> of zero and a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null`.</span></span> <span data-ttu-id="a1600-161">Diese Erkennungs Ausgabe wird dann direkt verarbeitet, indem der Rohtext verarbeitet wird.</span><span class="sxs-lookup"><span data-stu-id="a1600-161">This recognition output is then processed directly by parsing the raw text.</span></span>  
  
 <span data-ttu-id="a1600-162">In anderen Fällen verwendet der Handler Schlüssel zum Abrufen der RGB-Komponenten eines Farbnamens, um zu bestimmen, ob der Befehl den Vordergrund oder den Hintergrund ändert, oder um anzugeben, dass kein gültiger Schlüssel gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="a1600-162">In other cases, the handler uses keys to obtain the RGB components of a color name, to determine whether the command will change the foreground or background, or to indicate that no valid key was found.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        //  searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantics keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of Foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="semanticValue.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="a1600-163">Das auszuwertende Objekt.</span><span class="sxs-lookup"><span data-stu-id="a1600-163">The object to evaluate.</span></span></param>
        <summary><span data-ttu-id="a1600-164">Bestimmt, ob ein angegebenes Objekt eine Instanz von <c>SemanticValue</c> und gleich der aktuellen Instanz von <c>SemanticValue</c> ist.</span><span class="sxs-lookup"><span data-stu-id="a1600-164">Determines whether a specified object is an instance of <c>SemanticValue</c> and equal to the current instance of <c>SemanticValue</c>.</span></span></summary>
        <returns><span data-ttu-id="a1600-165"><see langword="true" />, wenn das angegebene Objekt und das aktuelle Objekt gleich sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a1600-165"><see langword="true" /> if the specified Object is equal to the current Object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="semanticValue.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a1600-166">Stellt einen Hashcode für ein <c>SemanticValue</c>-Objekt bereit.</span><span class="sxs-lookup"><span data-stu-id="a1600-166">Provides a hash code for a <c>SemanticValue</c> object.</span></span></summary>
        <returns><span data-ttu-id="a1600-167">Ein Hashcode für das aktuelle <see cref="T:System.Speech.Recognition.SemanticValue" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="a1600-167">A hash code for the current <see cref="T:System.Speech.Recognition.SemanticValue" /> object.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Speech.Recognition.SemanticValue this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Speech.Recognition.SemanticValue Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As String) As SemanticValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Speech::Recognition::SemanticValue ^ default[System::String ^] { System::Speech::Recognition::SemanticValue ^ get(System::String ^ key); void set(System::String ^ key, System::Speech::Recognition::SemanticValue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Speech.Recognition.SemanticValue with get, set" Usage="System.Speech.Recognition.SemanticValue.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Speech.Recognition.SemanticValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a1600-168">Ein Schlüssel für einen <see langword="KeyValuePair&lt;String, SemanticValue&gt;" />-Wert, der in der aktuellen Instanz von <see cref="T:System.Speech.Recognition.SemanticValue" /> enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="a1600-168">A key for a <see langword="KeyValuePair&lt;String, SemanticValue&gt;" /> contained in the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></param>
        <summary><span data-ttu-id="a1600-169">Gibt untergeordnete <see cref="T:System.Speech.Recognition.SemanticValue" />-Instanzen zurück, die zu dem aktuellen Element <see cref="T:System.Speech.Recognition.SemanticValue" /> gehören.</span><span class="sxs-lookup"><span data-stu-id="a1600-169">Returns child <see cref="T:System.Speech.Recognition.SemanticValue" /> instances that  belong to the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></summary>
        <value><span data-ttu-id="a1600-170">Gibt ein untergeordnetes Element des <see cref="T:System.Speech.Recognition.SemanticValue" /> aktuellen zurück, das als Teil eines Schlüssel-Wert-Paars indiziert werden kann: <c>KeyValuePair&lt;String,</c><c>&gt;SemanticValue</c>.</span><span class="sxs-lookup"><span data-stu-id="a1600-170">Returns a child of the current <see cref="T:System.Speech.Recognition.SemanticValue" /> that can be indexed as part of a key value pair: <c>KeyValuePair&lt;String,</c><c>SemanticValue&gt;</c>.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1600-171">Der <xref:System.Speech.Recognition.SemanticValue.Item%2A> ist schreibgeschützt und generiert Ausnahmen, wenn Elemente geändert werden.</span><span class="sxs-lookup"><span data-stu-id="a1600-171">The <xref:System.Speech.Recognition.SemanticValue.Item%2A> is read-only and generates exceptions if members are modified.</span></span>  
  
 <span data-ttu-id="a1600-172">Sie können nur zur Laufzeit und nicht zur Kompilierzeit auf die Daten zugreifen, z. b. zur Überprüfung `semantic["myKey"].Value`.</span><span class="sxs-lookup"><span data-stu-id="a1600-172">You can only access data by key value at run-time, not at compile-time, for example to check `semantic["myKey"].Value`.</span></span> <span data-ttu-id="a1600-173">Wenn Sie einen Schlüssel angeben, der nicht vorhanden ist, wird eine Ausnahme generiert.</span><span class="sxs-lookup"><span data-stu-id="a1600-173">Specifying a key that is not present generates an exception.</span></span>  
  
 <span data-ttu-id="a1600-174">Um das vorhanden sein eines bestimmten Schlüssels zu erkennen, verwenden <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> Sie die- <xref:System.Speech.Recognition.SemanticValue> Eigenschaft für eine-Instanz.</span><span class="sxs-lookup"><span data-stu-id="a1600-174">To detect the presence of a given key, use the <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> property on an <xref:System.Speech.Recognition.SemanticValue> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1600-175">Das folgende Beispiel zeigt einen Handler für ein <xref:System.Speech.Recognition.Grammar.SpeechRecognized> -Ereignis, das zum Behandeln von Befehlen zum Ändern der Vordergrund-und Hintergrundfarbe entworfen wurde.</span><span class="sxs-lookup"><span data-stu-id="a1600-175">The following example shows a handler for a <xref:System.Speech.Recognition.Grammar.SpeechRecognized> event designed to handle commands to change foreground and background color.</span></span>  
  
 <span data-ttu-id="a1600-176">Nachdem Sie erkannte Ausdrücke verarbeitet haben, die keine semantische Struktur aufweisen, prüft der Handler, ob geeignete <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> Schlüssel`applyChgToBackground`vorhanden `colorRGBValueList`sind. `colorStringList)`dabei wird (, oder <xref:System.Speech.Recognition.SemanticValue.Item%2A> ) verwendet, und anschließend wird die-Eigenschaft verwendet, um die Knoten abzurufen. mit den erforderlichen Informationen.</span><span class="sxs-lookup"><span data-stu-id="a1600-176">After handling recognized phrases that have no semantic structure, the handler checks for the presence of appropriate keys using <xref:System.Speech.Recognition.SemanticValue.ContainsKey%2A> (`applyChgToBackground`, `colorRGBValueList`, or `colorStringList)`, and then uses the <xref:System.Speech.Recognition.SemanticValue.Item%2A> property to obtain the nodes with needed information.</span></span>  
  
 <span data-ttu-id="a1600-177">Die Verwendung von <xref:System.Speech.Recognition.SemanticValue.Item%2A> wird unten hervorgehoben.</span><span class="sxs-lookup"><span data-stu-id="a1600-177">The use of <xref:System.Speech.Recognition.SemanticValue.Item%2A> is highlighted below.</span></span>  
  
```csharp  
  
newGrammar.SpeechRecognized +=  
  delegate(object sender, SpeechRecognizedEventArgs eventArgs)   
  {  
  
    // Retrieve the value of the semantic property.  
    bool changeBackGround = true;  
    string errorString = "";  
    SemanticValue semantics = eventArgs.Result.Semantics;  
  
    Color newColor = Color.Empty;  
  
    try   
    {  
      if (semantics.Count == 0 && semantics.Value==null)  
      {  
        // Signifies recognition by a grammar with no semantics.  
        // Parse the string, assuming that the last word is color,  
        //  searching for background or foreground in input.  
        if (eventArgs.Result.Text.Contains("foreground"))   
        {  
          changeBackGround = false;  
        }  
        string cName = eventArgs.Result.Words[eventArgs.Result.Words.Count - 1].Text;  
        newColor = Color.FromName(cName);  
  
      }  
      else if (semantics.ContainsKey("colorStringList") ^ semantics.ContainsKey("colorRGBValueList"))   
      {  
  
        // Determine whether to change background or foreground.  
        if (semantics.ContainsKey("applyChgToBackground"))   
        {  
          changeBackGround = semantics["applyChgToBackground"].Value is bool;  
        }  
  
        // Get the RGB color value.  
        if (semantics.ContainsKey("colorStringList"))   
        {  
          newColor = Color.FromName((string)semantics["colorStringList"].Value);  
        }  
        if (semantics.ContainsKey("colorRGBValueList"))   
        {  
          newColor = System.Drawing.Color.FromArgb((int)semantics["colorRGBValueList"].Value);  
        }  
      }  
      else   
      {  
  
        // Throw an exception if the semantics do not contain the keys we  
        // support.  
        throw(new Exception("Unsupported semantic keys found."));  
      }  
    }  
  
    catch (Exception exp)   
    {  
      MessageBox.Show(String.Format("Unable to process color semantics.:\n{0}\n", exp.Message));  
      return;  
    }  
  
    // Change colors, either foreground or background.  
    if (changeBackGround)   
    {  
      BackColor = newColor;  
      float Bright = BackColor.GetBrightness();  
      float Hue = BackColor.GetHue();  
      float Sat = BackColor.GetSaturation();  
      // Make sure that text is readable regardless of background.  
      if (BackColor.GetBrightness() <= .50)   
      {  
        ForeColor = Color.White;  
      }  
      else   
      {  
        ForeColor = Color.Black;  
      }  
    }  
    else   
    {  
      ForeColor = newColor;  
      float Bright = ForeColor.GetBrightness();  
      float Hue = ForeColor.GetHue();  
      float Sat = ForeColor.GetSaturation();  
  
      // Make sure that text is readable regardless of the foreground.  
      if (ForeColor.GetBrightness() <= .50)   
      {  
        BackColor = Color.White;  
      }  
      else   
      {  
        BackColor = Color.Black;  
      }  
    }  
    return;  
  };  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException"><span data-ttu-id="a1600-178">Wird ausgelöst, wenn kein untergeordneter Member der aktuellen Instanz von <see cref="T:System.Speech.Recognition.SemanticValue" /> über den Schlüssel verfügt, der dem <paramref name="key" />-Parameter entspricht.</span><span class="sxs-lookup"><span data-stu-id="a1600-178">Thrown if no child member of the current instance of <see cref="T:System.Speech.Recognition.SemanticValue" /> has the key matching the <paramref name="key" /> parameter.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a1600-179">Wird ausgelöst, wenn Code versucht, <see cref="T:System.Speech.Recognition.SemanticValue" /> an einem angegebenen Index zu ändern.</span><span class="sxs-lookup"><span data-stu-id="a1600-179">Thrown if code attempts to change the <see cref="T:System.Speech.Recognition.SemanticValue" /> at a given index.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As KeyValuePair(Of String, SemanticValue)) Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; key) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a1600-180">Ein Schlüssel für einen <see cref="T:System.Speech.Recognition.SemanticValue" />.</span><span class="sxs-lookup"><span data-stu-id="a1600-180">A key for a <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></param>
        <summary><span data-ttu-id="a1600-181">Fügt der Auflistung den angegebenen Schlüssel und <see cref="T:System.Speech.Recognition.SemanticValue" /> hinzu.</span><span class="sxs-lookup"><span data-stu-id="a1600-181">Adds the specified key and <see cref="T:System.Speech.Recognition.SemanticValue" /> to the collection.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Clear() = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a1600-182">Entfernt alle Schlüssel-Wert-Paare aus der Auflistung.</span><span class="sxs-lookup"><span data-stu-id="a1600-182">Removes all key/value pairs from the collection.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of String, SemanticValue)(), index As Integer) Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt; ^ array, int index) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a1600-183">Das Array von Schlüssel-Wert-Paaren, das das Ziel des Vorgangs ist.</span><span class="sxs-lookup"><span data-stu-id="a1600-183">The array of key/value pairs that is the target of the operation.</span></span></param>
        <param name="index"><span data-ttu-id="a1600-184">Eine ganze Zahl, die die Position im Array angibt, an die das Schlüssel-Wert-Paar kopiert wird.</span><span class="sxs-lookup"><span data-stu-id="a1600-184">An integer that specifies the location in the array to which the key/value pair will be copied.</span></span></param>
        <summary><span data-ttu-id="a1600-185">Kopiert ein Schlüssel-Wert-Paar an eine bestimmte Position in einem Zielarray.</span><span class="sxs-lookup"><span data-stu-id="a1600-185">Copies a key/value pair to a specific location in a targeted array.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String,System::Speech::Recognition::SemanticValue&gt;&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1600-186">Ruft einen Wert ab, der angibt, ob die Auflistung schreibgeschützt ist.</span><span class="sxs-lookup"><span data-stu-id="a1600-186">Gets a value that indicates whether the collection is read-only.</span></span></summary>
        <value><span data-ttu-id="a1600-187">Gibt einen Wert zurück, der angibt, ob die Auflistung schreibgeschützt ist.</span><span class="sxs-lookup"><span data-stu-id="a1600-187">Returns a value that indicates whether the collection is read-only.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt; key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{System.String,System.Speech.Recognition.SemanticValue})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As KeyValuePair(Of String, SemanticValue)) As Boolean Implements ICollection(Of KeyValuePair(Of String, SemanticValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt; key) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a1600-188">Ein Schlüssel für einen <see cref="T:System.Speech.Recognition.SemanticValue" />.</span><span class="sxs-lookup"><span data-stu-id="a1600-188">A key for a <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></param>
        <summary><span data-ttu-id="a1600-189">Entfernt den angegebenen Schlüssel und <see cref="T:System.Speech.Recognition.SemanticValue" /> aus der Auflistung.</span><span class="sxs-lookup"><span data-stu-id="a1600-189">Removes the specified key and <see cref="T:System.Speech.Recognition.SemanticValue" /> from the collection.</span></span></summary>
        <returns><span data-ttu-id="a1600-190"><see langword="true" />, wenn das Schlüssel-Wert-Paar erfolgreich aus der Collection entfernt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a1600-190"><see langword="true" /> if the key/value pair was successfully removed from the collection; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="a1600-191">Diese Methode gibt auch <see langword="false" /> zurück, wenn das Schlüssel-Werte-Paar nicht in der Auflistung vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a1600-191">This method also returns <see langword="false" /> if the key/value pair is not found in the collection.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add">
      <MemberSignature Language="C#" Value="void IDictionary&lt;string,SemanticValue&gt;.Add (string key, System.Speech.Recognition.SemanticValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add(string key, class System.Speech.Recognition.SemanticValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Add(System.String,System.Speech.Recognition.SemanticValue)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As String, value As SemanticValue) Implements IDictionary(Of String, SemanticValue).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Add(System::String ^ key, System::Speech::Recognition::SemanticValue ^ value) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticValue" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a1600-192">Ein Schlüssel für einen <see cref="T:System.Speech.Recognition.SemanticValue" />.</span><span class="sxs-lookup"><span data-stu-id="a1600-192">A key for a <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></param>
        <param name="value"><span data-ttu-id="a1600-193">Das hinzuzufügende <see cref="T:System.Speech.Recognition.SemanticValue" />.</span><span class="sxs-lookup"><span data-stu-id="a1600-193">The <see cref="T:System.Speech.Recognition.SemanticValue" /> to add.</span></span></param>
        <summary><span data-ttu-id="a1600-194">Fügt dem Wörterbuch den angegebenen Schlüssel und <see cref="T:System.Speech.Recognition.SemanticValue" /> hinzu.</span><span class="sxs-lookup"><span data-stu-id="a1600-194">Adds the specified key and <see cref="T:System.Speech.Recognition.SemanticValue" /> to the dictionary.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;string&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of String) Implements IDictionary(Of String, SemanticValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ System::Collections::Generic::IDictionary&lt;System::String,System::Speech::Recognition::SemanticValue&gt;::Keys { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1600-195">Gibt eine Auflistung ab, die die Schlüssel von einem Wörterbuch von Schlüssel-Wert-Paaren enthält.</span><span class="sxs-lookup"><span data-stu-id="a1600-195">Gets a collection that contains the keys from a dictionary of key/value pairs.</span></span></summary>
        <value><span data-ttu-id="a1600-196">Eine Auflistung, die die Schlüssel aus einem Wörterbuch von Schlüssel-Wert-Paaren enthält.</span><span class="sxs-lookup"><span data-stu-id="a1600-196">A collection that contains the keys from a dictionary of key/value pairs.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;string,SemanticValue&gt;.Remove (string key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (key As String) As Boolean Implements IDictionary(Of String, SemanticValue).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Remove(System::String ^ key) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a1600-197">Ein Schlüssel für einen <see cref="T:System.Speech.Recognition.SemanticValue" />.</span><span class="sxs-lookup"><span data-stu-id="a1600-197">A key for a <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></param>
        <summary><span data-ttu-id="a1600-198">Entfernt den angegebenen Schlüssel und <see cref="T:System.Speech.Recognition.SemanticValue" /> aus dem Wörterbuch.</span><span class="sxs-lookup"><span data-stu-id="a1600-198">Removes the specified key and <see cref="T:System.Speech.Recognition.SemanticValue" /> from the dictionary.</span></span></summary>
        <returns><span data-ttu-id="a1600-199"><see langword="true" />, wenn das Schlüssel-Wert-Paar erfolgreich aus dem Wörterbuch entfernt wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a1600-199"><see langword="true" /> if the key/value pair was successfully removed from the dictionary; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="a1600-200">Diese Methode gibt auch dann <see langword="false" /> zurück, wenn das Schlüssel/Wert-Paar nicht im Wörterbuch gefunden wurde.</span><span class="sxs-lookup"><span data-stu-id="a1600-200">This method also returns <see langword="false" /> if the key/value pair is not found in the dictionary.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue">
      <MemberSignature Language="C#" Value="bool IDictionary&lt;string,SemanticValue&gt;.TryGetValue (string key, out System.Speech.Recognition.SemanticValue value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue(string key, [out] class System.Speech.Recognition.SemanticValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#TryGetValue(System.String,System.Speech.Recognition.SemanticValue@)" />
      <MemberSignature Language="VB.NET" Value="Function TryGetValue (key As String, ByRef value As SemanticValue) As Boolean Implements IDictionary(Of String, SemanticValue).TryGetValue" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.TryGetValue(System::String ^ key, [Runtime::InteropServices::Out] System::Speech::Recognition::SemanticValue ^ % value) = System::Collections::Generic::IDictionary&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;::TryGetValue;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Speech.Recognition.SemanticValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key"><span data-ttu-id="a1600-201">Ein Schlüssel für einen <see cref="T:System.Speech.Recognition.SemanticValue" />.</span><span class="sxs-lookup"><span data-stu-id="a1600-201">A key for a <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></param>
        <param name="value"><span data-ttu-id="a1600-202">Der <see cref="T:System.Speech.Recognition.SemanticValue" />, der abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="a1600-202">The <see cref="T:System.Speech.Recognition.SemanticValue" /> to get.</span></span></param>
        <summary><span data-ttu-id="a1600-203">Ruft den <see cref="T:System.Speech.Recognition.SemanticValue" />-Wert ab, der dem angegebenen Schlüssel zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="a1600-203">Gets the <see cref="T:System.Speech.Recognition.SemanticValue" /> associated with the specified key.</span></span></summary>
        <returns><span data-ttu-id="a1600-204"><see langword="true" />, wenn das Wörterbuch ein Schlüssel-Wert-Paar mit dem angegebenen Schlüssel enthält, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a1600-204"><see langword="true" /> if the dictionary contains a key/value pair with the specified key; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;System.Speech.Recognition.SemanticValue&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.Speech.Recognition.SemanticValue&gt; System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IDictionary&lt;System#String,System#Speech#Recognition#SemanticValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of SemanticValue) Implements IDictionary(Of String, SemanticValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;System::Speech::Recognition::SemanticValue ^&gt; ^ System::Collections::Generic::IDictionary&lt;System::String,System::Speech::Recognition::SemanticValue&gt;::Values { System::Collections::Generic::ICollection&lt;System::Speech::Recognition::SemanticValue ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;System.String,System.Speech.Recognition.SemanticValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Speech.Recognition.SemanticValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1600-205">Ruft eine Auflistung ab, die die Werte von einem Wörterbuch von Schlüssel-Wert-Paaren enthält.</span><span class="sxs-lookup"><span data-stu-id="a1600-205">Gets a collection that contains the values from a dictionary of key/value pairs.</span></span></summary>
        <value><span data-ttu-id="a1600-206">Eine Auflistung, die die Werte aus einem Wörterbuch von Schlüssel-Wert-Paaren enthält.</span><span class="sxs-lookup"><span data-stu-id="a1600-206">A collection that contains the values from a dictionary of key/value pairs.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,System.Speech.Recognition.SemanticValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,SemanticValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Speech.Recognition.SemanticValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Speech#Recognition#SemanticValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, SemanticValue)) Implements IEnumerable(Of KeyValuePair(Of String, SemanticValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Speech::Recognition::SemanticValue ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Speech.Recognition.SemanticValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a1600-207">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</span><span class="sxs-lookup"><span data-stu-id="a1600-207">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="a1600-208">Ein Enumerator, der eine Auflistung durchläuft.</span><span class="sxs-lookup"><span data-stu-id="a1600-208">An enumerator that iterates through a collection.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Recognition.SemanticValue.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a1600-209">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</span><span class="sxs-lookup"><span data-stu-id="a1600-209">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="a1600-210">Gibt einen Enumerator zurück, der eine Auflistung durchläuft.</span><span class="sxs-lookup"><span data-stu-id="a1600-210">Returns an enumerator that iterates through a collection.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Recognition.SemanticValue.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Speech.Recognition.SemanticValue.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a1600-211">Eine schreibgeschützte Eigenschaft, die die Informationen zurückgibt, die in der aktuellen <see cref="T:System.Speech.Recognition.SemanticValue" /> enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="a1600-211">A read-only property that returns the information contained in the current <see cref="T:System.Speech.Recognition.SemanticValue" />.</span></span></summary>
        <value><span data-ttu-id="a1600-212">Gibt eine <see cref="T:System.Object" />-Instanz zurück, die die Informationen enthält, die in der aktuellen <see cref="T:System.Speech.Recognition.SemanticValue" />-Instanz gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="a1600-212">Returns an <see cref="T:System.Object" /> instance containing the information stored in the current <see cref="T:System.Speech.Recognition.SemanticValue" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a1600-213">Erkennungsergebnisse, für die die semantische Verarbeitung nicht verwendet wird, haben <xref:System.Speech.Recognition.SemanticValue.Value%2A> `null` immer und die <xref:System.Speech.Recognition.SemanticValue.Count%2A> -Eigenschaft 0 (null).</span><span class="sxs-lookup"><span data-stu-id="a1600-213">Recognition results which do not make use of semantic parsing always have a <xref:System.Speech.Recognition.SemanticValue.Value%2A> of `null` and a <xref:System.Speech.Recognition.SemanticValue.Count%2A> property of zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a1600-214">Das folgende Beispiel wird verwendet, um Informationen (einschließlich des Konfidenz) <xref:System.Windows.Forms.TreeNodeCollection>rekursiv zu durchlaufen, oder als die Knoten, die die Struktur der Semantik bilden, die zum Erkennen eines Ausdrucks verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="a1600-214">The following example is used to recursively traverse and then display information (including confidence) as a <xref:System.Windows.Forms.TreeNodeCollection>, or as the nodes making up the tree structure of the semantics used to recognize a phrase.</span></span>  
  
```csharp  
internal static void CreateSemanticsTreeNodes(  
          TreeNodeCollection nodes,  
          SemanticValue semantics,  
          String name)   
{  
  string semanticsText =   
      String.Format("  {0} ( Confidence {1})", name,semantics.Confidence);  
  
  // Format integers as hexadecimal.  
  if (semantics.Value == null )  
  {  
    semanticsText = semanticsText + " = null";  
  }  
  else if (semantics.Value.GetType() == typeof(int))   
  {  
    semanticsText = String.Format("{0} = {1:X} ", semanticsText, semantics.Value);  
  }  
  else   
  {  
    semanticsText = semanticsText + " = " + semantics.Value.ToString();  
  }  
  
  TreeNode semanticsNode = new TreeNode(semanticsText);  
  foreach (KeyValuePair<String, SemanticValue> child in semantics)   
  {  
    CreateSemanticsTreeNodes(semanticsNode.Nodes, child.Value, child.Key);  
  }  
  nodes.Add(semanticsNode);  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
