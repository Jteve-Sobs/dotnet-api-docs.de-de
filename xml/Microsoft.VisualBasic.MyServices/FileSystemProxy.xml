<Type Name="FileSystemProxy" FullName="Microsoft.VisualBasic.MyServices.FileSystemProxy">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d7d56db1bc55235c92822b2d743dbe4e0bb90477" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83975786" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemProxy" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FileSystemProxy extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.MyServices.FileSystemProxy" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemProxy" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemProxy" />
  <TypeSignature Language="F#" Value="type FileSystemProxy = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Eigenschaften und Methoden für die Arbeit mit Laufwerken, Dateien und Verzeichnissen bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Beispiele für Aufgaben im Zusammenhang mit dem `My.Computer.FileSystem` Objekt aufgeführt.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen aus einer Textdatei|[Vorgehensweise: Lesen aus Textdateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files)|  
|Aus einer durch Trennzeichen getrennten Textdatei lesen|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files)|  
|Lesen aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files)|  
|Lesen aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats)|  
|Lesen aus einer Binärdatei|[Gewusst wie: Lesen aus Binärdateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files)|  
|Lesen aus einer Textdatei mit einer <xref:System.IO.StreamReader>|[Gewusst wie: Lesen von Text aus Dateien mit einem StreamReader](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader)|  
|Schreiben von Text in eine Datei|[Gewusst wie: Schreiben von Text in Dateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files)|  
|An eine Textdatei anfügen|[Gewusst wie: Anfügen an Textdateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files)|  
|Schreiben in eine Binärdatei|[Gewusst wie: Schreiben in Binärdateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files)|  
|Schreiben in Textdateien im Verzeichnis " **MyDocuments** "|[Gewusst wie: Schreiben von Text in Dateien im Verzeichnis „Eigene Dokumente“](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory)|  
|Schreiben in eine Textdatei mit einer `StreamWriter`|[Gewusst wie: Schreiben von Text in Dateien mit einem StreamWriter](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter)|  
|Kopieren von Dateien mit einem bestimmten Muster|[Gewusst wie: Kopieren von Dateien mit einem bestimmten Muster in ein Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory)|  
|Datei in dasselbe Verzeichnis kopieren|[Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory)|  
|Kopieren einer Datei in ein anderes Verzeichnis|[Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory)|  
|Erstellen von Dateien|[Gewusst wie: Erstellen einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file)|  
|Löschen einer Datei|[Gewusst wie: Löschen einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file)|  
|Suchen nach Dateien mit einem bestimmten Muster|[Gewusst wie: Suchen nach Dateien mit einem bestimmten Muster](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern)|  
|Verschieben einer Datei|[Gewusst wie: Verschieben einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file)|  
|Umbenennen einer Datei|[Gewusst wie: Umbenennen einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file)|  
|Kopieren eines Verzeichnisses in ein anderes Verzeichnis|[Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory)|  
|Erstellen eines Verzeichnisses|[Gewusst wie: Erstellen eines Verzeichnisses](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory)|  
|Suchen nach Unterverzeichnissen mit einem bestimmten Muster|[Gewusst wie: Suchen nach Unterverzeichnissen mit einem bestimmten Muster](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern)|  
|Sammlung von Dateien in einem Verzeichnis|[Gewusst wie: Abrufen einer Sammlung von Dateien in einem Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory)|  
|Aus dem Verzeichnis " **MyDocuments** " lesen|[Gewusst wie: Abrufen des Inhalts des Verzeichnisses „Eigene Dokumente“](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory)|  
|Analysieren eines Dateipfads|[Gewusst wie: Analysieren von Dateipfaden](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths)|  
  
   
  
## Examples  
 In diesem Beispiel wird überprüft, um zu bestimmen, ob der Ordner `C:\backup\logs` vorhanden ist, und seine Eigenschaften überprüft.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
    <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="member this.CombinePath : string * string -&gt; string" Usage="fileSystemProxy.CombinePath (baseDirectory, relativePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" />
        <Parameter Name="relativePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseDirectory"><see langword="String" /> Erster Pfad, der kombiniert werden soll.</param>
        <param name="relativePath"><see langword="String" /> Zweiter Pfad, der kombiniert werden soll.</param>
        <summary>Verknüpft zwei Pfade und gibt einen ordnungsgemäß formatierten Pfad zurück.</summary>
        <returns>Die Kombination der angegebenen Pfade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode schneidet überflüssige Zeichen, um einen ordnungsgemäß formatierten Pfad zu erstellen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CombinePath`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Verzeichnispfad und Dateiname kombinieren|[Gewusst wie: Analysieren von Dateipfaden](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths)|  
  
   
  
## Examples  
 In diesem Beispiel werden ein Verzeichnispfad und ein Dateiname kombiniert, um einen korrekt formatierten Pfad zu erstellen.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 In diesem Beispiel werden zwei Pfade kombiniert, um einen ordnungsgemäß formatierten Pfad zu erstellen.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 In diesem Beispiel wird `C:\Dir1\Dir2\Dir4\Dir5\File.txt`zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="baseDirectory" /> oder <paramref name="relativePath" /> sind fehlerhafte Pfade.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert ein Verzeichnis in ein anderes Verzeichnis.</summary>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory">Gewusst wie: Abrufen einer Auflistung der Dateien in einem Verzeichnis in Visual Basic</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den das Verzeichnis kopiert werden soll.</param>
        <summary>Kopiert ein Verzeichnis in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert den Inhalt des Verzeichnisses sowie das Verzeichnis selbst. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn am Ziel Speicherort ein Verzeichnis mit demselben Namen vorhanden ist, werden die Inhalte der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien in einem Verzeichnis können Ausnahmen ausgelöst werden, die durch eine bestimmte Datei verursacht werden. Wenn solche Ausnahmen ausgelöst werden, werden Sie in einer einzelnen Ausnahme konsolidiert, deren `Data`-Eigenschaft Einträge in Form einer <xref:System.Collections.IDictionary> enthält, in der der Datei-oder Verzeichnispfad der Schlüssel ist und die spezifische Ausnahme Meldung im entsprechenden Wert enthalten ist. Verwenden Sie `For…Each`, um die Einträge aufzuzählen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyDirectory`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Kopieren eines Verzeichnisses|[Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Verzeichnis `TestDirectory1` in `TestDirectory2`kopiert und vorhandene Dateien überschrieben.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Ersetzen Sie `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten, und den Speicherort, an den Sie es kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory">Gewusst wie: Abrufen einer Auflistung der Dateien in einem Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths">Gewusst wie: Analysieren von Dateipfaden in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den das Verzeichnis kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Kopiert ein Verzeichnis in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert den Inhalt des Verzeichnisses sowie das Verzeichnis selbst. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn am Ziel Speicherort ein Verzeichnis mit demselben Namen vorhanden ist, werden die Inhalte der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien in einem Verzeichnis können Ausnahmen ausgelöst werden, die durch eine bestimmte Datei verursacht werden. Wenn solche Ausnahmen ausgelöst werden, werden Sie in einer einzelnen Ausnahme konsolidiert, deren `Data`-Eigenschaft Einträge in Form einer <xref:System.Collections.IDictionary> enthält, in der der Datei-oder Verzeichnispfad der Schlüssel ist und die spezifische Ausnahme Meldung im entsprechenden Wert enthalten ist. Verwenden Sie `For…Each`, um die Einträge aufzuzählen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyDirectory`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Kopieren eines Verzeichnisses|[Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Verzeichnis `TestDirectory1` in `TestDirectory2`kopiert und vorhandene Dateien überschrieben.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Ersetzen Sie `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten, und den Speicherort, an den Sie es kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="ShowUI" /> ist auf <see langword="UIOption.AllDialogs" /> festgelegt, und der Vorgang wird vom Benutzer abgebrochen, oder mindestens eine Datei im Verzeichnis kann nicht kopiert werden.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory">Gewusst wie: Abrufen einer Auflistung der Dateien in einem Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths">Gewusst wie: Analysieren von Dateipfaden in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * bool -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den das Verzeichnis kopiert werden soll.</param>
        <param name="overwrite"><see langword="True" />, wenn vorhandene Dateien überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Kopiert ein Verzeichnis in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert den Inhalt des Verzeichnisses sowie das Verzeichnis selbst. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn am Ziel Speicherort ein Verzeichnis mit demselben Namen vorhanden ist, werden die Inhalte der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien in einem Verzeichnis können Ausnahmen ausgelöst werden, die durch eine bestimmte Datei verursacht werden, z. b. eine Datei, die während eines Merge vorhanden ist, während `overwrite` auf `False`festgelegt ist. Wenn solche Ausnahmen ausgelöst werden, werden Sie in einer einzelnen Ausnahme konsolidiert, deren `Data`-Eigenschaft Einträge in Form einer <xref:System.Collections.IDictionary> enthält, in der der Datei-oder Verzeichnispfad der Schlüssel ist und die spezifische Ausnahme Meldung im entsprechenden Wert enthalten ist. Verwenden Sie `For…Each`, um die Einträge aufzuzählen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyDirectory`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Kopieren eines Verzeichnisses|[Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Verzeichnis `TestDirectory1` in `TestDirectory2`kopiert und vorhandene Dateien überschrieben.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Ersetzen Sie `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten, und den Speicherort, an den Sie es kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory">Gewusst wie: Abrufen einer Auflistung der Dateien in einem Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths">Gewusst wie: Analysieren von Dateipfaden in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Das zu kopierende Verzeichnis.</param>
        <param name="destinationDirectoryName">Der Speicherort, an den das Verzeichnis kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt die Aktion an, die ausgeführt werden soll, wenn während des Vorgangs auf **Abbrechen** geklickt wird. Der Standardwert ist <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Kopiert ein Verzeichnis in ein anderes Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kopiert den Inhalt des Verzeichnisses sowie das Verzeichnis selbst. Wenn das Zielverzeichnis nicht vorhanden ist, wird es erstellt. Wenn am Ziel Speicherort ein Verzeichnis mit demselben Namen vorhanden ist, werden die Inhalte der beiden Verzeichnisse zusammengeführt. Sie können während des Vorgangs einen neuen Namen für das Verzeichnis angeben.  
  
 Beim Kopieren von Dateien in einem Verzeichnis können Ausnahmen ausgelöst werden, die durch eine bestimmte Datei verursacht werden. Wenn solche Ausnahmen ausgelöst werden, werden Sie in einer einzelnen Ausnahme konsolidiert, deren `Data`-Eigenschaft Einträge in Form einer <xref:System.Collections.IDictionary> enthält, in der der Datei-oder Verzeichnispfad der Schlüssel ist und die spezifische Ausnahme Meldung im entsprechenden Wert enthalten ist. Verwenden Sie `For…Each`, um die Einträge aufzuzählen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyDirectory`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Kopieren eines Verzeichnisses|[Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Verzeichnis `TestDirectory1` in `TestDirectory2`kopiert und vorhandene Dateien überschrieben.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Ersetzen Sie `C:\TestDirectory1` und `C:\TestDirectory2` durch den Pfad und den Namen des Verzeichnisses, das Sie kopieren möchten, und den Speicherort, an den Sie es kopieren möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> oder <paramref name="sourceDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Quellverzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Ordnername im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Eine Zieldatei ist vorhanden, aber es ist kein Zugriff auf die Datei möglich.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="ShowUI" /> ist auf <see langword="UIOption.AllDialogs" /> festgelegt, und der Vorgang wird vom Benutzer abgebrochen, oder mindestens eine Datei im Verzeichnis kann nicht kopiert werden.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory">Gewusst wie: Abrufen einer Auflistung der Dateien in einem Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths">Gewusst wie: Analysieren von Dateipfaden in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory">Gewusst wie: Kopieren von Dateien mit einem bestimmten Muster in ein Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory">Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Ordner in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory">Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file">Gewusst wie: Umbenennen einer Datei in Visual Basic</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 in `CopyFile` werden ACEs (Access Control Einträge) nicht beibehalten. Die neu erstellte Datei erbt Standard-ACEs aus dem Verzeichnis, in dem Sie erstellt wird.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyFile`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Kopieren Sie eine Datei in dasselbe Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory)|  
|Kopieren Sie eine Datei in ein anderes Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory)|  
  
   
  
## Examples  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert, ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert und `NewFile.txt`umbenannt.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Zielverzeichnis mit demselben Namen wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory">Gewusst wie: Kopieren von Dateien mit einem bestimmten Muster in ein Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory">Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Ordner in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory">Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file">Gewusst wie: Umbenennen einer Datei in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 in `CopyFile` werden ACEs (Access Control Einträge) nicht beibehalten. Die neu erstellte Datei erbt Standard-ACEs aus dem Verzeichnis, in dem Sie erstellt wird.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyFile`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Kopieren Sie eine Datei in dasselbe Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory)|  
|Kopieren Sie eine Datei in ein anderes Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory)|  
  
   
  
## Examples  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert, ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert und `NewFile.txt`umbenannt.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Zieldatei ist bereits vorhanden, und <paramref name="overwrite" /> ist auf <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory">Gewusst wie: Kopieren von Dateien mit einem bestimmten Muster in ein Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory">Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Ordner in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory">Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file">Gewusst wie: Umbenennen einer Datei in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * bool -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <param name="overwrite"><see langword="True" />, wenn vorhandene Dateien überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 in `CopyFile` werden ACEs (Access Control Einträge) nicht beibehalten. Die neu erstellte Datei erbt Standard-ACEs aus dem Verzeichnis, in dem Sie erstellt wird.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyFile`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Kopieren Sie eine Datei in dasselbe Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory)|  
|Kopieren Sie eine Datei in ein anderes Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory)|  
  
   
  
## Examples  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert, ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert und `NewFile.txt`umbenannt.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Zieldatei ist bereits vorhanden, und <paramref name="overwrite" /> ist auf <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory">Gewusst wie: Kopieren von Dateien mit einem bestimmten Muster in ein Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory">Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Ordner in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory">Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file">Gewusst wie: Umbenennen einer Datei in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Die zu kopierende Datei.</param>
        <param name="destinationFileName">Der Speicherort, an den die Datei kopiert werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt die Aktion an, die ausgeführt werden soll, wenn während des Vorgangs auf **Abbrechen** geklickt wird. Der Standardwert ist <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Kopiert eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 in `CopyFile` werden ACEs (Access Control Einträge) nicht beibehalten. Die neu erstellte Datei erbt Standard-ACEs aus dem Verzeichnis, in dem Sie erstellt wird.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CopyFile`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Kopieren Sie eine Datei in dasselbe Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory)|  
|Kopieren Sie eine Datei in ein anderes Verzeichnis.|[Gewusst wie: Erstellen einer Kopie einer Datei in einem anderen Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory)|  
  
   
  
## Examples  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert, ohne vorhandene Dateien zu überschreiben.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 In diesem Beispiel werden die Datei `Test.txt` in das Verzeichnis `TestFiles2` kopiert und `NewFile.txt`umbenannt.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Ersetzen Sie die Dateipfade durch die Pfade, die Sie im Code verwenden möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> oder <paramref name="sourceFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Zieldatei ist bereits vorhanden, und <paramref name="overwrite" /> ist auf <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="UICancelOption" /> ist auf <see langword="ThrowException" /> festgelegt, und entweder hat der Benutzer den Vorgang abgebrochen, oder ein nicht näher bezeichneter E/A-Fehler tritt auf.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory">Gewusst wie: Kopieren von Dateien mit einem bestimmten Muster in ein Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory">Gewusst wie: Erstellen einer Kopie einer Datei im gleichen Ordner in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory">Gewusst wie: Kopieren eines Verzeichnisses in ein anderes Verzeichnis in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file">Gewusst wie: Umbenennen einer Datei in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.CreateDirectory : string -&gt; unit" Usage="fileSystemProxy.CreateDirectory directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Der Name und der Speicherort des Verzeichnisses.</param>
        <summary>Erstellt ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Verzeichnis bereits vorhanden ist, werden keine Ausnahmen ausgelöst.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.CreateDirectory`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Erstellen eines Verzeichnisses|[Gewusst wie: Erstellen eines Verzeichnisses](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory)|  
  
   
  
## Examples  
 In diesem Beispiel wird das Verzeichnis `NewDirectory`in `C:\Documents and Settings\All Users\Documents`erstellt.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name des Verzeichnisses ist falsch formatiert. Er enthält beispielsweise unzulässige Zeichen oder besteht nur aus Leerzeichen.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Verzeichnisname ist zu lang.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname besteht nur aus einem Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.IOException">Das übergeordnete Verzeichnis des zu erstellenden Verzeichnisses ist schreibgeschützt.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer ist nicht zum Erstellen des Verzeichnisses berechtigt.</exception>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktuelle Verzeichnis ab oder legt dieses fest.</summary>
        <value>Das aktuelle Verzeichnis für Datei-E/A-Operationen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` ist eine systemweite Umgebungsvariable.  
  
   
  
## Examples  
 In diesem Beispiel wird das aktuelle Verzeichnis zurückgegeben und in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 In diesem Beispiel wird das aktuelle Verzeichnis auf `C:\TestDirectory`festgelegt.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der Pfad ist nicht gültig.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht ein Verzeichnis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu löschende Verzeichnis.</param>
        <param name="onDirectoryNotEmpty">Gibt an, was geschehen soll, wenn ein Verzeichnis, das gelöscht werden soll, Dateien oder Verzeichnisse enthält. Der Standardwert ist <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Löscht ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im Beispiel wird das Verzeichnis `OldDirectory` nur dann gelöscht, wenn es leer ist.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In diesem Beispiel werden das Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht, und der Benutzer wird aufgefordert, den Löschvorgang zu bestätigen, aber der Inhalt wird nicht an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und alle zugehörigen Inhalte gelöscht und an den **Papierkorb**gesendet, aber der Fortschritt des Vorgangs wird nicht angezeigt.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0, der Pfad ist falsch formatiert, er enthält nur Leerzeichen oder er enthält ungültige Zeichen (einschließlich Platzhalterzeichen). Der Pfad ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis ist nicht vorhanden, oder es handelt sich um eine Datei.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Verzeichnis oder Unterverzeichnis wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname enthält einen Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer bricht den Vorgang ab, oder das Verzeichnis kann nicht gelöscht werden.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file">Gewusst wie: Löschen einer Datei in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu löschende Verzeichnis.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Löscht ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Parameter `showUI` und `recycle` werden nicht in Anwendungen unterstützt, die Nichtbenutzer interaktiv sind, wie z. b. Windows-Dienste.  
  
   
  
## Examples  
 Im Beispiel wird das Verzeichnis `OldDirectory` nur dann gelöscht, wenn es leer ist.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In diesem Beispiel werden das Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht, und der Benutzer wird aufgefordert, den Löschvorgang zu bestätigen, aber der Inhalt wird nicht an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und alle zugehörigen Inhalte gelöscht und an den **Papierkorb**gesendet, aber der Fortschritt des Vorgangs wird nicht angezeigt.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0, der Pfad ist falsch formatiert, er enthält nur Leerzeichen oder er enthält ungültige Zeichen (einschließlich Platzhalterzeichen). Der Pfad ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis ist nicht vorhanden, oder es handelt sich um eine Datei.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Verzeichnis oder Unterverzeichnis wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname enthält einen Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer bricht den Vorgang ab, oder das Verzeichnis kann nicht gelöscht werden.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file">Gewusst wie: Löschen einer Datei in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu löschende Verzeichnis.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst werden soll, wenn auf **Abbrechen** geklickt wird.</param>
        <summary>Löscht ein Verzeichnis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `showUI`-, `recycle`-und `onUserCancel`-Parameter werden nicht in Anwendungen unterstützt, die Nichtbenutzer interaktiv sind, wie z. b. Windows-Dienste.  
  
   
  
## Examples  
 Im Beispiel wird das Verzeichnis `OldDirectory` nur dann gelöscht, wenn es leer ist.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 In diesem Beispiel werden das Verzeichnis `OldDirectory` und der gesamte Inhalt gelöscht, und der Benutzer wird aufgefordert, den Löschvorgang zu bestätigen, aber der Inhalt wird nicht an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 In diesem Beispiel werden die Verzeichnis `OldDirectory` und alle zugehörigen Inhalte gelöscht und an den **Papierkorb**gesendet, aber der Fortschritt des Vorgangs wird nicht angezeigt.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0, der Pfad ist falsch formatiert, er enthält nur Leerzeichen oder er enthält ungültige Zeichen (einschließlich Platzhalterzeichen). Der Pfad ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das Verzeichnis ist nicht vorhanden, oder es handelt sich um eine Datei.</exception>
        <exception cref="T:System.IO.IOException">Eine Datei im Verzeichnis oder Unterverzeichnis wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnisname enthält einen Doppelpunkt (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer bricht den Vorgang ab, oder das Verzeichnis kann nicht gelöscht werden.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file">Gewusst wie: Löschen einer Datei in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht eine Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string -&gt; unit" Usage="fileSystemProxy.DeleteFile file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu löschenden Datei.</param>
        <summary>Löscht eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.DeleteFile`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|So löschen Sie eine Datei|[Gewusst wie: Löschen einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt`gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Dieses Beispiel löscht die Datei `Test.txt` und ermöglicht dem Benutzer zu bestätigen, dass die Datei gelöscht werden soll.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In diesem Beispiel wird die Datei `Test.txt` gelöscht und an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; er weist an der Position, an der eine Datei angegeben werden muss, einen abschließenden Schrägstrich auf; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung zum Löschen der Datei, oder die Datei ist schreibgeschützt.</exception>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file">Gewusst wie: Löschen einer Datei in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="fileSystemProxy.DeleteFile (file, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu löschenden Datei.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Löscht eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Parameter `showUI` und `recycle` werden nicht in Anwendungen unterstützt, die Nichtbenutzer interaktiv sind, wie z. b. Windows-Dienste.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.DeleteFile`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|So löschen Sie eine Datei|[Gewusst wie: Löschen einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt`gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Dieses Beispiel löscht die Datei `Test.txt` und ermöglicht dem Benutzer zu bestätigen, dass die Datei gelöscht werden soll.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In diesem Beispiel wird die Datei `Test.txt` gelöscht und an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; er weist an der Position, an der eine Datei angegeben werden muss, einen abschließenden Schrägstrich auf; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung zum Löschen der Datei, oder die Datei ist schreibgeschützt.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file">Gewusst wie: Löschen einer Datei in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu löschenden Datei.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Gibt an, ob die gelöschte Datei in den **Papierkorb** verschoben werden soll. Der Standardwert ist <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst wird, wenn der Benutzer den Vorgang abbricht. Der Standardwert ist <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Löscht eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `showUI`-, `recycle`-und `onUserCancel`-Parameter werden nicht in Anwendungen unterstützt, die Nichtbenutzer interaktiv sind, wie z. b. Windows-Dienste.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.DeleteFile`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|So löschen Sie eine Datei|[Gewusst wie: Löschen einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt`gelöscht.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Dieses Beispiel löscht die Datei `Test.txt` und ermöglicht dem Benutzer zu bestätigen, dass die Datei gelöscht werden soll.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 In diesem Beispiel wird die Datei `Test.txt` gelöscht und an den **Papierkorb**gesendet.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; er weist an der Position, an der eine Datei angegeben werden muss, einen abschließenden Schrägstrich auf; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird gegenwärtig verwendet.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung zum Löschen der Datei, oder die Datei ist schreibgeschützt.</exception>
        <exception cref="T:System.OperationCanceledException">Der Benutzer hat den Vorgang abgebrochen, und <paramref name="onUserCancel" /> ist auf <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" /> festgelegt.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file">Gewusst wie: Löschen einer Datei in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.DirectoryExists : string -&gt; bool" Usage="fileSystemProxy.DirectoryExists directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Der Pfad des Verzeichnisses.</param>
        <summary>Gibt <see langword="True" /> zurück, wenn das angegebene Verzeichnis vorhanden ist.</summary>
        <returns><see langword="True" />, wenn das Verzeichnis vorhanden ist, andernfalls <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird ermittelt, ob das Verzeichnis `C:\backup\logs` vorhanden ist, und seine Eigenschaften werden überprüft.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories">Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.Drives" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt eine schreibgeschützte Auflistung aller verfügbaren Laufwerknamen zurück.</summary>
        <value>Eine schreibgeschützte Auflistung aller verfügbaren Laufwerke als <see cref="T:System.IO.DriveInfo" />-Objekte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt alle logischen Laufwerke zurück.  
  
   
  
## Examples  
 In diesem Beispiel werden die verfügbaren Laufwerks Namen in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.FileExists : string -&gt; bool" Usage="fileSystemProxy.FileExists file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der Datei.</param>
        <summary>Gibt <see langword="True" /> zurück, wenn die angegebene Datei vorhanden ist.</summary>
        <returns>Diese Methode gibt <see langword="True" /> zurück, wenn die Datei vorhanden ist, andernfalls gibt sie <see langword="False" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Anwendung nicht über ausreichende Berechtigungen zum Lesen der angegebenen Datei verfügt, gibt die `FileExists` Methode `False`zurück, unabhängig davon, ob der Pfad vorhanden ist. die-Methode löst keine Ausnahme aus.  
  
   
  
## Examples  
 In diesem Beispiel wird überprüft, ob die Datei `Check.txt` vorhanden ist, und die Informationen werden in einem Meldungs Feld bereitstellt.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name der Datei endet mit einem umgekehrten Schrägstrich (\\).</exception>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories">Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien mit dem angegebenen Text darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="member this.FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <param name="containsText">Der Suchtext.</param>
        <param name="ignoreCase"><see langword="True" />, wenn die Groß-/Kleinschreibung bei der Suche berücksichtigt werden soll, andernfalls <see langword="False" />. Der Standardwert ist <see langword="True" />.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien mit dem angegebenen Text darstellen.</summary>
        <returns>Eine schreibgeschützte Collection der Namen der Dateien, die den angegebenen Text enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.FindInFiles`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Durchsuchen eines Verzeichnisses nach Dateien, die eine bestimmte Zeichenfolge enthalten|[Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories)|  
  
   
  
## Examples  
 In diesem Beispiel wird das Verzeichnis `C:\TestDir` nach Dateien durchsucht, die die Zeichenfolge `"sample string"` enthalten, und die Ergebnisse werden in `ListBox1`angezeigt.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Um zu funktionieren, muss das Projekt eine `ListBox` mit dem Namen `ListBox1`enthalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0 (null), er enthält nur Leerzeichen, er enthält ungültige Zeichen, oder er ist ein Gerätepfad (beginnt mit <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der angegebene Verzeichnispfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories">Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="member this.FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="containsText" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="fileWildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <param name="containsText">Der Suchtext.</param>
        <param name="ignoreCase"><see langword="True" />, wenn die Groß-/Kleinschreibung bei der Suche berücksichtigt werden soll, andernfalls <see langword="False" />. Der Standardwert ist <see langword="True" />.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Das Muster, das übereinstimmen muss.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien mit dem angegebenen Text darstellen.</summary>
        <returns>Eine schreibgeschützte Collection der Namen der Dateien, die den angegebenen Text enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.FindInFiles`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Durchsuchen eines Verzeichnisses nach Dateien, die eine bestimmte Zeichenfolge enthalten|[Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories)|  
  
   
  
## Examples  
 In diesem Beispiel wird das Verzeichnis `C:\TestDir` nach Dateien durchsucht, die die Zeichenfolge `"sample string"` enthalten, und die Ergebnisse werden in `ListBox1`angezeigt.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Um zu funktionieren, muss das Projekt eine `ListBox` mit dem Namen `ListBox1`enthalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0 (null), er enthält nur Leerzeichen, er enthält ungültige Zeichen, oder er ist ein Gerätepfad (beginnt mit <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der angegebene Verzeichnispfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories">Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine Auflistung von Zeichenfolgen zurück, die die Pfadnamen der Unterverzeichnisse in einem Verzeichnis darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetDirectories directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Name und Pfad des Verzeichnisses.</param>
        <summary>Gibt eine Auflistung von Zeichenfolgen zurück, die die Pfadnamen der Unterverzeichnisse in einem Verzeichnis darstellen.</summary>
        <returns>Schreibgeschützte Auflistung der Pfadnamen für die Unterverzeichnisse im angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.GetDirectories`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Auflisten von Unterverzeichnissen mit einem bestimmten Muster|[Gewusst wie: Suchen nach Unterverzeichnissen mit einem bestimmten Muster](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Verzeichnisse in der Verzeichnisstruktur zurückgegeben, die das Wort `Logs` in ihren Namen enthalten, und `ListBox1`hinzugefügt.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetDirectories (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Name und Pfad des Verzeichnisses.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Das Muster für den Namensvergleich.</param>
        <summary>Gibt eine Auflistung von Zeichenfolgen zurück, die die Pfadnamen der Unterverzeichnisse in einem Verzeichnis darstellen.</summary>
        <returns>Schreibgeschützte Auflistung der Pfadnamen für die Unterverzeichnisse im angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den `wildcards` -Parameter verwenden, um ein bestimmtes Muster anzugeben. Wenn Sie den Inhalt der Unterverzeichnisse in Ihre Suche mit einbeziehen möchten, legen Sie den `searchType`-Parameter auf `SearchAllSubDirectories` fest.  
  
 Es wird eine leere Auflistung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.GetDirectories`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Auflisten von Unterverzeichnissen mit einem bestimmten Muster|[Gewusst wie: Suchen nach Unterverzeichnissen mit einem bestimmten Muster](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Verzeichnisse in der Verzeichnisstruktur zurückgegeben, die das Wort `Logs` in ihren Namen enthalten, und `ListBox1`hinzugefügt.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Mindestens eines der angegebenen Platzhalterzeichen ist <see langword="Nothing" />, eine leere Zeichenfolge oder enthält nur Leerzeichen.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das angegebene Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das angegebene Verzeichnis zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="fileSystemProxy.GetDirectoryInfo directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory"><see langword="String" /> Pfad des Verzeichnisses.</param>
        <summary>Gibt für den angegebenen Pfad ein <see cref="T:System.IO.DirectoryInfo" />-Objekt zurück.</summary>
        <returns>Ein <see cref="T:System.IO.DirectoryInfo" />-Objekt für den angegebenen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Verzeichnis nicht vorhanden ist, wird keine Ausnahme ausgelöst, bis das erste Mal auf eine Eigenschaft des <xref:System.IO.DirectoryInfo> Objekts zugegriffen wird.  
  
   
  
## Examples  
 In diesem Beispiel wird ein <xref:System.IO.DirectoryInfo> Objekt für das Verzeichnis `C:\Documents and Settings` abgerufen, und es werden die Erstellungszeit des Verzeichnisses, der Zeitpunkt des letzten Zugriffs und der letzte Schreib Zeitpunkt angezeigt.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="directory" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Der Verzeichnispfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="member this.GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="fileSystemProxy.GetDriveInfo drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="drive">Das zu überprüfende Laufwerk.</param>
        <summary>Gibt ein <see cref="T:System.IO.DriveInfo" />-Objekt für das angegebene Laufwerk zurück.</summary>
        <returns>Ein <see cref="T:System.IO.DriveInfo" />-Objekt für das angegebene Laufwerk.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.DriveInfo>-Klasse modelliert ein Laufwerk und stellt Methoden und Eigenschaften zum Abfragen von Laufwerk Informationen bereit. Verwenden Sie <xref:System.IO.DriveInfo>, um zu bestimmen, welche Laufwerke verfügbar sind und welche Art von Laufwerken Sie sind. Sie können die-Eigenschaft auch Abfragen, um die Kapazität und den verfügbaren freien Speicherplatz auf dem Laufwerk zu ermitteln.  
  
   
  
## Examples  
 In diesem Beispiel wird ein <xref:System.IO.DriveInfo> Objekt für das Laufwerk C abgerufen und zum Anzeigen von Informationen über das Laufwerk verwendet.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Informationen zu den verschiedenen Laufwerkstypen finden Sie unter <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="drive" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.GetFileInfo : string -&gt; System.IO.FileInfo" Usage="fileSystemProxy.GetFileInfo file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der Datei.</param>
        <summary>Gibt ein <see cref="T:System.IO.FileInfo" />-Objekt für die angegebene Datei zurück.</summary>
        <returns>Ein <see cref="T:System.IO.FileInfo" />-Objekt für die angegebene Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Datei nicht vorhanden ist, wird keine Ausnahme ausgelöst. Stattdessen wird Sie ausgelöst, wenn auf die Eigenschaften des Objekts zum ersten Mal zugegriffen wird.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.GetFileInfo`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Festlegen eines Datei namens und-Pfads|[Gewusst wie: Analysieren von Dateipfaden](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths)|  
  
   
  
## Examples  
 In diesem Beispiel wird ein <xref:System.IO.FileInfo?displayProperty=nameWithType> Objekt für die Datei `MyLogFile.log` abgerufen und verwendet, um den vollständigen Namen der Datei, den Zeitpunkt des letzten Zugriffs und die Länge zu melden.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfadname ist falsch formatiert. Er enthält beispielsweise ungültige Zeichen oder besteht nur aus Leerzeichen. Der Dateiname enthält einen nachgestellten Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="file" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.NotSupportedException">Der Pfad enthält einen Doppelpunkt in der Mitte der Zeichenfolge.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad ist zu lang.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt über keinen ACL (Access Control List)-Zugriff auf die Datei.</exception>
        <altmember cref="T:System.IO.FileInfo" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories">Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien in einem Verzeichnis darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetFiles directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien in einem Verzeichnis darstellen.</summary>
        <returns>Eine schreibgeschützte Auflistung von Dateinamen aus dem angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.GetFiles`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Sammlung von Dateien in einem Verzeichnis|[Gewusst wie: Abrufen einer Sammlung von Dateien in einem Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory)|  
|Suchen nach Dateien mit einem bestimmten Muster in einem Verzeichnis|[Gewusst wie: Suchen nach Dateien mit einem bestimmten Muster](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Dateien im Verzeichnis zurückgegeben und `ListBox1` hinzugefügt.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 In diesem Beispiel werden alle Dateien im Verzeichnis mit der Erweiterung `.txt` zurückgegeben und `ListBox1`hinzugefügt.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das zu durchsuchende Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="directory" /> zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern">Gewusst wie: Suchen nach Dateien mit einem bestimmten Muster in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory">Gewusst wie: Abrufen einer Auflistung der Dateien in einem Verzeichnis in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetFiles (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" />
        <Parameter Name="wildcards" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Das zu durchsuchende Verzeichnis.</param>
        <param name="searchType">Gibt an, ob Unterordner eingeschlossen werden. Der Standardwert ist <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Das Muster, das übereinstimmen muss.</param>
        <summary>Gibt eine schreibgeschützte Auflistung von Zeichenfolgen zurück, die die Namen der Dateien in einem Verzeichnis darstellen.</summary>
        <returns>Eine schreibgeschützte Auflistung von Dateinamen aus dem angegebenen Verzeichnis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird eine leere Sammlung zurückgegeben, wenn keine Dateien dem angegebenen Muster entsprechen.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.GetFiles`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Sammlung von Dateien in einem Verzeichnis|[Gewusst wie: Abrufen einer Sammlung von Dateien in einem Verzeichnis](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory)|  
|Suchen nach Dateien mit einem bestimmten Muster in einem Verzeichnis|[Gewusst wie: Suchen nach Dateien mit einem bestimmten Muster](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern)|  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Dateien im Verzeichnis zurückgegeben und `ListBox1` hinzugefügt.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 In diesem Beispiel werden alle Dateien im Verzeichnis mit der Erweiterung `.txt` zurückgegeben und `ListBox1`hinzugefügt.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 Für dieses Beispiel ist es erforderlich, dass Sie über eine `ListBox` mit dem Namen `ListBox1` im Formular verfügen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Das zu durchsuchende Verzeichnis ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="directory" /> zeigt auf eine vorhandene Datei.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern">Gewusst wie: Suchen nach Dateien mit einem bestimmten Muster in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory">Gewusst wie: Abrufen einer Auflistung der Dateien in einem Verzeichnis in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.GetName : string -&gt; string" Usage="fileSystemProxy.GetName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Erforderlich. Der zu analysierende Pfad. <see langword="String" /></param>
        <summary>Analysiert den Dateinamen aus dem bereitgestellten Pfad.</summary>
        <returns>Der Dateiname aus dem angegebenen Pfad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein Zeichen folgen Vorgang. die `FileSystem` wird nicht untersucht.  
  
 Die `GetName`-Methode ignoriert einen Schrägstrich am Ende des Pfads.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.GetFileName`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Analysieren eines Dateipfads|[Gewusst wie: Analysieren von Dateipfaden](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths)|  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Dateipfad analysiert und der Name der Datei zurückgegeben.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Ersetzen Sie den Pfad `C:\Testdirectory\Testfile` durch den Pfad, den Sie analysieren möchten.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.GetParentPath : string -&gt; string" Usage="fileSystemProxy.GetParentPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der zu überprüfende Pfad.</param>
        <summary>Gibt den übergeordneten Pfad des bereitgestellten Pfades zurück.</summary>
        <returns>Der übergeordnete Pfad des bereitgestellten Pfads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein Zeichen folgen Vorgang. das Dateisystem wird nicht untersucht.  
  
   
  
## Examples  
 In diesem Beispiel wird der übergeordnete Pfad für `C:\Backups\Tmp\Test`abgerufen.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad verfügt über keinen übergeordneten Pfad, weil er ein Stammpfad ist.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths">Gewusst wie: Analysieren von Dateipfaden in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="member this.GetTempFileName : unit -&gt; string" Usage="fileSystemProxy.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine eindeutig benannte temporäre Datei mit einer Größe von 0 Byte auf dem Datenträger und gibt den vollständigen Pfad dieser Datei zurück.</summary>
        <returns>Ein <see langword="String" />, der den vollständigen Pfad der temporären Datei enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann zum Erstellen einer temporären Datei verwendet werden.  
  
   
  
## Examples  
 In diesem Beispiel wird eine temporäre Datei erstellt und der Pfad zurückgegeben.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis innerhalb eines nicht vorhandenen Verzeichnisses zu verschieben, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben, und das Verzeichnis wird überschrieben, wenn es bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Quelle ist ein Stammverzeichnis, oder der Quellpfad und der Zielpfad sind identisch.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis innerhalb eines nicht vorhandenen Verzeichnisses zu verschieben, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben, und das Verzeichnis wird überschrieben, wenn es bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das Zielverzeichnis ist bereits vorhanden, und <paramref name="overwrite" /> ist auf den Wert <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * bool -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <param name="overwrite"><see langword="True" />, wenn vorhandene Verzeichnisse überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis innerhalb eines nicht vorhandenen Verzeichnisses zu verschieben, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben, und das Verzeichnis wird überschrieben, wenn es bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Das Zielverzeichnis ist bereits vorhanden, und <paramref name="overwrite" /> ist auf den Wert <see langword="False" /> festgelegt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Der Pfad des Verzeichnisses, das verschoben werden soll.</param>
        <param name="destinationDirectoryName">Der Pfad des Verzeichnisses, in das das Quellverzeichnis verschoben wird.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst wird, wenn der Benutzer den Vorgang abbricht. Der Standardwert ist <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Verschiebt ein Verzeichnis von einem Speicherort an einen anderen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn versucht wird, ein Verzeichnis innerhalb eines nicht vorhandenen Verzeichnisses zu verschieben, wird die Zielstruktur erstellt.  
  
   
  
## Examples  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 In diesem Beispiel wird `Directory1` in `Directory2`verschoben, und das Verzeichnis wird überschrieben, wenn es bereits vorhanden ist.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Er ist eine Zeichenfolge der Länge 0; er enthält nur Leerräume; er enthält ungültige Zeichen; er ist ein Gerätepfad (beginnt mit \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> oder <paramref name="destinationDirectoryName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="onUserCancel" /> ist auf <see langword="ThrowException" /> festgelegt, und ein Unterverzeichnis der Datei kann nicht kopiert werden.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="onUserCancel" /> ist auf <see langword="ThrowException" /> festgelegt, und der Benutzer bricht den Vorgang ab, oder der Vorgang kann nicht abgeschlossen werden.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.InvalidOperationException">Der Vorgang ist zyklisch.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird Sie erstellt.  
  
 Die `MoveFile`-Methode behält ACEs (Access Control Einträge) nur bei, wenn die Datei innerhalb desselben Volumes verschoben wird. Dies schließt geerbte ACEs ein, die zu direkten ACEs werden, wenn Sie verschoben werden (direkte ACEs haben Vorrang vor geerbten ACEs). Wenn eine Datei zwischen Volumes verschoben wird, werden ACEs nicht kopiert.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Verschieben einer Datei|[Gewusst wie: Verschieben einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2` verschoben und `Test2.txt`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird Sie erstellt.  
  
 Die `MoveFile`-Methode behält ACEs (Access Control Einträge) nur bei, wenn die Datei innerhalb desselben Volumes verschoben wird. Dies schließt geerbte ACEs ein, die zu direkten ACEs werden, wenn Sie verschoben werden (direkte ACEs haben Vorrang vor geerbten ACEs). Wenn eine Datei zwischen Volumes verschoben wird, werden ACEs nicht kopiert.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Verschieben einer Datei|[Gewusst wie: Verschieben einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2` verschoben und `Test2.txt`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * bool -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <param name="overwrite"><see langword="True" />, wenn vorhandene Dateien überschrieben werden sollen, andernfalls <see langword="False" />. Der Standardwert ist <see langword="False" />.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird Sie erstellt.  
  
 Die `MoveFile`-Methode behält ACEs (Access Control Einträge) nur bei, wenn die Datei innerhalb desselben Volumes verschoben wird. Dies schließt geerbte ACEs ein, die zu direkten ACEs werden, wenn Sie verschoben werden (direkte ACEs haben Vorrang vor geerbten ACEs). Wenn eine Datei zwischen Volumes verschoben wird, werden ACEs nicht kopiert.  
  
 In der folgenden Tabelle sind Beispiele für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile`-Methode aufgeführt.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Verschieben einer Datei|[Gewusst wie: Verschieben einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2` verschoben und `Test2.txt`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Der Pfad der zu verschiebenden Datei.</param>
        <param name="destinationFileName">Der Pfad des Verzeichnisses, in das die Datei verschoben werden soll.</param>
        <param name="showUI">Gibt an, ob der Status des Vorgangs visuell dargestellt werden soll. Der Standardwert ist <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Gibt an, ob eine Ausnahme ausgelöst wird, wenn der Benutzer den Vorgang abbricht. Der Standardwert ist <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Verschiebt eine Datei an einen neuen Speicherort.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zielstruktur nicht vorhanden ist, wird Sie erstellt.  
  
 Die `MoveFile`-Methode behält ACEs (Access Control Einträge) nur bei, wenn die Datei innerhalb desselben Volumes verschoben wird. Dies schließt geerbte ACEs ein, die zu direkten ACEs werden, wenn Sie verschoben werden (direkte ACEs haben Vorrang vor geerbten ACEs). Wenn eine Datei zwischen Volumes verschoben wird, werden ACEs nicht kopiert.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.MoveFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Verschieben einer Datei|[Gewusst wie: Verschieben einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2`verschoben.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 In diesem Beispiel wird die Datei `Test.txt` aus `TestDir1` in `TestDir2` verschoben und `Test2.txt`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="destinationFileName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Quelldatei ist ungültig oder nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="onUserCancel" /> ist auf <see langword="ThrowException" /> festgelegt, und entweder hat der Benutzer den Vorgang abgebrochen, oder ein nicht näher bezeichneter E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z. B. Protokolle, sowohl einfach als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die mit dem <see langword="TextFieldParser" /> geöffnet werden soll.</param>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z. B. Protokolle, sowohl einfach als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> zum Lesen der angegebenen Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.OpenTextFieldParser`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Aus einer durch Trennzeichen getrennten Textdatei lesen|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files)|  
|Lesen aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files)|  
|Lesen aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats)|  
  
   
  
## Examples  
 In diesem Beispiel wird der `TextFieldParser.reader` geöffnet und zum Lesen aus `C:\TestFolder1\Test1.txt`verwendet.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Eine Zeile kann nicht mit dem angegebenen Format analysiert werden. Die Ausnahmemeldung gibt die Zeile an, die die Ausnahme verursacht, während der in der Zeile enthaltene Text der <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />-Eigenschaft zugewiesen wird.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files">Gewusst wie: Lesen von Textdateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files">Gewusst wie: Lesen aus durch Kommas getrennten Textdateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats">Gewusst wie: Lesen aus Textdateien mit mehreren Formaten in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object">Analysieren von Textdateien mit dem TextFieldParser-Objekt</related>
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser (file, fieldWidths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="fieldWidths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die mit dem <see langword="TextFieldParser" /> geöffnet werden soll.</param>
        <param name="fieldWidths">Die Breiten der Felder.</param>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z. B. Protokolle, sowohl einfach als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> zum Lesen der angegebenen Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.OpenTextFieldParser`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Aus einer durch Trennzeichen getrennten Textdatei lesen|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files)|  
|Lesen aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files)|  
|Lesen aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats)|  
  
   
  
## Examples  
 In diesem Beispiel wird der `TextFieldParser.reader` geöffnet und zum Lesen aus `C:\TestFolder1\Test1.txt`verwendet.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Eine Zeile kann nicht mit dem angegebenen Format analysiert werden. Die Ausnahmemeldung gibt die Zeile an, die die Ausnahme verursacht, während der in der Zeile enthaltene Text der <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />-Eigenschaft zugewiesen wird.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files">Gewusst wie: Lesen von Textdateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files">Gewusst wie: Lesen aus durch Kommas getrennten Textdateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats">Gewusst wie: Lesen aus Textdateien mit mehreren Formaten in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object">Analysieren von Textdateien mit dem TextFieldParser-Objekt</related>
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser (file, delimiters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="delimiters" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die mit dem <see langword="TextFieldParser" /> geöffnet werden soll.</param>
        <param name="delimiters">Trennzeichen für die Felder.</param>
        <summary>Mit der <see langword="OpenTextFieldParser" />-Methode kann ein <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />-Objekt erstellt werden, mit dessen Hilfe strukturierte Textdateien, z. B. Protokolle, sowohl einfach als auch effizient analysiert werden können. Mit dem <see langword="TextFieldParser" />-Objekt können sowohl Dateien mit Trennzeichen als auch Dateien mit fester Breite gelesen werden.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> zum Lesen der angegebenen Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.OpenTextFieldParser`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Aus einer durch Trennzeichen getrennten Textdatei lesen|[Gewusst wie: Lesen aus Textdateien mit Kommatrennung](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files)|  
|Lesen aus einer Textdatei mit fester Breite|[Gewusst wie: Lesen aus einer Textdatei mit fester Breite](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files)|  
|Lesen aus einer Textdatei mit mehreren Formaten|[Gewusst wie: Lesen aus Textdateien mit mehreren Formaten](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats)|  
  
   
  
## Examples  
 In diesem Beispiel wird der `TextFieldParser.reader` geöffnet und zum Lesen aus `C:\TestFolder1\Test1.txt`verwendet.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">Eine Zeile kann nicht mit dem angegebenen Format analysiert werden. Die Ausnahmemeldung gibt die Zeile an, die die Ausnahme verursacht, während der in der Zeile enthaltene Text der <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" />-Eigenschaft zugewiesen wird.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files">Gewusst wie: Lesen von Textdateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files">Gewusst wie: Lesen aus durch Kommas getrennten Textdateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats">Gewusst wie: Lesen aus Textdateien mit mehreren Formaten in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object">Analysieren von Textdateien mit dem TextFieldParser-Objekt</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein <see cref="T:System.IO.StreamReader" />-Objekt, das aus einer Datei gelesen werden soll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="fileSystemProxy.OpenTextFileReader file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die zu lesende Datei.</param>
        <summary>Öffnet ein <see cref="T:System.IO.StreamReader" />-Objekt, das aus einer Datei gelesen werden soll.</summary>
        <returns><see cref="T:System.IO.StreamReader" />-Objekt zum Lesen aus der Datei</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur Textdateien können mit einem <xref:System.IO.StreamReader>gelesen werden.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.OpenTextFileReader`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Öffnen Sie eine Datei mit einer <xref:System.IO.StreamReader>|[Gewusst wie: Lesen von Text aus Dateien mit einem StreamReader](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Testfile.txt`geöffnet, eine Zeile aus ihr gelesen und die Zeile in einer `MessageBox`angezeigt.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem umgekehrten Schrägstrich (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Lesen aus der Datei.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader">Gewusst wie: Lesen von Text aus Dateien mit einem StreamReader (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileReader (file As String, encoding As Encoding) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="fileSystemProxy.OpenTextFileReader (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Die zu lesende Datei.</param>
        <param name="encoding">Die für den Inhalt der Datei zu verwendende Codierung. Der Standardwert ist ASCII.</param>
        <summary>Öffnet ein <see cref="T:System.IO.StreamReader" />-Objekt, das aus einer Datei gelesen werden soll.</summary>
        <returns><see cref="T:System.IO.StreamReader" />-Objekt zum Lesen aus der Datei</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur Textdateien können mit einem <xref:System.IO.StreamReader>gelesen werden.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.OpenTextFileReader`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Öffnen Sie eine Datei mit einer <xref:System.IO.StreamReader>|[Gewusst wie: Lesen von Text aus Dateien mit einem StreamReader](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Testfile.txt`geöffnet, eine Zeile aus ihr gelesen und die Zeile in einer `MessageBox`angezeigt.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem umgekehrten Schrägstrich (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.Security.SecurityException">Der Benutzer verfügt nicht über die erforderlichen Berechtigungen zum Lesen aus der Datei.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader">Gewusst wie: Lesen von Text aus Dateien mit einem StreamReader (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein <see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="fileSystemProxy.OpenTextFileWriter (file, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="append"><see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <summary>Öffnet ein <see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</summary>
        <returns><see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `OpenTextFileWriter`-Methode öffnet und initialisiert einen Stream für eine Datei und gibt dann das <xref:System.IO.StreamWriter>-Objekt für diesen Stream zurück. Sie können so oft wie nötig in den Dampf schreiben und ihn dann schließen, wenn Sie fertig sind.  
  
> [!NOTE]
>  Um sicherzustellen, dass alle Daten ordnungsgemäß in den zugrunde liegenden Stream geschrieben werden, müssen Sie die <xref:System.IO.StreamWriter.Close%2A>-Methode für das <xref:System.IO.StreamWriter>-Objekt aufzurufen.  
  
 Wenn Sie nur einige wenige Zeichen folgen in eine Datei schreiben, ist es möglicherweise einfacher, die <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A>-Methode zu verwenden.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.OpenTextFileWriter`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Schreiben von Text in eine Datei mit einer `StreamWriter`|[Gewusst wie: Schreiben von Text in Dateien mit einem StreamWriter](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter)|  
  
   
  
## Examples  
 In diesem Beispiel wird ein <xref:System.IO.StreamWriter> mit der `My.Computer.FileSystem.OpenTextFileWriter`-Methode geöffnet und verwendet, um eine Zeichenfolge mit der `WriteLine`-Methode der `StreamWriter`-Klasse in eine Textdatei zu schreiben.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem nachgestellten Schrägstrich.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileWriter (file As String, append As Boolean, encoding As Encoding) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="fileSystemProxy.OpenTextFileWriter (file, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="append"><see langword="True" />, wenn Daten an den Inhalt in der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <param name="encoding">Die Codierung, die beim Schreiben in die Datei verwendet werden soll. Der Standardwert ist ASCII.</param>
        <summary>Öffnet einen <see cref="T:System.IO.StreamWriter" />, der in die angegebene Datei geschrieben werden soll.</summary>
        <returns><see cref="T:System.IO.StreamWriter" />-Objekt, das in die angegebene Datei geschrieben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `OpenTextFileWriter`-Methode öffnet und initialisiert einen Stream für eine Datei und gibt dann das <xref:System.IO.StreamWriter>-Objekt für diesen Stream zurück. Sie können so oft wie nötig in den Dampf schreiben und ihn dann schließen, wenn Sie fertig sind.  
  
> [!NOTE]
>  Um sicherzustellen, dass alle Daten ordnungsgemäß in den zugrunde liegenden Stream geschrieben werden, müssen Sie die <xref:System.IO.StreamWriter.Close%2A>-Methode für das <xref:System.IO.StreamWriter>-Objekt aufzurufen.  
  
 Wenn Sie nur einige wenige Zeichen folgen in eine Datei schreiben, ist es möglicherweise einfacher, die <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A>-Methode zu verwenden.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.OpenTextFileWriter`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Schreiben von Text in eine Datei mit einer `StreamWriter`|[Gewusst wie: Schreiben von Text in Dateien mit einem StreamWriter](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter)|  
  
   
  
## Examples  
 In diesem Beispiel wird ein <xref:System.IO.StreamWriter> mit der `My.Computer.FileSystem.OpenTextFileWriter`-Methode geöffnet und verwendet, um eine Zeichenfolge mit der `WriteLine`-Methode der `StreamWriter`-Klasse in eine Textdatei zu schreiben.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Dateiname endet mit einem nachgestellten Schrägstrich.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter">Gewusst wie: Schreiben von Text in eine Datei mit einem StreamWriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.ReadAllBytes : string -&gt; byte[]" Usage="fileSystemProxy.ReadAllBytes file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die zu lesende Datei.</param>
        <summary>Gibt den Inhalt einer Datei als Bytearray zurück.</summary>
        <returns>Ein <see langword="Byte" />-Array mit dem Inhalt der Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadAllBytes`-Methode des `My.Computer.FileSystem`-Objekts ermöglicht das Lesen aus einer Binärdatei. Der Inhalt der Datei wird als Bytearray zurückgegeben.  
  
 Beurteilen Sie den Inhalt der Datei nicht anhand des Dateinamens. Bei der Datei "Form1.vb" handelt es sich zum Beispiel nicht unbedingt um eine Visual Basic-Quelldatei. Überprüfen Sie alle Eingaben, bevor Sie die Daten in der Anwendung verwenden.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.ReadAllBytes`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen aus einer Binärdatei|[Gewusst wie: Lesen aus Binärdateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files)|  
  
   
  
## Examples  
 In diesem Beispiel wird aus der Datei gelesen `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Inhalt einer Textdatei als <see langword="String" /> zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.ReadAllText : string -&gt; string" Usage="fileSystemProxy.ReadAllText file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu lesenden Datei.</param>
        <summary>Gibt den Inhalt einer Textdatei als <see langword="String" /> zurück.</summary>
        <returns>Ein <see langword="String" /> mit dem Inhalt der Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadAllText`-Methode des `My.Computer.FileSystem`-Objekts ermöglicht das Lesen aus einer Textdatei. Der Inhalt der Datei wird als Zeichenfolge zurückgegeben.  
  
 Die Datei Codierung kann angegeben werden, wenn der Inhalt der Datei eine Codierung wie ASCII oder UTF-8 enthält. Wenn Sie aus einer Datei mit erweiterten Zeichen lesen, müssen Sie die Datei Codierung mithilfe einer anderen Überladung der <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText%2A>-Methode angeben.  
  
 Beurteilen Sie den Inhalt der Datei nicht anhand des Dateinamens. Bei der Datei "Form1.vb" handelt es sich zum Beispiel nicht unbedingt um eine Visual Basic-Quelldatei. Überprüfen Sie alle Eingaben, bevor Sie die Daten in der Anwendung verwenden.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.ReadAllText`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen aus einer Textdatei|[Vorgehensweise: Lesen aus Textdateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files)|  
  
   
  
## Examples  
 In diesem Beispiel wird der Inhalt `Test.txt` in eine Zeichenfolge gelesen und dann in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 In diesem Beispiel wird der Inhalt der ASCII-Datei `Test.txt` in eine Zeichenfolge gelesen und dann in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String)" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader">Gewusst wie: Lesen von Text aus Dateien mit einem StreamReader (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/troubleshooting-reading-from-and-writing-to-text-files">Problembehandlung: Lesen aus und Schreiben in Textdateien</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories">Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-encodings">Dateicodierungen</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAllText (file As String, encoding As Encoding) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.ReadAllText : string * System.Text.Encoding -&gt; string" Usage="fileSystemProxy.ReadAllText (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Name und Pfad der zu lesenden Datei.</param>
        <param name="encoding">Die Zeichencodierung, die beim Lesen der Datei verwendet werden soll. Die Standardeinstellung ist UTF-8.</param>
        <summary>Gibt den Inhalt einer Textdatei als <see langword="String" /> zurück.</summary>
        <returns>Ein <see langword="String" /> mit dem Inhalt der Datei.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `ReadAllText`-Methode des `My.Computer.FileSystem`-Objekts ermöglicht das Lesen aus einer Textdatei. Der Inhalt der Datei wird als Zeichenfolge zurückgegeben.  
  
 Die Datei Codierung kann angegeben werden, wenn der Inhalt der Datei eine Codierung wie ASCII oder UTF-8 enthält. Wenn Sie aus einer Datei mit erweiterten Zeichen lesen, müssen Sie die Datei Codierung angeben.  
  
 Beurteilen Sie den Inhalt der Datei nicht anhand des Dateinamens. Bei der Datei "Form1.vb" handelt es sich zum Beispiel nicht unbedingt um eine Visual Basic-Quelldatei. Überprüfen Sie alle Eingaben, bevor Sie die Daten in der Anwendung verwenden.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.ReadAllText`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Lesen aus einer Textdatei|[Vorgehensweise: Lesen aus Textdateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files)|  
  
   
  
## Examples  
 In diesem Beispiel wird der Inhalt `Test.txt` in eine Zeichenfolge gelesen und dann in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 In diesem Beispiel wird der Inhalt der ASCII-Datei `Test.txt` in eine Zeichenfolge gelesen und dann in einem Meldungs Feld angezeigt.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files">Lesen aus Dateien in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader">Gewusst wie: Lesen von Text aus Dateien mit einem StreamReader (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/troubleshooting-reading-from-and-writing-to-text-files">Problembehandlung: Lesen aus und Schreiben in Textdateien</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories">Exemplarische Vorgehensweise: Bearbeiten von Dateien und Verzeichnissen in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/file-encodings">Dateicodierungen</related>
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="member this.RenameDirectory : string * string -&gt; unit" Usage="fileSystemProxy.RenameDirectory (directory, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directory">Der Pfad und der Name des umzubenennenden Verzeichnisses.</param>
        <param name="newName">Neuer Name für das Verzeichnis.</param>
        <summary>Benennt ein Verzeichnis um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nicht zum Verschieben eines Verzeichnisses verwendet werden. Verwenden Sie die `MoveDirectory`-Methode, um das Verzeichnis zu verschieben und umzubenennen.  
  
   
  
## Examples  
 In diesem Beispiel wird das `Test` Verzeichnis in `SecondTest`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> enthält Pfadinformationen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> ist <see langword="Nothing" />.  
  
- oder - 
 Der <paramref name="newName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Es ist eine Datei oder ein Verzeichnis mit dem in <paramref name="newName" /> angegebenen Namen vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths">Gewusst wie: Analysieren von Dateipfaden in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="member this.RenameFile : string * string -&gt; unit" Usage="fileSystemProxy.RenameFile (file, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, die umbenannt werden soll.</param>
        <param name="newName">Neuer Name der Datei.</param>
        <summary>Benennt eine Datei um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nicht dazu verwendet werden, um eine Datei zu verschieben; verwenden Sie die <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile%2A>-Methode, um die Datei zu verschieben und umzubenennen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.RenameFile`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Umbenennen einer Datei|[Gewusst wie: Umbenennen einer Datei](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Datei `Test.txt` in `SecondTest.txt`umbenannt.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Ändern Sie "`C:\Test.txt`" in den Pfad und den Dateinamen der Datei, die Sie umbenennen möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> enthält Pfadinformationen oder endet mit einem umgekehrten Schrägstrich (\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.  
  
- oder - 
 Der <paramref name="newName" /> ist <see langword="Nothing" /> oder eine leere Zeichenfolge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Es ist eine Datei oder ein Verzeichnis mit dem in <paramref name="newName" /> angegebenen Namen vorhanden.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der Benutzer verfügt nicht über die erforderliche Berechtigung.</exception>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories">Erstellen, Löschen und Verschieben von Dateien und Verzeichnissen in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="SpecialDirectories">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy SpecialDirectories { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy SpecialDirectories" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.SpecialDirectories" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SpecialDirectories As SpecialDirectoriesProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::MyServices::SpecialDirectoriesProxy ^ SpecialDirectories { Microsoft::VisualBasic::MyServices::SpecialDirectoriesProxy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SpecialDirectories : Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.SpecialDirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Objekt ab, das Eigenschaften für den Zugriff auf Verzeichnisse bereitstellt, auf die häufig verwiesen wird.</summary>
        <value>Diese Eigenschaft gibt das <see cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />-Objekt für den Computer zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel wird der Dateipfad für das Desktop Verzeichnis des Benutzers zurückgegeben und angezeigt.  
  
 [!code-vb[VbVbcnMyFileSystem#80](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#80)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="member this.WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="fileSystemProxy.WriteAllBytes (file, data, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Der Pfad und Name der Datei, in die geschrieben werden soll.</param>
        <param name="data">Die in die Datei zu schreibenden Daten.</param>
        <param name="append"><see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <summary>Schreibt Daten in eine Binärdatei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der angegebene Pfad ohne den Dateinamen ungültig ist, wird eine <xref:System.IO.DirectoryNotFoundException> Ausnahme ausgelöst. Wenn der Pfad gültig ist, die Datei jedoch nicht vorhanden ist, wird die Datei erstellt.  
  
> [!NOTE]
>  Die `WriteAllBytes`-Methode öffnet eine Datei, schreibt Sie in die Datei und schließt Sie. Code, der die `WriteAllBytes`-Methode verwendet, ist einfacher als Code, der ein <xref:System.IO.BinaryWriter> Objekt verwendet. Wenn Sie jedoch einer Datei mithilfe einer-Schleife Daten hinzufügen, kann ein <xref:System.IO.BinaryWriter> Objekt eine bessere Leistung bereitstellen, da Sie die Datei nur einmal öffnen und schließen müssen.  
  
 In der folgenden Tabelle wird ein Beispiel für eine Aufgabe mit der `My.Computer.FileSystem.WriteAllBytes`-Methode aufgelistet.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Schreiben in eine Binärdatei|[Gewusst wie: Schreiben in Binärdateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files)|  
  
   
  
## Examples  
 In diesem Beispiel wird das Daten Array `CustomerData` an die Datei `CollectedData`angefügt.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files">Gewusst wie: Schreiben in eine Binärdatei in Visual Basic</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt Text in eine Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="member this.WriteAllText : string * string * bool -&gt; unit" Usage="fileSystemProxy.WriteAllText (file, text, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="text">Text, der in eine Datei geschrieben werden soll.</param>
        <param name="append"><see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <summary>Schreibt Text in eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die UTF-8-Codierung wird verwendet, um in die Datei zu schreiben. Verwenden Sie eine andere Überladung der <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A>-Methode, um eine andere Codierung anzugeben.  
  
 Ist die angegebene Datei noch nicht vorhanden, wird diese erstellt.  
  
 Wenn die angegebene Codierung nicht mit der vorhandenen Codierung der Datei identisch ist, wird die angegebene Codierung ignoriert.  
  
> [!NOTE]
>  Die `WriteAllText`-Methode öffnet eine Datei, schreibt Sie in die Datei und schließt Sie. Code, der die `WriteAllText`-Methode verwendet, ist einfacher als Code, der ein <xref:System.IO.StreamWriter> Objekt verwendet. Wenn Sie jedoch einer Datei Zeichen folgen mithilfe einer-Schleife hinzufügen, kann ein <xref:System.IO.StreamWriter> Objekt eine bessere Leistung bereitstellen, da Sie die Datei nur einmal öffnen und schließen müssen. Weitere Informationen finden Sie unter der Methode <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter%2A>.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.WriteAllText`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Schreiben von Text in eine Datei|[Gewusst wie: Schreiben von Text in Dateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files)|  
|Anfügen von Text an eine Datei|[Gewusst wie: Anfügen an Textdateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Zeile `"This is new text to be added."` in die Datei `Test.txt`geschrieben, wobei vorhandener Text in der Datei überschrieben wird.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 In diesem Beispiel werden die Namen der Dateien im `Documents and Settings` Ordner in `FileList.txt`geschrieben, sodass ein Wagen Rücklauf zur besseren Lesbarkeit eingefügt werden kann.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean)" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAllText (file As String, text As String, append As Boolean, encoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="fileSystemProxy.WriteAllText (file, text, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Forms</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="append" Type="System.Boolean" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="file">Die Datei, in die geschrieben werden soll.</param>
        <param name="text">Text, der in eine Datei geschrieben werden soll.</param>
        <param name="append"><see langword="True" />, wenn Daten an den Inhalt der Datei angefügt werden sollen, <see langword="False" />, wenn der Inhalt der Datei überschrieben werden soll. Der Standardwert ist <see langword="False" />.</param>
        <param name="encoding">Die beim Schreiben in die Datei zu verwendende Codierung. Die Standardeinstellung ist UTF-8.</param>
        <summary>Schreibt Text in eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ist die angegebene Datei noch nicht vorhanden, wird diese erstellt.  
  
 Wenn die angegebene Codierung nicht mit der vorhandenen Codierung der Datei identisch ist, wird die angegebene Codierung ignoriert.  
  
> [!NOTE]
>  Die `WriteAllText`-Methode öffnet eine Datei, schreibt Sie in die Datei und schließt Sie. Code, der die `WriteAllText`-Methode verwendet, ist einfacher als Code, der ein <xref:System.IO.StreamWriter> Objekt verwendet. Wenn Sie jedoch einer Datei Zeichen folgen mithilfe einer-Schleife hinzufügen, kann ein <xref:System.IO.StreamWriter> Objekt eine bessere Leistung bereitstellen, da Sie die Datei nur einmal öffnen und schließen müssen. Weitere Informationen finden Sie unter der Methode <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter%2A>.  
  
 In der folgenden Tabelle sind Beispiele für Aufgaben aufgeführt, die die `My.Computer.FileSystem.WriteAllText`-Methode betreffen.  
  
|Beschreibung|Siehe|  
|--------|---------|  
|Schreiben von Text in eine Datei|[Gewusst wie: Schreiben von Text in Dateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files)|  
|Anfügen von Text an eine Datei|[Gewusst wie: Anfügen an Textdateien](/dotnet/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files)|  
  
   
  
## Examples  
 In diesem Beispiel wird die Zeile `"This is new text to be added."` in die Datei `Test.txt`geschrieben, wobei vorhandener Text in der Datei überschrieben wird.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 In diesem Beispiel werden die Namen der Dateien im `Documents and Settings` Ordner in `FileList.txt`geschrieben, sodass ein Wagen Rücklauf zur besseren Lesbarkeit eingefügt werden kann.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Pfad ist aus einem der folgenden Gründe ungültig: Es handelt sich um eine Zeichenfolge der Länge 0; der Pfad enthält nur Leerräume; er enthält ungültige Zeichen; es handelt sich um einen Gerätepfad (beginnt mit \\\\.\\); er endet mit einem nachstehenden Schrägstrich.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> ist <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.IO.IOException">Die Datei wird von einem anderen Prozess verwendet, oder ein E/A-Fehler tritt auf.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der Pfad überschreitet die im System definierte maximale Länge.</exception>
        <exception cref="T:System.NotSupportedException">Ein Datei- oder Verzeichnisname im Pfad enthält einen Doppelpunkt (:) oder hat ein ungültiges Format.</exception>
        <exception cref="T:System.OutOfMemoryException">Es ist nicht genügend Arbeitsspeicher vorhanden, um die Zeichenfolge in den Puffer zu schreiben.</exception>
        <exception cref="T:System.Security.SecurityException">Dem Benutzer fehlen die erforderlichen Berechtigungen zum Anzeigen des Pfads.</exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="/dotnet/visual-basic/language-reference/objects/">Objekte (Visual Basic)</related>
        <related type="Article" href="/dotnet/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files">Schreiben in Dateien in Visual Basic</related>
      </Docs>
    </Member>
  </Members>
</Type>
