<Type Name="XmlDataDocument" FullName="System.Xml.XmlDataDocument">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a4b70d5401a16fe4376b323472deb863f016a788" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70626952" /></Metadata><TypeSignature Language="C#" Value="public class XmlDataDocument : System.Xml.XmlDocument" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDataDocument extends System.Xml.XmlDocument" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDataDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlDataDocument&#xA;Inherits XmlDocument" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlDataDocument : System::Xml::XmlDocument" />
  <TypeSignature Language="F#" Value="type XmlDataDocument = class&#xA;    inherit XmlDocument" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlDocument</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-3.0">
      <AttributeName>System.Obsolete("XmlDataDocument class will be removed in a future release.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Ermöglicht das Speichern, Abrufen und Bearbeiten strukturierter Daten über ein relationales <see cref="T:System.Data.DataSet" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse erweitert <xref:System.Xml.XmlDocument>. Es ermöglicht das Laden von relationalen Daten oder XML-Daten und das Bearbeiten dieser Daten mithilfe der World Wide Web Consortium (W3C) Dokumentobjektmodell (DOM). Das DOM stellt Daten als Hierarchie von Knoten Objekten dar. Da `XmlDataDocument` <xref:System.Xml.Xsl.XslTransform> die <xref:System.Xml.XPath.IXPathNavigable> -Schnittstelle implementiert, kann Sie auch als Quelldokument für die-Klasse verwendet werden.  
  
 `XmlDataDocument`hat eine enge Zugehörigkeit zu der `DataSet` -Klasse, die eine relationale Ansicht der geladenen XML-Daten bereitstellt. Alle Änderungen, die am `XmlDataDocument` vorgenommen werden, werden `DataSet` in und umgekehrt.  
  
 Um ein `DataSet` mit XML-Daten zu laden <xref:System.Data.DataSet.ReadXmlSchema%2A> , verwenden Sie, um eine relationale Zuordnung zu erstellen. Die XML-Daten können dann mithilfe <xref:System.Xml.XmlDataDocument.Load%2A> von oder <xref:System.Xml.XmlDocument.LoadXml%2A>geladen werden.  
  
 Um relationale Daten zu laden, `DataSet` geben Sie das mit den relationalen Daten als <xref:System.Xml.XmlDataDocument.%23ctor%2A> Parameter im Konstruktor an.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xml.XmlDataDocument" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDataDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDataDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xml.XmlDataDocument" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein leeres <xref:System.Data.DataSet> wird erstellt und zugeordnet `XmlDataDocument`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDataDocument (System.Data.DataSet dataset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataSet dataset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.#ctor(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDataDocument(System::Data::DataSet ^ dataset);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDataDocument : System.Data.DataSet -&gt; System.Xml.XmlDataDocument" Usage="new System.Xml.XmlDataDocument dataset" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataset" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataset">Das <see langword="DataSet" />, das in das <see langword="XmlDataDocument" /> geladen werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xml.XmlDataDocument" />-Klasse mit der angegebenen <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `XmlDataDocument` wird mit dem angegebenen `DataSet`synchronisiert. Alle Daten in der `DataSet` sind sofort `XmlDataDocument`über verfügbar. Alle Änderungen in `DataSet` werden in der `XmlDataDocument`weitergegeben. Alle Änderungen `XmlDataDocument`, die in vorgenommen wurden, sofern Sie `DataSet` dem Schema entsprechen `DataSet`, werden im weitergegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Customer-Tabelle in `XmlDataDocument`eine geladen.  
  
 Im Beispiel wird die SQL Server 2000-Datenbank Northwind verwendet.  
  
 [!code-cpp[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.XmlDataDocument1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.XmlDataDocument1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.SqlClient.SqlConnection" />
        <altmember cref="T:System.Data.SqlClient.SqlDataAdapter" />
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberSignature Language="F#" Value="override this.CloneNode : bool -&gt; System.Xml.XmlNode" Usage="xmlDataDocument.CloneNode deep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep"><see langword="true" />, wenn die Teilstruktur unter dem angegebenen Knoten rekursiv geklont werden soll, <see langword="false" />, wenn nur der Knoten selbst geklont werden soll.</param>
        <summary>Erstellt ein Duplikat des aktuellen Knotens.</summary>
        <returns>Der geklonte Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Klonen von wird <xref:System.Data.DataSet> auch das Schema geklont. `XmlDataDocument`  
  
 Wenn `deep` `DataSet` auf `false`festgelegt ist, hat das geklonte keine Daten, d. h. keine Zeilen.  
  
 Wenn `deep` `DataSet` auf `true`festgelegt ist, wird der geklonte mit dem Schema festgelegt und dann mit den Daten aufgefüllt.  
  
 Unter in der `XmlNode` -Klasse finden Sie eine Tabelle, in der beschrieben wird, wie sich diese Methode mit den einzelnen Knoten Typen verhält. <xref:System.Xml.XmlNode.CloneNode%2A>  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein `DataSet` in einen `XmlDataDocument` geladen und anschließend `XmlDataDocument`ein flacher Klon von erstellt.  
  
 Im Beispiel wird die SQL Server 2000-Datenbank Northwind verwendet.  
  
 [!code-cpp[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateElement (prefix As String, localName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlElement ^ CreateElement(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="override this.CreateElement : string * string * string -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.CreateElement (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Das Präfix des neuen Elements. Bei String.Empty oder <see langword="null" /> ist kein Präfix vorhanden.</param>
        <param name="localName">Der lokale Name des neuen Elements.</param>
        <param name="namespaceURI">Der Namespace-URI (Uniform Resource Identifier) des neuen Elements. Bei String.Empty oder <see langword="null" /> ist kein namespaceURI vorhanden.</param>
        <summary>Erstellt ein Element mit der angegebenen <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> und der <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Ein neuer <see cref="T:System.Xml.XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Note to Inheritors`Wenn Sie diese Funktion überladen, kann Sie nicht für die Erweiterbarkeit verwendet werden. Stattdessen können Sie ein Element zurückgeben, das von der Basisklasse erstellt wurde, in `XmlDataDocument`diesem Fall. Weitere Informationen finden Sie im folgenden Beispiel.  
  
```csharp  
class MyXmlDataDocument : XmlDataDocument {  
 public override XmlElement CreateElement(string prefix, string localName, string nsURI) {  
   //Ensure we are returning the base class implementation of element.  
   XmlElement e = base.CreateElement(prefix, localName, nsURI);  
   //Add additional code here.  
   return e;    //Return the element created by XmlDataDocument.  
 }      
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateEntityReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateEntityReference (name As String) As XmlEntityReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlEntityReference ^ CreateEntityReference(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.CreateEntityReference : string -&gt; System.Xml.XmlEntityReference" Usage="xmlDataDocument.CreateEntityReference name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Entitätsverweises.</param>
        <summary>Erstellt eine <see cref="T:System.Xml.XmlEntityReference" /> mit dem angegebenen Namen.</summary>
        <returns>Die <see cref="T:System.Xml.XmlEntityReference" /> mit dem angegebenen Namen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlEntityReference>für <xref:System.Xml.XmlDataDocument> -Objekte können keine Knoten erstellt werden. Das Aufrufen dieser Methode löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Aufrufen dieser Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected override System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateNavigator (node As XmlNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::XmlNode ^ node);" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : System.Xml.XmlNode -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDataDocument.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Xml.XmlNode" />, auf dem Sie den Navigator zunächst positionieren möchten.</param>
        <summary>Erstellt ein neues <see cref="T:System.Xml.XPath.XPathNavigator" />-Objekt zum Navigieren in diesem Dokument. Der <see langword="XPathNavigator" /> ist auf dem im <paramref name="node" />-Parameter angegebenen Knoten positioniert.</summary>
        <returns>Ein zum Navigieren im Dokument verwendeter <see langword="XPathNavigator" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XPathNavigator` Bietet schreibgeschützten, zufälligen Zugriff auf Daten. Da Sie für XSLT-Transformationen optimiert ist, bietet Sie Leistungsvorteile, wenn Sie als Eingabe Mechanismus für <xref:System.Xml.Xsl.XslTransform.Transform%2A> die-Methode verwendet wird.  
  
   
  
## Examples  
 Weitere Informationen zum Anzeigen einer XSLT `XmlDataDocument` `XPathNavigator`-Transformation mithilfe von und <xref:System.Xml.Xsl.XslTransform.Transform%2A?displayProperty=nameWithType> finden Sie unter der-Methode.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Xsl.XslTransform" />
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDataDocument.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Xml.XmlDataDocument.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Data.DataSet" /> ab, das eine relationale Darstellung der Daten im <see langword="XmlDataDocument" /> bereitstellt.</summary>
        <value>Ein <see langword="DataSet" />, das verwendet werden kann, um mithilfe eines relationalen Modells auf die Daten im <see langword="XmlDataDocument" /> zuzugreifen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ermöglicht den Zugriff auf die Daten `XmlDataDocument` in mithilfe eines relationalen Modells. `DataSet` Dies bedeutet, dass Sie die Daten als Tabellen und Sichten, Zeilen und Spalten, Beziehungen usw. verarbeiten können. Im vorgenommene `DataSet` Änderungen werden sofort in der `XmlDataDocument`sichtbar.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Preis eines Buchs mithilfe der `DataSet` -Methoden geändert.  
  
 [!code-cpp[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/VB/source.vb#1)]  
  
 In diesem Beispiel werden die folgenden beiden Dateien als Eingabe verwendet.  
  
 `2books.xml`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#3](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="T:System.Data.DataTable" />
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlElement GetElementById (string elemId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlElement GetElementById(string elemId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementById (elemId As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlElement ^ GetElementById(System::String ^ elemId);" />
      <MemberSignature Language="F#" Value="override this.GetElementById : string -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.GetElementById elemId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elemId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elemId">Die Attribut-ID, mit der eine Übereinstimmung gefunden werden soll.</param>
        <summary>Ruft das <see cref="T:System.Xml.XmlElement" /> mit der angegebenen ID ab. Diese Methode wird von der <see cref="T:System.Xml.XmlDataDocument" />-Klasse nicht unterstützt. Das Aufrufen dieser Methode löst eine Ausnahme aus.</summary>
        <returns>Das <see cref="T:System.Xml.XmlElement" /> mit der angegebenen ID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der <xref:System.Xml.XmlDataDocument>-Klasse nicht unterstützt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Aufrufen dieser Methode.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementFromRow">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement GetElementFromRow (System.Data.DataRow r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement GetElementFromRow(class System.Data.DataRow r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementFromRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementFromRow (r As DataRow) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ GetElementFromRow(System::Data::DataRow ^ r);" />
      <MemberSignature Language="F#" Value="member this.GetElementFromRow : System.Data.DataRow -&gt; System.Xml.XmlElement" Usage="xmlDataDocument.GetElementFromRow r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="r">Das <see langword="DataRow" />, dessen zugeordnete <see langword="XmlElement" /> abgerufen werden soll.</param>
        <summary>Ruft das <see cref="T:System.Xml.XmlElement" /> ab, das der angegebenen <see cref="T:System.Data.DataRow" /> zugeordnet ist.</summary>
        <returns>Das <see langword="XmlElement" />, das eine Darstellung der angegebenen <see langword="DataRow" /> enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird ein `DataSet` -Objekt `XmlDataDocument` in einen geladen und `XmlElement` anschließend ein erstellt, das den ersten Kundendaten Satz darstellt.  
  
 Im Beispiel wird die SQL Server 2000-Datenbank Northwind verwendet.  
  
 [!code-cpp[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDataDocument.GetElementFromRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDataDocument.GetElementFromRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="T:System.Data.DataTable" />
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetElementsByTagName (name As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetElementsByTagName : string -&gt; System.Xml.XmlNodeList" Usage="xmlDataDocument.GetElementsByTagName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name, mit dem eine Übereinstimmung gefunden werden soll. Er wird mit der <see cref="P:System.Xml.XmlDocument.Name" />-Eigenschaft des übereinstimmenden Knotens verglichen. Der spezielle Wert „*“ entspricht allen Tags.</param>
        <summary>Gibt eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Liste aller untergeordneten Elemente zurück, die mit dem angegebenen <see cref="P:System.Xml.XmlDocument.Name" /> übereinstimmen.</summary>
        <returns>Eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Liste aller übereinstimmenden Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Es wird empfohlen, anstelle der- <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> <xref:System.Xml.XmlDataDocument.GetElementsByTagName%2A> Methode <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> die-Methode oder die-Methode zu verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRowFromElement">
      <MemberSignature Language="C#" Value="public System.Data.DataRow GetRowFromElement (System.Xml.XmlElement e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow GetRowFromElement(class System.Xml.XmlElement e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.GetRowFromElement(System.Xml.XmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRowFromElement (e As XmlElement) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ GetRowFromElement(System::Xml::XmlElement ^ e);" />
      <MemberSignature Language="F#" Value="member this.GetRowFromElement : System.Xml.XmlElement -&gt; System.Data.DataRow" Usage="xmlDataDocument.GetRowFromElement e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Xml.XmlElement" />
      </Parameters>
      <Docs>
        <param name="e">Das <see langword="XmlElement" />, dessen zugeordnete <see langword="DataRow" /> abgerufen werden soll.</param>
        <summary>Ruft das <see cref="T:System.Data.DataRow" /> ab, das der angegebenen <see cref="T:System.Xml.XmlElement" /> zugeordnet ist.</summary>
        <returns>Die <see langword="DataRow" /> enthält eine Darstellung des <see langword="XmlElement" />. <see langword="null" />, wenn dem <see langword="DataRow" /> keine <see langword="XmlElement" /> zugeordnet ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird der Preis des ersten Buchs geändert.  
  
 [!code-cpp[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/CPP/getrow.cpp#1)]
 [!code-csharp[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/CS/getrow.cs#1)]
 [!code-vb[XmlDataDocument.GetRowFromElement#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDataDocument.GetRowFromElement/VB/getrow.vb#1)]  
  
 In diesem Beispiel werden die folgenden Eingabedateien verwendet:  
  
 `2books.xml`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[Classic WebData XmlDataDocument.DataSet Example#3](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDataDocument.DataSet Example/XML/source.xml#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt das <see langword="XmlDataDocument" /> mithilfe der angegebenen Datenquelle und synchronisiert das <see cref="T:System.Data.DataSet" /> mit den geladenen Daten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Um die XML-Daten relationale anzuzeigen, müssen Sie zuerst ein Schema angeben, das für die Datenzuordnung verwendet werden soll. Dies kann entweder durch Aufrufen der <xref:System.Data.DataSet.ReadXmlSchema%2A> -Methode oder durch das manuelle Erstellen der Tabellen und Spalten innerhalb der `DataSet` erreicht werden. Dieser Schritt muss ausgeführt werden, bevor `Load`aufgerufen wird.  
  
 `XmlDataDocument`unterstützt nicht das Erstellen von Entitäts verweisen. Wenn die Daten Entitäts Verweise enthalten, `Load` löst die Methode alle Entitäts Verweise auf und erweitert Sie. Wenn Sie jedoch die `Load` -Überladung verwenden, die ein <xref:System.Xml.XmlReader> als Argument annimmt, müssen Sie einen `XmlReader` angeben, der Entitäten auflösen kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (inStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::IO::Stream ^ inStream);" />
      <MemberSignature Language="F#" Value="override this.Load : System.IO.Stream -&gt; unit" Usage="xmlDataDocument.Load inStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">Der Stream, der das zu ladende XML-Dokument enthält.</param>
        <summary>Lädt das <see langword="XmlDataDocument" /> aus dem angegebenen Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument`unterstützt nicht das Erstellen von Entitäts verweisen. Wenn die Daten Entitäts Verweise enthalten, `Load` löst die Methode alle Entitäts Verweise auf und erweitert Sie.  
  
> [!NOTE]
>  Um die XML-Daten relationale anzuzeigen, müssen Sie zuerst ein Schema angeben, das für die Datenzuordnung verwendet werden soll. Dies kann entweder durch Aufrufen der <xref:System.Data.DataSet.ReadXmlSchema%2A> -Methode oder durch das manuelle Erstellen der Tabellen und Spalten innerhalb der `DataSet` erreicht werden. Dieser Schritt muss ausgeführt werden, bevor `Load`aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (txtReader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::IO::TextReader ^ txtReader);" />
      <MemberSignature Language="F#" Value="override this.Load : System.IO.TextReader -&gt; unit" Usage="xmlDataDocument.Load txtReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader">Der zum Übertragen von XML-Daten in das Dokument verwendete <see langword="TextReader" />.</param>
        <summary>Lädt das <see langword="XmlDataDocument" /> aus dem angegebenen <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument`unterstützt nicht das Erstellen von Entitäts verweisen. Wenn die Daten Entitäts Verweise enthalten, `Load` löst die Methode alle Entitäts Verweise auf und erweitert Sie.  
  
> [!NOTE]
>  Um die XML-Daten relationale anzuzeigen, müssen Sie zuerst ein Schema angeben, das für die Datenzuordnung verwendet werden soll. Dies kann entweder durch Aufrufen der <xref:System.Data.DataSet.ReadXmlSchema%2A> -Methode oder durch das manuelle Erstellen der Tabellen und Spalten innerhalb der `DataSet` erreicht werden. Dieser Schritt muss ausgeführt werden, bevor `Load`aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="override this.Load : string -&gt; unit" Usage="xmlDataDocument.Load filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Die URL der Datei, die das zu ladende XML-Dokument enthält.</param>
        <summary>Lädt das <see langword="XmlDataDocument" /> mit der angegebenen URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument`unterstützt nicht das Erstellen von Entitäts verweisen. Wenn die Daten Entitäts Verweise enthalten, `Load` löst die Methode alle Entitäts Verweise auf und erweitert Sie.  
  
> [!NOTE]
>  Um die XML-Daten relationale anzuzeigen, müssen Sie zuerst ein Schema angeben, das für die Datenzuordnung verwendet werden soll. Dies kann entweder durch Aufrufen der <xref:System.Data.DataSet.ReadXmlSchema%2A> -Methode oder durch das manuelle Erstellen der Tabellen und Spalten innerhalb der `DataSet` erreicht werden. Dieser Schritt muss ausgeführt werden, bevor `Load`aufgerufen wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDataDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Load (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.Load : System.Xml.XmlReader -&gt; unit" Usage="xmlDataDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see langword="XmlReader" />, der das zu ladende XML-Dokument enthält.</param>
        <summary>Lädt das <see langword="XmlDataDocument" /> aus dem angegebenen <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDataDocument`unterstützt nicht das Erstellen von Entitäts verweisen. Wenn die Datenquelle Entitäts Verweise enthält, müssen Sie eine <xref:System.Xml.XmlValidatingReader> erstellen, <xref:System.Xml.XmlValidatingReader.EntityHandling%2A> bei der die-Eigenschaft auf EntityHandling. ExpandEntities festgelegt ist (Dies ist das `XmlValidatingReader` Standardverhalten `Load` ) und an die-Methode übergeben. Wenn Sie keinen verwenden `XmlValidatingReader`, löst die `Load` Methode eine Ausnahme aus.  
  
 Die `Load` -Methode behält immer signifikanten Leerraum bei. Die <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> -Eigenschaft bestimmt, ob Leerraum beibehalten wird. Der Standardwert `false`ist, dass Leerraum nicht beibehalten wird.  
  
 Wenn sich der Reader im Anfangszustand befindet (d. h. "Read State" = "Read State `Load` . Initial"), verwendet den gesamten Inhalt des Readers und erstellt das DOM aus dem gefundenen Inhalt.  
  
 Wenn der Reader bereits auf einem Knoten mit der Tiefe "n" positioniert ist, lädt diese Methode diesen Knoten und alle nachfolgenden gleich geordneten Elemente bis zum Endtag, das die Tiefe "n" schließt. Dies hat die folgenden Ergebnisse:  
  
 Wenn der aktuelle Knoten und die folgenden neben geordneten Elemente in etwa wie folgt aussehen:  
  
```xml  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load`löst eine Ausnahme aus, da ein Dokument nicht über zwei Elemente auf Stamm Ebene verfügen kann. Wenn der aktuelle Knoten und die folgenden neben geordneten Elemente in etwa wie folgt aussehen:  
  
```xml  
<!--comment--><?process  
    instruction?><!--comment--></endtag>  
```  
  
 `Load`wird erfolgreich ausgeführt. Sie verfügen jedoch über eine unvollständige DOM-Struktur, da es kein Element auf Stamm Ebene gibt. Sie müssen ein Element auf Stamm Ebene hinzufügen, bevor Sie das Dokument speichern. Andernfalls löst die <xref:System.Xml.XmlDocument.Save%2A> Methode eine Ausnahme aus.  
  
 Wenn sich der Reader auf einem Endknoten befindet, der für die Stammebene eines Dokuments ungültig ist (z. B. ein Leerraum- oder ein Attributknoten), setzt der Reader den Lesevorgang solange fort, bis er sich auf einem Knoten befindet, der als Stamm verwendet werden kann. Das Dokument beginnt an dieser Stelle mit dem Laden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Preis eines Buchs mithilfe der `DataSet` -Methoden geändert.  
  
 [!code-cpp[XmlDataDocument.Load#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDataDocument.Load/CPP/loadrdr.cpp#1)]
 [!code-csharp[XmlDataDocument.Load#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDataDocument.Load/CS/loadrdr.cs#1)]
 [!code-vb[XmlDataDocument.Load#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDataDocument.Load/VB/loadrdr.vb#1)]  
  
 In diesem Beispiel werden die folgenden beiden Eingabedateien verwendet.  
  
 `2books.xml`  
  
 [!code-xml[XmlDataDocument.Load#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDataDocument.Load/XML/2books.xml#2)]  
  
 `store.xsd`  
  
 [!code-xml[XmlDataDocument.Load#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDataDocument.Load/XML/test.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die geladenen XML-Daten enthalten Entitätsverweise, und der Reader kann Entitäten nicht auflösen.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
