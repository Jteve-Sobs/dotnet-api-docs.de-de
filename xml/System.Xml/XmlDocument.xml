<Type Name="XmlDocument" FullName="System.Xml.XmlDocument">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c4dc9d6c30170e2681decaf84b68504524fec1d6" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75045858" /></Metadata><TypeSignature Language="C#" Value="public class XmlDocument : System.Xml.XmlNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDocument extends System.Xml.XmlNode" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlDocument&#xA;Inherits XmlNode" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlDocument : System::Xml::XmlNode" />
  <TypeSignature Language="F#" Value="type XmlDocument = class&#xA;    inherit XmlNode" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlNode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt ein XML-Dokument dar. Sie können diese Klasse zum Laden, Überprüfen, Bearbeiten, Hinzufügen und Positionieren von XML in einem Dokument verwenden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="Remarks"></a>Die <xref:System.Xml.XmlDocument>-Klasse ist eine Speicher interne Darstellung eines XML-Dokuments. Es implementiert die W3C- [XML-Dokumentobjektmodell (DOM)](~/docs/standard/data/xml/xml-document-object-model-dom.md) Level 1 Core und das DOM Level 2 (DOM).  
  
 *DOM* steht für das *Dokument Objektmodell*. Weitere Informationen hierzu finden Sie unter [XML Dokumentobjektmodell (DOM)](~/docs/standard/data/xml/xml-document-object-model-dom.md).  
  
 Sie können XML in das DOM laden, indem Sie die <xref:System.Xml.XmlDocument>-Klasse verwenden und dann XML im Dokument Programm gesteuert lesen, ändern und entfernen.  
  
 Wenn Sie die <xref:System.Xml.XmlDocument>-Klasse öffnen und sehen möchten, wie Sie implementiert wird, finden Sie weitere Informationen unter [Verweis Quelle](https://referencesource.microsoft.com/#System.Xml/Xml/System/Xml/Dom/XmlDocument.cs#f82a4c1bd1f0ee12).  
  
<a name="Common"></a>   
## <a name="tasks"></a>Aufgaben  
  
-   [Laden von XML in das Dokument Objektmodell](#Load)  
  
-   [Überprüfen anhand eines Schemas](#Validation)  
  
-   [Navigieren in der Dokumentstruktur](#Navigate)  
  
-   [Knoten suchen](#Find)  
  
-   [Knoten bearbeiten](#Edit)  
  
-   [Knoten hinzufügen](#Add)  
  
-   [Entfernen von Knoten](#Remove)  
  
-   [Positions Knoten](#Position)  
  
<a name="Load"></a>   
## <a name="load-xml-into-the-document-object-model"></a>Laden von XML in das Dokument Objektmodell  
 Beginnen Sie mit einem XML-Dokument wie diesem mit einigen Büchern in einer Auflistung. Sie enthält die grundlegenden Dinge, die Sie in einem beliebigen XML-Dokument finden, einschließlich eines Namespaces, Elemente, die Daten darstellen, und Attributen, die die Daten beschreiben.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<books xmlns="http://www.contoso.com/books">  
  <book genre="novel" ISBN="1-861001-57-8" publicationdate="1823-01-28">  
    <title>Pride And Prejudice</title>  
    <price>24.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861002-30-1" publicationdate="1985-01-01">  
    <title>The Handmaid's Tale</title>  
    <price>29.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861001-45-3" publicationdate="1811-01-01">  
    <title>Sense and Sensibility</title>  
    <price>19.95</price>  
  </book>  
</books>  
```  
  
 Als Nächstes laden Sie diese Daten in das DOM, damit Sie im Arbeitsspeicher damit arbeiten können. Die gängigste Methode hierfür ist das verweisen auf eine Datei auf dem lokalen Computer oder in einem Netzwerk.  
  
 In diesem Beispiel wird XML aus einer Datei geladen. Wenn die Datei nicht vorhanden ist, generiert Sie lediglich XML und lädt Sie.  
  
 [!code-cpp[XMLProcessingApp#1](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#1)]
 [!code-csharp[XMLProcessingApp#1](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#1)]
 [!code-vb[XMLProcessingApp#1](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#1)]  
  
 **Complete Sample:** [Bearbeiten von XML im Arbeitsspeicher mithilfe der XmlDocument-Klasse und anderer verwandter Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Weitere Informationen:** [Lesen eines XML-Dokuments in das DOM](~/docs/standard/data/xml/reading-an-xml-document-into-the-dom.md)  
  
<a name="Validation"></a>   
## <a name="validate-it-against-a-schema"></a>Überprüfen anhand eines Schemas  
 Beginnen Sie mit einem XML-Schema, das wie folgt aussieht. Dieses Schema definiert die Datentypen im XML-Format und welche Attribute erforderlich sind.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"  
  attributeFormDefault="unqualified"   
  elementFormDefault="qualified"  
  targetNamespace="http://www.contoso.com/books">   
  <xs:element name="books">  
    <xs:complexType>  
      <xs:sequence>  
        <xs:element maxOccurs="unbounded" name="book">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="title" type="xs:string" />  
              <xs:element name="price" type="xs:decimal" />  
            </xs:sequence>  
            <xs:attribute name="genre" type="xs:string" use="required" />  
            <xs:attribute name="ISBN" type="xs:string" use="required" />  
            <xs:attribute name="publicationdate" type="xs:date" use="required" />  
          </xs:complexType>  
        </xs:element>  
      </xs:sequence>  
    </xs:complexType>  
  </xs:element>  
</xs:schema>  
```  
  
 Erstellen Sie ein <xref:System.Xml.XmlReader> Objekt, indem Sie das Schema verwenden, und laden Sie das Objekt dann in das DOM. Erstellen Sie einen Ereignishandler, der ausgeführt wird, wenn der Code versucht, die XML-Datei so zu ändern, dass Sie die Regeln des Schemas verletzen.  
  
 Diese Code Blöcke zeigen Hilfsmethoden, die all dies tun.  
  
 [!code-cpp[XMLProcessingApp#2](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#2)]
 [!code-csharp[XMLProcessingApp#2](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#2)]
 [!code-vb[XMLProcessingApp#2](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#2)]  
  
 **Complete Sample:** [Bearbeiten von XML im Arbeitsspeicher mithilfe der XmlDocument-Klasse und anderer verwandter Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Weitere Informationen:** [Validieren eines XML-Dokuments im Dom](~/docs/standard/data/xml/validating-an-xml-document-in-the-dom.md)  
  
<a name="Navigate"></a>   
## <a name="navigate-the-document-tree"></a>Navigieren in der Dokumentstruktur  
 Sie können Eigenschaften verwenden, um um ein XML-Dokument zu navigieren. Bevor Sie eine dieser Komponenten verwenden, können Sie sich schnell mit einigen Begriffen auseinandersetzen. Ihr Dokument besteht aus Knoten. Jeder Knoten verfügt über einen direkt oberhalb über *geordneten* Knoten. Der einzige Knoten, der über keinen übergeordneten Knoten verfügt, ist der Stamm des Dokuments, da er der Knoten der obersten Ebene ist. Die meisten Knoten können *über unter* geordnete Knoten verfügen, die direkt unterhalb der Knoten liegen. Knoten, die sich auf derselben *Ebene befinden,* sind gleich geordnete Knoten.  
  
 In den folgenden Beispielen wird veranschaulicht, wie Sie den Stamm Knoten abrufen, zum ersten untergeordneten Knoten des Stamm Knotens springen, auf alle untergeordneten Knoten zugreifen, den übergeordneten Knoten zurückkehren und dann über neben geordnete Knoten navigieren.  
  
 **Mit dem Stamm Knoten beginnen**  
  
 In diesem Beispiel wird der Stamm Knoten abgerufen und anschließend verwendet, um den Inhalt des Dokuments an die Konsole auszugeben.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Untergeordnete Knoten erhalten**  
  
 Dieses Beispiel springt zum ersten untergeordneten Knoten des Stamm Knotens und durchläuft dann die untergeordneten Knoten dieses Knotens, sofern vorhanden.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 **Zurück zum übergeordneten Knoten**  
  
 Verwenden Sie die <xref:System.Xml.XmlDocument.ParentNode%2A>-Eigenschaft.  
  
 **Siehe den letzten untergeordneten Knoten.**  
  
 In diesem Beispiel wird der Preis eines Buchs in die Konsole geschrieben. Der Preis Knoten ist das letzte untergeordnete Element eines Book-Knotens.  
  
 [!code-cpp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/VB/source.vb#1)]  
  
 **Vorwärtsnavigation über gleich geordnete Elemente**  
  
 Dieses Beispiel wechselt von Book zu Book. Buch Knoten sind gleich geordnete Knoten.  
  
 [!code-cpp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/VB/source.vb#1)]  
  
 **Rückwärts Navigation zwischen gleich geordneten Elementen**  
  
 Dieses Beispiel wechselt rückwärts von Book zu Book.  
  
 [!code-cpp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/VB/source.vb#1)]  
  
<a name="Find"></a>   
## <a name="find-nodes"></a>Knoten suchen  
 Die gängigste Methode, um einen oder mehrere Knoten von Daten zu finden, ist die Verwendung einer XPath-Abfrage Zeichenfolge, aber es gibt auch Methoden, die keine solche Knoten erfordern.  
  
 **Einen einzelnen Knoten erhalten**  
  
 In diesem Beispiel wird ein Buch mit der ISBN-Nummer angezeigt.  
  
 [!code-cpp[XMLProcessingApp#3](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#3)]
 [!code-csharp[XMLProcessingApp#3](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#3)]
 [!code-vb[XMLProcessingApp#3](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#3)]  
  
 Die in diesem Beispiel verwendete Zeichenfolge ist eine XPath-Abfrage. Weitere Beispiele finden Sie hier: [XPath-Beispiele](https://msdn.microsoft.com/library/ms256086.aspx).  
  
 Sie können die <xref:System.Xml.XmlDocument.GetElementById%2A> auch zum Abrufen von Knoten verwenden. Um diesen Ansatz zu verwenden, müssen Sie IDs in den Dokumenttyp-Definitions Deklarationen der XML-Datei definieren.  
  
 Nachdem Sie einen Knoten erhalten haben, erhalten Sie den Wert von Attributen oder untergeordneten Knoten. In diesem Beispiel wird dies mit einem book-Knoten erledigt.  
  
 [!code-cpp[XMLProcessingApp#4](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#4)]
 [!code-csharp[XMLProcessingApp#4](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#4)]
 [!code-vb[XMLProcessingApp#4](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#4)]  
  
 **Sammlung von Knoten**  
  
 In diesem Beispiel werden alle Bücher ausgewählt, bei denen der Nachname des Autors **Austen**ist, und dann der Preis dieser Bücher geändert wird.  
  
 [!code-cpp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/VB/source.vb#1)]  
  
 Sie können auch eine Sammlung von Knoten mithilfe des Namens des Knotens erhalten. In diesem Beispiel wird z. b. eine Sammlung aller Buchtitel abgerufen.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 **Complete Sample:** [Bearbeiten von XML im Arbeitsspeicher mithilfe der XmlDocument-Klasse und anderer verwandter Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Weitere Informationen:** [Auswählen von Knoten mithilfe der XPath-Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md)  
  
<a name="Edit"></a>   
## <a name="edit-nodes"></a>Knoten bearbeiten  
 In diesem Beispiel werden ein Buch Knoten und seine Attribute bearbeitet.  
  
 [!code-cpp[XMLProcessingApp#7](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#7)]
 [!code-csharp[XMLProcessingApp#7](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#7)]
 [!code-vb[XMLProcessingApp#7](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#7)]  
  
 **Weitere Informationen:** [Ändern von Knoten, Inhalten und Werten in einem XML-Dokument](~/docs/standard/data/xml/modifying-nodes-content-and-values-in-an-xml-document.md)  
  
 **Complete Sample:** [Bearbeiten von XML im Arbeitsspeicher mithilfe der XmlDocument-Klasse und anderer verwandter Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
<a name="Add"></a>   
## <a name="add-nodes"></a>Knoten hinzufügen  
 Um einen Knoten hinzuzufügen, verwenden Sie die <xref:System.Xml.XmlDocument.CreateElement%2A>-Methode oder die <xref:System.Xml.XmlDocument.CreateNode%2A>-Methode.  
  
 Um einen Datenknoten wie z. b. ein Buch hinzuzufügen, verwenden Sie die <xref:System.Xml.XmlDocument.CreateElement%2A>-Methode.  
  
 Verwenden Sie für jeden anderen Knotentyp, z. b. einen Kommentar, einen leer Raum Knoten oder einen CDATA-Knoten, die <xref:System.Xml.XmlDocument.CreateNode%2A>-Methode.  
  
 In diesem Beispiel wird ein Buch Knoten erstellt, dem Knoten Attribute hinzugefügt und dann der Knoten dem Dokument hinzugefügt.  
  
 [!code-cpp[XMLProcessingApp#5](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#5)]
 [!code-csharp[XMLProcessingApp#5](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#5)]
 [!code-vb[XMLProcessingApp#5](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#5)]  
  
 **Complete Sample:** [Bearbeiten von XML im Arbeitsspeicher mithilfe der XmlDocument-Klasse und anderer verwandter Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Weitere Informationen:** [Einfügen von Knoten in ein XML-Dokument](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md)  
  
<a name="Remove"></a>   
## <a name="remove-nodes"></a>Entfernen von Knoten  
 Um einen Knoten zu entfernen, verwenden Sie die <xref:System.Xml.XmlNode.RemoveChild%2A>-Methode.  
  
 In diesem Beispiel wird ein Buch aus dem Dokument und alle Leerzeichen entfernt, die direkt vor dem Buch Knoten angezeigt werden.  
  
 [!code-cpp[XMLProcessingApp#6](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#6)]
 [!code-csharp[XMLProcessingApp#6](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#6)]
 [!code-vb[XMLProcessingApp#6](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#6)]  
  
 **Complete Sample:** [Bearbeiten von XML im Arbeitsspeicher mithilfe der XmlDocument-Klasse und anderer verwandter Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Weitere Informationen:** [Entfernen von Knoten, Inhalten und Werten aus einem XML-Dokument](~/docs/standard/data/xml/removing-nodes-content-and-values-from-an-xml-document.md)  
  
<a name="Position"></a>   
## <a name="position-nodes"></a>Positions Knoten  
 Mithilfe der Methoden <xref:System.Xml.XmlNode.InsertBefore%2A> und <xref:System.Xml.XmlNode.InsertAfter%2A> können Sie auswählen, wo ein Knoten in Ihrem Dokument angezeigt werden soll.  
  
 Dieses Beispiel zeigt zwei Hilfsmethoden. Einer von Ihnen verschiebt einen Knoten in einer Liste nach oben. Der andere verschiebt einen Knoten nach unten.  
  
 Diese Methoden können in einer Anwendung verwendet werden, die es Benutzern ermöglicht, Bücher in einer Liste von Büchern nach oben oder unten zu verschieben. Wenn ein Benutzer ein Buch auswählt und eine nach-oben-oder nach-unten-Taste drückt, könnte der Code Methoden wie diese aufzurufen, um den entsprechenden Buch Knoten vor oder nach anderen Buch Knoten zu positionieren.  
  
 [!code-cpp[XMLProcessingApp#8](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#8)]
 [!code-csharp[XMLProcessingApp#8](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#8)]
 [!code-vb[XMLProcessingApp#8](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#8)]  
  
 **Complete Sample:** [Bearbeiten von XML im Arbeitsspeicher mithilfe der XmlDocument-Klasse und anderer verwandter Typen](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xml.XmlNodeChangedEventHandler" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xml.XmlDocument" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xml.XmlDocument" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden finden Sie ein Beispiel für die Überprüfung der Lade Zeit. Eine Dokumenttyp Definition (DTD), die <xref:System.Xml.XmlReader> überprüft, wird an die <xref:System.Xml.XmlDocument.Load%2A>-Methode übermittelt, und es wird ein <xref:System.Xml.Schema.ValidationEventHandler> bereitgestellt, um Benutzer über Validierungs Fehler zu benachrichtigen. In diesem Beispiel wurde ein Validierungs Fehler gefunden, aber das Dokument ist immer noch geladen. Alternativ können Sie einen validierenden <xref:System.Xml.XmlReader> definieren, um eine Ausnahme auszulösen und den Ladevorgang zu beenden, wenn ein Validierungs Fehler auftritt, indem Sie den <xref:System.Xml.Schema.ValidationEventHandler>nicht angeben. Weitere Informationen zum Überprüfen von XML-Daten finden Sie im Abschnitt Hinweise der <xref:System.Xml.XmlReader>-Referenzseite.  
  
 [!code-cpp[XmlDocument.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.cctor/CPP/docload.cpp#1)]
 [!code-csharp[XmlDocument.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.cctor/CS/docload.cs#1)]
 [!code-vb[XmlDocument.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.cctor/VB/docload.vb#1)]  
  
 In diesem Beispiel wird die Datei `bookDTD.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlDocument.cctor#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.cctor/XML/bookdtd.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlDocument.Load(System.String)" />
        <altmember cref="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected internal XmlDocument (System.Xml.XmlImplementation imp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlImplementation imp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlImplementation)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub New (imp As XmlImplementation)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; XmlDocument(System::Xml::XmlImplementation ^ imp);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDocument : System.Xml.XmlImplementation -&gt; System.Xml.XmlDocument" Usage="new System.Xml.XmlDocument imp" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="imp" Type="System.Xml.XmlImplementation" />
      </Parameters>
      <Docs>
        <param name="imp">Die zu verwendenden <see langword="XmlImplementation" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="XmlDocument" />-Klasse mit dem angegebenen <see cref="T:System.Xml.XmlImplementation" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlDocument(System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlDocument : System.Xml.XmlNameTable -&gt; System.Xml.XmlDocument" Usage="new System.Xml.XmlDocument nt" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">Die zu verwendenden <see langword="XmlNameTable" />.</param>
        <summary>Initialisiert eine neue Instanz der <see langword="XmlDocument" />-Klasse mit dem angegebenen <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlDocument.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Basis-URI des aktuellen Knotens ab.</summary>
        <value>Der Speicherort, von dem aus der Knoten geladen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein vernetztes XML-Dokument besteht aus Datenblöcken, die mit verschiedenen W3C-Standard Inklusions Mechanismen aggregiert werden und daher Knoten enthalten, die von unterschiedlichen Stellen stammen. Der `BaseURI` gibt Aufschluss über den Speicherort dieser Knoten.  
  
 Für Dokument Knoten gibt `BaseURI` den Speicherort des XML-Dokuments zurück. Wenn die `XmlDocument` z. b. mithilfe des folgenden Aufruf`doc.Load("http://server/mydata.xml")`geladen wurde, ist die `BaseURI` für den Dokument Knoten `http://server/mydata.xml`. Wenn die <xref:System.Xml.XmlDocument.Load%2A>-Methode jedoch vom Server an einen anderen URI umgeleitet wird, gibt `BaseURI` den ursprünglichen URI zurück, der an die `Load`-Methode weitergegeben wurde.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM). Weitere Informationen zu `BaseURI` und deren Verhalten mit anderen Knoten Typen finden Sie unter <xref:System.Xml.XmlNode.BaseURI%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberSignature Language="F#" Value="override this.CloneNode : bool -&gt; System.Xml.XmlNode" Usage="xmlDocument.CloneNode deep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep"><see langword="true" />, wenn die Teilstruktur unter dem angegebenen Knoten rekursiv geklont werden soll, <see langword="false" />, wenn nur der Knoten selbst geklont werden soll.</param>
        <summary>Erstellt ein Duplikat dieses Knotens.</summary>
        <returns>Der geklonte <see langword="XmlDocument" />-Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode dient als Kopierkonstruktor für-Knoten. Der geklonte Knoten besitzt kein übergeordnetes Element (<xref:System.Xml.XmlNode.ParentNode%2A> `null`) zurück.  
  
 Wenn `deep` `true`ist, enthält der geklonte Knoten alle untergeordneten Knoten; andernfalls wird nur der Knoten `XmlDocument` geklont. Sehen Sie sich die <xref:System.Xml.XmlNode.CloneNode%2A?displayProperty=nameWithType>-Methode an, um zu sehen, wie sich diese Methode bei anderen Knoten Typen verhält  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Unterschied zwischen einem tiefen und einem flachen Klon.  
  
 [!code-cpp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine <see cref="T:System.Xml.XmlAttribute" /> mit dem angegebenen Namen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (name As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateAttribute : string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Attributs. Wenn der Name einen Doppelpunkt enthält, gibt die <see cref="P:System.Xml.XmlNode.Prefix" />-Eigenschaft den vor dem Doppelpunkt stehenden Teil des Namens und die <see cref="P:System.Xml.XmlDocument.LocalName" />-Eigenschaft den hinter dem Doppelpunkt stehenden Teil wieder. Der <see cref="P:System.Xml.XmlNode.NamespaceURI" /> bleibt leer, sofern das Präfix kein erkanntes integriertes Präfix, z. B. „xmlns“ ist. In diesem Fall hat <see langword="NamespaceURI" /> den Wert <c>http://www.w3.org/2000/xmlns/</c>.</param>
        <summary>Erstellt ein <see cref="T:System.Xml.XmlAttribute" /> mit dem angegebenen <see cref="P:System.Xml.XmlDocument.Name" />.</summary>
        <returns>Die neue <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `XmlAttribute` kann einer <xref:System.Xml.XmlElement> mithilfe der <xref:System.Xml.XmlElement.SetAttributeNode%2A>-Methode hinzugefügt werden.  
  
   
  
## Examples  
 Im folgenden wird ein Attribut erstellt und einem XML-Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAttribute (qualifiedName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="member this.CreateAttribute : string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute (qualifiedName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Der qualifizierte Name des Attributs. Wenn der Name einen Doppelpunkt enthält, gibt die <see cref="P:System.Xml.XmlNode.Prefix" />-Eigenschaft den vor dem Doppelpunkt stehenden Teil des Namens und die <see cref="P:System.Xml.XmlDocument.LocalName" />-Eigenschaft den hinter dem Doppelpunkt stehenden Teil wieder.</param>
        <param name="namespaceURI">Der namespaceURI des Attributs. Wenn der qualifizierte Name das Präfix „xmlns“ enthält, muss dieser Parameter „<c>http://www.w3.org/2000/xmlns/</c>“ lauten.</param>
        <summary>Erstellt ein <see cref="T:System.Xml.XmlAttribute" /> mit dem angegebenen qualifizierten Namen und dem angegebenen <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `XmlAttribute` kann einer <xref:System.Xml.XmlElement> mithilfe der <xref:System.Xml.XmlElement.SetAttributeNode%2A>-Methode hinzugefügt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlAttribute CreateAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlAttribute ^ CreateAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateAttribute : string * string * string -&gt; System.Xml.XmlAttribute&#xA;override this.CreateAttribute : string * string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateAttribute (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Das Präfix des Attributs (sofern vorhanden). „String.Empty“ und <see langword="null" /> sind äquivalent.</param>
        <param name="localName">Der lokale Name des Attributs.</param>
        <param name="namespaceURI">Der Namespace-URI des Attributs (sofern vorhanden). „String.Empty“ und <see langword="null" /> sind äquivalent. Wenn <paramref name="prefix" /> „xmlns“ ist, muss dieser Parameter „<c>http://www.w3.org/2000/xmlns/</c>“ lauten. Andernfalls wird eine Ausnahme ausgelöst.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlAttribute" /> mit dem angegebenen <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> und <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `XmlAttribute` kann einer <xref:System.Xml.XmlElement> mithilfe der <xref:System.Xml.XmlElement.SetAttributeNode%2A>-Methode hinzugefügt werden.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCDataSection">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlCDataSection CreateCDataSection (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlCDataSection CreateCDataSection(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateCDataSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateCDataSection (data As String) As XmlCDataSection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlCDataSection ^ CreateCDataSection(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateCDataSection : string -&gt; System.Xml.XmlCDataSection&#xA;override this.CreateCDataSection : string -&gt; System.Xml.XmlCDataSection" Usage="xmlDocument.CreateCDataSection data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlCDataSection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Der Inhalt des neuen <see langword="XmlCDataSection" />.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlCDataSection" />, der die angegebenen Daten enthält.</summary>
        <returns>Die neue <see langword="XmlCDataSection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 Gemäß der Empfehlung W3C [Extensible Markup Language (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)sind CDATASection-Knoten innerhalb von Element Knoten und EntityReference-Knoten zulässig, wenn der EntityReference-Knoten kein untergeordnetes Element eines Attribut Knotens ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein CDATA-Knoten erstellt und dem Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlComment CreateComment (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlComment CreateComment(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateComment(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateComment (data As String) As XmlComment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlComment ^ CreateComment(System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateComment : string -&gt; System.Xml.XmlComment&#xA;override this.CreateComment : string -&gt; System.Xml.XmlComment" Usage="xmlDocument.CreateComment data" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlComment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">Der Inhalt des neuen <see langword="XmlComment" />.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlComment" />, der die angegebenen Daten enthält.</summary>
        <returns>Die neue <see langword="XmlComment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 Gemäß der Empfehlung W3C- [Extensible Markup Language (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)sind Kommentar Knoten nur in den Knoten Document, Element und EntityReference zulässig, wenn der EntityReference-Knoten kein untergeordnetes Element eines Attribut Knotens ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Kommentar erstellt und einem XML-Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultAttribute">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XmlAttribute CreateDefaultAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDefaultAttribute(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDefaultAttribute (prefix As String, localName As String, namespaceURI As String) As XmlAttribute" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XmlAttribute ^ CreateDefaultAttribute(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateDefaultAttribute : string * string * string -&gt; System.Xml.XmlAttribute&#xA;override this.CreateDefaultAttribute : string * string * string -&gt; System.Xml.XmlAttribute" Usage="xmlDocument.CreateDefaultAttribute (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="localName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="namespaceURI" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="prefix">Das Präfix des Attributs (sofern vorhanden).</param>
        <param name="localName">Der lokale Name des Attributs.</param>
        <param name="namespaceURI">Der Namespace-URI des Attributs (sofern vorhanden).</param>
        <summary>Erstellt ein Standardattribut mit dem angegebenen Präfix, lokalen Namen und Namespace-URI.</summary>
        <returns>Die neue <see cref="T:System.Xml.XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentFragment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentFragment CreateDocumentFragment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentFragment CreateDocumentFragment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentFragment" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentFragment () As XmlDocumentFragment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentFragment ^ CreateDocumentFragment();" />
      <MemberSignature Language="F#" Value="abstract member CreateDocumentFragment : unit -&gt; System.Xml.XmlDocumentFragment&#xA;override this.CreateDocumentFragment : unit -&gt; System.Xml.XmlDocumentFragment" Usage="xmlDocument.CreateDocumentFragment " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentFragment</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine <see cref="T:System.Xml.XmlDocumentFragment" />.</summary>
        <returns>Die neue <see langword="XmlDocumentFragment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 DocumentFragment-Knoten können nicht in ein Dokument eingefügt werden. Allerdings können Sie untergeordnete Elemente des Knotens "DocumentFragment" in ein Dokument einfügen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden neue Knoten zu einem XML-Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType CreateDocumentType (string name, string publicId, string systemId, string internalSubset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentType CreateDocumentType(string name, string publicId, string systemId, string internalSubset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentType(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDocumentType (name As String, publicId As String, systemId As String, internalSubset As String) As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDocumentType ^ CreateDocumentType(System::String ^ name, System::String ^ publicId, System::String ^ systemId, System::String ^ internalSubset);" />
      <MemberSignature Language="F#" Value="abstract member CreateDocumentType : string * string * string * string -&gt; System.Xml.XmlDocumentType&#xA;override this.CreateDocumentType : string * string * string * string -&gt; System.Xml.XmlDocumentType" Usage="xmlDocument.CreateDocumentType (name, publicId, systemId, internalSubset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="publicId" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="systemId" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="internalSubset" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Dokumenttyps.</param>
        <param name="publicId">Der öffentliche Bezeichner des Dokumenttyps oder <see langword="null" />. Sie können einen öffentlichen URI ebenso wie einen Systembezeichner angeben, um den Speicherort der externen DTD-Teilmenge zu identifizieren.</param>
        <param name="systemId">Der Systembezeichner des Dokumenttyps oder <see langword="null" />. Gibt die URL des Dateispeicherorts für die externe DTD-Teilmenge an.</param>
        <param name="internalSubset">Die interne DTD-Teilmenge für den Dokumenttyp oder <see langword="null" />.</param>
        <summary>Gibt ein neues <see cref="T:System.Xml.XmlDocumentType" />-Objekt zurück.</summary>
        <returns>Die neue <see langword="XmlDocumentType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zurückgegebene Knoten hat <xref:System.Xml.XmlDocumentType.Entities%2A> und <xref:System.Xml.XmlDocumentType.Notations%2A> Auflistungen analysiert.  
  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 Gemäß der Empfehlung des W3C- [Extensible Markup Language (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)sind DocumentType-Knoten nur innerhalb von Dokument Knoten zulässig. Jede <xref:System.Xml.XmlDocument> kann nur über einen DocumentType-Knoten verfügen. Der DocumentType-Knoten muss auch vor dem root-Element des `XmlDocument` eingefügt werden (wenn das Dokument bereits ein root-Element aufweist, können Sie keinen DocumentType-Knoten hinzufügen).    
 Wenn die bestandenen Parameter nicht kombiniert werden, um eine gültige `XmlDocumentType`zu erstellen, wird eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein DocumentType-Knoten erstellt und einem XML-Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Diese Methode hat eine Vererbungs Anforderung. Volle Vertrauenswürdigkeit ist erforderlich, um die <see langword="CreateDocumentType" />-Methode zu überschreiben.  
  
Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine <see cref="T:System.Xml.XmlElement" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (name As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Elements. Wenn der Name einen Doppelpunkt enthält, gibt die <see cref="P:System.Xml.XmlNode.Prefix" />-Eigenschaft den vor dem Doppelpunkt stehenden Teil des Namens und die <see cref="P:System.Xml.XmlDocument.LocalName" />-Eigenschaft den hinter dem Doppelpunkt stehenden Teil wieder. Der qualifizierte Name darf nicht das Präfix "xmlns" enthalten.</param>
        <summary>Erstellt ein Element mit dem angegebenen Namen.</summary>
        <returns>Die neue <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die zurückgegebene Instanz die `XmlElement`-Schnittstelle implementiert, sodass Standard Attribute direkt für das zurückgegebene Objekt erstellt werden.  
  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 Gemäß der Empfehlung W3C- [Extensible Markup Language (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)sind Element Knoten innerhalb von Dokument-und Element Knoten sowie in EntityReference-Knoten zulässig, wenn der EntityReference-Knoten kein untergeordnetes Element eines Attribut Knotens ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein neues-Element erstellt und dem Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (qualifiedName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlElement ^ CreateElement(System::String ^ qualifiedName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string * string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement (qualifiedName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">Der qualifizierte Name des Elements. Wenn der Name einen Doppelpunkt enthält, gibt die <see cref="P:System.Xml.XmlNode.Prefix" />-Eigenschaft den vor dem Doppelpunkt stehenden Teil des Namens und die <see cref="P:System.Xml.XmlDocument.LocalName" />-Eigenschaft den hinter dem Doppelpunkt stehenden Teil wieder. Der qualifizierte Name darf nicht das Präfix "xmlns" enthalten.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Erstellt ein <see cref="T:System.Xml.XmlElement" /> mit dem qualifizierten Namen und dem <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der folgende C# Code  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy:item", "urn:abc");  
```  
  
 führt zu einem Element, das dem folgenden XML-Text entspricht.  
  
```  
<xy:item  
       xmlns:xy="urn:abc"/>  
```  
  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 Gemäß der Empfehlung W3C- [Extensible Markup Language (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)sind Element Knoten innerhalb von Dokument-und Element Knoten sowie in EntityReference-Knoten zulässig, wenn der EntityReference-Knoten kein untergeordnetes Element eines Attribut Knotens ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateElement (prefix As String, localName As String, namespaceURI As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ CreateElement(System::String ^ prefix, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateElement : string * string * string -&gt; System.Xml.XmlElement&#xA;override this.CreateElement : string * string * string -&gt; System.Xml.XmlElement" Usage="xmlDocument.CreateElement (prefix, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Das Präfix des neuen Elements (sofern vorhanden). „String.Empty“ und <see langword="null" /> sind äquivalent.</param>
        <param name="localName">Der lokale Name des neuen Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des neuen Elements (sofern vorhanden). „String.Empty“ und <see langword="null" /> sind äquivalent.</param>
        <summary>Erstellt ein Element mit dem angegebenen <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> und der <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see cref="T:System.Xml.XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der folgende C# Code  
  
```csharp  
XmlElement elem;  
elem=doc.CreateElement("xy", "item", "urn:abc");  
```  
  
 erstellt ein-Element, das dem folgenden XML-Text entspricht:  
  
```  
<xy:item xmlns:xy="urn:abc"/>  
```  
  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 Gemäß der Empfehlung W3C- [Extensible Markup Language (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)sind Element Knoten innerhalb von Dokument-und Element Knoten sowie in EntityReference-Knoten zulässig, wenn der EntityReference außerhalb eines Attribut Knotens liegt.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird dem vorhandenen XML-Dokument ein neues-Element hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateEntityReference(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEntityReference (name As String) As XmlEntityReference" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlEntityReference ^ CreateEntityReference(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member CreateEntityReference : string -&gt; System.Xml.XmlEntityReference&#xA;override this.CreateEntityReference : string -&gt; System.Xml.XmlEntityReference" Usage="xmlDocument.CreateEntityReference name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des Entitätsverweises.</param>
        <summary>Erstellt eine <see cref="T:System.Xml.XmlEntityReference" /> mit dem angegebenen Namen.</summary>
        <returns>Die neue <see langword="XmlEntityReference" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Entität, auf die verwiesen wird, bekannt ist, wird die untergeordnete Liste des `XmlEntityReference` Knotens genauso wie der entsprechende <xref:System.Xml.XmlEntity> Knoten erstellt.  
  
 Die im Ersetzungstext für den Entitäts Verweis verwendeten Namespaces werden an den Zeitpunkt gebunden, an dem das übergeordnete Element des Entitäts Verweis Knotens zuerst festgelegt wird (z. b. wenn der Entitäts Verweis Knoten in das Dokument eingefügt wird). Angenommen, Sie haben die folgende Entität:  
  
```  
<!ENTITY a "<b>test</b>">  
```  
  
 Wenn Sie `CreateEntityReference("a")` aufgerufen wird, erhalten Sie einen einzelnen Knoten vom Typ EntityReference ohne untergeordnete Elemente. Wenn Sie diesen Knoten als untergeordnetes Element des folgenden Knotens anfügen,  
  
```  
<item xmlns="urn:1"/>  
```  
  
 zum Zeitpunkt des Aufrufs von <xref:System.Xml.XmlNode.AppendChild%2A>wird das übergeordnete Element des neu erstellten Entitäts Verweis Knotens festgelegt, und die untergeordneten Elemente werden in diesem Namespace Kontext erweitert. Für den untergeordneten Elementknoten `b` wird "NamespaceURI" gleich "`urn:1`" sein. Die untergeordneten Knoten des Entitäts Verweises bleiben unverändert, auch wenn Sie den Entitäts Verweis an eine Stelle im Dokument mit einem anderen Standard Namespace Kontext verschieben. Dies geschieht nicht bei vorhandenen Entitäts Verweis Knoten, wenn Sie Sie entfernen und einfügen, oder für Entitäts Verweise, die mit <xref:System.Xml.XmlDocument.CloneNode%2A>geklont werden. Dies geschieht nur bei neu erstellten Entitäts verweisen.  
  
 Wenn die entsprechende Entität beim Hinzufügen des Entitäts Verweis Knotens nicht in DocumentType definiert ist, ist der einzige untergeordnete Knoten ein leerer Textknoten, da der Entitäts Verweis nicht definiert ist.  
  
 Die integrierten Entitäten amp, lt, gt, apos und quot sind ebenfalls zulässig, und Sie verfügen über einen untergeordneten Textknoten mit dem entsprechenden erweiterten Zeichen Wert.  
  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 Gemäß der Empfehlung W3C [Extensible Markup Language (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)sind EntityReference-Knoten nur innerhalb der Knoten Element, Attribute und EntityReference zulässig.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei Entitäts Verweis Knoten erstellt und in ein XML-Dokument eingefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name ist ungültig (z. B. sind Namen ungültig, die mit "#" beginnen.)</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNavigator">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein neues <see cref="T:System.Xml.XPath.XPathNavigator" />-Objekt zum Navigieren in diesem Dokument.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public override System.Xml.XPath.XPathNavigator CreateNavigator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateNavigator () As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Xml::XPath::XPathNavigator ^ CreateNavigator();" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : unit -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDocument.CreateNavigator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein neues <see cref="T:System.Xml.XPath.XPathNavigator" />-Objekt zum Navigieren in diesem Dokument.</summary>
        <returns>Ein <see cref="T:System.Xml.XPath.XPathNavigator" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Ein Beispiel für die Verwendung dieser Methode finden Sie unter <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateNavigator (node As XmlNode) As XPathNavigator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xml::XPath::XPathNavigator ^ CreateNavigator(System::Xml::XmlNode ^ node);" />
      <MemberSignature Language="F#" Value="override this.CreateNavigator : System.Xml.XmlNode -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlDocument.CreateNavigator node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="node">Der <see cref="T:System.Xml.XmlNode" />, auf dem Sie den Navigator zunächst positionieren möchten.</param>
        <summary>Erstellt ein <see cref="T:System.Xml.XPath.XPathNavigator" />-Objekt zum Navigieren in diesem Dokument, das auf dem angegebenen <see cref="T:System.Xml.XmlNode" /> positioniert ist.</summary>
        <returns>Ein <see cref="T:System.Xml.XPath.XPathNavigator" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Ein Beispiel für die Verwendung dieser Methode finden Sie unter <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNode">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine <see cref="T:System.Xml.XmlNode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (string nodeTypeString, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(string nodeTypeString, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (nodeTypeString As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::String ^ nodeTypeString, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : string * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : string * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (nodeTypeString, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeTypeString" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nodeTypeString">Zeichenfolgenversion des <see cref="T:System.Xml.XmlNodeType" /> für den neuen Knoten. Dieser Parameter muss einer der in der folgenden Tabelle aufgelisteten Werte sein.</param>
        <param name="name">Der qualifizierte Name des neuen Knotens. Wenn der Name einen Doppelpunkt enthält, wird er in eine <see cref="P:System.Xml.XmlNode.Prefix" />-Komponente und eine <see cref="P:System.Xml.XmlDocument.LocalName" />-Komponente aufgelöst.</param>
        <param name="namespaceURI">Der Namespace-URI des neuen Knotens.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlNode" /> mit dem angegebenen Knotentyp, <see cref="P:System.Xml.XmlDocument.Name" /> und <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim `nodeTypeString`-Parameter wird die Groß-/Kleinschreibung beachtet, und es muss einer der Werte in der folgenden Tabelle sein.  
  
|nodeTypeString|XmlNodeType|  
|--------------------|-----------------|  
|Attribut|Attribut|  
|cdatasection|CDATA|  
|Kommentar|Anmerkungen|  
|document|Dokument|  
|"DocumentFragment"|DocumentFragment|  
|DocumentType|DocumentType|  
|Element|Element|  
|EntityReference|EntityReference|  
|ProcessingInstruction|ProcessingInstruction|  
|SignificantWhitespace|SignificantWhitespace|  
|Text|Text|  
|whitespace|Whitespace|  
  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 In der folgenden Tabelle wird gezeigt, wie NodeType [row] in einem anderen NodeType [Column] gemäß der W3C- [Extensible Markup Language Empfehlung (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)zulässig ist.  
  
||Dokument|DocumentType|XmlDeclaration|Element|Attribut|Text|CDATA|Markup|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|no|no|no|no|no|no|no|no|no|  
|`DocumentType`|ja|no|no|no|no|no|no|no|no|  
|`XmlDeclaration`|zwar|no|no|no|no|no|no|no|no|  
|`Element`|ja|no|no|ja|no|no|no|no|Ja * * *|  
|`Attribute`|no|no|no|Ja * * * *|no|no|no|no|no|  
|`Text`|no|no|no|ja|ja|no|no|no|ja|  
|`CDATA`|no|no|no|ja|no|no|no|no|Ja * * *|  
|`Markup**`|ja|no|no|ja|no|no|no|no|no|  
|`EntityReference`|no|no|no|ja|ja|no|no|no|ja|  
  
 \* der XmlDeclaration-Knoten muss das erste untergeordnete Element des Dokument Knotens sein.  
  
 * * Das Markup umfasst processinginkonstruktion-und comment-Knoten.  
  
 Element-und CDATA-Knoten sind nur in EntityReference-Knoten zulässig, wenn der EntityReference-Knoten kein untergeordnetes Element eines Attribut Knotens ist.  
  
 Attribute sind keine untergeordneten Elemente eines Element Knotens. Attribute sind in einer Attribut Auflistung enthalten, die zu einem Element Knoten gehört.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein neues-Element erstellt und in das Dokument eingefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name wurde nicht bereitgestellt und <see langword="XmlNodeType" /> erfordert einen Namen, oder <paramref name="nodeTypeString" /> zählt nicht zu den unten aufgeführten Zeichenfolgen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : System.Xml.XmlNodeType * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : System.Xml.XmlNodeType * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (type, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der <see langword="XmlNodeType" /> des neuen Knotens.</param>
        <param name="name">Der qualifizierte Name des neuen Knotens. Wenn der Name einen Doppelpunkt enthält, wird er in eine <see cref="P:System.Xml.XmlNode.Prefix" />-Komponente und eine <see cref="P:System.Xml.XmlDocument.LocalName" />-Komponente aufgelöst.</param>
        <param name="namespaceURI">Der Namespace-URI des neuen Knotens.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlNode" /> mit dem angegebenen <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlDocument.Name" /> und <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 In der folgenden Tabelle wird gezeigt, wie NodeType [row] in einem anderen NodeType [Column] gemäß der W3C- [Extensible Markup Language Empfehlung (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)zulässig ist.  
  
||Dokument|DocumentType|XmlDeclaration|Element|Attribut|Text|CDATA|Markup|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|no|no|no|no|no|no|no|no|no|  
|`DocumentType`|ja|no|no|no|no|no|no|no|no|  
|`XmlDeclaration`|zwar|no|no|no|no|no|no|no|no|  
|`Element`|ja|no|no|ja|no|no|no|no|Ja * * *|  
|`Attribute`|no|no|no|Ja * * * *|no|no|no|no|no|  
|`Text`|no|no|no|ja|ja|no|no|no|ja|  
|`CDATA`|no|no|no|ja|no|no|no|no|Ja * * *|  
|`Markup**`|ja|no|no|ja|no|no|no|no|no|  
|`EntityReference`|no|no|no|ja|ja|no|no|no|ja|  
  
 \* der XmlDeclaration-Knoten muss das erste untergeordnete Element des Dokument Knotens sein.  
  
 * * Das Markup umfasst processinginkonstruktion-und comment-Knoten.  
  
 Element-und CDATA-Knoten sind nur in EntityReference-Knoten zulässig, wenn der EntityReference-Knoten kein untergeordnetes Element eines Attribut Knotens ist.  
  
 Attribute sind keine untergeordneten Elemente eines Element Knotens. Attribute sind in einer Attribut Auflistung enthalten, die zu einem Element Knoten gehört.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein neues-Element erstellt und in ein XML-Dokument eingefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name wurde nicht bereitgestellt, und <see langword="XmlNodeType" /> erfordert einen Namen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNode (type As XmlNodeType, prefix As String, name As String, namespaceURI As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ CreateNode(System::Xml::XmlNodeType type, System::String ^ prefix, System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member CreateNode : System.Xml.XmlNodeType * string * string * string -&gt; System.Xml.XmlNode&#xA;override this.CreateNode : System.Xml.XmlNodeType * string * string * string -&gt; System.Xml.XmlNode" Usage="xmlDocument.CreateNode (type, prefix, name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der <see langword="XmlNodeType" /> des neuen Knotens.</param>
        <param name="prefix">Das Präfix des neuen Knotens.</param>
        <param name="name">Der lokale Name des neuen Knotens.</param>
        <param name="namespaceURI">Der Namespace-URI des neuen Knotens.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlNode" /> mit dem angegebenen <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.Name" /> und <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>Die neue <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 In der folgenden Tabelle wird gezeigt, wie NodeType [row] in einem anderen NodeType [Column] gemäß der W3C- [Extensible Markup Language Empfehlung (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)zulässig ist.  
  
||Dokument|DocumentType|XmlDeclaration|Element|Attribut|Text|CDATA|Markup|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|no|no|no|no|no|no|no|no|no|  
|`DocumentType`|ja|no|no|no|no|no|no|no|no|  
|`XmlDeclaration`|zwar|no|no|no|no|no|no|no|no|  
|`Element`|ja|no|no|ja|no|no|no|no|Ja * * *|  
|`Attribute`|no|no|no|Ja * * * *|no|no|no|no|no|  
|`Text`|no|no|no|ja|ja|no|no|no|ja|  
|`CDATA`|no|no|no|ja|no|no|no|no|Ja * * *|  
|`Markup**`|ja|no|no|ja|no|no|no|no|no|  
|`EntityReference`|no|no|no|ja|ja|no|no|no|ja|  
  
 \* der XmlDeclaration-Knoten muss das erste untergeordnete Element des Dokument Knotens sein.  
  
 * * Das Markup umfasst processinginkonstruktion-und comment-Knoten.  
  
 Element-und CDATA-Knoten sind nur in EntityReference-Knoten zulässig, wenn der EntityReference-Knoten kein untergeordnetes Element eines Attribut Knotens ist.  
  
 Attribute sind keine untergeordneten Elemente eines Element Knotens. Attribute sind in einer Attribut Auflistung enthalten, die zum Element Knoten gehört.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird dem Dokument ein neues-Element hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Name wurde nicht bereitgestellt, und <see langword="XmlNodeType" /> erfordert einen Namen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProcessingInstruction">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlProcessingInstruction CreateProcessingInstruction (string target, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlProcessingInstruction CreateProcessingInstruction(string target, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateProcessingInstruction(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateProcessingInstruction (target As String, data As String) As XmlProcessingInstruction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlProcessingInstruction ^ CreateProcessingInstruction(System::String ^ target, System::String ^ data);" />
      <MemberSignature Language="F#" Value="abstract member CreateProcessingInstruction : string * string -&gt; System.Xml.XmlProcessingInstruction&#xA;override this.CreateProcessingInstruction : string * string -&gt; System.Xml.XmlProcessingInstruction" Usage="xmlDocument.CreateProcessingInstruction (target, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlProcessingInstruction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Der Name der Verarbeitungsanweisung.</param>
        <param name="data">Die Daten für die Verarbeitungsanweisung.</param>
        <summary>Erstellt eine <see cref="T:System.Xml.XmlProcessingInstruction" /> mit dem angegebenen Namen und den angegebenen Daten.</summary>
        <returns>Die neue <see langword="XmlProcessingInstruction" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 Gemäß der W3C- [Extensible Markup Language Empfehlung (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)sind processinginbaunodes nur innerhalb der Knoten "Document", "Element" und "EntityReference" zulässig, wenn der EntityReference-Knoten kein untergeordnetes Element eines Attribut Knotens ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein processinginkonstruktion-Knoten erstellt und dem Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSignificantWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateSignificantWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateSignificantWhitespace (text As String) As XmlSignificantWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlSignificantWhitespace ^ CreateSignificantWhitespace(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateSignificantWhitespace : string -&gt; System.Xml.XmlSignificantWhitespace&#xA;override this.CreateSignificantWhitespace : string -&gt; System.Xml.XmlSignificantWhitespace" Usage="xmlDocument.CreateSignificantWhitespace text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSignificantWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Die Zeichenfolge darf nur die Zeichen &amp;#20;, &amp;#10;, &amp;#13; und &amp;#9; enthalten.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlSignificantWhitespace" />-Knoten.</summary>
        <returns>Ein neuer <see langword="XmlSignificantWhitespace" />-Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM). Sie wird verwendet, wenn Sie das Dokument manuell formatieren möchten.  
  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird dem Dokument ein signifikanter Leerraum hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTextNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlText CreateTextNode (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlText CreateTextNode(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateTextNode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateTextNode (text As String) As XmlText" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlText ^ CreateTextNode(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateTextNode : string -&gt; System.Xml.XmlText&#xA;override this.CreateTextNode : string -&gt; System.Xml.XmlText" Usage="xmlDocument.CreateTextNode text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlText</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Der Text für den Text-Knoten.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlText" /> mit dem angegebenen Text.</summary>
        <returns>Der neue <see langword="XmlText" />-Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 Gemäß der Empfehlung W3C [Extensible Markup Language (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)sind Text Knoten nur innerhalb der Knoten Element, Attribute und EntityReference zulässig.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein neues-Element erstellt und dem Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlWhitespace CreateWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlWhitespace CreateWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateWhitespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateWhitespace (text As String) As XmlWhitespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlWhitespace ^ CreateWhitespace(System::String ^ text);" />
      <MemberSignature Language="F#" Value="abstract member CreateWhitespace : string -&gt; System.Xml.XmlWhitespace&#xA;override this.CreateWhitespace : string -&gt; System.Xml.XmlWhitespace" Usage="xmlDocument.CreateWhitespace text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Die Zeichenfolge darf nur die Zeichen &amp;#20;, &amp;#10;, &amp;#13; und &amp;#9; enthalten.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlWhitespace" />-Knoten.</summary>
        <returns>Ein neuer <see langword="XmlWhitespace" />-Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM). Sie wird verwendet, wenn Sie das Dokument manuell formatieren möchten.  
  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird dem Dokument Leerraum hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXmlDeclaration">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDeclaration CreateXmlDeclaration (string version, string encoding, string standalone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDeclaration CreateXmlDeclaration(string version, string encoding, string standalone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateXmlDeclaration(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateXmlDeclaration (version As String, encoding As String, standalone As String) As XmlDeclaration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlDeclaration ^ CreateXmlDeclaration(System::String ^ version, System::String ^ encoding, System::String ^ standalone);" />
      <MemberSignature Language="F#" Value="abstract member CreateXmlDeclaration : string * string * string -&gt; System.Xml.XmlDeclaration&#xA;override this.CreateXmlDeclaration : string * string * string -&gt; System.Xml.XmlDeclaration" Usage="xmlDocument.CreateXmlDeclaration (version, encoding, standalone)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDeclaration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.String" />
        <Parameter Name="encoding" Type="System.String" />
        <Parameter Name="standalone" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="version">Die Version muss "1.0" sein.</param>
        <param name="encoding">Der Wert des Codierungsattributs. Dies ist die Codierung, die für das Speichern des <see cref="T:System.Xml.XmlDocument" /> in einer Datei oder einem Stream verwendet wird. Daher muss das Codierungsattribut auf eine von der <see cref="T:System.Text.Encoding" />-Klasse unterstützte Zeichenfolge festgelegt werden. Andernfalls schlägt <see cref="M:System.Xml.XmlDocument.Save(System.String)" /> fehl. Wenn der Wert <see langword="null" /> oder „String.Empty“ ist, schreibt die <see langword="Save" />-Methode kein Codierungsattribut für die XML-Deklaration, und es wird daher die Standardcodierung UTF-8 verwendet.  
  
Wenn das <see langword="XmlDocument" /> in einem <see cref="T:System.IO.TextWriter" /> oder einem <see cref="T:System.Xml.XmlTextWriter" /> gespeichert wird, wird dieser Codierungswert verworfen. Stattdessen wird die Codierung des <see langword="TextWriter" /> oder <see langword="XmlTextWriter" /> verwendet. Dadurch ist gewährleistet, dass die geschriebenen XML-Daten mit der richtigen Codierung eingelesen werden können.</param>
        <param name="standalone">Der Wert muss entweder yes oder no sein. Wenn der Wert <see langword="null" /> oder String.Empty ist, schreibt die <see langword="Save" />-Methode kein eigenständiges Attribut für die XML-Deklaration.</param>
        <summary>Erstellt einen <see cref="T:System.Xml.XmlDeclaration" />-Knoten mit den angegebenen Werten.</summary>
        <returns>Der neue <see langword="XmlDeclaration" />-Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Attribute werden als spezielle Eigenschaften des `XmlDeclaration` Knotens und nicht als <xref:System.Xml.XmlAttribute> Knoten verfügbar gemacht.  
  
 Obwohl diese Methode das neue-Objekt im Kontext des Dokuments erstellt, wird das neue-Objekt nicht automatisch der Dokumentstruktur hinzugefügt. Um das neue-Objekt hinzuzufügen, müssen Sie explizit eine der Knoten Einfügemethoden aufzurufen.  
  
 Gemäß der Empfehlung W3C [Extensible Markup Language (XML) 1,0](https://www.w3.org/TR/1998/REC-xml-19980210)muss der Knoten `XmlDeclaration` der erste Knoten im Dokument sein.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine XML-Deklaration erstellt und dem Dokument hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Werte von <paramref name="version" /> oder <paramref name="standalone" /> unterscheiden sich von den oben angegebenen Werten.</exception>
        <altmember cref="T:System.Xml.XmlDeclaration" />
      </Docs>
    </Member>
    <Member MemberName="DocumentElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement DocumentElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement DocumentElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentElement As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlElement ^ DocumentElement { System::Xml::XmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentElement : System.Xml.XmlElement" Usage="System.Xml.XmlDocument.DocumentElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Stamm-<see cref="T:System.Xml.XmlElement" /> für das Dokument ab.</summary>
        <value>Das <see langword="XmlElement" />, das den Stamm der XML-Dokumentstruktur darstellt. Wenn kein Stamm vorhanden ist, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird das Stamm Element des XML-Dokuments angezeigt.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Ausgabe:**  
  
```  
<book genre="novel" ISBN="1-861001-57-5"><title>Pride And Prejudice</title></book>   
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DocumentType As XmlDocumentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocumentType ^ DocumentType { System::Xml::XmlDocumentType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentType : System.Xml.XmlDocumentType" Usage="System.Xml.XmlDocument.DocumentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Knoten ab, der die DOCTYPE-Deklaration enthält.</summary>
        <value>Der <see cref="T:System.Xml.XmlNode" />, der DocumentType (DOCTYPE-Deklaration) enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein `XmlDocument` kann nur ein untergeordnetes Element aufweisen, <xref:System.Xml.XmlNodeType> gleich DocumentType ist.  
  
> [!NOTE]
>  Diese Eigenschaft ist schreibgeschützt. Um den Knoten DocumentType zu ändern, löschen Sie den vorhandenen Knoten, erstellen Sie einen neuen Knoten mithilfe der <xref:System.Xml.XmlDocument.CreateDocumentType%2A>-Methode, und fügen Sie dem Dokument den neuen Knoten hinzu.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die DOCTYPE-Deklaration für das Dokument abgerufen und angezeigt.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlDocumentType" />
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement GetElementById (string elementId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement GetElementById(string elementId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementById (elementId As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlElement ^ GetElementById(System::String ^ elementId);" />
      <MemberSignature Language="F#" Value="abstract member GetElementById : string -&gt; System.Xml.XmlElement&#xA;override this.GetElementById : string -&gt; System.Xml.XmlElement" Usage="xmlDocument.GetElementById elementId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementId" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="elementId">Die Attribut-ID, mit der eine Übereinstimmung gefunden werden soll.</param>
        <summary>Ruft das <see cref="T:System.Xml.XmlElement" /> mit der angegebenen ID ab.</summary>
        <returns>Das <see langword="XmlElement" /> mit der passenden ID oder <see langword="null" />, wenn kein übereinstimmendes Element gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das Dokument über mehrere Elemente mit der entsprechenden ID verfügt, gibt diese Methode das erste übereinstimmende Element im Dokument zurück.  
  
> [!NOTE]
>  Die DOM-Implementierung muss über Informationen verfügen, die definieren, welche Attribute vom Typ "ID" sind. Obwohl Attribute des Typs ID in XSD-Schemas oder DTDs definiert werden können, unterstützt diese Version des Produkts nur die in DTDs definierten. Attribute mit dem Namen "ID" sind nicht vom Typ "ID", es sei denn, Sie sind in der DTD definiert. Implementierungen, bei denen es nicht bekannt ist, ob die Attribute vom Typ ID den `null`zurückgeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `GetElementById`-Methode verwendet:  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/VB/source.vb#1)]  
  
 Im Beispiel wird die Datei (`ids.xml`) als Eingabe verwendet.  
  
```xml  
<!DOCTYPE root [  
  <!ELEMENT root ANY>   
  <!ELEMENT Person ANY>   
  <!ELEMENT Customer EMPTY>  
  <!ELEMENT Team EMPTY>  
  <!ATTLIST Person SSN ID #REQUIRED>  
  <!ATTLIST Customer id IDREF #REQUIRED >  
  <!ATTLIST Team members IDREFS #REQUIRED>]>  
<root>  
  <Person SSN='A111' Name='Fred'/>  
  <Person SSN='A222' Name='Tom'/>  
  <Customer id='A222334444'/>  
  <Team members='A222334444 A333445555'/>  
</root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetElementsByTagName">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Liste aller Nachfolgerelemente zurück, die mit dem angegebenen Namen übereinstimmen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (name As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetElementsByTagName : string -&gt; System.Xml.XmlNodeList&#xA;override this.GetElementsByTagName : string -&gt; System.Xml.XmlNodeList" Usage="xmlDocument.GetElementsByTagName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name, mit dem eine Übereinstimmung gefunden werden soll. Er wird mit der <see langword="Name" />-Eigenschaft des übereinstimmenden Knotens verglichen. Der spezielle Wert „*“ entspricht allen Tags.</param>
        <summary>Gibt eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Liste aller untergeordneten Elemente zurück, die mit dem angegebenen <see cref="P:System.Xml.XmlDocument.Name" /> übereinstimmen.</summary>
        <returns>Eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Liste aller übereinstimmenden Knoten. Wenn mit <paramref name="name" /> keine Knoten übereinstimmen, ist die zurückgegebene Auflistung leer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Knoten werden in der Reihenfolge platziert, in der Sie im Dokument gefunden werden.  
  
> [!NOTE]
>  Es wird empfohlen, anstelle der <xref:System.Xml.XmlDocument.GetElementsByTagName%2A>-Methode die <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType>-oder <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType>-Methode zu verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein `XmlDocument`-Objekt erstellt und die `GetElementsByTagName`-Methode und das resultierende <xref:System.Xml.XmlNodeList>-Objekt verwendet, um alle Buch Titel anzuzeigen.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 In diesem Beispiel wird die Datei `books.xml` als Eingabe verwendet.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetElementsByTagName (localName As String, namespaceURI As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeList ^ GetElementsByTagName(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetElementsByTagName : string * string -&gt; System.Xml.XmlNodeList&#xA;override this.GetElementsByTagName : string * string -&gt; System.Xml.XmlNodeList" Usage="xmlDocument.GetElementsByTagName (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Der LocalName, mit dem eine Übereinstimmung gefunden werden soll. Der spezielle Wert „*“ entspricht allen Tags.</param>
        <param name="namespaceURI">Der NamespaceURI, mit dem eine Übereinstimmung gefunden werden soll.</param>
        <summary>Gibt eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Liste aller untergeordneten Elemente zurück, die mit dem angegebenen <see cref="P:System.Xml.XmlDocument.LocalName" /> und <see cref="P:System.Xml.XmlNode.NamespaceURI" /> übereinstimmen.</summary>
        <returns>Eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Liste aller übereinstimmenden Knoten. Wenn keine mit dem angegebenen <paramref name="localName" /> und dem <paramref name="namespaceURI" /> kein Knoten übereinstimmt, ist die zurückgegebene Auflistung leer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Knoten werden in der Reihenfolge platziert, in der Sie in der Dokumentstruktur gefunden werden.  
  
> [!NOTE]
>  Es wird empfohlen, anstelle der <xref:System.Xml.XmlDocument.GetElementsByTagName%2A>-Methode die <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType>-oder <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType>-Methode zu verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Implementation">
      <MemberSignature Language="C#" Value="public System.Xml.XmlImplementation Implementation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlImplementation Implementation" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Implementation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Implementation As XmlImplementation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlImplementation ^ Implementation { System::Xml::XmlImplementation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Implementation : System.Xml.XmlImplementation" Usage="System.Xml.XmlDocument.Implementation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlImplementation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xml.XmlImplementation" />-Objekt für das aktuelle Dokument ab.</summary>
        <value>Das <see langword="XmlImplementation" />-Objekt für das aktuelle Dokument.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument` Objekte, die aus demselben `XmlImplementation` erstellt wurden, haben dieselbe <xref:System.Xml.XmlNameTable>gemeinsam. Dies ermöglicht es Benutzern, Attribut-und Elementnamen als-Objekte und nicht als Zeichen folgen zu vergleichen.  
  
 Obwohl die `XmlDocument`-Objekte dieselbe Implementierung verwenden, müssen Sie zum Verschieben von Knoten aus einem Dokument in ein anderes die <xref:System.Xml.XmlDocument.ImportNode%2A>-Methode verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine neue `XmlDocument` mithilfe der Implementierung eines anderen Dokuments erstellt.  
  
 [!code-cpp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ImportNode (System.Xml.XmlNode node, bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ImportNode(class System.Xml.XmlNode node, bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportNode (node As XmlNode, deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ImportNode(System::Xml::XmlNode ^ node, bool deep);" />
      <MemberSignature Language="F#" Value="abstract member ImportNode : System.Xml.XmlNode * bool -&gt; System.Xml.XmlNode&#xA;override this.ImportNode : System.Xml.XmlNode * bool -&gt; System.Xml.XmlNode" Usage="xmlDocument.ImportNode (node, deep)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="node">Der Knoten, der importiert wird.</param>
        <param name="deep"><see langword="true" /> für das Erstellen eines tiefen Klons, andernfalls <see langword="false" />.</param>
        <summary>Importiert einen Knoten aus einem anderen Dokument in das aktuelle Dokument.</summary>
        <returns>Der importierte <see cref="T:System.Xml.XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zurückgegebene Knoten weist kein übergeordnetes Element auf. Der Quellknoten wird nicht geändert oder aus dem ursprünglichen Dokument entfernt. `ImportNode` eine Kopie des Quell Knotens erstellt.  
  
 Beim Importieren eines Knotens wird ein `XmlNode` Objekt erstellt, das im Besitz des importierten Dokuments ist, wobei <xref:System.Xml.XmlNode.Name%2A> und <xref:System.Xml.XmlNode.NodeType%2A> mit dem Quellknoten identisch sind. Das neue-Objekt verfügt auch über die Attribute, die sich auf Namespaces beziehen (<xref:System.Xml.XmlNode.Prefix%2A>, <xref:System.Xml.XmlNode.LocalName%2A>und <xref:System.Xml.XmlNode.NamespaceURI%2A>).  
  
 Abhängig vom Knotentyp des importierten Knotens und dem Wert des Parameters `deep` werden nach Bedarf zusätzliche Informationen kopiert. Diese Methode versucht, das Verhalten zu spiegeln, das erwartet wird, wenn ein XML-oder HTML-Fragment aus einem Dokument in ein anderes kopiert wurde (wobei erkannt wird, dass die beiden Dokumente im XML-Fall unterschiedliche DTDs aufweisen könnten).  
  
 In der folgenden Tabelle wird das spezifische Verhalten der einzelnen <xref:System.Xml.XmlNodeType>beschrieben.  
  
|XmlNodeType|ImportNode (true)|ImportNode (false)|  
|-----------------|------------------------|-------------------------|  
|Attribut|Die <xref:System.Xml.XmlAttribute.Specified%2A>-Eigenschaft wird auf die `true` der generierten <xref:System.Xml.XmlAttribute>festgelegt. Die Nachfolger der Quell `XmlAttribute` werden rekursiv importiert, und die resultierenden Knoten werden wieder zusammengefügt, um die entsprechende Unterstruktur zu bilden.|Der `deep`-Parameter gilt nicht für `XmlAttribute` Knoten. beim Importieren enthalten Sie immer ihre untergeordneten Elemente.|  
|CDATA|Kopiert den Knoten einschließlich der zugehörigen Daten.|Kopiert den Knoten einschließlich der zugehörigen Daten.|  
|Anmerkungen|Kopiert den Knoten einschließlich der zugehörigen Daten.|Kopiert den Knoten einschließlich der zugehörigen Daten.|  
|DocumentFragment|Die untergeordneten Elemente des Quellknotens werden rekursiv importiert. Die daraus resultierenden Knoten werden neu assembliert und bilden die entsprechende Teilstruktur.|Es wird ein leerer <xref:System.Xml.XmlDocumentFragment> generiert.|  
|DocumentType|Kopiert den Knoten einschließlich der zugehörigen Daten.*|Kopiert den Knoten einschließlich der zugehörigen Daten.*|  
|Element|Die Nachfolger des Quell Elements und der angegebenen Attribut Knoten werden rekursiv importiert, und die resultierenden Knoten werden wieder zusammengefügt, um die entsprechende Unterstruktur zu bilden.<br /><br /> Hinweis: Standard Attribute werden nicht kopiert. Wenn das Dokument, in das importiert wird, Standardattribute für diesen Elementnamen definiert, werden diese zugewiesen.|Die angegebenen Attribut Knoten des Quell Elements werden importiert, und die generierten `XmlAttribute` Knoten werden an den generierten <xref:System.Xml.XmlElement>angefügt.<br /><br /> Hinweis: Standard Attribute werden nicht kopiert. Wenn das Dokument, in das importiert wird, Standardattribute für diesen Elementnamen definiert, werden diese zugewiesen.|  
|EntityReference|Da in den Quell-und Ziel Dokumenten die Entitäten unterschiedlich definiert sein können, kopiert diese Methode nur den <xref:System.Xml.XmlEntityReference> Knoten. Der Ersetzungstext ist davon nicht betroffen. Wenn die Entität des Zieldokuments definiert ist, wird deren Wert zugewiesen.|Da in den Quell-und Ziel Dokumenten die Entitäten unterschiedlich definiert sein können, kopiert diese Methode nur den <xref:System.Xml.XmlEntityReference> Knoten. Der Ersetzungstext ist davon nicht betroffen. Wenn die Entität des Zieldokuments definiert ist, wird deren Wert zugewiesen.|  
|ProcessingInstruction|Kopiert den Ziel- und Datenwert des importierten Knotens.|Kopiert den Ziel- und Datenwert des importierten Knotens.|  
|Text|Kopiert den Knoten einschließlich der zugehörigen Daten.|Kopiert den Knoten einschließlich der zugehörigen Daten.|  
|SignificantWhitespace|Kopiert den Knoten einschließlich der zugehörigen Daten.|Kopiert den Knoten einschließlich der zugehörigen Daten.|  
|Whitespace|Kopiert den Knoten einschließlich der zugehörigen Daten.|Kopiert den Knoten einschließlich der zugehörigen Daten.|  
|XmlDeclaration|Kopiert den Ziel- und Datenwert des importierten Knotens.|Kopiert den Ziel- und Datenwert des importierten Knotens.|  
|Alle anderen Knoten Typen.|Diese Knotentypen können nicht importiert werden.|Diese Knotentypen können nicht importiert werden.|  
  
 * Obwohl DocumentType-Knoten importiert werden können, kann ein Dokument nur einen DocumentType aufweisen. Wenn das Dokument derzeit über einen documentype-Knoten verfügt, muss es entfernt werden, bevor ein neues Dokument hinzugefügt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Buch Knoten aus einem zweiten XML-Dokument in das ursprüngliche XML-Dokument importiert.  
  
 [!code-cpp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/VB/source.vb#1)]  
  
 Im Beispiel wird die Datei (`books.xml`) als Eingabe verwendet.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aufrufen dieser Methode für einen Knotentyp, der nicht importiert werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public override string InnerText { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerText {  void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string" Usage="System.Xml.XmlDocument.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Löst in allen Fällen eine <see cref="T:System.InvalidOperationException" /> aus.</summary>
        <value>Die Werte des Knotens und aller diesem untergeordneten Knoten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist nicht implementiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerXml">
      <MemberSignature Language="C#" Value="public override string InnerXml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property InnerXml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerXml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerXml : string with get, set" Usage="System.Xml.XmlDocument.InnerXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Markup ab, das die untergeordneten Elemente des aktuellen Knotens darstellt, oder legt dieses fest.</summary>
        <value>Das Markup der untergeordneten Elemente des aktuellen Knotens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Festlegen dieser Eigenschaft werden die untergeordneten Elemente des Knotens durch den analysierten Inhalt der angegebenen Zeichenfolge ersetzt. Die Analyse wird im Kontext des aktuellen Namespaces durchgeführt.  
  
 `InnerXml` entfernt redundante Namespace Deklarationen. Daher wird die Größe des Dokuments nicht mit redundanten Namespacedeklarationen erhöht, wenn zahlreiche Ausschneide- und Einfügevorgänge erfolgen. Sehen Sie sich das folgende XSL-Dokument an:  
  
```xml  
<xsl:stylesheet version="1.0"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     <xsl:template match="stock">  
         ...  
     </xsl:template>  
    </xsl:stylesheet>  
```  
  
 Die `InnerXml`-Eigenschaft auf dem Stylesheet-Knoten gibt die folgende Zeichenfolge zurück:  
  
```xml  
<xsl:template match="stock"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     ...  
    </xsl:template>  
```  
  
 Beachten Sie die zusätzliche xmlns: XSL-Namespace Deklaration, die verwendet wird, um die Knoten Identität beizubehalten. Wenn Sie diese innere XML-Zeichenfolge erneut einfügen, erhalten Sie das ursprüngliche Dokument. Anders ausgedrückt: `InnerXml` erkennt, dass die xmlns: XSL-Namespace Deklaration redundant ist, da das übergeordnete XSL: Stylesheet-Element bereits über die xmlns: XSL-Namespace Deklaration verfügt und daher entfernt wird.  
  
 Wenn Sie `InnerXml` aus einem Dokument ohne Standard Namespace in ein Dokument mit einem Standard Namespace verschieben, ist das Verhalten etwas anders. Beachten Sie die folgende XML-Zeichenfolge:  
  
```xml  
<test>  
      <item>123</item>  
    </test>  
```  
  
 `InnerXml` gibt eine einfache XML-Zeichenfolge ohne Namespace Deklarationen zurück:  
  
```xml  
<item>123</item>  
```  
  
 Fügen Sie diese Zeichenfolge dann in ein Dokument ein, das über einen Standard Namespace verfügt, z. b. Folgendes:  
  
```xml  
<test2 xmlns="urn:1">  
    </test>  
```  
  
 `InnerXml` analysiert die Zeichenfolge im Kontext, und die neuen Knoten übernehmen den urn: 1-Namespace. Das Ergebnis sieht wie folgt aus:  
  
```xml  
<test2 xmlns="urn:1">  
      <item>123</item>  
    </test>  
```  
  
 Wenn Sie nun nach dem `InnerXml` Fragen, erhalten Sie Folgendes:  
  
```xml  
<item xmlns="urn:1">123</item>  
```  
  
 Wenn das eingefügte Element explizit die Tatsache erhalten soll, dass es aus einem Dokument ohne Namespace stammt, müssen Sie manuell eine xmlns = ""-Deklaration hinzufügen und die resultierende Zeichenfolge einfügen:  
  
```xml  
<item xmlns="">123</item>  
```  
  
 Dies hat folgende Auswirkungen:  
  
1.  Das Ausschnitten und Einfügen von `InnerXml` zwischen Dokumenten, die keine Namespaces verwenden, ist bereinigt und einfach und erstellt keine "xmlns"-Redundanz in ihren Zeichen folgen.  
  
2.  `InnerXml` können auch zum Ausschneiden und Einfügen zwischen Dokumenten verwendet werden, die über mehr als einen Namespace (XSL-Stylesheets) verfügen.  
  
3.  xmlns: XSL-Deklarationen werden automatisch in ihren Zeichen folgen angezeigt und verschwinden in Ihren Knoten Hierarchien.  
  
4.  Wenn Sie `InnerXml` aus einem Dokument mit einem Standard Namespace in ein Dokument mit einem Standard Namespace verschieben, wird der neue Standard Namespace von den neuen Knoten abgerufen.  
  
 Wenn `InnerXml` mit Text, der Entitäts Verweise enthält, die derzeit nicht im Dokument definiert sind, festgelegt ist, enthält die resultierende Struktur leere EntityReference-Knoten.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der beim Festlegen dieser Eigenschaft angegebene XML-Code ist nicht ordnungsgemäß formatiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xml.XmlDocument.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Knoten schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn der aktuelle Knoten schreibgeschützt ist, andernfalls <see langword="false" />. <see langword="XmlDocument" />-Knoten geben immer <see langword="false" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Schreib geschützter Knoten ist ein Knoten, dessen Eigenschaften, Attribute oder untergeordnete Elemente nicht geändert werden können. Sie können einen schreibgeschützten Knoten aus der Struktur entfernen und an anderer Stelle einfügen.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `IsReadOnly`-Eigenschaft veranschaulicht.  
  
 [!code-cpp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt die angegebenen XML-Daten aus einem <see cref="T:System.IO.Stream" />, einer URL, einem <see cref="T:System.IO.TextReader" /> oder einem <see cref="T:System.Xml.XmlReader" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (inStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::Stream ^ inStream);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.Stream -&gt; unit&#xA;override this.Load : System.IO.Stream -&gt; unit" Usage="xmlDocument.Load inStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">Der Stream, der das zu ladende XML-Dokument enthält.</param>
        <summary>Lädt das XML-Dokument aus dem angegebenen Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die `Load`-Methode behält immer signifikanten Leerraum bei. Die <xref:System.Xml.XmlDocument.PreserveWhitespace%2A>-Eigenschaft bestimmt, ob unbedeutender Leerraum, der Leerraum im Element Inhalt ist, beibehalten wird. Der Standardwert ist `false`; Leerraum im Element Inhalt wird nicht beibehalten.  
  
 Wenn Sie eine Validierung durchführen möchten, können Sie eine validierende <xref:System.Xml.XmlReader>-Instanz erstellen, indem Sie die <xref:System.Xml.XmlReaderSettings>-Klasse und die <xref:System.Xml.XmlReader.Create%2A>-Methode verwenden. Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
 Diese Methode erkennt automatisch das Zeichen folgen Format der Eingabe-XML (z. b. UTF-8, ANSI usw.). Wenn die Anwendung wissen muss, welche Codierung zum Lesen des Streams verwendet wird, sollten Sie die Verwendung eines <xref:System.Xml.XmlTextReader> Objekts zum Lesen des Streams in Erwägung gezogen und dann die <xref:System.Xml.XmlTextReader.Encoding%2A?displayProperty=nameWithType>-Eigenschaft verwenden, um die Codierung zu ermitteln. Wenn Sie ein <xref:System.Xml.XmlDocument>-Objekt für die Arbeit mit XML verwenden müssen, können Sie das <xref:System.Xml.XmlTextReader>-Objekt verwenden, um eines zu erstellen. Weitere Informationen finden Sie unter [Lesen von XML-Daten mithilfe von XPathDocument und XmlDocument](~/docs/standard/data/xml/reading-xml-data-using-xpathdocument-and-xmldocument.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Die XML weist einen Lade- oder Analysefehler auf. In diesem Fall wird eine <see cref="T:System.IO.FileNotFoundException" /> ausgelöst.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (txtReader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::IO::TextReader ^ txtReader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.IO.TextReader -&gt; unit&#xA;override this.Load : System.IO.TextReader -&gt; unit" Usage="xmlDocument.Load txtReader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader">Der zum Übertragen von XML-Daten in das Dokument verwendete <see langword="TextReader" />.</param>
        <summary>Lädt das XML-Dokument aus dem angegebenen <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die `Load`-Methode behält immer signifikanten Leerraum bei. Die <xref:System.Xml.XmlDocument.PreserveWhitespace%2A>-Eigenschaft bestimmt, ob unbedeutender Leerraum, der Leerraum im Element Inhalt ist, beibehalten wird. Der Standardwert ist `false`; Leerraum im Element Inhalt wird nicht beibehalten.  
  
 Wenn Sie eine Validierung durchführen möchten, können Sie eine validierende <xref:System.Xml.XmlReader>-Instanz erstellen, indem Sie die <xref:System.Xml.XmlReaderSettings>-Klasse und die <xref:System.Xml.XmlReader.Create%2A>-Methode verwenden. Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.StringReader>-Klasse verwendet, um eine Zeichenfolge von XML-Daten in das `XmlDocument`-Objekt zu laden.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Die XML weist einen Lade- oder Analysefehler auf. In diesem Fall bleibt das Dokument leer.</exception>
        <altmember cref="T:System.IO.StreamReader" />
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; unit&#xA;override this.Load : string -&gt; unit" Usage="xmlDocument.Load filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="filename">Die URL für die Datei, die das zu ladende XML-Dokument enthält. Die URL kann eine lokale Datei oder eine HTTP-URL (eine Webadresse) sein.</param>
        <summary>Lädt das XML-Dokument aus der angegebenen URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die `Load`-Methode behält immer signifikanten Leerraum bei. Die <xref:System.Xml.XmlDocument.PreserveWhitespace%2A>-Eigenschaft bestimmt, ob unbedeutender Leerraum, der Leerraum im Element Inhalt ist, beibehalten wird. Der Standardwert ist `false`; Leerraum im Element Inhalt wird nicht beibehalten.  
  
 Wenn Sie eine Validierung durchführen möchten, können Sie eine validierende <xref:System.Xml.XmlReader>-Instanz erstellen, indem Sie die <xref:System.Xml.XmlReaderSettings>-Klasse und die <xref:System.Xml.XmlReader.Create%2A>-Methode verwenden. Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Die XML weist einen Lade- oder Analysefehler auf. In diesem Fall wird eine <see cref="T:System.IO.FileNotFoundException" /> ausgelöst.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="filename" /> ist eine leere Zeichenfolge, enthält nur Leerzeichen oder mindestens ein ungültiges Zeichen gemäß der Definition von <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="filename" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig (er befindet sich z. B. auf einem nicht zugeordneten Laufwerk).</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="filename" /> hat eine schreibgeschützte Datei angegeben.  
  
- oder - 
Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  
  
- oder - 
 <paramref name="filename" /> hat ein Verzeichnis angegeben.  
  
- oder - 
Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die in <paramref name="filename" /> angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="filename" /> weist ein ungültiges Format auf.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Load (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Xml.XmlReader -&gt; unit&#xA;override this.Load : System.Xml.XmlReader -&gt; unit" Usage="xmlDocument.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der zum Übertragen von XML-Daten in das Dokument verwendete <see langword="XmlReader" />.</param>
        <summary>Lädt das XML-Dokument aus dem angegebenen <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Die `Load`-Methode behält immer signifikanten Leerraum bei. Die <xref:System.Xml.XmlDocument.PreserveWhitespace%2A>-Eigenschaft bestimmt, ob unbedeutender Leerraum, der Leerraum im Element Inhalt ist, beibehalten wird. Der Standardwert ist `false`; Leerraum im Element Inhalt wird nicht beibehalten.  
  
 Wenn sich der Reader im Anfangszustand befindet (<xref:System.Xml.XmlReader.ReadState%2A> = "Read State. Initial"), verwendet `Load` den gesamten Inhalt des Readers und erstellt das DOM aus dem, was es findet.  
  
 Wenn der Reader bereits auf einem Knoten mit der Tiefe "n" positioniert ist, lädt diese Methode diesen Knoten und alle nachfolgenden gleich geordneten Elemente bis zum Endtag, das die Tiefe "n" schließt. Dies hat die folgenden Ergebnisse:  
  
 Wenn der aktuelle Knoten und seine gleich geordneten Elemente wie folgt aussehen:  
  
```xml  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load` löst eine Ausnahme aus, da ein Dokument nicht über zwei Elemente auf Stamm Ebene verfügen kann. Wenn der aktuelle Knoten und seine gleich geordneten Elemente wie folgt aussehen:  
  
```xml  
<!--comment--><?process instruction?><!--comment--></endtag>  
```  
  
 `Load` ist erfolgreich, aber Sie verfügen über eine unvollständige DOM-Struktur, da kein Element auf Stamm Ebene vorhanden ist. Bevor Sie das Dokument speichern, müssen Sie ein Element auf Stamm Ebene hinzufügen. andernfalls wird <xref:System.Xml.XmlDocument.Save%2A> eine Ausnahme auslösen.  
  
 Wenn sich der Reader auf einem Endknoten befindet, der für die Stamm Ebene eines Dokuments ungültig ist (z. b. ein Leerraum-oder Attribut Knoten), wird der Reader so lange fortgesetzt, bis er auf einem Knoten positioniert ist, der für den Stamm verwendet werden kann. Das Dokument beginnt an dieser Stelle mit dem Laden.  
  
 Wenn Sie eine Validierung durchführen möchten, können Sie eine validierende <xref:System.Xml.XmlReader>-Instanz erstellen, indem Sie die <xref:System.Xml.XmlReaderSettings>-Klasse und die <xref:System.Xml.XmlReader.Create%2A>-Methode verwenden. Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird der letzte book-Knoten der `books.xml`-Datei in das XML-Dokument geladen.  
  
 [!code-cpp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/VB/source.vb#1)]  
  
 Im Beispiel wird die Datei (`books.xml`) als Eingabe verwendet.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Die XML weist einen Lade- oder Analysefehler auf. In diesem Fall bleibt das Dokument leer.</exception>
        <altmember cref="T:System.Xml.Schema.ValidationEventArgs" />
        <altmember cref="T:System.Xml.Schema.XmlSeverityType" />
        <altmember cref="P:System.Xml.XmlValidatingReader.Schemas" />
      </Docs>
    </Member>
    <Member MemberName="LoadXml">
      <MemberSignature Language="C#" Value="public virtual void LoadXml (string xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadXml(string xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadXml (xml As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadXml(System::String ^ xml);" />
      <MemberSignature Language="F#" Value="abstract member LoadXml : string -&gt; unit&#xA;override this.LoadXml : string -&gt; unit" Usage="xmlDocument.LoadXml xml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xml" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">Zeichenfolge, die das zu ladende XML-Dokument enthält.</param>
        <summary>Lädt das XML-Dokument aus der angegebenen Zeichenfolge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird in der `LoadXml`-Methode kein Leerraum oder signifikanter Leerraum beibehalten.  
  
 Diese Methode analysiert DTDs, aber keine DTD-oder Schema Validierung. Wenn Sie eine Validierung durchführen möchten, können Sie eine validierende <xref:System.Xml.XmlReader>-Instanz erstellen, indem Sie die <xref:System.Xml.XmlReaderSettings>-Klasse und die <xref:System.Xml.XmlReader.Create%2A>-Methode verwenden. Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 Wenn Sie aus einer <xref:System.IO.Stream>, <xref:System.String>, <xref:System.IO.TextReader>oder <xref:System.Xml.XmlReader>laden möchten, verwenden Sie anstelle dieser Methode die Load-Methode.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird XML in ein `XmlDocument` Objekt geladen und in einer Datei gespeichert.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Die XML weist einen Lade- oder Analysefehler auf. In diesem Fall bleibt das Dokument leer.</exception>
        <altmember cref="P:System.Xml.XmlDocument.PreserveWhitespace" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlDocument.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den lokalen Namen des Knotens ab.</summary>
        <value>Für <see langword="XmlDocument" />-Knoten lautet der lokale Name „#document“.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zurückgegebene lokale Name hängt vom <xref:System.Xml.XmlDocument.NodeType%2A> des Knotens ab. Eine Tabelle, in der der für die einzelnen Knoten Typen zurückgegebene lokale Name beschrieben wird, finden Sie in der <xref:System.Xml.XmlNode.LocalName%2A>-Eigenschaft in der <xref:System.Xml.XmlNode>-Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlDocument.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den qualifizierten Namen des Knotens ab.</summary>
        <value>Für <see langword="XmlDocument" />-Knoten lautet der Name „#document“.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zurückgegebene Name hängt vom <xref:System.Xml.XmlDocument.NodeType%2A> des Knotens ab. Eine Tabelle mit einer Beschreibung des für die einzelnen Knoten Typen zurückgegebenen Namens finden Sie unter der <xref:System.Xml.XmlNode.Name%2A>-Eigenschaft in der <xref:System.Xml.XmlNode>-Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlDocument.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Xml.XmlNameTable" /> ab, die dieser Implementierung zugeordnet ist.</summary>
        <value>Eine <see langword="XmlNameTable" />, die das Abrufen der atomisierten Version einer Zeichenfolge im Dokument ermöglicht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jedes `XmlDocument`-Objekt verfügt über ein <xref:System.Xml.NameTable>-Objekt. Element-und Attributnamen werden in der `NameTable` als atomisierte Zeichen folgen gespeichert. Dies bedeutet, dass selbst dann, wenn im Dokument mehrmals auf einen Namen verwiesen wird, das Dokument nur einmal in der `NameTable`gespeichert wird. Wenn das Dokument z. b. mehrere Elemente mit dem Namen "Customer" enthielt, gibt `NameTable` dasselbe Objekt zurück, wenn es eine Anforderung für diesen Namen erhält. Folglich können Benutzercode mithilfe von Objekt vergleichen für diese Zeichen folgen anstelle der kostspielteren Zeichen folgen Vergleiche schreiben.  
  
 Weitere Informationen zu atomisierten Zeichenfolgen finden Sie unter <xref:System.Xml.XmlNameTable>.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanged">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanged As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanged;" />
      <MemberSignature Language="F#" Value="member this.NodeChanged : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeChanged : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Xml.XmlNode.Value" /> eines zu diesem Dokument gehörenden Knotens geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis gilt nur für Knoten mit einem Wert.  
  
 Alle von diesem Dokument erstellten Knoten, unabhängig davon, ob Sie in das Dokument eingefügt wurden, sind in diesem Ereignis enthalten.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeChanging">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeChanging As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeChanging;" />
      <MemberSignature Language="F#" Value="member this.NodeChanging : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeChanging : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der <see cref="P:System.Xml.XmlNode.Value" /> eines zu diesem Dokument gehörenden Knotens gerade geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis ermöglicht dem Benutzer, zusätzliche Überprüfungen durchzuführen und ggf. eine Ausnahme auszulösen, um den Vorgang zu beenden. Wenn eine Ausnahme ausgelöst wird, wird der `XmlDocument` in seinen ursprünglichen Zustand zurückversetzt. Dieses Ereignis gilt nur für Knoten mit einem Wert.  
  
 Alle von diesem Dokument erstellten Knoten, unabhängig davon, ob Sie in das Dokument eingefügt wurden, sind in diesem Ereignis enthalten.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserted">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserted" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserted As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserted;" />
      <MemberSignature Language="F#" Value="member this.NodeInserted : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeInserted : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein zu diesem Dokument gehörender Knoten in einen anderen Knoten eingefügt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle von diesem Dokument erstellten Knoten, unabhängig davon, ob Sie in das Dokument eingefügt wurden, sind in diesem Ereignis enthalten.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeInserting">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserting" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeInserting As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeInserting;" />
      <MemberSignature Language="F#" Value="member this.NodeInserting : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeInserting : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein zu diesem Dokument gehörender Knoten gerade in einen anderen Knoten eingefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis ermöglicht dem Benutzer, zusätzliche Überprüfungen durchzuführen und ggf. eine Ausnahme auszulösen, um den Vorgang zu beenden. Wenn eine Ausnahme ausgelöst wird, wird der `XmlDocument` in seinen ursprünglichen Zustand zurückversetzt.  
  
 Alle von diesem Dokument erstellten Knoten, unabhängig davon, ob Sie in das Dokument eingefügt wurden, sind in diesem Ereignis enthalten.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoved">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoved As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoved;" />
      <MemberSignature Language="F#" Value="member this.NodeRemoved : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeRemoved : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein zu diesem Dokument gehörender Knoten aus dem übergeordneten Element entfernt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle von diesem Dokument erstellten Knoten, unabhängig davon, ob Sie in das Dokument eingefügt wurden, sind in diesem Ereignis enthalten.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeRemoving">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoving" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NodeRemoving As XmlNodeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Xml::XmlNodeChangedEventHandler ^ NodeRemoving;" />
      <MemberSignature Language="F#" Value="member this.NodeRemoving : System.Xml.XmlNodeChangedEventHandler " Usage="member this.NodeRemoving : System.Xml.XmlNodeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein zu diesem Dokument gehörender Knoten gerade aus dem Dokument entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis ermöglicht dem Benutzer, zusätzliche Überprüfungen durchzuführen und ggf. eine Ausnahme auszulösen, um den Vorgang zu beenden. Wenn eine Ausnahme ausgelöst wird, wird der `XmlDocument` in seinen ursprünglichen Zustand zurückversetzt.  
  
 Alle von diesem Dokument erstellten Knoten, unabhängig davon, ob Sie in das Dokument eingefügt wurden, sind in diesem Ereignis enthalten.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNodeChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlDocument.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des aktuellen Knotens ab.</summary>
        <value>Der Knotentyp. Für <see langword="XmlDocument" />-Knoten ist dieser Wert „XmlNodeType.Document“.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="OwnerDocument">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlDocument OwnerDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocument OwnerDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.OwnerDocument" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property OwnerDocument As XmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocument ^ OwnerDocument { System::Xml::XmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDocument : System.Xml.XmlDocument" Usage="System.Xml.XmlDocument.OwnerDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xml.XmlDocument" /> ab, zu dem der aktuelle Knoten gehört.</summary>
        <value>Für <see langword="XmlDocument" />-Knoten (<see cref="P:System.Xml.XmlDocument.NodeType" /> entspricht „XmlNodeType.Document“) gibt diese Eigenschaft immer <see langword="null" /> zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode ParentNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode ParentNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.ParentNode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ParentNode As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ ParentNode { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentNode : System.Xml.XmlNode" Usage="System.Xml.XmlDocument.ParentNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den übergeordneten Knoten dieses Knotens ab (bei Knoten, die über übergeordnete Knoten verfügen können).</summary>
        <value>Gibt immer <see langword="null" /> zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveWhitespace">
      <MemberSignature Language="C#" Value="public bool PreserveWhitespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public Property PreserveWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PreserveWhitespace { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PreserveWhitespace : bool with get, set" Usage="System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Leerraum im Elementinhalt beibehalten wird, oder legt diesen fest.</summary>
        <value><see langword="true" />, um Leerraum beizubehalten, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bestimmt, wie Leerraum während des Lade-und Speicher Prozesses behandelt wird.  
  
 Wenn `PreserveWhitespace` `true`, bevor <xref:System.Xml.XmlDocument.Load%2A> oder <xref:System.Xml.XmlDocument.LoadXml%2A> aufgerufen wird, werden leer Raum Knoten beibehalten. Andernfalls wird, wenn diese Eigenschaft `false`ist, ein signifikanter Leerraum beibehalten, Leerzeichen nicht.  
  
 Wenn `PreserveWhitespace` vor dem Aufruf von <xref:System.Xml.XmlDocument.Save%2A> `true` wird, wird der Leerraum im Dokument in der Ausgabe beibehalten. Wenn diese Eigenschaft `false`ist, `XmlDocument` die Ausgabe andernfalls automatisch eingerückt.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Leerraum aus einer Datei entfernt wird.  
  
 [!code-cpp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/VB/source.vb#1)]  
  
 Im Beispiel wird die Datei `book.xml` als Eingabe verwendet.  
  
 [!code-xml[Classic WebData XmlDocument.PreserveWhitespace Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ReadNode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ReadNode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ReadNode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadNode (reader As XmlReader) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ReadNode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadNode : System.Xml.XmlReader -&gt; System.Xml.XmlNode&#xA;override this.ReadNode : System.Xml.XmlReader -&gt; System.Xml.XmlNode" Usage="xmlDocument.ReadNode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Die XML-Quelle</param>
        <summary>Erstellt anhand der Informationen im <see cref="T:System.Xml.XmlNode" /> ein <see cref="T:System.Xml.XmlReader" />-Objekt. Der Reader muss auf einem Knoten oder Attribut positioniert sein.</summary>
        <returns>Der neue <see langword="XmlNode" /> oder <see langword="null" />, wenn keine weiteren Knoten vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liest eine `XmlNode` aus dem angegebenen Reader und positioniert den Reader auf dem nächsten Knoten. Diese Methode erstellt den Typ der `XmlNode`, die mit dem <xref:System.Xml.XmlNode.NodeType%2A> übereinstimmt, auf dem der Reader gerade positioniert ist. (Wenn sich der Reader im ursprünglichen Zustand befindet, verschiebt `ReadNode` den Reader auf den ersten Knoten und arbeitet dann mit diesem Knoten.)  
  
 Wenn sich der Reader am Anfang eines Elements befindet, liest `ReadNode` alle Attribute und alle untergeordneten Knoten, bis einschließlich des Endtags des aktuellen Knotens. Der zurückgegebene `XmlNode` enthält die Unterstruktur, die alle gelesenen Elemente darstellt. Der Reader befindet sich unmittelbar nach dem Endtag.  
  
 `ReadNode` können auch Attribute lesen, aber in diesem Fall wird der Reader nicht auf das nächste Attribut zurückzuführen. Auf diese Weise können Sie den folgenden C# Code schreiben:  
  
```csharp  
XmlDocument doc = new XmlDocument();  
while (reader.MoveToNextAttribute())  
{  
  XmlNode a = doc.ReadNode(reader);  
  // Do some more processing.  
}  
```  
  
 `ReadNode` verwendet jedoch den Attribut Wert. Dies bedeutet, dass <xref:System.Xml.XmlReader.ReadAttributeValue%2A?displayProperty=nameWithType> `false`zurückgibt, nachdem `ReadNode` für ein Attribut aufgerufen wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird `ReadNode` verwendet, um einen neuen Knoten zu erstellen, und dann wird der neue Knoten in das Dokument eingefügt.  
  
 [!code-cpp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/VB/source.vb#1)]  
  
 Im Beispiel wird die Datei (`cd.xml`) als Eingabe verwendet.  
  
 [!code-xml[Classic WebData XmlDocument.ReadNode Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Der Reader ist auf einem Knotentyp positioniert, der nicht in einen gültigen DOM-Knoten übersetzt wird (z. B. EndElement oder EndEntity).</exception>
        <block subset="none" type="overrides"><para>Diese Methode hat eine Vererbungs Anforderung. Volle Vertrauenswürdigkeit ist erforderlich, um die <see langword="ReadNode" />-Methode zu überschreiben.  
  
Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).</para></block>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Speichert das XML-Dokument am angegebenen Speicherort.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.Stream outStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.Stream outStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (outStream As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::Stream ^ outStream);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.IO.Stream -&gt; unit&#xA;override this.Save : System.IO.Stream -&gt; unit" Usage="xmlDocument.Save outStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="outStream">Der Stream, in dem gespeichert werden soll.</param>
        <summary>Speichert das XML-Dokument im angegebenen Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leerraum wird nur beibehalten, wenn <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> auf `true`festgelegt ist.  
  
 Die XmlDeclaration des aktuellen `XmlDocument` Objekts bestimmt das Codierungs Attribut im gespeicherten Dokument. Der Wert des Codierungs Attributs wird aus der <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType>-Eigenschaft entnommen. Wenn der `XmlDocument` nicht über eine XmlDeclaration verfügt oder wenn die XmlDeclaration über kein Codierungs Attribut verfügt, enthält das gespeicherte Dokument keines.  
  
 Wenn das Dokument gespeichert wird, werden xmlns-Attribute generiert, um die Knoten Identität (lokaler Name und Namespace-URI) ordnungsgemäß beizubehalten. Der folgende C# Code wird z. b.  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 generiert dieses xmls-Attribut `<item xmls="urn:1"/>`.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
 Beachten Sie, dass nur die <xref:System.Xml.XmlDocument.Save%2A>-Methode ein wohl geformtes XML-Dokument erzwingt. Alle anderen `Save` Überladungen garantieren nur ein wohl geformtes Fragment.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der Vorgang führt nicht zu einem wohlgeformten XML-Dokument (z. B. zu keinem Dokumentelement oder zu doppelten XML-Deklarationen).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.IO.TextWriter -&gt; unit&#xA;override this.Save : System.IO.TextWriter -&gt; unit" Usage="xmlDocument.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der <see langword="TextWriter" />, in dem gespeichert werden soll.</param>
        <summary>Speichert das XML-Dokument im angegebenen <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Codierung auf der `TextWriter` bestimmt die auszuschreibender Codierung (die Codierung des Knotens "XmlDeclaration" wird durch die Codierung der `TextWriter`ersetzt). Wenn für den `TextWriter`keine Codierung angegeben wurde, wird die `XmlDocument` ohne Codierungs Attribut gespeichert.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
 Beachten Sie, dass nur die <xref:System.Xml.XmlDocument.Save%2A>-Methode ein wohl geformtes XML-Dokument erzwingt. Alle anderen `Save` Überladungen garantieren nur ein wohl geformtes Fragment.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der Vorgang führt nicht zu einem wohlgeformten XML-Dokument (z. B. zu keinem Dokumentelement oder zu doppelten XML-Deklarationen).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="abstract member Save : string -&gt; unit&#xA;override this.Save : string -&gt; unit" Usage="xmlDocument.Save filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="filename">Der Speicherort der Datei, in der Sie das Dokument speichern möchten.</param>
        <summary>Speichert das XML-Dokument in der angegebenen Datei. Die angegebene Datei existiert, diese Methode überschreibt sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leerraum wird in der Ausgabedatei nur beibehalten, wenn <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> auf `true`festgelegt ist.  
  
 Die XmlDeclaration des aktuellen `XmlDocument` Objekts bestimmt das Codierungs Attribut im gespeicherten Dokument. Der Wert des Codierungs Attributs wird aus der <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType>-Eigenschaft entnommen. Wenn der `XmlDocument` nicht über eine XmlDeclaration verfügt oder wenn die XmlDeclaration über kein Codierungs Attribut verfügt, enthält das gespeicherte Dokument keines.  
  
 Wenn das Dokument gespeichert wird, werden xmlns-Attribute generiert, um die Knoten Identität (lokaler Name und Namespace-URI) ordnungsgemäß beizubehalten. Der folgende C# Code wird z. b.  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 generiert dieses xmls-Attribut `<item xmls="urn:1"/>`.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
 Beachten Sie, dass nur die <xref:System.Xml.XmlDocument.Save%2A>-Methode ein wohl geformtes XML-Dokument erzwingt. Alle anderen `Save` Überladungen garantieren nur ein wohl geformtes Fragment.  
  
   
  
## Examples  
 Im folgenden Beispiel wird XML in ein XmlDocument-Objekt geladen, geändert und dann in einer Datei namens "Data. xml" gespeichert.  
  
 [!code-cpp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/VB/source.vb#1)]  
  
 Die Datei "Data. xml" enthält den folgenden XML-Code: `<item><name>wrench</name><price>10.95</price></item>`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der Vorgang führt nicht zu einem wohlgeformten XML-Dokument (z. B. zu keinem Dokumentelement oder zu doppelten XML-Deklarationen).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Save (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Save(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="abstract member Save : System.Xml.XmlWriter -&gt; unit&#xA;override this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.Save w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">Der <see langword="XmlWriter" />, in dem gespeichert werden soll.</param>
        <summary>Speichert das XML-Dokument im angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Leerraum wird nur beibehalten, wenn <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> auf `true`festgelegt ist.  
  
 Die Codierung auf der `XmlWriter` bestimmt die auszuschreibender Codierung (die Codierung des Knotens "XmlDeclaration" wird durch die Codierung der `XmlWriter`ersetzt). Wenn für den `XmlWriter`keine Codierung angegeben wurde, wird die `XmlDocument` ohne Codierungs Attribut gespeichert.  
  
 Wenn das Dokument gespeichert wird, werden xmlns-Attribute generiert, um die Knoten Identität (LocalName + NamespaceURI) ordnungsgemäß beizubehalten. Der folgende C# Code wird z. b.  
  
```csharp  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 generiert dieses xmls-Attribut:  
  
```xml  
<item  
    xmls="urn:1"/>  
```  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
 Beachten Sie, dass nur die <xref:System.Xml.XmlDocument.Save%2A>-Methode ein wohl geformtes XML-Dokument erzwingt. Alle anderen `Save` Überladungen garantieren nur ein wohl geformtes Fragment.  
  
   
  
## Examples  
 Im folgenden Beispiel wird XML in ein `XmlDocument` Objekt geladen und in einer Datei gespeichert.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der Vorgang führt nicht zu einem wohlgeformten XML-Dokument (z. B. zu keinem Dokumentelement oder zu doppelten XML-Deklarationen).</exception>
        <altmember cref="P:System.Xml.XmlTextWriter.Formatting" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public override System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlDocument.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt das PSVI (Post-Schema-Validation Infoset) des Knotens zurück.</summary>
        <value>Das <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />-Objekt, das das PSVI des Knotens darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der PSVI-Inhalt dieser Eigenschaft wird festgelegt, nachdem der Knoten überprüft wurde.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaSet Schemas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaSet Schemas" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Schemas" />
      <MemberSignature Language="VB.NET" Value="Public Property Schemas As XmlSchemaSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Schema::XmlSchemaSet ^ Schemas { System::Xml::Schema::XmlSchemaSet ^ get(); void set(System::Xml::Schema::XmlSchemaSet ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Schemas : System.Xml.Schema.XmlSchemaSet with get, set" Usage="System.Xml.XmlDocument.Schemas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xml.Schema.XmlSchemaSet" />-Objekt ab, das diesem <see cref="T:System.Xml.XmlDocument" /> zugeordnet ist, oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Xml.Schema.XmlSchemaSet" />-Objekt, das die diesem <see cref="T:System.Xml.XmlDocument" /> zugeordneten XSD-Schemas (XML Schema Definition) enthält, andernfalls ein leeres <see cref="T:System.Xml.Schema.XmlSchemaSet" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Schemas, die in einem <xref:System.Xml.Schema.XmlSchemaSet> Objekt enthalten sind, das einem <xref:System.Xml.XmlDocument>-Objekt zugeordnet ist, werden für die Validierung verwendet, wenn die <xref:System.Xml.XmlDocument.Validate%2A>-Methode einer <xref:System.Xml.XmlDocument> ausgeführt wird.  
  
 Wenn ein <xref:System.Xml.XmlDocument> Objekt mit XML-Daten aus einem <xref:System.Xml.XmlReader> Objekt initialisiert wird, wird das <xref:System.Xml.Schema.XmlSchemaSet> Objekt aus der <xref:System.Xml.XmlReaderSettings.Schemas%2A>-Eigenschaft des <xref:System.Xml.XmlReader> Objekts geladen.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.XmlDocument.Validate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Validiert das <see cref="T:System.Xml.XmlDocument" /> anhand der in der <see cref="P:System.Xml.XmlDocument.Schemas" />-Eigenschaft enthaltenen XSD-Schemas (XML Schema Definition).</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler);" />
      <MemberSignature Language="F#" Value="member this.Validate : System.Xml.Schema.ValidationEventHandler -&gt; unit" Usage="xmlDocument.Validate validationEventHandler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">Das <see cref="T:System.Xml.Schema.ValidationEventHandler" />-Objekt, das Informationen zu Warnungen und Fehlern der Schemavalidierung empfängt.</param>
        <summary>Validiert das <see cref="T:System.Xml.XmlDocument" /> anhand der in der <see cref="P:System.Xml.XmlDocument.Schemas" />-Eigenschaft enthaltenen XSD-Schemas (XML Schema Definition).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xml.XmlDocument.Validate%2A>-Methode überprüft die XML-Daten in der <xref:System.Xml.XmlDocument> mit den Schemas, die in der <xref:System.Xml.XmlDocument.Schemas%2A>-Eigenschaft enthalten sind. Die <xref:System.Xml.XmlDocument.Validate%2A>-Methode führt die Infoset-Erweiterung aus. Vor der erfolgreichen Validierung werden standardmäßig Schema Standardwerte angewendet, Textwerte werden bei Bedarf in atomarische Werte konvertiert, und Typinformationen sind validierten Informations Elementen zugeordnet. Das Ergebnis ist eine zuvor nicht typisierte XML-Unterstruktur in der <xref:System.Xml.XmlDocument> die durch eine typisierte Unterstruktur ersetzt wurde.  
  
 Beachten Sie die folgenden wichtigen Hinweise, wenn Sie die <xref:System.Xml.XmlDocument.Validate%2A>-Methode verwenden.  
  
-   Schema-Speicherort Hinweise wie `xsi:schemaLocation` oder `xsi:noNamespaceSchemaLocation` werden ignoriert.  
  
-   Inline Schemas werden ignoriert.  
  
-   Wenn während der Validierung Schema Validierungs Fehler auftreten, wird der <xref:System.Xml.XmlDocument> teilweise mit einigen Knoten mit korrekten Typinformationen und einigen ohne überprüft.  
  
-   Der Überprüfungsprozess umfasst die Überprüfung auf Eindeutigkeit und Verweis Einschränkungen (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`und `xs:unique`).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Xml.XmlDocument.Validate%2A>-Methode veranschaulicht. Im Beispiel wird eine <xref:System.Xml.XmlDocument> erstellt, die ein zugeordnetes XSD-Schema mit den <xref:System.Xml.XmlReaderSettings>-und <xref:System.Xml.XmlReader>-Objekten enthält. Im Beispiel wird dann die <xref:System.Xml.XPath.XPathNavigator>-Klasse verwendet, um den typisierten Wert eines Elements im XML-Dokument zu ändern, wodurch ein Schema Validierungs Fehler erzeugt wird.  
  
 [!code-cpp[XPathValidation#1](~/samples/snippets/cpp/VS_Snippets_Data/XPathValidation/CPP/XPathValidation.cpp#1)]
 [!code-csharp[XPathValidation#1](~/samples/snippets/csharp/VS_Snippets_Data/XPathValidation/CS/XPathValidation.cs#1)]
 [!code-vb[XPathValidation#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XPathValidation/VB/XPathValidation.vb#1)]  
  
 Im Beispiel werden die `contosoBooks.xml`-und `contosoBooks.xsd` Dateien als Eingabe angenommen.  
  
 [!code-xml[XPathXMLExamples#2](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xml#2)]  
  
 [!code-xml[XPathXMLExamples#3](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Ein Schemavalidierungsereignis ist aufgetreten, und es wurde kein <see cref="T:System.Xml.Schema.ValidationEventHandler" />-Objekt angegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler, System.Xml.XmlNode nodeToValidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler, class System.Xml.XmlNode nodeToValidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Validate(System::Xml::Schema::ValidationEventHandler ^ validationEventHandler, System::Xml::XmlNode ^ nodeToValidate);" />
      <MemberSignature Language="F#" Value="member this.Validate : System.Xml.Schema.ValidationEventHandler * System.Xml.XmlNode -&gt; unit" Usage="xmlDocument.Validate (validationEventHandler, nodeToValidate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="nodeToValidate" Type="System.Xml.XmlNode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">Das <see cref="T:System.Xml.Schema.ValidationEventHandler" />-Objekt, das Informationen zu Warnungen und Fehlern der Schemavalidierung empfängt.</param>
        <param name="nodeToValidate">Das <see cref="T:System.Xml.XmlNode" />-Objekt, das aus einem zu validierenden <see cref="T:System.Xml.XmlDocument" /> erstellt wurde.</param>
        <summary>Validiert das angegebene <see cref="T:System.Xml.XmlNode" />-Objekt anhand der in der <see cref="P:System.Xml.XmlDocument.Schemas" />-Eigenschaft enthaltenen XSD-Schemas (XML Schema Definition).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xml.XmlDocument.Validate%2A>-Methode überprüft die XML-Daten im <xref:System.Xml.XmlNode>-Objekt anhand der Schemas, die in der <xref:System.Xml.XmlDocument.Schemas%2A>-Eigenschaft enthalten sind. Die <xref:System.Xml.XmlDocument.Validate%2A>-Methode führt die Infoset-Erweiterung aus. Vor der erfolgreichen Validierung werden standardmäßig Schema Standardwerte angewendet, Textwerte werden bei Bedarf in atomarische Werte konvertiert, und Typinformationen sind validierten Informations Elementen zugeordnet. Das Ergebnis ist eine zuvor nicht typisierte XML-Unterstruktur in der <xref:System.Xml.XmlDocument> die durch eine typisierte Unterstruktur ersetzt wurde.  
  
 Beachten Sie die folgenden wichtigen Hinweise, wenn Sie die <xref:System.Xml.XmlDocument.Validate%2A>-Methode verwenden.  
  
-   Schema-Speicherort Hinweise wie `xsi:schemaLocation` oder `xsi:noNamespaceSchemaLocation` werden ignoriert.  
  
-   Inline Schemas werden ignoriert.  
  
-   Wenn während der Validierung Schema Validierungs Fehler auftreten, wird der <xref:System.Xml.XmlDocument> teilweise mit einigen Knoten mit korrekten Typinformationen und einigen ohne überprüft.  
  
 Wenn es sich bei dem zu überprüfenden Knoten um den Stamm Knoten handelt, umfasst der Überprüfungsprozess die Überprüfung auf Eindeutigkeit und Verweis Einschränkungen (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`und `xs:unique`). Andernfalls werden Eindeutigkeit und Verweis Einschränkungen ausgelassen.  
  
   
  
## Examples  
 Ein Beispiel für die <xref:System.Xml.XmlDocument.Validate%2A>-Methode finden Sie unter der <xref:System.Xml.XmlDocument.Validate%2A>-Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <see cref="T:System.Xml.XmlNode" />-Objektparameter wurde nicht aus einem <see cref="T:System.Xml.XmlDocument" /> erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlNode" />-Objektparameter ist kein Element, Attribut, Dokumentfragment oder der Stammknoten.</exception>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Ein Schemavalidierungsereignis ist aufgetreten, und es wurde kein <see cref="T:System.Xml.Schema.ValidationEventHandler" />-Objekt angegeben.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteContentTo">
      <MemberSignature Language="C#" Value="public override void WriteContentTo (System.Xml.XmlWriter xw);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteContentTo(class System.Xml.XmlWriter xw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteContentTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteContentTo (xw As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteContentTo(System::Xml::XmlWriter ^ xw);" />
      <MemberSignature Language="F#" Value="override this.WriteContentTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.WriteContentTo xw" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xw" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="xw">Der <see langword="XmlWriter" />, in dem gespeichert werden soll.</param>
        <summary>Speichert alle untergeordneten Elemente des <see langword="XmlDocument" />-Knotens im angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM). Sie ist funktional äquivalent zur <xref:System.Xml.XmlDocument.InnerXml%2A>-Eigenschaft.  
  
 Die <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType>-Eigenschaft bestimmt die ausgegeschriebene Codierung. Wenn die `Encoding`-Eigenschaft keinen Wert hat, wird die `XmlDocument` ohne Codierungs Attribut geschrieben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Dokument auf dem Bildschirm angezeigt.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="override this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlDocument.WriteTo w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">Der <see langword="XmlWriter" />, in dem gespeichert werden soll.</param>
        <summary>Speichert den <see langword="XmlDocument" />-Knoten im angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM). Sie ist funktional äquivalent zur <xref:System.Xml.XmlNode.OuterXml%2A>-Eigenschaft.  
  
 Die <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType>-Eigenschaft bestimmt die ausgegeschriebene Codierung. Wenn die `Encoding`-Eigenschaft keinen Wert hat, wird die `XmlDocument` ohne Codierungs Attribut geschrieben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Dokument auf dem Bildschirm angezeigt.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XmlResolver : System.Xml.XmlResolver" Usage="System.Xml.XmlDocument.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Legt den für die Auflösung externer Ressourcen zu verwendenden <see cref="T:System.Xml.XmlResolver" /> fest.</summary>
        <value>Die zu verwendenden <see langword="XmlResolver" />.  
  
In .NET Framework, Version 1.1, kann nur ein vollständig vertrauenswürdiger Aufrufer einen <see langword="XmlResolver" /> festlegen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `XmlResolver` kann zum Laden von DTDs oder zum Erweitern von Entitäts verweisen verwendet werden. Mithilfe der <xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=nameWithType>-Eigenschaft können Sie Anmelde Informationen für den `XmlResolver` festlegen, um auf Ressourcen zuzugreifen, die in einer sicheren Netzwerkressource gespeichert sind.  
  
-   Wenn das Dokument nicht mit einem <xref:System.Xml.XmlReader> geladen wurde (d. h., wenn es mit einem Stream, einer Datei usw. geladen wurde), wird der `XmlResolver` auf dem `XmlDocument` immer verwendet.  
  
-   Wenn das Dokument mit einem <xref:System.Xml.XmlTextReader>geladen wurde, wird der Konflikt Löser für die `XmlTextReader` verwendet, um alle DTD-Verweise im DocumentType-Knoten aufzulösen. Der Konflikt Löser auf dem `XmlDocument` wird zum Erweitern von Entitäts verweisen verwendet.  
  
-   Wenn das Dokument mit einem <xref:System.Xml.XmlValidatingReader>geladen wurde, wird der Konflikt Löser für die `XmlDocument` nie verwendet.  
  
-   Wenn das Dokument mit einer Klasse geladen wurde, die `XmlReader` erweitert, und die `XmlReader` Entitäten nicht auflösen kann (<xref:System.Xml.XmlReader.CanResolveEntity%2A> gibt `false`zurück), wird der `XmlResolver` auf der `XmlDocument` zum Auflösen aller Verweise im DocumentType-Knoten und zum Erweitern von Entitäts verweisen verwendet.  
  
> [!NOTE]
>  Wenn der `XmlDocument` mit einem <xref:System.Xml.XmlReader> geladen wird, für den ein `XmlResolver` festgelegt wurde, wird der `XmlResolver` auf dem `XmlReader` nach Abschluss `XmlDocument` nicht durch den <xref:System.Xml.XmlDocument.Load%2A> zwischengespeichert.  
  
 Wenn diese Eigenschaft in Version 1,1 von The.NET Framework nicht festgelegt ist, bestimmt die Vertrauens Ebene der Anwendung das Standardverhalten.  
  
 `Fully trusted code:` das Dokument eine Standard <xref:System.Xml.XmlUrlResolver> ohne Benutzer Anmelde Informationen verwendet. Wenn für den Zugriff auf eine Netzwerkressource eine Authentifizierung erforderlich ist, verwenden Sie die `XmlResolver`-Eigenschaft, um eine `XmlResolver` mit den erforderlichen Anmelde Informationen anzugeben.  
  
 `Semi-trusted code:` die `XmlResolver`-Eigenschaft auf `null`festgelegt ist. Externe Ressourcen werden nicht aufgelöst.  
  
 Weitere Informationen zur Sicherheit und zur `XmlResolver`-Eigenschaft finden Sie unter [Auflösen externer Ressourcen](~/docs/standard/data/xml/resolving-external-resources.md).  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein XML-Dokument geladen, das einen Verweis auf eine DTD-Datei enthält. Mit der `XmlResolver`-Eigenschaft werden die Anmelde Informationen festgelegt, die für den Zugriff auf die Netzwerkressource erforderlich sind.  
  
 [!code-cpp[XmlDocument.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.XmlResolver/CPP/docresolver.cpp#1)]
 [!code-csharp[XmlDocument.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.XmlResolver/CS/docresolver.cs#1)]
 [!code-vb[XmlDocument.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.XmlResolver/VB/docresolver.vb#1)]  
  
 In diesem Beispiel werden die folgenden Datendateien als Eingabe verwendet.  
  
 `book5.xml`  
  
 [!code-xml[XmlDocument.XmlResolver#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/book5.xml#2)]  
  
 `books.dtd`  
  
 [!code-xml[XmlDocument.XmlResolver#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/books.dtd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Diese Eigenschaft ist auf <see langword="null" /> festgelegt, und es wird eine externe DTD oder Entität gefunden.</exception>
        <altmember cref="P:System.Xml.XmlUrlResolver.Credentials" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Xml.XmlSecureResolver" />
      </Docs>
    </Member>
  </Members>
</Type>
