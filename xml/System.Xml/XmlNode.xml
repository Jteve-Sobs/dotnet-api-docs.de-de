<Type Name="XmlNode" FullName="System.Xml.XmlNode">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7ffa841e8f3c9ac33d056009f411f09d7820dc40" /><Meta Name="ms.sourcegitcommit" Value="a22d0855bbf24d893f43605f8b7e3a44bd9551a5" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70372091" /></Metadata><TypeSignature Language="C#" Value="public abstract class XmlNode : ICloneable, System.Collections.IEnumerable, System.Xml.XPath.IXPathNavigable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlNode extends System.Object implements class System.Collections.IEnumerable, class System.ICloneable, class System.Xml.XPath.IXPathNavigable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlNode" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlNode&#xA;Implements ICloneable, IEnumerable, IXPathNavigable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlNode abstract : ICloneable, System::Collections::IEnumerable, System::Xml::XPath::IXPathNavigable" />
  <TypeSignature Language="F#" Value="type XmlNode = class&#xA;    interface ICloneable&#xA;    interface IEnumerable&#xA;    interface IXPathNavigable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.XPath.IXPathNavigable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen einzelnen Knoten im XML-Dokument dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Klasse implementiert den W3C-Dokumentobjektmodell (DOM) Level 1 Core und das DOM Level 2 (DOM). DOM ist eine Strukturdarstellung eines XML-Dokuments im Arbeitsspeicher (Cache). `XmlNode`ist die Basisklasse in der .NET-Implementierung des DOM. Sie unterstützt die XPath-Auswahl und stellt Bearbeitungsfunktionen bereit. Die <xref:System.Xml.XmlDocument> -Klasse `XmlNode` erweitert und stellt ein XML-Dokument dar. Sie können verwenden `XmlDocument` , um XML-Daten zu laden und zu speichern. Sie enthält auch Methoden für die Knoten Erstellung. Weitere Informationen finden Sie unter [XML Dokumentobjektmodell (DOM)](~/docs/standard/data/xml/xml-document-object-model-dom.md) .  
  
> [!IMPORTANT]
>  Ausnahmen, die aufgrund der Verwendung der <xref:System.Xml.XmlNode> -Klasse ausgelöst werden, z. b. die <xref:System.Xml.XmlException> -Klasse, können vertrauliche Informationen enthalten, die in nicht vertrauenswürdigen Szenarien nicht verfügbar gemacht werden sollen. Ausnahmen sollten ordnungsgemäß behandelt werden, damit diese vertraulichen Informationen in nicht vertrauenswürdigen Szenarios nicht verfügbar gemacht werden.  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Xml.XmlNode.SelectNodes(System.String)" />
    <related type="Article" href="~/docs/standard/data/xml/create-new-nodes-in-the-dom.md">[&lt;topic://cpconCreateNewNodesInDOM&gt;]</related>
  </Docs>
  <Members>
    <Member MemberName="AppendChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode AppendChild (System.Xml.XmlNode newChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode AppendChild(class System.Xml.XmlNode newChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.AppendChild(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AppendChild (newChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ AppendChild(System::Xml::XmlNode ^ newChild);" />
      <MemberSignature Language="F#" Value="abstract member AppendChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.AppendChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.AppendChild newChild" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="newChild">Der hinzuzufügende Knoten. Der gesamte Inhalt des hinzuzufügenden Knotens wird an den angegebenen Speicherort verschoben.</param>
        <summary>Fügt den angegebenen Knoten am Ende der Liste der untergeordneten Knoten dieses Knotens hinzu.</summary>
        <returns>Der hinzugefügte Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich `newChild` die bereits in der Struktur befindet, wird Sie von der ursprünglichen Position entfernt und ihrer Zielposition hinzugefügt. Weitere Informationen zum Einfügen von Knoten finden Sie unter [Einfügen von Knoten in ein XML-Dokument](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md).  
  
 Wenn der Knoten, der eingefügt wird, aus einem anderen Dokument erstellt wurde <xref:System.Xml.XmlDocument.ImportNode%2A?displayProperty=nameWithType> , können Sie verwenden, um den Knoten in das aktuelle Dokument zu importieren. Der importierte Knoten kann dann in das aktuelle Dokument eingefügt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird dem XML-Dokument ein neuer Knoten hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlNode.AppendChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.AppendChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.AppendChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.AppendChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.AppendChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.AppendChild Example/VB/source.vb#1)]  
  
 **Ausgabe:**  
  
```  
Display the modified XML...  
<?xml version="1.0" encoding="IBM437"?>  
<book genre="novel" ISBN="1-861001-57-5">  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Typ dieses Knotens lässt keine untergeordneten Knoten vom Typ des <paramref name="newChild" />-Knotens zu.  
  
<paramref name="newChild" /> ist eine frühere Version dieses Knotens.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newChild" /> wurde nicht aus dem Dokument erstellt, aus dem dieser Knoten erstellt wurde.  
  
Dieser Knoten ist schreibgeschützt.</exception>
        <block subset="none" type="overrides"><para>Wenn Sie <see langword="AppendChild" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die-Methode der Basisklasse aufzurufen, damit Ereignisse ordnungsgemäß ausgelöst werden. <see langword="AppendChild" /></para></block>
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/891e54f5-54f6-4bb4-b624-9d1b6a1f1216">Einfügen von Knoten in ein XML-Dokument</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlAttributeCollection Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlAttributeCollection Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Attributes As XmlAttributeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlAttributeCollection ^ Attributes { System::Xml::XmlAttributeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Xml.XmlAttributeCollection" Usage="System.Xml.XmlNode.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttributeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Xml.XmlAttributeCollection" /> ab, die die Attribute dieses Knotens enthält.</summary>
        <value>Eine <see langword="XmlAttributeCollection" />, die die Attribute des Knotens enthält.  
  
Wenn der Knoten vom Typ XmlNodeType.Element ist, werden die Attribute des Knotens zurückgegeben. Andernfalls gibt diese Eigenschaft <see langword="null" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird dem XML-Dokument ein neues-Attribut hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public virtual string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlNode.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Basis-URI des aktuellen Knotens ab.</summary>
        <value>Die Position, aus der der Knoten geladen wurde oder String.Empty, wenn der Knoten über keinen Basis-URI verfügt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein vernetztes XML-Dokument besteht aus Datenblöcken, die mit verschiedenen W3C-Standard Inklusions Mechanismen aggregiert werden und daher Knoten enthalten, die von unterschiedlichen Stellen stammen. Der `BaseURI` gibt Aufschluss über den Speicherort dieser Knoten.  
  
 Der Wert dieser Eigenschaft variiert abhängig vom Knotentyp. Dokument Knoten geben z. b. den Speicherort <xref:System.Xml.XmlDocument> des-Objekts zurück. Knoten, die untergeordnete Knoten externer EntityReference-Knoten sind, geben den Speicherort der Entität selbst zurück. Sehen Sie sich beispielsweise das folgende XML-Dokument an:  
  
```xml  
<!DOCTYPE item [  
<!ENTITY xyz SYSTEM "a/b.xml">  
]>  
<item num='123'>&xyz;</item>  
```  
  
 Dabei enthält die externe `a/b.xml` Entität den XML- `<test>123</test>`Text:.  
  
 Wenn das Dokument aus `http://server/mydata.xml`geladen wird, `BaseURI` wird Folgendes zurückgegeben:  
  
|NodeType|name|BaseURI|  
|--------------|----------|-------------|  
|Attribut|num|`http://server/mydata.xml`|  
|Dokument|#document|`http://server/mydata.xml`|  
|DocumentType|Element|`http://server/mydata.xml`|  
|Entität|XYZ|`http://server/mydata.xml`|  
|Element|Element|`http://server/mydata.xml`|  
|EntityReference|XYZ|`http://server/mydata.xml`|  
|Element|Test|`http://server/a/b.xml`|  
|Text|#text|`http://server/a/b.xml`|  
  
 `BaseURI`sucht nach Entitäts Verweis Grenzen, d. h., wenn Entitäten erweitert werden, werden diese Informationen nicht beibehalten, `XmlDocument` und diese Eigenschaft gibt den Speicherort des Objekts in allen Fällen zurück.  
  
 Ein zweites Beispiel ist das folgende XML-Dokument:  
  
```xml  
<!DOCTYPE Mydata SYSTEM "http://localhost/doctype.dtd">  
<baa>&xyz;</baa>  
```  
  
 die DTD-Datei enthält Folgendes:  
  
```  
<!ENTITY xyz <E1>My Data</E1>  
<!ELEMENT baa #PCDATA>  
<!ATTLIST baa attr1 "woof">  
```  
  
 Wenn das XML-Dokument aus http://localhost/mydata.xmlgeladen wird, `BaseURI` wird für jeden Knoten Folgendes zurückgegeben:  
  
|NodeType|name|BaseURI|  
|--------------|----------|-------------|  
|Dokument|#document|http://localhost/mydata.xml|  
|DocumentType|Mydata|http://localhost/mydata.xml<br /><br /> Die <xref:System.Xml.XmlDocumentType.SystemId%2A?displayProperty=nameWithType> - <xref:System.Xml.XmlDocumentType.PublicId%2A?displayProperty=nameWithType> Eigenschaft oder die-Eigenschaft kann verwendet werden, um zu bestimmen, woher die DTD-Datei geladen wurde.|  
|Element|BAA|http://localhost/mydata.xml|  
|Entität|XYZ|http://localhost/doctype.dtd|  
|EntityReference|XYZ|http://localhost/mydata.xml|  
|Attribut|Wuff|http://localhost/mydata.xml|  
  
> [!NOTE]
>  Der Basis-URI eines Standard Attributs ist identisch mit dem Basis-URI des Elements, zu dem Sie gehören.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildNodes">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList ChildNodes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNodeList ChildNodes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.ChildNodes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ChildNodes As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeList ^ ChildNodes { System::Xml::XmlNodeList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildNodes : System.Xml.XmlNodeList" Usage="System.Xml.XmlNode.ChildNodes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft alle untergeordneten Knoten des Knotens ab.</summary>
        <value>Ein Objekt, das sämtliche untergeordneten Knoten des Knotens enthält.  
  
Wenn keine untergeordneten Knoten vorhanden sind, gibt diese Eigenschaft eine leere <see cref="T:System.Xml.XmlNodeList" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu untergeordneten Knoten finden Sie in der [Spezifikation der W3C-DOM (Core) Ebene 1](https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html) .  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle untergeordneten Knoten des Root-Elements angezeigt.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Xml.XmlNode&#xA;override this.Clone : unit -&gt; System.Xml.XmlNode" Usage="xmlNode.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt ein Duplikat dieses Knotens.</summary>
        <returns>Der geklonte Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Klonen von werden alle Attribute und deren Werte kopiert,einschließlichderjenigen,dievomXML-Prozessorgeneriertwerden,umStandardAttributedarzustellen.<xref:System.Xml.XmlElement> Diese Methode klont den Knoten und die untergeordnete Struktur rekursiv.  
  
 `Clone`entspricht dem Aufrufen `CloneNode(true)`von.  
  
 In der folgenden Tabelle wird das jeweilige Verhalten <xref:System.Xml.XmlNodeType>beschrieben.  
  
|XmlNodeType|Klonen|  
|-----------------|-----------|  
|Attribut|Klont den Attribut Knoten, einschließlich der untergeordneten Knoten.|  
|CDATA|Klont den CDATA-Knoten, einschließlich seines Daten Inhalts.|  
|Kommentar|Klont den Kommentar Knoten, einschließlich seines Text Inhalts.|  
|Dokument|Klont den Dokument Knoten, einschließlich aller untergeordneten Knoten.|  
|DocumentFragment|Klont den Dokument Fragmente Knoten, einschließlich aller untergeordneten Knoten.|  
|DocumentType|Klont den Dokumenttyp Knoten.|  
|Element|Klont den Elementknoten, seine Attribute und alle untergeordneten Knoten.|  
|Entität|Entitätsknoten können nicht geklont werden.|  
|EntityReference|Klont den Entitäts Verweis Knoten. Der Ersetzungstext ist davon nicht betroffen.|  
|Notation|Notationsknoten können nicht geklont werden.|  
|ProcessingInstruction|Klont den Verarbeitungs Anweisungs Knoten, einschließlich seines Ziels und der zugehörigen Daten.|  
|SignificantWhitespace|Klont den signifikanten Leerraum Knoten, einschließlich seines Datenwerts.|  
|Text|Klont den Textknoten, einschließlich seines Datenwerts.|  
|Whitespace|Klont den Leerraum Knoten, einschließlich seines Datenwerts.|  
|XmlDeclaration|Klont den XmlDeclaration-Knoten, einschließlich seines Datenwerts.|  
|Alle anderen Knoten Typen.|Diese Knoten Typen können nicht geklont werden.|  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Stamm Knoten des XML-Dokuments geklont.  
  
 [!code-cpp[Classic WebData XmlNode.Clone Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.Clone Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlNode.CloneNode(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.CloneNode(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CloneNode (deep As Boolean) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Xml::XmlNode ^ CloneNode(bool deep);" />
      <MemberSignature Language="F#" Value="abstract member CloneNode : bool -&gt; System.Xml.XmlNode" Usage="xmlNode.CloneNode deep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep"><see langword="true" />, wenn die Teilstruktur unter dem angegebenen Knoten rekursiv geklont werden soll, <see langword="false" />, wenn nur der Knoten selbst geklont werden soll.</param>
        <summary>Erstellt beim Überschreiben in einer abgeleiteten Klasse ein Duplikat des Knotens.</summary>
        <returns>Der geklonte Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode dient als Kopierkonstruktor für-Knoten. Der doppelte Knoten weist kein übergeordnetes<xref:System.Xml.XmlNode.ParentNode%2A> Element `null`auf (gibt zurück).  
  
 In der folgenden Tabelle wird das jeweilige Verhalten <xref:System.Xml.XmlNodeType>beschrieben.  
  
|XmlNodeType|Clonumode (true)|Clonumode (false)|  
|-----------------|-----------------------|------------------------|  
|Attribut|Klont den Attribut Knoten, einschließlich der untergeordneten Knoten.|Klont den Attribut Knoten, einschließlich der untergeordneten Knoten.|  
|CDATA|Klont den CDATA-Knoten, einschließlich seines Daten Inhalts.|Klont den CDATA-Knoten, einschließlich seines Daten Inhalts.|  
|Kommentar|Klont den Kommentar Knoten, einschließlich seines Text Inhalts.|Klont den Kommentar Knoten, einschließlich seines Text Inhalts.|  
|Dokument|Klont den Dokument Knoten, einschließlich aller untergeordneten Knoten.|Klont den Dokument Knoten.|  
|DocumentFragment|Klont den Dokument Fragmente Knoten, einschließlich aller untergeordneten Knoten.|Klont den Dokument Fragment-Knoten.|  
|DocumentType|Klont den Dokumenttyp Knoten.|Klont den Dokumenttyp Knoten.|  
|Element|Klont den Elementknoten, seine Attribute und alle untergeordneten Knoten.|Klont den Elementknoten und seine Attribute, einschließlich aller Standard Attribute.|  
|Entität|Entitätsknoten können nicht geklont werden.|Entitätsknoten können nicht geklont werden.|  
|EntityReference|Klont den Entitäts Verweis Knoten. Der Ersetzungstext ist davon nicht betroffen.|Klont den Entitäts Verweis Knoten. Der Ersetzungstext ist davon nicht betroffen.|  
|Notation|Notationsknoten können nicht geklont werden.|Notationsknoten können nicht geklont werden.|  
|ProcessingInstruction|Klont den Verarbeitungs Anweisungs Knoten, einschließlich seines Ziels und der zugehörigen Daten.|Klont den Verarbeitungs Anweisungs Knoten, einschließlich seines Ziels und der zugehörigen Daten.|  
|SignificantWhitespace|Klont den signifikanten Leerraum Knoten, einschließlich seines Datenwerts.|Klont den signifikanten Leerraum Knoten, einschließlich seines Datenwerts.|  
|Text|Klont den Textknoten, einschließlich seines Datenwerts.|Klont den Textknoten, einschließlich seines Datenwerts.|  
|Whitespace|Klont den Leerraum Knoten, einschließlich seines Datenwerts.|Klont den Leerraum Knoten, einschließlich seines Datenwerts.|  
|XmlDeclaration|Klont den XmlDeclaration-Knoten, einschließlich seines Datenwerts.|Klont den XmlDeclaration-Knoten, einschließlich seines Datenwerts.|  
|Alle anderen Knoten Typen.|Diese Knoten Typen können nicht geklont werden.|Diese Knoten Typen können nicht geklont werden.|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Unterschied zwischen einem tiefen und einem flachen Klon.  
  
 [!code-cpp[Classic WebData XmlNode.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aufruf dieser Methode für einen Knotentyp, der nicht geklont werden kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XPath.XPathNavigator CreateNavigator ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.CreateNavigator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateNavigator () As XPathNavigator" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XPath::XPathNavigator ^ CreateNavigator();" />
      <MemberSignature Language="F#" Value="abstract member CreateNavigator : unit -&gt; System.Xml.XPath.XPathNavigator&#xA;override this.CreateNavigator : unit -&gt; System.Xml.XPath.XPathNavigator" Usage="xmlNode.CreateNavigator " />
      <MemberSignature Language="C#" Value="public System.Xml.XPath.XPathNavigator CreateNavigator ();" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNavigator () As XPathNavigator" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.XPath.IXPathNavigable.CreateNavigator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen <see cref="T:System.Xml.XPath.XPathNavigator" /> zum Navigieren in diesem Objekt.</summary>
        <returns>Ein <see langword="XPathNavigator" />-Objekt zum Navigieren des Knotens. Der <see langword="XPathNavigator" /> ist auf dem Knoten positioniert, von dem die Methode aufgerufen wurde. Er ist nicht im Stamm des Dokuments positioniert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XPathNavigator` Bietet schreibgeschützten, zufälligen Zugriff auf Daten. Da Sie für XSLT-Transformationen optimiert ist, bietet Sie Leistungsvorteile, wenn Sie als Eingabe Mechanismus für <xref:System.Xml.Xsl.XslTransform.Transform%2A?displayProperty=nameWithType> die-Methode verwendet wird.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein XML-Dokument geladen und bearbeitet, bevor eine XSLT-Transformation durchgeführt wird.  
  
 [!code-cpp[XslTransform.Transform2#1](~/samples/snippets/cpp/VS_Snippets_Data/XslTransform.Transform2/CPP/trans_snip.cpp#1)]
 [!code-csharp[XslTransform.Transform2#1](~/samples/snippets/csharp/VS_Snippets_Data/XslTransform.Transform2/CS/trans_snip.cs#1)]
 [!code-vb[XslTransform.Transform2#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XslTransform.Transform2/VB/trans_snip.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.Xsl.XslTransform" />
      </Docs>
    </Member>
    <Member MemberName="FirstChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode FirstChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode FirstChild" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.FirstChild" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FirstChild As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ FirstChild { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstChild : System.Xml.XmlNode" Usage="System.Xml.XmlNode.FirstChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das erste untergeordnete Element des Knotens ab.</summary>
        <value>Das erste untergeordnete Element des Knotens. Wenn kein solcher Knoten vorhanden ist, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu untergeordneten Knoten finden Sie in der [Spezifikation der W3C-DOM (Core) Ebene 1](https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html) .  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Title-Element angezeigt.  
  
 [!code-cpp[Classic WebData XmlNode.FirstChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.FirstChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.FirstChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.FirstChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.FirstChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.FirstChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="xmlNode.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Enumerator ab, der die untergeordneten Knoten des aktuellen Knotens durchläuft.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, mit dem die untergeordneten Knoten im aktuellen Knoten durchlaufen werden können.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bietet Unterstützung für die "for each"-Iterationen über die Knoten in `XmlNode`.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Bücher im XML-Dokument angezeigt.  
  
 [!code-cpp[Classic WebData XmlNode.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.GetEnumerator Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.GetEnumerator Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.GetEnumerator Example/VB/source.vb#1)]  
  
 Im Beispiel wird die-Datei `books.xml`als Eingabe verwendet.  
  
 [!code-xml[Classic WebData XmlNode.GetEnumerator Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNode.GetEnumerator Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamespaceOfPrefix">
      <MemberSignature Language="C#" Value="public virtual string GetNamespaceOfPrefix (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetNamespaceOfPrefix(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.GetNamespaceOfPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetNamespaceOfPrefix (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetNamespaceOfPrefix(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member GetNamespaceOfPrefix : string -&gt; string&#xA;override this.GetNamespaceOfPrefix : string -&gt; string" Usage="xmlNode.GetNamespaceOfPrefix prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Das Präfix, dessen Namespace-URI gesucht werden soll.</param>
        <summary>Sucht im Gültigkeitsbereich des aktuellen Knotens die nächstgelegene **xmlns**-Deklaration für das angegebene Präfix und gibt den Namespace-URI in der Deklaration zurück.</summary>
        <returns>Der Namespace-URI des angegebenen Präfixes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird dem XML-Dokument ein neues-Attribut hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrefixOfNamespace">
      <MemberSignature Language="C#" Value="public virtual string GetPrefixOfNamespace (string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetPrefixOfNamespace(string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.GetPrefixOfNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPrefixOfNamespace (namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetPrefixOfNamespace(System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetPrefixOfNamespace : string -&gt; string&#xA;override this.GetPrefixOfNamespace : string -&gt; string" Usage="xmlNode.GetPrefixOfNamespace namespaceURI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="namespaceURI">Der Namespace-URI, dessen Präfix gesucht werden soll.</param>
        <summary>Sucht im Gültigkeitsbereich des aktuellen Knotens die nächstgelegene **xmlns**-Deklaration für den angegebenen Namespace-URI und gibt das in dieser Deklaration definierte Präfix zurück.</summary>
        <returns>Das Präfix für den angegebenen Namespace-URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird dem XML-Dokument ein neues-Element hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlNode.GetPrefixOfNamespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.GetPrefixOfNamespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.GetPrefixOfNamespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.GetPrefixOfNamespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.GetPrefixOfNamespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.GetPrefixOfNamespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChildNodes">
      <MemberSignature Language="C#" Value="public virtual bool HasChildNodes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildNodes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.HasChildNodes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasChildNodes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasChildNodes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildNodes : bool" Usage="System.Xml.XmlNode.HasChildNodes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieser Knoten über untergeordnete Knoten verfügt.</summary>
        <value><see langword="true" />, wenn der Knoten über untergeordnete Knoten verfügt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu untergeordneten Knoten finden Sie in der [Spezifikation der W3C-DOM (Core) Ebene 1](https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html) .  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle untergeordneten Knoten des Root-Elements angezeigt.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public virtual string InnerText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string with get, set" Usage="System.Xml.XmlNode.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die verketteten Werte des Knotens und sämtlicher diesem untergeordneten Knoten ab oder legt diese fest.</summary>
        <value>Die verketteten Werte des Knotens und aller diesem untergeordneten Knoten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Festlegen dieser Eigenschaft werden alle untergeordneten Knoten durch den analysierten Inhalt der angegebenen Zeichenfolge ersetzt.  
  
 Für Blattknoten `InnerText` gibt denselben Inhalt wie die <xref:System.Xml.XmlNode.Value%2A> -Eigenschaft zurück.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel werden die `InnerText` Eigenschaften <xref:System.Xml.XmlNode.InnerXml%2A> und verglichen.  
  
 [!code-cpp[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/VB/source.vb#1)]  
  
 **Ausgabe:**  
  
```  
Display the InnerText of the element...  
some textmore text  
Display the InnerXml of the element...  
some text<child />more text  
<elem>Text containing &lt;markup/&gt; will have char(&lt;) and char(&gt;) escape  
d.</elem>  
<elem>Text containing <markup />.</elem>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InnerXml">
      <MemberSignature Language="C#" Value="public virtual string InnerXml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.InnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property InnerXml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ InnerXml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerXml : string with get, set" Usage="System.Xml.XmlNode.InnerXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Markup ab, das nur die untergeordneten Knoten dieses Knotens darstellt, oder legt dieses fest.</summary>
        <value>Das Markup der untergeordneten Knoten dieses Knotens.  
  
 <block subset="none" type="note"><para><see langword="InnerXml" /> gibt keine Standardattribute zurück.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie versuchen, diese Eigenschaft von einem Knoten festzulegen, der keine untergeordneten Knoten haben kann, z. b. ein Text Knoten, wird eine Ausnahme ausgelöst. Andernfalls ersetzt die `InnerXml` -Einstellung die untergeordneten Knoten des Knotens durch den analysierten Inhalt der angegebenen Zeichenfolge. Die Analyse wird im Kontext des aktuellen Namespaces durchgeführt.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
> [!NOTE]
>  `InnerXml`ist keine effiziente Methode zum Ändern des DOM. Beim Ersetzen komplexer Knoten treten möglicherweise Leistungsprobleme auf. Es ist effizienter, Knoten zu erstellen und Methoden `InsertBefore`wie, `InsertAfter`, `AppendChild`und `RemoveChild` zu verwenden, um das XML-Dokument zu ändern.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die <xref:System.Xml.XmlNode.InnerText%2A> Eigenschaften `InnerXml` und verglichen.  
  
 [!code-cpp[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.InnerText Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.InnerText Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Festlegen dieser Eigenschaft auf einem Knoten, der keine untergeordneten Knoten besitzen kann.</exception>
        <exception cref="T:System.Xml.XmlException">Der beim Festlegen dieser Eigenschaft angegebene XML-Code ist nicht ordnungsgemäß formatiert.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertAfter">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode InsertAfter (System.Xml.XmlNode newChild, System.Xml.XmlNode refChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode InsertAfter(class System.Xml.XmlNode newChild, class System.Xml.XmlNode refChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.InsertAfter(System.Xml.XmlNode,System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InsertAfter (newChild As XmlNode, refChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ InsertAfter(System::Xml::XmlNode ^ newChild, System::Xml::XmlNode ^ refChild);" />
      <MemberSignature Language="F#" Value="abstract member InsertAfter : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.InsertAfter : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.InsertAfter (newChild, refChild)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newChild" Type="System.Xml.XmlNode" />
        <Parameter Name="refChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="newChild">Der einzufügende Knoten.</param>
        <param name="refChild">Der Verweisknoten. <paramref name="newChild" /> wird hinter <paramref name="refChild" /> platziert.</param>
        <summary>Fügt den angegebenen Knoten unmittelbar hinter dem angegebenen Verweisknoten ein.</summary>
        <returns>Der Knoten, der eingefügt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `refChild` gleich `null`ist, `newChild` fügen Sie am Anfang der Liste mit untergeordneten Knoten ein. Der gesamte Inhalt des `newChild` wird in der gleichen Reihenfolge nach `refChild`eingefügt. Wenn sich `newChild` die bereits in der Struktur befindet, wird Sie von der ursprünglichen Position entfernt und ihrer Zielposition hinzugefügt. Weitere Informationen zum Einfügen von Knoten finden Sie unter [Einfügen von Knoten in ein XML-Dokument](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md).  
  
 Wenn der Knoten, der eingefügt wird, aus einem anderen Dokument erstellt wurde <xref:System.Xml.XmlDocument.ImportNode%2A?displayProperty=nameWithType> , können Sie verwenden, um den Knoten in das aktuelle Dokument zu importieren. Der importierte Knoten kann dann in das aktuelle Dokument eingefügt werden.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird dem XML-Dokument ein neuer Knoten hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlNode.InsertAfter Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.InsertAfter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.InsertAfter Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.InsertAfter Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.InsertAfter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.InsertAfter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Typ dieses Knotens lässt keine untergeordneten Knoten vom Typ des <paramref name="newChild" />-Knotens zu.  
  
<paramref name="newChild" /> ist eine frühere Version dieses Knotens.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newChild" /> wurde nicht aus dem Dokument erstellt, aus dem dieser Knoten erstellt wurde.  
  
<paramref name="refChild" /> ist kein untergeordnetes Element dieses Knotens.  
  
Dieser Knoten ist schreibgeschützt.</exception>
        <block subset="none" type="overrides"><para>Wenn Sie <see langword="InsertAfter" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die-Methode der Basisklasse aufzurufen, damit Ereignisse ordnungsgemäß ausgelöst werden. <see langword="InsertAfter" /></para></block>
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/891e54f5-54f6-4bb4-b624-9d1b6a1f1216">Einfügen von Knoten in ein XML-Dokument</related>
      </Docs>
    </Member>
    <Member MemberName="InsertBefore">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode InsertBefore (System.Xml.XmlNode newChild, System.Xml.XmlNode refChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode InsertBefore(class System.Xml.XmlNode newChild, class System.Xml.XmlNode refChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.InsertBefore(System.Xml.XmlNode,System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InsertBefore (newChild As XmlNode, refChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ InsertBefore(System::Xml::XmlNode ^ newChild, System::Xml::XmlNode ^ refChild);" />
      <MemberSignature Language="F#" Value="abstract member InsertBefore : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.InsertBefore : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.InsertBefore (newChild, refChild)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newChild" Type="System.Xml.XmlNode" />
        <Parameter Name="refChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="newChild">Der einzufügende Knoten.</param>
        <param name="refChild">Der Verweisknoten. <paramref name="newChild" /> wird vor diesem Knoten platziert.</param>
        <summary>Fügt den angegebenen Knoten direkt vor dem angegebenen Verweisknoten ein.</summary>
        <returns>Der Knoten, der eingefügt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `refChild` gleich `null`ist, `newChild` fügen Sie am Ende der Liste der untergeordneten Knoten ein. Der gesamte Inhalt des `newChild` wird in derselben Reihenfolge wie vor `refChild`eingefügt. Wenn sich `newChild` die bereits in der Struktur befindet, wird Sie von der ursprünglichen Position entfernt und ihrer Zielposition hinzugefügt. Weitere Informationen zum Einfügen von Knoten finden Sie unter [Einfügen von Knoten in ein XML-Dokument](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md).  
  
 Wenn der Knoten, der eingefügt wird, aus einem anderen Dokument erstellt wurde <xref:System.Xml.XmlDocument.ImportNode%2A?displayProperty=nameWithType> , können Sie verwenden, um den Knoten in das aktuelle Dokument zu importieren. Der importierte Knoten kann dann in das aktuelle Dokument eingefügt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird dem XML-Dokument ein neuer Knoten hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlNode.InsertBefore Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.InsertBefore Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.InsertBefore Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.InsertBefore Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.InsertBefore Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.InsertBefore Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Typ des aktuellen Knotens lässt keine untergeordneten Knoten vom Typ des <paramref name="newChild" />-Knotens zu.  
  
<paramref name="newChild" /> ist eine frühere Version dieses Knotens.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newChild" /> wurde nicht aus dem Dokument erstellt, aus dem dieser Knoten erstellt wurde.  
  
<paramref name="refChild" /> ist kein untergeordnetes Element dieses Knotens.  
  
Dieser Knoten ist schreibgeschützt.</exception>
        <block subset="none" type="overrides"><para>Wenn Sie <see langword="InsertBefore" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die-Methode der Basisklasse aufzurufen, damit Ereignisse ordnungsgemäß ausgelöst werden. <see langword="InsertBefore" /></para></block>
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/891e54f5-54f6-4bb4-b624-9d1b6a1f1216">Einfügen von Knoten in ein XML-Dokument</related>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xml.XmlNode.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Knoten schreibgeschützt ist.</summary>
        <value><see langword="true" />, wenn der Knoten schreibgeschützt ist. <see langword="false" />andernfalls.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Schreib geschützter Knoten ist ein Knoten, dessen Eigenschaften, Attribute oder untergeordnete Knoten nicht geändert werden können. Sie können einen schreibgeschützten Knoten aus der Struktur entfernen und an anderer Stelle einfügen. Beispielsweise sind Entitäts Knoten immer schreibgeschützt.  
  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft das angegebene untergeordnete Element ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlElement ^ default[System::String ^] { System::Xml::XmlElement ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Xml.XmlElement" Usage="System.Xml.XmlNode.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der gekennzeichnete Name des abzurufenden Elements.</param>
        <summary>Ruft das erste untergeordnete Element mit dem angegebenen <see cref="P:System.Xml.XmlNode.Name" /> ab.</summary>
        <value>Das erste <see cref="T:System.Xml.XmlElement" />, das mit dem angegebenen Namen übereinstimmt. Es wird ein NULL-Verweis zurückgegeben (<see langword="Nothing" /> in Visual Basic), wenn keine Übereinstimmung vorhanden ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Title-Element angezeigt.  
  
 [!code-cpp[Classic WebData XmlNode.this Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.this Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.this Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.this Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.this Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.this Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement this[string localname, string ns] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(localname As String, ns As String) As XmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlElement ^ default[System::String ^, System::String ^] { System::Xml::XmlElement ^ get(System::String ^ localname, System::String ^ ns); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : System.Xml.XmlElement" Usage="System.Xml.XmlNode.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Der lokale Name des Elements.</param>
        <param name="ns">Der Namespace-URI des Elements.</param>
        <summary>Ruft das erste untergeordnete Element mit dem angegebenen <see cref="P:System.Xml.XmlNode.LocalName" /> und dem <see cref="P:System.Xml.XmlNode.NamespaceURI" /> ab.</summary>
        <value>Das erste <see cref="T:System.Xml.XmlElement" /> mit dem passenden <paramref name="localname" /> und <paramref name="ns" />. sein. Es wird ein NULL-Verweis zurückgegeben (<see langword="Nothing" /> in Visual Basic), wenn keine Übereinstimmung vorhanden ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode LastChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode LastChild" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.LastChild" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LastChild As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ LastChild { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LastChild : System.Xml.XmlNode" Usage="System.Xml.XmlNode.LastChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das letzte untergeordnete Element des Knotens ab.</summary>
        <value>Das letzte untergeordnete Element des Knotens. Wenn kein solcher Knoten vorhanden ist, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird das price-Element angezeigt.  
  
 [!code-cpp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlNode.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den lokalen Namen des Knotens ab, wenn er in einer abgeleiteten Klasse überschrieben wird.</summary>
        <value>Der Name des Knotens ohne dessen Präfix. Beispielsweise <see langword="LocalName" /> ist Book für das-Element &lt;BK: Book&gt;.  
  
Der zurückgegebene Name hängt vom <see cref="P:System.Xml.XmlNode.NodeType" /> des Knotens ab: 
 <list type="table"><listheader><term> Typ 
 </term><description> name 
 </description></listheader><item><term> Attribut 
 </term><description> Der lokale Name des Attributs.  
  
 </description></item><item><term> CDATA 
 </term><description> #cdata-section 
 </description></item><item><term> Kommentar 
 </term><description> #comment 
 </description></item><item><term> Dokument 
 </term><description> #document 
 </description></item><item><term> DocumentFragment 
 </term><description> #document-fragment 
 </description></item><item><term> DocumentType 
 </term><description> Der Name des Dokumenttyps.  
  
 </description></item><item><term> Element 
 </term><description> Der lokale Name des Elements.  
  
 </description></item><item><term> Entität 
 </term><description> Der Name der Entität.  
  
 </description></item><item><term> EntityReference 
 </term><description> Der Name der Entität, auf die verwiesen wird.  
  
 </description></item><item><term> Notation 
 </term><description> Der Notationsname.  
  
 </description></item><item><term> ProcessingInstruction 
 </term><description> Das Ziel der Verarbeitungsanweisung.  
  
 </description></item><item><term> Text 
 </term><description> #text 
 </description></item><item><term> Whitespace 
 </term><description> #whitespace 
 </description></item><item><term> SignificantWhitespace 
 </term><description> #significant-whitespace 
 </description></item><item><term> XmlDeclaration 
 </term><description> #xml-declaration 
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Knoten kein Präfix hat, ist LocalName identisch <xref:System.Xml.XmlNode.Name%2A>mit.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.XmlNode.Prefix" />
        <altmember cref="P:System.Xml.XmlNode.Name" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlNode.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den qualifizierten Namen des Knotens ab, wenn er in einer abgeleiteten Klasse überschrieben wurde.</summary>
        <value>Der gekennzeichnete Name des Knotens. Der zurückgegebene Name hängt vom <see cref="P:System.Xml.XmlNode.NodeType" /> des Knotens ab: 
 <list type="table"><listheader><term> Typ 
 </term><description> name 
 </description></listheader><item><term> Attribut 
 </term><description> Der qualifizierte Name des Attributs.  
  
 </description></item><item><term> CDATA 
 </term><description> #cdata-section 
 </description></item><item><term> Kommentar 
 </term><description> #comment 
 </description></item><item><term> Dokument 
 </term><description> #document 
 </description></item><item><term> DocumentFragment 
 </term><description> #document-fragment 
 </description></item><item><term> DocumentType 
 </term><description> Der Name des Dokumenttyps.  
  
 </description></item><item><term> Element 
 </term><description> Der qualifizierte Name des Elements.  
  
 </description></item><item><term> Entität 
 </term><description> Der Name der Entität.  
  
 </description></item><item><term> EntityReference 
 </term><description> Der Name der Entität, auf die verwiesen wird.  
  
 </description></item><item><term> Notation 
 </term><description> Der Notationsname.  
  
 </description></item><item><term> ProcessingInstruction 
 </term><description> Das Ziel der Verarbeitungsanweisung.  
  
 </description></item><item><term> Text 
 </term><description> #text 
 </description></item><item><term> Whitespace 
 </term><description> #whitespace 
 </description></item><item><term> SignificantWhitespace 
 </term><description> #significant-whitespace 
 </description></item><item><term> XmlDeclaration 
 </term><description> #xml-declaration 
 </description></item></list></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public virtual string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlNode.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namespace-URI dieses Knotens ab.</summary>
        <value>Der Namespace-URI dieses Knotens. Wenn kein Namespace-URI vorhanden ist, gibt diese Eigenschaft String.Empty zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist der zum Zeitpunkt der Erstellung angegebene Namespace-URI. Beispielsweise `NamespaceURI` ist urn: Samples für das-Element \<BK: Book xmlns: BK = "urn: Samples" >  
  
 Ein Attribut erbt nicht seinen Namespace von dem Element, mit dem es verbunden ist. Wenn einem Attribut nicht explizit ein Namespace zugewiesen wird, hat es einfach keinen Namespace.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextSibling">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode NextSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode NextSibling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.NextSibling" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NextSibling As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ NextSibling { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSibling : System.Xml.XmlNode" Usage="System.Xml.XmlNode.NextSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Knoten ab, der diesem Knoten unmittelbar folgt.</summary>
        <value>Der nächste <see langword="XmlNode" />. Wenn kein nächster Knoten vorhanden ist, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel werden alle Bücher im XML-Dokument angezeigt.  
  
 [!code-cpp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlNode.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Typ des aktuellen Knotens ab.</summary>
        <value>Einer der <see cref="T:System.Xml.XmlNodeType" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt nie `XmlNodeType` endelta, EndEntity oder None zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public virtual void Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Normalize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Normalize();" />
      <MemberSignature Language="F#" Value="abstract member Normalize : unit -&gt; unit&#xA;override this.Normalize : unit -&gt; unit" Usage="xmlNode.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Weist allen XmlText-Knoten in der Teilstruktur unterhalb dieses XmlNode eine „normale“ Form zu. In dieser werden XmlText-Knoten nur durch Markup (d. h. Tags, Kommentare, Verarbeitungsanweisungen, CDATA-Abschnitte und Entitätsverweise) getrennt, und es sind somit keine direkt aufeinander folgenden XmlText-Knoten vorhanden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann verwendet werden, um sicherzustellen, dass die DOM-Ansicht eines Dokuments identisch ist, wenn Sie gespeichert und erneut geladen wird. Dies ist hilfreich, wenn Vorgänge (z. b. XPointer-Lookups), die von einer bestimmten Dokumentstruktur abhängen, verwendet werden sollen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OuterXml">
      <MemberSignature Language="C#" Value="public virtual string OuterXml { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.OuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OuterXml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ OuterXml { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OuterXml : string" Usage="System.Xml.XmlNode.OuterXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Markup ab, das diesen Knoten und alle ihm untergeordneten Knoten enthält.</summary>
        <value>Das Markup, das diesen Knoten und alle ihm untergeordneten Knoten enthält.  
  
 <block subset="none" type="note"><para><see langword="OuterXml" /> gibt keine Standardattribute zurück.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist eine Microsoft-Erweiterung des Dokumentobjektmodells (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Ausgabe der <xref:System.Xml.XmlNode.InnerXml%2A> - `OuterXml` Eigenschaft und der-Eigenschaft verglichen.  
  
 [!code-cpp[Classic WebData XmlNode.OuterXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.OuterXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.OuterXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.OuterXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.OuterXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.OuterXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerDocument">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocument OwnerDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocument OwnerDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.OwnerDocument" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property OwnerDocument As XmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlDocument ^ OwnerDocument { System::Xml::XmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDocument : System.Xml.XmlDocument" Usage="System.Xml.XmlNode.OwnerDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xml.XmlDocument" /> ab, zu dem dieser Knoten gehört.</summary>
        <value>Das <see cref="T:System.Xml.XmlDocument" />, zu dem dieser Knoten gehört.  
  
Wenn der Knoten ein <see cref="T:System.Xml.XmlDocument" /> ist (NodeType ist gleich XmlNodeType.Document), gibt diese Eigenschaft <see langword="null" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie beim Hinzufügen von Knoten zum aktuellen Knoten <xref:System.Xml.XmlDocument> den, der <xref:System.Xml.XmlNode.OwnerDocument%2A> von der-Eigenschaft zurückgegeben wird, um den Knoten zu erstellen.  
  
   
  
## Examples  
 Ein <xref:System.Xml.XmlElement.OwnerDocument%2A> Beispiel für die Verwendung dieser Eigenschaft finden Sie unter (in der XmlElement-Klasse).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ParentNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode ParentNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.ParentNode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ParentNode As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ ParentNode { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentNode : System.Xml.XmlNode" Usage="System.Xml.XmlNode.ParentNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das übergeordnete Element dieses Knotens ab (bei Knoten, die über übergeordnete Elemente verfügen können).</summary>
        <value>Der <see langword="XmlNode" />, der das übergeordnete Element des aktuellen Knotens ist. Wenn ein Knoten gerade erstellt, jedoch noch nicht der Struktur hinzugefügt oder aus dieser entfernt wurde, ist das übergeordnete Element <see langword="null" />. Für alle anderen Knoten hängt der zurückgegebene Wert vom <see cref="P:System.Xml.XmlNode.NodeType" /> des Knotens ab. In der folgenden Tabelle werden die möglichen Rückgabewerte für die <see langword="ParentNode" />-Eigenschaft beschrieben.  
  
 <list type="table"><listheader><term> NodeType 
 </term><description> Rückgabewert von ParentNode 
 </description></listheader><item><term> Attribute, Document, DocumentFragment, Entity, Notation 
 </term><description> Gibt <see langword="null" /> zurück. Diese Knoten verfügen über keine übergeordneten Elemente.  
  
 </description></item><item><term> CDATA 
 </term><description> Gibt das Element oder den Entitätsverweis mit dem CDATA-Abschnitt zurück.  
  
 </description></item><item><term> Kommentar 
 </term><description> Gibt das Element, den Entitätsverweis, den Dokumenttyp oder das Dokument mit dem Kommentar zurück.  
  
 </description></item><item><term> DocumentType 
 </term><description> Gibt den Dokumentknoten zurück.  
  
 </description></item><item><term> Element 
 </term><description> Gibt den übergeordneten Knoten des Elements zurück. Wenn das Element der Stammknoten der Struktur ist, ist das übergeordnete Element der Dokumentknoten.  
  
 </description></item><item><term> EntityReference 
 </term><description> Gibt das Element, das Attribut oder den Entitätsverweis mit dem Entitätsverweis zurück.  
  
 </description></item><item><term> ProcessingInstruction 
 </term><description> Gibt das Dokument, das Element, den Dokumenttyp oder den Entitätsverweis mit der Verarbeitungsanweisung zurück.  
  
 </description></item><item><term> Text 
 </term><description> Gibt das übergeordnete Element, das Attribut oder den Entitätsverweis mit dem Textknoten zurück.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu über-und untergeordneten Knoten finden Sie in der [Spezifikation der W3C-DOM (Core) Ebene 1](https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html) .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public virtual string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Xml.XmlNode.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Namespacepräfix dieses Knotens ab oder legt dieses fest.</summary>
        <value>Das Namespacepräfix dieses Knotens. Beispielsweise <see langword="Prefix" /> ist BK für das-Element &lt;BK: Book&gt;. Wenn kein Präfix vorhanden ist, gibt diese Eigenschaft String.Empty zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft festlegen, wird die <xref:System.Xml.XmlNode.Name%2A> Eigenschaft, die den qualifizierten Namen enthält, auf Element-und Attribut Knoten geändert. Das Festlegen dieser Eigenschaft auf Knoten Typen, die kein Präfix haben können (z. b. Text, comment, EntityReference, CDATA, processinginbau, Document und DocumentFragment), hat keine Auswirkungen. Wenn Sie das Präfix eines Attributs ändern, für das bekanntermaßen ein Standardwert vorhanden ist, wird kein neues Attribut mit dem Standardwert erstellt, und das ursprüngliche Präfix wird angezeigt, da der Namespace-URI und der lokale Name nicht geändert werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Dieser Knoten ist schreibgeschützt.</exception>
        <exception cref="T:System.Xml.XmlException">Das angegebene Präfix enthält ein ungültiges Zeichen.  
  
 Das angegebene Präfix ist falsch formatiert.  
  
 Das angegebene Präfix ist „xml“, und der namespaceURI dieses Knotens unterscheidet sich von „http://www.w3.org/XML/1998/namespace“.  
  
 Dieser Knoten ist ein Attribut, das angegebene Präfix ist „xmlns“, und der namespaceURI dieses Knotens unterscheidet von „http://www.w3.org/2000/xmlns/“.  
  
 Dieser Knoten ist ein Attribut, und der qualifiedName dieses Knotens ist "xmlns".</exception>
        <block subset="none" type="overrides"><para>Beim Überschreiben in einer abgeleiteten Klasse kann diese Eigenschaft nicht festgelegt werden. <see langword="Prefix" /></para></block>
      </Docs>
    </Member>
    <Member MemberName="PrependChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode PrependChild (System.Xml.XmlNode newChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode PrependChild(class System.Xml.XmlNode newChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.PrependChild(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PrependChild (newChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ PrependChild(System::Xml::XmlNode ^ newChild);" />
      <MemberSignature Language="F#" Value="abstract member PrependChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.PrependChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.PrependChild newChild" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="newChild">Der hinzuzufügende Knoten. Der gesamte Inhalt des hinzuzufügenden Knotens wird an den angegebenen Speicherort verschoben.</param>
        <summary>Fügt den angegebenen Knoten am Anfang der Liste der untergeordneten Knoten dieses Knotens hinzu.</summary>
        <returns>Der hinzugefügte Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn sich `newChild` die bereits in der Struktur befindet, wird Sie von der ursprünglichen Position entfernt und ihrer Zielposition hinzugefügt. Weitere Informationen zum Einfügen von Knoten finden Sie unter [Einfügen von Knoten in ein XML-Dokument](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md).  
  
 Wenn der Knoten, der eingefügt wird, aus einem anderen Dokument erstellt wurde <xref:System.Xml.XmlDocument.ImportNode%2A?displayProperty=nameWithType> , können Sie verwenden, um den Knoten in das aktuelle Dokument zu importieren. Der importierte Knoten kann dann in das aktuelle Dokument eingefügt werden.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird dem XML-Dokument ein neuer Knoten hinzugefügt.  
  
 [!code-cpp[Classic WebData XmlNode.PrependChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PrependChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PrependChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PrependChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PrependChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PrependChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Typ dieses Knotens lässt keine untergeordneten Knoten vom Typ des <paramref name="newChild" />-Knotens zu.  
  
<paramref name="newChild" /> ist eine frühere Version dieses Knotens.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newChild" /> wurde nicht aus dem Dokument erstellt, aus dem dieser Knoten erstellt wurde.  
  
Dieser Knoten ist schreibgeschützt.</exception>
        <block subset="none" type="overrides"><para>Wenn Sie <see langword="PrependChild" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die-Methode der Basisklasse aufzurufen, damit Ereignisse ordnungsgemäß ausgelöst werden. <see langword="PrependChild" /></para></block>
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/891e54f5-54f6-4bb4-b624-9d1b6a1f1216">Einfügen von Knoten in ein XML-Dokument</related>
      </Docs>
    </Member>
    <Member MemberName="PreviousSibling">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode PreviousSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode PreviousSibling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.PreviousSibling" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PreviousSibling As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ PreviousSibling { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousSibling : System.Xml.XmlNode" Usage="System.Xml.XmlNode.PreviousSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Knoten ab, der diesem Knoten unmittelbar vorausgeht.</summary>
        <value>Der vorausgehende <see langword="XmlNode" />. Wenn kein vorausgehender Knoten vorhanden ist, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel werden alle Bücher im XML-Dokument angezeigt.  
  
 [!code-cpp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousText">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode PreviousText { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode PreviousText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.PreviousText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PreviousText As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNode ^ PreviousText { System::Xml::XmlNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousText : System.Xml.XmlNode" Usage="System.Xml.XmlNode.PreviousText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Textknoten ab, der diesem Knoten unmittelbar vorausgeht.</summary>
        <value>Gibt <see cref="T:System.Xml.XmlNode" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft hat eine höhere Leistung als <xref:System.Xml.XmlNode.PreviousSibling%2A> die-Eigenschaft, Sie können Sie jedoch nur verwenden, um einen <xref:System.Xml.XmlNodeType.Text>Knoten vom Typ zu erhalten. Verwenden Sie die <xref:System.Xml.XmlNode.PreviousSibling%2A> -Eigenschaft, um einen beliebigen anderen Knotentyp zu erhalten, der diesem Knoten vorausgeht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public virtual void RemoveAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.RemoveAll" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAll();" />
      <MemberSignature Language="F#" Value="abstract member RemoveAll : unit -&gt; unit&#xA;override this.RemoveAll : unit -&gt; unit" Usage="xmlNode.RemoveAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle untergeordneten Knoten bzw. Attribute des aktuellen Knotens.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein entferntes Attribut bekanntermaßen über einen Standardwert verfügt, wird sofort ein Attribut mit dem Standardwert und ggf. dem entsprechenden Namespace-URI, lokalen Namen und Präfix angezeigt.  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle untergeordneten Knoten und Attribut Knoten aus dem Stamm Knoten entfernt.  
  
 [!code-cpp[Classic WebData XmlNode.RemoveAll Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.RemoveAll Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.RemoveAll Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.RemoveAll Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.RemoveAll Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.RemoveAll Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie <see langword="RemoveAll" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die-Methode der Basisklasse aufzurufen, damit Ereignisse ordnungsgemäß ausgelöst werden. <see langword="RemoveAll" /></para></block>
      </Docs>
    </Member>
    <Member MemberName="RemoveChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode RemoveChild (System.Xml.XmlNode oldChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode RemoveChild(class System.Xml.XmlNode oldChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.RemoveChild(System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function RemoveChild (oldChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ RemoveChild(System::Xml::XmlNode ^ oldChild);" />
      <MemberSignature Language="F#" Value="abstract member RemoveChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.RemoveChild : System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.RemoveChild oldChild" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="oldChild">Der Knoten, der entfernt wird.</param>
        <summary>Entfernt den angegebenen untergeordneten Knoten.</summary>
        <returns>Der entfernte Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird ein Knoten aus dem XML-Dokument entfernt.  
  
 [!code-cpp[Classic WebData XmlNode.RemoveChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.RemoveChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.RemoveChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.RemoveChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.RemoveChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.RemoveChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="oldChild" /> ist kein untergeordnetes Element dieses Knotens. Oder dieser Knoten ist schreibgeschützt.</exception>
        <block subset="none" type="overrides"><para>Wenn Sie <see langword="RemoveChild" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die-Methode der Basisklasse aufzurufen, damit Ereignisse ordnungsgemäß ausgelöst werden. <see langword="RemoveChild" /></para></block>
      </Docs>
    </Member>
    <Member MemberName="ReplaceChild">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ReplaceChild (System.Xml.XmlNode newChild, System.Xml.XmlNode oldChild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ReplaceChild(class System.Xml.XmlNode newChild, class System.Xml.XmlNode oldChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.ReplaceChild(System.Xml.XmlNode,System.Xml.XmlNode)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReplaceChild (newChild As XmlNode, oldChild As XmlNode) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNode ^ ReplaceChild(System::Xml::XmlNode ^ newChild, System::Xml::XmlNode ^ oldChild);" />
      <MemberSignature Language="F#" Value="abstract member ReplaceChild : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode&#xA;override this.ReplaceChild : System.Xml.XmlNode * System.Xml.XmlNode -&gt; System.Xml.XmlNode" Usage="xmlNode.ReplaceChild (newChild, oldChild)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newChild" Type="System.Xml.XmlNode" />
        <Parameter Name="oldChild" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="newChild">Der neue Knoten, der in die Liste der untergeordneten Elemente eingefügt werden soll.</param>
        <param name="oldChild">Der Knoten, der in der Liste ersetzt wird.</param>
        <summary>Ersetzt den untergeordneten <paramref name="oldChild" />-Knoten durch den <paramref name="newChild" />-Knoten.</summary>
        <returns>Der ersetzte Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das `newChild` bereits in der Struktur vorhanden ist, wird es zuerst entfernt.  
  
 Wenn aus einem anderen Dokument erstellt <xref:System.Xml.XmlDocument.ImportNode%2A?displayProperty=nameWithType> wurde,könnenSieverwenden,umdenKnotenindasaktuelleDokumentzuimportieren.`newChild` Der importierte Knoten kann dann an die `ReplaceChild` -Methode weitergegeben werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Title-Element im XML-Dokument ersetzt.  
  
 [!code-cpp[Classic WebData XmlNode.ReplaceChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.ReplaceChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.ReplaceChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.ReplaceChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.ReplaceChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.ReplaceChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Typ dieses Knotens lässt keine untergeordneten Knoten vom Typ des <paramref name="newChild" />-Knotens zu.  
  
<paramref name="newChild" /> ist eine frühere Version dieses Knotens.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="newChild" /> wurde nicht aus dem Dokument erstellt, aus dem dieser Knoten erstellt wurde.  
  
Dieser Knoten ist schreibgeschützt.  
  
<paramref name="oldChild" /> ist kein untergeordnetes Element dieses Knotens.</exception>
        <block subset="none" type="overrides"><para>Wenn Sie <see langword="ReplaceChild" /> in einer abgeleiteten Klasse überschreiben, müssen Sie die-Methode der Basisklasse aufzurufen, damit Ereignisse ordnungsgemäß ausgelöst werden. <see langword="ReplaceChild" /></para></block>
        <altmember cref="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlNode.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Post-Schema-Validation-Infoset ab, das diesem Knoten als Ergebnis der Schemavalidierung zugewiesen wurde.</summary>
        <value>Ein <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />-Objekt, das das Post-Schema-Validation-Infoset dieses Knotens enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xml.XmlNode.SchemaInfo%2A> -Eigenschaft wird festgelegt, wenn dieser Knoten überprüft wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectNodes">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wählt eine Liste von Knoten aus, die mit dem XPath-Ausdruck übereinstimmen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XPath-Ausdrücke können Namespaces enthalten. Namespace-Auflösung wird mithilfe von `XmlNamespaceManager` unterstützt. Wenn der XPath-Ausdruck ein Präfix enthält, müssen das Paar aus Präfix-und Namespace `XmlNamespaceManager`-URI hinzugefügt werden.  
  
> [!NOTE]
>  Wenn der XPath-Ausdruck kein Präfix enthält, wird davon ausgegangen, dass der Namespace-URI der leere Namespace ist. Wenn Ihr XML-Code einen Standard Namespace enthält, müssen Sie trotzdem ein Präfix und einen Namespace `XmlNamespaceManager`-URI hinzufügen. andernfalls werden keine Knoten ausgewählt.  
  
 Weitere Informationen finden Sie unter [Auswählen von Knoten mithilfe der XPath-Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md). Wählen Sie im vorherigen Abschnitt eine Überladung aus der Überladungs Liste aus, um Codebeispiele zu erhalten.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">XPath-Auswahl und benutzerdefinierte Funktionen und mehr</related>
        <related type="ExternalDocumentation" href="https://www.w3.org/TR/1999/REC-xpath-19991116/">W3C-Empfehlung zu XPath 1,0</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectNodes">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNodeList SelectNodes (string xpath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlNodeList SelectNodes(string xpath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.SelectNodes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNodes (xpath As String) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlNodeList ^ SelectNodes(System::String ^ xpath);" />
      <MemberSignature Language="F#" Value="member this.SelectNodes : string -&gt; System.Xml.XmlNodeList" Usage="xmlNode.SelectNodes xpath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xpath" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="xpath">Der XPath-Ausdruck.</param>
        <summary>Wählt eine Liste von Knoten aus, die mit dem XPath-Ausdruck übereinstimmen.</summary>
        <returns>Eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Auflistung der Knoten, die mit der XPath-Abfrage übereinstimmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn für den XPath-Ausdruck eine Namespace Auflösung erforderlich ist, `SelectNodes` müssen Sie die- <xref:System.Xml.XmlNamespaceManager> Überladung verwenden, die einen als sein Argument annimmt. Der `XmlNamespaceManager` wird zum Auflösen von Namespaces verwendet.  
  
> [!NOTE]
>  Wenn der XPath-Ausdruck kein Präfix enthält, wird davon ausgegangen, dass der Namespace-URI der leere Namespace ist. Wenn Ihr XML `XmlNamespaceManager` -Code einen Standard Namespace enthält, müssen Sie weiterhin verwenden und ein Präfix und einen Namespace-URI hinzufügen. andernfalls werden keine Knoten ausgewählt. Weitere Informationen finden Sie unter [Auswählen von Knoten mithilfe der XPath-Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md).  
  
> [!NOTE]
>  Ein häufiges Problem beim Formulieren von XPath-Ausdrücken besteht darin, wie Sie ein einzelnes Anführungszeichen (') oder doppelte Anführungszeichen (") in den Ausdruck einschließen. Wenn Sie nach einem Wert suchen müssen, der ein einzelnes Anführungszeichen enthält, müssen Sie die Zeichenfolge in doppelte Anführungszeichen einschließen. Wenn Sie nach einem Wert suchen müssen, der ein doppeltes Anführungszeichen enthält, müssen Sie die Zeichenfolge in einfache Anführungszeichen einschließen.  
  
 Nehmen Sie beispielsweise an, Sie verfügen über die folgenden XML-Daten:  
  
```xml  
<bookstore>  
  <book>  
    <title>&apos;Emma&apos;</title>  
  </book>  
</bookstore>  
```  
  
 Der folgende Visual Basic Code wählt ein Element aus, das einfache Anführungszeichen enthält:  
  
```csharp  
nodeList = root.SelectNodes("//book[contains(title,""'Emma'"")]")  
```  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
 Das <xref:System.Xml.XmlNodeList> von dieser Methode zurückgegebene Objekt ist gültig, während das zugrunde liegende Dokument unverändert bleibt. Wenn das zugrunde liegende Dokument geändert wird, können unerwartete Ergebnisse zurückgegeben werden (es wird keine Ausnahme ausgelöst).  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Bücher ausgewählt, bei denen der Nachname des Autors Austen ist, und dann der Preis dieser Bücher geändert wird.  
  
 [!code-cpp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/VB/source.vb#1)]  
  
 In diesem Beispiel wird der folgende XML-Code verwendet:  
  
 [!code-xml[Classic WebData XmlNode.SelectNodes Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XPath.XPathException">Der XPath-Ausdruck enthält ein Präfix. Siehe [XPath-Beispiele](https://msdn.microsoft.com/library/1431789e-c545-4765-8c09-3057e07d3041).</exception>
        <altmember cref="M:System.Xml.XmlNode.SelectSingleNode(System.String)" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">XPath-Auswahl und benutzerdefinierte Funktionen und mehr</related>
        <related type="ExternalDocumentation" href="https://www.w3.org/TR/1999/REC-xpath-19991116/">W3C-Empfehlung zu XPath 1,0</related>
      </Docs>
    </Member>
    <Member MemberName="SelectNodes">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNodeList SelectNodes (string xpath, System.Xml.XmlNamespaceManager nsmgr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlNodeList SelectNodes(string xpath, class System.Xml.XmlNamespaceManager nsmgr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.SelectNodes(System.String,System.Xml.XmlNamespaceManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNodes (xpath As String, nsmgr As XmlNamespaceManager) As XmlNodeList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlNodeList ^ SelectNodes(System::String ^ xpath, System::Xml::XmlNamespaceManager ^ nsmgr);" />
      <MemberSignature Language="F#" Value="member this.SelectNodes : string * System.Xml.XmlNamespaceManager -&gt; System.Xml.XmlNodeList" Usage="xmlNode.SelectNodes (xpath, nsmgr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xpath" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nsmgr" Type="System.Xml.XmlNamespaceManager" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="xpath">Der XPath-Ausdruck. Siehe [XPath-Beispiele](https://msdn.microsoft.com/library/1431789e-c545-4765-8c09-3057e07d3041).</param>
        <param name="nsmgr">Ein <see cref="T:System.Xml.XmlNamespaceManager" /> zum Auflösen von Namespaces für Präfixe im XPath-Ausdruck.</param>
        <summary>Wählt eine Liste von Knoten aus, die mit dem XPath-Ausdruck übereinstimmen. Sämtliche im XPath-Ausdruck vorhandenen Präfixe werden mit dem angegebenen <see cref="T:System.Xml.XmlNamespaceManager" /> aufgelöst.</summary>
        <returns>Eine <see cref="T:System.Xml.XmlNodeList" /> mit einer Auflistung der Knoten, die mit der XPath-Abfrage übereinstimmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XPath-Ausdrücke können Namespaces enthalten. Namespace-Auflösung wird mithilfe von `XmlNamespaceManager` unterstützt. Wenn der XPath-Ausdruck ein Präfix enthält, müssen das Paar aus Präfix-und Namespace `XmlNamespaceManager`-URI hinzugefügt werden.  
  
> [!NOTE]
>  Wenn der XPath-Ausdruck kein Präfix enthält, wird davon ausgegangen, dass der Namespace-URI der leere Namespace ist. Wenn Ihr XML-Code einen Standard Namespace enthält, müssen Sie trotzdem ein Präfix und einen Namespace `XmlNamespaceManager`-URI hinzufügen. andernfalls werden keine Knoten ausgewählt. Weitere Informationen finden Sie unter [Auswählen von Knoten mithilfe der XPath-Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md).  
  
 Wenn Sie z. b. den folgenden XML-Code haben:  
  
```xml  
<bookstore xmlns="http://www.lucernepublishing.com">  
 <book>  
   <title>Pride And Prejudice</title>  
 </book>  
</bookstore>  
```  
  
 Der folgende C# Code wählt alle Buch Knoten aus:  
  
```csharp  
XmlNamespaceManager nsmgr = new XmlNamespaceManager(doc.NameTable);  
nsmgr.AddNamespace("ab", "http://www.lucernepublishing.com");  
XmlNodeList nodelist = doc.SelectNodes("//ab:book", nsmgr);  
```  
  
> [!NOTE]
>  Ein häufiges Problem beim Formulieren von XPath-Ausdrücken besteht darin, wie Sie ein einzelnes Anführungszeichen (') oder doppelte Anführungszeichen (") in den Ausdruck einschließen. Wenn Sie nach einem Wert suchen müssen, der ein einzelnes Anführungszeichen enthält, müssen Sie die Zeichenfolge in doppelte Anführungszeichen einschließen. Wenn Sie nach einem Wert suchen müssen, der ein doppeltes Anführungszeichen enthält, müssen Sie die Zeichenfolge in einfache Anführungszeichen einschließen.  
  
 Nehmen Sie beispielsweise an, Sie verfügen über die folgenden XML-Daten:  
  
```xml  
<bookstore xmlns="http://www.lucernepublishing.com">  
  <book>  
    <title>&apos;Emma&apos;</title>  
  </book>  
</bookstore>  
```  
  
 Der folgende Visual Basic Code wählt ein Element aus, das einfache Anführungszeichen enthält:  
  
```vb  
Dim nsmgr As XmlNamespaceManager = New XmlNamespaceManager(doc.NameTable)  
nsmgr.AddNamespace("ab", "http://www.lucernepublishing.com")  
nodeList = root.SelectNodes("//ab:book[contains(ab:title,""'Emma'"")]", nsmgr)  
```  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
 Das <xref:System.Xml.XmlNodeList> von dieser Methode zurückgegebene Objekt ist gültig, während das zugrunde liegende Dokument unverändert bleibt. Wenn das zugrunde liegende Dokument geändert wird, können unerwartete Ergebnisse zurückgegeben werden (es wird keine Ausnahme ausgelöst).  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Werte der einzelnen ISBN-Attribute angezeigt. In diesem Beispiel wird <xref:System.Xml.XmlElement> ein-Objekt verwendet, das von <xref:System.Xml.XmlNode> der-Klasse erbt.  
  
 [!code-cpp[XmlNode.SelectNodes1#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlNode.SelectNodes1/CPP/selectnodes1.cpp#1)]
 [!code-csharp[XmlNode.SelectNodes1#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlNode.SelectNodes1/CS/selectnodes1.cs#1)]
 [!code-vb[XmlNode.SelectNodes1#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlNode.SelectNodes1/VB/selectnodes1.vb#1)]  
  
 Im Beispiel wird die-Datei `booksort.xml`als Eingabe verwendet.  
  
 [!code-xml[Classic WebData XmlNode.SelectNodes Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XPath.XPathException">Der XPath-Ausdruck enthält ein Präfix, das im <see langword="XmlNamespaceManager" /> nicht definiert ist.</exception>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">XPath-Auswahl und benutzerdefinierte Funktionen und mehr</related>
        <related type="ExternalDocumentation" href="https://www.w3.org/TR/1999/REC-xpath-19991116/">W3C-Empfehlung zu XPath 1,0</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SelectSingleNode">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wählt den ersten <see langword="XmlNode" /> aus, der mit dem XPath-Ausdruck übereinstimmt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XPath-Ausdrücke können Namespaces enthalten. Namespace-Auflösung wird mithilfe von `XmlNamespaceManager` unterstützt. Wenn der XPath-Ausdruck ein Präfix enthält, müssen das Paar aus Präfix-und Namespace `XmlNamespaceManager`-URI hinzugefügt werden.  
  
> [!NOTE]
>  Wenn der XPath-Ausdruck kein Präfix enthält, wird davon ausgegangen, dass der Namespace-URI der leere Namespace ist. Wenn Ihr XML-Code einen Standard Namespace enthält, müssen Sie trotzdem ein Präfix und einen Namespace `XmlNamespaceManager`-URI hinzufügen. andernfalls werden keine Knoten ausgewählt. Weitere Informationen finden Sie unter [Auswählen von Knoten mithilfe der XPath-Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird das erste Buch mit dem passenden Autorennamen zurückgegeben. `XmlNamespaceManager` löst den Standardnamespace im XPath-Ausdruck auf.  
  
 [!code-cpp[XmlNode.SelectSingleNode2#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlNode.SelectSingleNode2/CPP/XmlNode.SelectSingleNode2.cpp#1)]
 [!code-csharp[XmlNode.SelectSingleNode2#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlNode.SelectSingleNode2/CS/selectsingnode2.cs#1)]
 [!code-vb[XmlNode.SelectSingleNode2#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlNode.SelectSingleNode2/VB/selectsingnode2.vb#1)]  
  
 Im Beispiel wird die-Datei `newbooks.xml`als Eingabe verwendet.  
  
 [!code-xml[XmlNode.SelectSingleNode2#2](~/samples/snippets/xml/VS_Snippets_Data/XmlNode.SelectSingleNode2/XML/newbooks.xml#2)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">XPath-Auswahl und benutzerdefinierte Funktionen und mehr</related>
        <related type="ExternalDocumentation" href="https://www.w3.org/TR/1999/REC-xpath-19991116/">W3C-Empfehlung zu XPath 1,0</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="SelectSingleNode">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNode SelectSingleNode (string xpath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlNode SelectSingleNode(string xpath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.SelectSingleNode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectSingleNode (xpath As String) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlNode ^ SelectSingleNode(System::String ^ xpath);" />
      <MemberSignature Language="F#" Value="member this.SelectSingleNode : string -&gt; System.Xml.XmlNode" Usage="xmlNode.SelectSingleNode xpath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xpath" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="xpath">Der XPath-Ausdruck. Siehe [XPath-Beispiele](https://msdn.microsoft.com/library/1431789e-c545-4765-8c09-3057e07d3041).</param>
        <summary>Wählt den ersten <see langword="XmlNode" /> aus, der mit dem XPath-Ausdruck übereinstimmt.</summary>
        <returns>Der erste <see langword="XmlNode" />, der mit der XPath-Abfrage übereinstimmt, oder <see langword="null" />, wenn kein übereinstimmender Knoten gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn für den XPath-Ausdruck eine Namespace Auflösung erforderlich ist, `SelectSingleNode` müssen Sie die- <xref:System.Xml.XmlNamespaceManager> Überladung verwenden, die einen als sein Argument annimmt. Der `XmlNamespaceManager` wird zum Auflösen von Namespaces verwendet.  
  
> [!NOTE]
>  Wenn der XPath-Ausdruck kein Präfix enthält, wird davon ausgegangen, dass der Namespace-URI der leere Namespace ist. Wenn Ihr XML `XmlNamespaceManager` -Code einen Standard Namespace enthält, müssen Sie weiterhin verwenden und ein Präfix und einen Namespace-URI hinzufügen. andernfalls erhalten Sie keinen ausgewählten Knoten. Weitere Informationen finden Sie unter [Auswählen von Knoten mithilfe der XPath-Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md).  
  
> [!NOTE]
>  Ein häufiges Problem beim Formulieren von XPath-Ausdrücken besteht darin, wie Sie ein einzelnes Anführungszeichen (') oder doppelte Anführungszeichen (") in den Ausdruck einschließen. Wenn Sie nach einem Wert suchen müssen, der ein einzelnes Anführungszeichen enthält, müssen Sie die Zeichenfolge in doppelte Anführungszeichen einschließen. Wenn Sie nach einem Wert suchen müssen, der ein doppeltes Anführungszeichen enthält, müssen Sie die Zeichenfolge in einfache Anführungszeichen einschließen.  
  
 Nehmen Sie beispielsweise an, Sie verfügen über die folgenden XML-Daten:  
  
```xml  
<bookstore>  
  <book>  
    <title>&apos;Emma&apos;</title>  
  </book>  
</bookstore>  
```  
  
 Der folgende Visual Basic Code wählt ein Element aus, das einfache Anführungszeichen enthält:  
  
```  
book = root.SelectSingleNode("descendant::book[title=""'Emma'""]")  
```  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Preis des ersten Jane Austen-Buchs geändert.  
  
 [!code-cpp[Classic WebData XmlNode.SelectSingleNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectSingleNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectSingleNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectSingleNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectSingleNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectSingleNode Example/VB/source.vb#1)]  
  
 Im Beispiel wird die-Datei `booksort.xml`als Eingabe verwendet.  
  
 [!code-xml[Classic WebData XmlNode.SelectSingleNode Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNode.SelectSingleNode Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XPath.XPathException">Der XPath-Ausdruck enthält ein Präfix.</exception>
        <altmember cref="M:System.Xml.XmlNode.SelectNodes(System.String)" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">XPath-Auswahl und benutzerdefinierte Funktionen und mehr</related>
        <related type="ExternalDocumentation" href="https://www.w3.org/TR/1999/REC-xpath-19991116/">W3C-Empfehlung zu XPath 1,0</related>
      </Docs>
    </Member>
    <Member MemberName="SelectSingleNode">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNode SelectSingleNode (string xpath, System.Xml.XmlNamespaceManager nsmgr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlNode SelectSingleNode(string xpath, class System.Xml.XmlNamespaceManager nsmgr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.SelectSingleNode(System.String,System.Xml.XmlNamespaceManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectSingleNode (xpath As String, nsmgr As XmlNamespaceManager) As XmlNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlNode ^ SelectSingleNode(System::String ^ xpath, System::Xml::XmlNamespaceManager ^ nsmgr);" />
      <MemberSignature Language="F#" Value="member this.SelectSingleNode : string * System.Xml.XmlNamespaceManager -&gt; System.Xml.XmlNode" Usage="xmlNode.SelectSingleNode (xpath, nsmgr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xpath" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="nsmgr" Type="System.Xml.XmlNamespaceManager" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="xpath">Der XPath-Ausdruck. Siehe [XPath-Beispiele](https://msdn.microsoft.com/library/1431789e-c545-4765-8c09-3057e07d3041).</param>
        <param name="nsmgr">Ein <see cref="T:System.Xml.XmlNamespaceManager" /> zum Auflösen von Namespaces für Präfixe im XPath-Ausdruck.</param>
        <summary>Wählt den ersten <see langword="XmlNode" /> aus, der mit dem XPath-Ausdruck übereinstimmt. Sämtliche im XPath-Ausdruck vorhandenen Präfixe werden mit dem angegebenen <see cref="T:System.Xml.XmlNamespaceManager" /> aufgelöst.</summary>
        <returns>Der erste <see langword="XmlNode" />, der mit der XPath-Abfrage übereinstimmt, oder <see langword="null" />, wenn kein übereinstimmender Knoten gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XPath-Ausdrücke können Namespaces enthalten. Namespace-Auflösung wird mithilfe von `XmlNamespaceManager` unterstützt. Wenn der XPath-Ausdruck ein Präfix enthält, müssen das Paar aus Präfix-und Namespace `XmlNamespaceManager`-URI hinzugefügt werden.  
  
> [!NOTE]
>  Wenn der XPath-Ausdruck kein Präfix enthält, wird davon ausgegangen, dass der Namespace-URI der leere Namespace ist. Wenn Ihr XML-Code einen Standard Namespace enthält, müssen Sie trotzdem ein Präfix und einen Namespace `XmlNamespaceManager`-URI hinzufügen. andernfalls wird kein Knoten ausgewählt. Weitere Informationen finden Sie unter [Auswählen von Knoten mithilfe der XPath-Navigation](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md).  
  
 Wenn Sie z. b. den folgenden XML-Code haben:  
  
```xml  
<bookstore xmlns="http://www.lucernepublishing.com">  
 <book>  
   <title>Pride And Prejudice</title>  
 </book>  
</bookstore>  
```  
  
 Der folgende C# Code wählt den ersten Buch Knoten aus:  
  
```csharp  
XmlNamespaceManager nsmgr = new XmlNamespaceManager(doc.NameTable);  
nsmgr.AddNamespace("ab", "http://www.lucernepublishing.com");  
XmlNode book = doc.SelectSingleNode("//ab:book", nsmgr);  
```  
  
> [!NOTE]
>  Ein häufiges Problem beim Formulieren von XPath-Ausdrücken besteht darin, wie Sie ein einzelnes Anführungszeichen (') oder doppelte Anführungszeichen (") in den Ausdruck einschließen. Wenn Sie nach einem Wert suchen müssen, der ein einzelnes Anführungszeichen enthält, müssen Sie die Zeichenfolge in doppelte Anführungszeichen einschließen. Wenn Sie nach einem Wert suchen müssen, der ein doppeltes Anführungszeichen enthält, müssen Sie die Zeichenfolge in einfache Anführungszeichen einschließen.  
  
 Nehmen Sie beispielsweise an, Sie verfügen über die folgenden XML-Daten:  
  
```xml  
<bookstore xmlns="http://www.lucernepublishing.com">  
  <book>  
    <title>&apos;Emma&apos;</title>  
  </book>  
</bookstore>  
```  
  
 Der folgende Visual Basic Code wählt ein Element aus, das einfache Anführungszeichen enthält:  
  
```vb  
Dim nsmgr As XmlNamespaceManager = New XmlNamespaceManager(doc.NameTable)  
nsmgr.AddNamespace("ab", "http://www.lucernepublishing.com")  
book = root.SelectSingleNode("descendant::ab:book[ab:title=""'Emma'""]", nsmgr)  
```  
  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM).  
  
   
  
## Examples  
 Im folgenden Beispiel wird das Buch mit dem entsprechenden ISBN-Wert ausgewählt.  
  
 [!code-cpp[XmlNode.SelectSingleNode1#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlNode.SelectSingleNode1/CPP/selectsingnode.cpp#1)]
 [!code-csharp[XmlNode.SelectSingleNode1#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlNode.SelectSingleNode1/CS/selectsingnode.cs#1)]
 [!code-vb[XmlNode.SelectSingleNode1#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlNode.SelectSingleNode1/VB/selectsingnode.vb#1)]  
  
 Im Beispiel wird die-Datei `booksort.xml`als Eingabe verwendet.  
  
 [!code-xml[Classic WebData XmlNode.SelectNodes Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XPath.XPathException">Der XPath-Ausdruck enthält ein Präfix, das im <see langword="XmlNamespaceManager" /> nicht definiert ist.</exception>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/magazine/cc188773.aspx">XPath-Auswahl und benutzerdefinierte Funktionen und mehr</related>
        <related type="ExternalDocumentation" href="https://www.w3.org/TR/1999/REC-xpath-19991116/">W3C-Empfehlung zu XPath 1,0</related>
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (string feature, string version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(string feature, string version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.Supports(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (feature As String, version As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::String ^ feature, System::String ^ version);" />
      <MemberSignature Language="F#" Value="abstract member Supports : string * string -&gt; bool&#xA;override this.Supports : string * string -&gt; bool" Usage="xmlNode.Supports (feature, version)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="feature" Type="System.String" />
        <Parameter Name="version" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="feature">Der Paketname des zu testenden Features. Bei diesem Namen wird die Groß- und Kleinschreibung nicht berücksichtigt.</param>
        <param name="version">Die Versionsnummer des zu testenden Paketnamens. Wenn die Version nicht angegeben ist (NULL) und jede Version der Funktion unterstützt wird, gibt die Methode True zurück.</param>
        <summary>Überprüft, ob die DOM-Implementierung ein bestimmtes Funktion implementiert.</summary>
        <returns><see langword="true" />, wenn das Feature in der angegebenen Version implementiert ist, andernfalls <see langword="false" />. In der folgenden Tabelle werden die Kombinationen beschrieben, bei denen <see langword="true" /> zurückgegeben wird.  
  
 <list type="table"><listheader><term> Feature 
 </term><description> Version 
 </description></listheader><item><term> XML 
 </term><description> 1.0 
 </description></item><item><term> XML 
 </term><description> 2.0 
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.XmlNode.GetEnumerator" />.</summary>
        <returns>Ein Enumerator für die Auflistung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Xml.XmlNode>-Instanz in eine <xref:System.Collections.IEnumerable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ICloneable.Clone">
      <MemberSignature Language="C#" Value="object ICloneable.Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ICloneable.Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.System#ICloneable#Clone" />
      <MemberSignature Language="VB.NET" Value="Function Clone () As Object Implements ICloneable.Clone" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ICloneable.Clone() = ICloneable::Clone;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.XmlNode.Clone" />.</summary>
        <returns>Eine Kopie des Knotens, von dem der Aufruf erfolgt ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Xml.XmlNode>-Instanz in eine <xref:System.ICloneable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public virtual string Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlNode.Value" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Value { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Value : string with get, set" Usage="System.Xml.XmlNode.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Wert des Knotens ab oder legt diesen fest.</summary>
        <value>Der zurückgegebene Wert hängt vom <see cref="P:System.Xml.XmlNode.NodeType" /> des Knotens ab: 
 <list type="table"><listheader><term> Typ 
 </term><description> Wert 
 </description></listheader><item><term> Attribut 
 </term><description> Der Wert des Attributs.  
  
 </description></item><item><term> CDATASection 
 </term><description> Der Inhalt des CDATA-Abschnitts.  
  
 </description></item><item><term> Kommentar 
 </term><description> Der Inhalt des Kommentars.  
  
 </description></item><item><term> Dokument 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> DocumentFragment 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> DocumentType 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> Element 
 </term><description><see langword="null" />. Sie können mit der <see cref="P:System.Xml.XmlElement.InnerText" />-Eigenschaft oder der <see cref="P:System.Xml.XmlElement.InnerXml" />-Eigenschaft auf den Wert des Elementknotens zugreifen.  
  
 </description></item><item><term> Entität 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> EntityReference 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> Notation 
 </term><description><see langword="null" />.  
  
 </description></item><item><term> ProcessingInstruction 
 </term><description> Der gesamte Inhalt mit Ausnahme des Ziels.  
  
 </description></item><item><term> Text 
 </term><description> Der Inhalt des Textknotens.  
  
 </description></item><item><term> SignificantWhitespace 
 </term><description> Die Leerraumzeichen. Leerraum kann aus einem oder mehreren Leerzeichen, Wagenrückläufen, Zeilenvorschüben und Tabstopps bestehen.  
  
 </description></item><item><term> Whitespace 
 </term><description> Die Leerraumzeichen. Leerraum kann aus einem oder mehreren Leerzeichen, Wagenrückläufen, Zeilenvorschüben und Tabstopps bestehen.  
  
 </description></item><item><term> XmlDeclaration 
 </term><description> Der Inhalt der Deklaration (d. h. alles &lt;zwischen "? XML&gt;" und "?").  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird dem XML-Dokument ein neues-Attribut hinzugefügt <xref:System.Xml.XmlNode.Value%2A> und die-Eigenschaft des neuen Attributs festgelegt.  
  
 [!code-cpp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.GetNamespaceOfPrefix Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.GetNamespaceOfPrefix Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Festlegen des Werts eines schreibgeschützten Knotens.</exception>
        <exception cref="T:System.InvalidOperationException">Festlegen des Werts eines Knotens, der normalerweise keinen Wert besitzt (z. B. ein Elementknoten).</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteContentTo">
      <MemberSignature Language="C#" Value="public abstract void WriteContentTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteContentTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.WriteContentTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteContentTo (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteContentTo(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="abstract member WriteContentTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlNode.WriteContentTo w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">Der <see langword="XmlWriter" />, in dem gespeichert werden soll.</param>
        <summary>Speichert beim Überschreiben in einer abgeleiteten Klasse sämtliche untergeordneten Knoten des Knotens im angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM). Sie ist funktionell gleichwertig mit <xref:System.Xml.XmlNode.InnerXml%2A> der-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt des Stamm Knotens der Konsole angezeigt.  
  
 [!code-cpp[Classic WebData XmlNode.WriteContentTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.WriteContentTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.WriteContentTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.WriteContentTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.WriteContentTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.WriteContentTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.XmlNode.WriteTo(System.Xml.XmlWriter)" />
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public abstract void WriteTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlNode.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteTo (w As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteTo(System::Xml::XmlWriter ^ w);" />
      <MemberSignature Language="F#" Value="abstract member WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xmlNode.WriteTo w" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">Der <see langword="XmlWriter" />, in dem gespeichert werden soll.</param>
        <summary>Speichert beim Überschreiben in einer abgeleiteten Klasse den aktuellen Knoten im angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine Microsoft-Erweiterung für die Dokumentobjektmodell (DOM). Sie ist funktionell gleichwertig mit <xref:System.Xml.XmlNode.OuterXml%2A> der-Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Stamm Knoten in der Konsole angezeigt.  
  
 [!code-cpp[Classic WebData XmlNode.WriteTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.WriteTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.WriteTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.WriteTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.WriteTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.WriteTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
