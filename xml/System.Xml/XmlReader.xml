<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="90a6a0facff37d5e17e797e128971423207eeb48" /><Meta Name="ms.sourcegitcommit" Value="2982b8c4cce02c2542285fcaf172f7544d6b80bc" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/09/2019" /><Meta Name="ms.locfileid" Value="59355136" /></Metadata><TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReader abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type XmlReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Reader dar, der einen schnellen Zugriff auf XML-Daten bietet, ohne Zwischenspeicher und welcher nur vorwärts möglich ist.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader> bietet Vorwärtscursor, schreibgeschützte Zugriff auf XML-Daten in einem Dokument oder den Stream. Diese Klasse entspricht den W3C [Extensible Markup Language (XML) 1.0 (fourth Edition)](https://www.w3.org/TR/2006/REC-xml-20060816/) und [-Namespaces in XML 1.0 (3. Auflage)](https://www.w3.org/TR/REC-xml-names/) Empfehlungen.  
  
 <xref:System.Xml.XmlReader> -Methoden können Sie die XML-Daten durchlaufen und den Inhalt eines Knotens lesen. Die Eigenschaften der Klasse entsprechen den Wert des aktuellen Knotens handelt es sich, in dem der Reader positioniert ist. Die <xref:System.Xml.XmlReader.ReadState%2A> -Eigenschaftenwert gibt an, den aktuellen Zustand des XML-Reader. Beispielsweise ist die Eigenschaft auf festgelegt <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType> durch die <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> Methode und <xref:System.Xml.ReadState.Closed?displayProperty=nameWithType> von der <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> Methode. <xref:System.Xml.XmlReader> bietet die datenkonformitätsüberprüfung und eine DTD oder Schema-Validierung.  
  
 <xref:System.Xml.XmlReader> verwendet ein Pull-Modell zum Abrufen von Daten an. Dieses Modell:  
  
-   Vereinfacht die Verwaltung des Zustands von einem natürlichen und von oben nach unten Prozedur.  
  
-   Unterstützt mehrere Eingabedatenströme und überlagern.  
  
-   Ermöglicht den Client, der Parser einen Puffer übergeben, in dem die Zeichenfolge direkt geschrieben werden, und vermeidet somit die Notwendigkeit einer zusätzlichen Zeichenfolge, die Kopie.  
  
-   Unterstützt das selektive Verarbeitung. Der Client kann Elemente überspringen und zu verarbeiten, die für die Anwendung von Interesse sind. Sie können auch festlegen, dass Eigenschaften im Voraus für die Verwaltung, wie der XML-Stream (z. B. Normalisierung) verarbeitet wird.  
  
 In diesem Abschnitt  
  
 [Erstellen einen XML-reader](#xmlreader_create)   
 [Validieren von XML-Daten](#xmlreader_validate)   
 [Datenübereinstimmung](#xmlreader_data)   
 [Navigieren durch die Knoten](#xmlreader_nodes)   
 [Lesen der XML-Elemente](#xmlreader_elements)   
 [Lesen der XML-Attribute](#xmlreader_attributes)   
 [Lesen der XML-Inhalt](#xmlreader_content)   
 [Konvertieren CLR-Typen](#xmlreader_clr)   
 [Asynchrone Programmierung](#xmlreader_async)   
 [Sicherheitsüberlegungen](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>Erstellen einen XML-reader  
 Verwenden der <xref:System.Xml.XmlReader.Create%2A> Methode zum Erstellen einer <xref:System.Xml.XmlReader> Instanz.  
  
 Zwar .NET Framework konkrete Implementierungen der <xref:System.Xml.XmlReader> Klasse, z. B. die <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>, und die <xref:System.Xml.XmlValidatingReader> Klassen, es wird empfohlen, dass Sie die spezialisierten Klassen nur in diesen Szenarien verwenden:  
  
-   Wenn Sie eine XML-DOM-Unterstruktur aus lesen möchten eine <xref:System.Xml.XmlNode> -Objekts die <xref:System.Xml.XmlNodeReader> Klasse. (Jedoch nicht diese Klasse DTD- oder schemavalidierung unterstützen.)  
  
-   Wenn müssen Sie Entitäten auf Anforderung erweitern, Sie nicht Ihren Text Content normalisiert, oder Sie möchten nicht standardmäßige Attribute zurückgegeben, verwenden Sie die <xref:System.Xml.XmlTextReader> Klasse.  
  
 Um den Satz von Features für den XML-Reader aktivieren möchten, übergeben einen <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> -Objekt an die <xref:System.Xml.XmlReader.Create%2A> Methode. Können Sie eine einzelne <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> das Objekt, für mehrere Reader mit denselben Funktionen zu erstellen, oder ändern Sie die <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> Objekt, um einen neuen Reader mit einem anderen Satz von Features zu erstellen. Sie können auch auf einfache Weise einem vorhandenen Reader Funktionen hinzufügen.  
  
 Wenn Sie nicht verwenden eine <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> Objekt ist, werden Standardeinstellungen verwendet. Finden Sie unter den <xref:System.Xml.XmlReader.Create%2A> Referenzseite für Details.  
  
 <xref:System.Xml.XmlReader> Löst ein <xref:System.Xml.XmlException> auf XML-Analysefehler. Nachdem eine Ausnahme ausgelöst wird, ist der Zustand des Readers nicht vorhersagbar. Beispielsweise kann der angegebene Knotentyp sich von dem Typ der Knoten des aktuellen Knotens sein. Verwenden der <xref:System.Xml.XmlReader.ReadState%2A> Eigenschaft zu überprüfen, ob der Reader befindet sich im Status "Fehler".  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>Validieren von XML-Daten  
 Um die Struktur von XML-Dokument und dessen elementbeziehungen, Datentypen und inhaltseinschränkungen anzugeben, verwenden Sie eine Dokumenttypdefinition (DTD) oder das Schema für XML Schema Definition Language (XSD). Ein XML-Dokument gilt als wohlgeformt sein, wenn es alle syntaktischen Anforderungen von definierten erfüllt die [W3C XML 1.0 Recommendation](https://www.w3.org/TR/2006/REC-xml-20060816/). Es ist gültig, wenn es sowohl wohlgeformt ist und auch die Einschränkungen der DTD oder Schema entspricht. (Finden Sie unter den [W3C XML Schema Part 1: Strukturen](https://www.w3.org/TR/xmlschema-1/) und [W3C XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/) Empfehlungen.) Obwohl alle gültigen XML-Dokumente wohlgeformt sind, sind daher nicht alle wohlgeformten XML-Dokumente gültig.  
  
 Sie können überprüfen, dass die Daten anhand einer DTD, die eine Inline-XSD-Schema oder ein XSD-Schema in ein <xref:System.Xml.Schema.XmlSchemaSet> Objekt (einen Cache); diese Szenarien werden beschrieben, auf die <xref:System.Xml.XmlReader.Create%2A> Referenzseite. <xref:System.Xml.XmlReader> Schema-Validierung von XML-Data Reduced (XDR) nicht unterstützt werden.  
  
 Verwenden Sie die folgenden Einstellungen auf der <xref:System.Xml.XmlReaderSettings> Klasse, um welche Art von Validierung, geben Sie ggf. die <xref:System.Xml.XmlReader> Instanz unterstützt.  
  
|Verwenden Sie diese Option <xref:System.Xml.XmlReaderSettings> Member|Angabe von|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> property|Ob die DTD-Verarbeitung zu ermöglichen. Standardmäßig werden DTD-Verarbeitung nicht zugelassen.|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> property|Gibt an, ob der Reader die Daten überprüfen soll, und welche Art der Überprüfung (DTD oder Schema) durchgeführt. Der Standardwert ist keine Validierung.|  
|<xref:System.Xml.XmlReaderSettings.ValidationEventHandler> event|Ein Ereignishandler für das Informationen über Validierungsereignisse empfangen. Wenn ein Ereignishandler nicht angegeben wird, eine <xref:System.Xml.XmlException> beim ersten Validierungsfehler ausgelöst wird.|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> property|Zusätzlicher Validierung "Optionen" über die <xref:System.Xml.Schema.XmlSchemaValidationFlags> Enumerationsmember:<br /><br /> -   `AllowXmlAttributes`– Lassen XML-Attribute (`xml:*`) in Instanzdokumenten auch, wenn sie nicht im Schema definiert sind. Die Attribute werden anhand ihres Datentyps validiert. Finden Sie unter den <xref:System.Xml.Schema.XmlSchemaValidationFlags> Referenzseite für die Einstellung für die Verwendung in bestimmten Szenarien. (Standardmäßig deaktiviert).<br />-   `ProcessIdentityConstraints` --Prozessidentitätsconstraints (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, `xs:unique`) während der Validierung gefunden. (Standardmäßig aktiviert).<br />-   `ProcessSchemaLocation` – Verarbeiten Sie anhand des Schemas der `xsi:schemaLocation` oder `xsi:noNamespaceSchemaLocation` Attribut. (Standardmäßig aktiviert).<br />-   `ProcessInlineSchema`– Verarbeiten von Inline-XML-Schemas während der Überprüfung. (Standardmäßig deaktiviert).<br />-   `ReportValidationWarnings`--Melden Sie Ereignisse, wenn eine überprüfungswarnung auftritt. In der Regel wird eine Warnung ausgegeben, wenn keine DTD oder XML-Schema überprüft ein bestimmtes Element oder Attribut, für. Die <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> wird zur Benachrichtigung verwendet. (Standardmäßig deaktiviert).|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|Die für die Validierung zu verwendende <xref:System.Xml.Schema.XmlSchemaSet>.|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> property|Die <xref:System.Xml.XmlResolver> zum Auflösen von und Zugreifen auf externe Ressourcen. Dies kann externe Entitäten wie z. B. DTD und Schemas sowie alle umfassen `xs:include` oder `xs:import` in das XML-Schema enthaltenen Elemente. Wenn Sie nicht angeben einer <xref:System.Xml.XmlResolver>, <xref:System.Xml.XmlReader> verwendet einen Standard- <xref:System.Xml.XmlUrlResolver> ohne Benutzeranmeldeinformationen.|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>Datenübereinstimmung  
 Durch die erstellte XML-Reader der <xref:System.Xml.XmlReader.Create%2A> Methode die folgenden Complianceanforderungen erfüllen, werden standardmäßig:  
  
-   Neue Zeilen und Attributwert werden gemäß der W3C normalisiert [XML 1.0 Recommendation](https://www.w3.org/TR/2006/REC-xml-20060816/).  
  
-   Alle Entitäten werden automatisch erweitert.  
  
-   Standardattribute deklariert, die in der Document Type Definition werden immer hinzugefügt werden, selbst wenn der Reader nicht zu überprüfen.  
  
-   Deklaration eines XML-Namespacepräfix, den richtigen XML-Namespace-URI zugeordnet ist zulässig.  
  
-   Die Notationsnamen in einem einzelnen `NotationType` -Attributdeklaration und `NmTokens` in einem einzelnen `Enumeration` Attributdeklaration unterscheiden sich.  
  
 Verwenden Sie diese <xref:System.Xml.XmlReaderSettings> Eigenschaften, die angeben, die Typen der übereinstimmungsprüfungen überprüft Sie aktivieren möchten:  
  
|Verwenden Sie diese Option <xref:System.Xml.XmlReaderSettings> Eigenschaft|Beschreibung|Standard|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> property|Aktivieren oder Deaktivieren von Überprüfungen für Folgendes:<br /><br /> -Zeichen werden innerhalb des Bereichs zulässiger XML-Zeichen gemäß der [2.2 Characters](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets) Abschnitt der W3C-Empfehlung für XML 1.0.<br />-Alle XML-Namen sind gültig, gemäß der [2.3 Common Syntactic Constructs](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) Abschnitt der W3C-Empfehlung für XML 1.0.<br /><br /> Wenn diese Eigenschaft auf festgelegt ist `true` (Standard), ein <xref:System.Xml.XmlException> Ausnahme wird ausgelöst, die XML-Datei enthält unzulässige Zeichen oder eine ungültige XML-Namen (z. B. ein Elementname mit einer Zahl beginnt).|Zeichen- und namensüberprüfung ist aktiviert.<br /><br /> Durch Festlegen von <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> auf `false` wird die Zeichenüberprüfung für Zeichenentitätsverweise deaktiviert. Wenn der Reader Textdaten verarbeitet wird, überprüft, dass die XML-Namen gültig ist, unabhängig von dieser Einstellung sind. **Hinweis:** die Empfehlung XML 1.0-Konformität auf Dokumentebene erfordert, wenn eine DTD vorhanden ist. Aus diesem Grund, wenn der Reader für die Unterstützung konfiguriert ist <xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>, aber die XML-Daten enthält, eine Dokumenttypdefinition (DTD), ein <xref:System.Xml.XmlException> ausgelöst.|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> property|Wählen Sie die Ebene der Übereinstimmung mit Standards, um zu erzwingen:<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. Entsprechen die Regeln für eine [wohlgeformtes XML 1.0-Dokument](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed).<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. Entsprechen den Regeln für ein wohlgeformtes Dokument-Fragment, das als genutzt werden, kann ein [extern analysierte Entität](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities).<br />-   <xref:System.Xml.ConformanceLevel.Auto>. Entspricht der Ebene, die vom Reader entschieden.<br /><br /> Wenn die Daten in Übereinstimmung mit Standards, ist ein <xref:System.Xml.XmlException> Ausnahme ausgelöst.|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>Navigieren durch die Knoten  
 Der aktuelle Knoten ist die XML-Knoten, die auf dem der XML-Reader derzeit positioniert ist. Alle <xref:System.Xml.XmlReader> Methoden führen Vorgänge in Bezug auf diesen Knoten und alle <xref:System.Xml.XmlReader> Eigenschaften reflektiert den Wert des aktuellen Knotens.  
  
 Die folgenden Methoden erleichtern die zum Navigieren durch Knoten, und Analysieren von Daten.  
  
|Verwenden Sie diese Option <xref:System.Xml.XmlReaderSettings> Methode|Beschreibung|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|Lesen Sie den ersten Knoten, und fahren Sie fort, über den Stream einen Knoten zu einem Zeitpunkt. Solche Aufrufe erfolgen in der Regel innerhalb einer `while` Schleife.<br /><br /> Verwenden der <xref:System.Xml.XmlReader.NodeType%2A> Eigenschaft, um den Typ des aktuellen Knotens (z. B. Attribut, Kommentar, Element und So weiter) abzurufen.|  
|<xref:System.Xml.XmlReader.Skip%2A>|Überspringen Sie die untergeordneten Elemente des aktuellen Knotens, und wechseln Sie zum nächsten Knoten.|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> und <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|Übersprungen Sie nicht-Inhaltsknoten, und verschieben Sie auf dem nächsten Inhaltsknoten oder an das Ende der Datei.<br /><br /> Nicht-Inhaltsknoten umfassen <xref:System.Xml.XmlNodeType.ProcessingInstruction>, <xref:System.Xml.XmlNodeType.DocumentType>, <xref:System.Xml.XmlNodeType.Comment>, <xref:System.Xml.XmlNodeType.Whitespace>, und <xref:System.Xml.XmlNodeType.SignificantWhitespace>.<br /><br /> Inhaltsknoten umfassen Textknoten ohne Leerraum, <xref:System.Xml.XmlNodeType.CDATA>, <xref:System.Xml.XmlNodeType.EntityReference> , und <xref:System.Xml.XmlNodeType.EndEntity>.|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|Ein Element und alle zugehörigen untergeordneten Elemente und gibt ein neues <xref:System.Xml.XmlReader> festgelegte Instanz <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>.<br /><br /> Diese Methode ist nützlich zum Erstellen von XML-Elemente für die Begrenzung. Wenn Daten an eine andere Komponente für die Verarbeitung übergeben werden sollen und wie viel der Daten einschränken möchten kann z. B. die Komponente zugreifen.|  
  
 Finden Sie unter den <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> Referenzseite für ein Beispiel für die Navigation zu einem Zeitpunkt Stream ein Textknoten und für den Typ der einzelnen Knoten anzeigen.  
  
 In den folgenden Abschnitten beschrieben, wie Sie bestimmte Typen von Daten, z. B. Elemente, Attribute lesen können und typisierte Daten.  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>Lesen der XML-Elemente  
 Die folgende Tabelle enthält die Methoden und Eigenschaften, die die <xref:System.Xml.XmlReader> -Klasse für Verarbeitungselemente bereitstellt. Nach der <xref:System.Xml.XmlReader> befindet sich auf ein Element, das die Eigenschaften des Knotens, z. B. <xref:System.Xml.XmlReader.Name%2A>, die Elementwerte wider. Zusätzlich zu den Mitgliedern unten, alle allgemeinen Methoden und Eigenschaften der <xref:System.Xml.XmlReader> Klasse kann auch verwendet werden, um Elemente zu verarbeiten. Beispielsweise können Sie die <xref:System.Xml.XmlReader.ReadInnerXml%2A> Methode, um den Inhalt eines Elements lesen.  
  
> [!NOTE]
>  Finden Sie im Abschnitt 3.1 die [W3C XML 1.0 Recommendation](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags) Definitionen von Starttags, Tags und leeres Element-Tags zu beenden.  
  
|Verwenden Sie diese Option <xref:System.Xml.XmlReader> Member|Beschreibung|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.IsStartElement%2A> Methode|Überprüfen Sie, ob der aktuelle Knoten ein Anfangstag oder ein leeres Elementtag ist.|  
|<xref:System.Xml.XmlReader.ReadStartElement%2A> Methode|Überprüfen Sie, ob der aktuelle Knoten ein Element, und treiben Sie den Reader auf den nächsten Knoten (Aufrufe <xref:System.Xml.XmlReader.IsStartElement%2A> gefolgt von <xref:System.Xml.XmlReader.Read%2A>).|  
|<xref:System.Xml.XmlReader.ReadEndElement%2A> Methode|Überprüfen Sie, dass der aktuelle Knoten ein Endtag ist, und fahren Sie fort, des Readers auf den nächsten Knoten.|  
|<xref:System.Xml.XmlReader.ReadElementString%2A> Methode|Lesen eines nur-Text-Elements.|  
|<xref:System.Xml.XmlReader.ReadToDescendant%2A> Methode|Fahren Sie fort, des XML-Readers zum nächsten Element Nachfolger (untergeordnete), die dem angegebenen Namen ab.|  
|<xref:System.Xml.XmlReader.ReadToNextSibling%2A> Methode|Fahren Sie fort, des XML-Readers auf die nächste nebengeordnete Element mit dem angegebenen Namen ab.|  
|<xref:System.Xml.XmlReader.IsEmptyElement%2A> property|Überprüfen Sie, ob das aktuelle Element ein Endtag aufweist. Beispiel:<br /><br /> -   `<item num="123"/>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> ist `true`.)<br />-   `<item num="123"> </item>` (<xref:System.Xml.XmlReader.IsEmptyElement%2A> ist `false`, obwohl der Inhalt des Elements leer ist.)|  
  
 Ein Beispiel für das Lesen des Textinhalts von Elementen, finden Sie unter den <xref:System.Xml.XmlReader.ReadString%2A> Methode. Im folgende Beispiel verarbeitet Elemente mithilfe einer `while` Schleife.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>Lesen der XML-Attribute  
 XML-Attribute werden am häufigsten für Elemente gefunden, aber sie können auch auf XML-Deklaration und Dokumenttypknoten zulässig.  
  
 Wenn auf einem Elementknoten positioniert die <xref:System.Xml.XmlReader.MoveToAttribute%2A> -Methode können Sie das Durchlaufen der Attributliste des Elements. Beachten Sie, dass nach dem <xref:System.Xml.XmlReader.MoveToAttribute%2A> aufgerufen wurde, Eigenschaften des Knotens wie z. B. <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, und <xref:System.Xml.XmlReader.Prefix%2A> geben die Eigenschaften dieses Attributs, nicht die Eigenschaften des Elements das Attribut gehört.  
  
 Die <xref:System.Xml.XmlReader> Klasse enthält, diese Methoden und Eigenschaften zum Lesen und Verarbeiten von Attributen in Elementen.  
  
|Verwenden Sie diese Option <xref:System.Xml.XmlReader> Member|Beschreibung|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.HasAttributes%2A> property|Überprüfen Sie, ob der aktuelle Knoten über Attribute verfügt.|  
|<xref:System.Xml.XmlReader.AttributeCount%2A> property|Die Anzahl der Attribute für das aktuelle Element zu erhalten.|  
|<xref:System.Xml.XmlReader.MoveToFirstAttribute%2A> Methode|Verschieben Sie auf das erste Attribut in einem Element.|  
|<xref:System.Xml.XmlReader.MoveToNextAttribute%2A> Methode|Verschieben Sie auf das nächste Attribut in einem Element.|  
|<xref:System.Xml.XmlReader.MoveToAttribute%2A> Methode|Verschieben Sie in einem angegebenen Attribut.|  
|<xref:System.Xml.XmlReader.GetAttribute%2A> Methode oder <xref:System.Xml.XmlReader.Item%2A> Eigenschaft|Ruft den Wert eines angegebenen Attributs.|  
|<xref:System.Xml.XmlReader.IsDefault%2A> property|Überprüfen Sie, ob der aktuelle Knoten ein Attribut ist, die von den in der DTD oder Schema definierten Standardwert generiert wurde.|  
|<xref:System.Xml.XmlReader.MoveToElement%2A> Methode|Verschieben Sie in das Element, das das aktuelle Attribut besitzt. Verwenden Sie diese Methode, um auf ein Element zurückzugeben, nach der Navigation durch die Attribute.|  
|<xref:System.Xml.XmlReader.ReadAttributeValue%2A> Methode|Analysieren Sie den Wert des Attributs in einen oder mehrere `Text`, `EntityReference`, oder `EndEntity` Knoten.|  
  
 Alle allgemeinen <xref:System.Xml.XmlReader> Methoden und Eigenschaften können auch zum Verarbeiten von Attributen verwendet werden. Z. B. nach der <xref:System.Xml.XmlReader> auf einem Attribut positioniert ist die <xref:System.Xml.XmlReader.Name%2A> und <xref:System.Xml.XmlReader.Value%2A> Eigenschaften stellen die Werte des Attributs. Sie können auch Inhalte `Read` Methoden, um den Wert des Attributs zu erhalten.  
  
 Dieses Beispiel verwendet die <xref:System.Xml.XmlReader.AttributeCount%2A> Eigenschaft, um alle Attribute für ein Element zu navigieren.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 Dieses Beispiel verwendet die <xref:System.Xml.XmlReader.MoveToNextAttribute%2A> -Methode in einer `while` Schleife, um die Navigation in der Attributes.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **Lesen von Attributen in XML-Deklarationsknoten**  
  
 Wenn der XML-Reader auf einem Knoten des XML-Deklaration, befindet die <xref:System.Xml.XmlReader.Value%2A> Eigenschaft gibt die Version, eigenständige und Codierungsinformationen als einzelne Zeichenfolge zurück. <xref:System.Xml.XmlReader> Objekten von erstellt die <xref:System.Xml.XmlReader.Create%2A> -Methode, die <xref:System.Xml.XmlTextReader> -Klasse, und die <xref:System.Xml.XmlValidatingReader> Klasse verfügbar zu machen, die Version, die eigenständige und die Codierung Elemente als Attribute.  
  
 **Lesen von Attributen in Dokumenttypknoten**  
  
 Wenn der XML-Reader auf einem Dokumenttypknoten positioniert ist die <xref:System.Xml.XmlReader.GetAttribute%2A> Methode und <xref:System.Xml.XmlReader.Item%2A> Eigenschaft kann verwendet werden, um die Werte für die Literale SYSTEM und PUBLIC zurückzugeben. Zum Beispiel der Aufruf `reader.GetAttribute("PUBLIC")` der Wert PUBLIC zurückgegeben.  
  
 **Lesen von Attributen auf die Verarbeitungsanweisungsknoten**  
  
 Wenn die <xref:System.Xml.XmlReader> auf einem Verarbeitungsanweisungsknoten positioniert ist die <xref:System.Xml.XmlReader.Value%2A> Eigenschaft gibt den gesamten Textinhalt zurück. Elemente im Verarbeitungsanweisungsknoten werden nicht als Attribute behandelt. Sie können nicht gelesen werden, mit der <xref:System.Xml.XmlReader.GetAttribute%2A> oder <xref:System.Xml.XmlReader.MoveToAttribute%2A> Methode.  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>Lesen der XML-Inhalt  
 Die XMLReader-Klasse enthält die folgenden Elemente, die Lesen von Inhalt aus einer XML-Datei, und geben Sie den Inhalt als Zeichenfolgenwerte zurück. (CLR-Typen finden Sie unter den [nächsten Abschnitt](#xmlreader_clr).)  
  
|Verwenden Sie diese Option <xref:System.Xml.XmlReader> Member|Beschreibung|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Value%2A> property|Rufen Sie den Textinhalt des aktuellen Knotens. Der zurückgegebene Wert hängt von Knotentyp ab. finden Sie unter den <xref:System.Xml.XmlReader.Value%2A> Referenzseite für Details.|  
|<xref:System.Xml.XmlReader.ReadString%2A> Methode|Abrufen des Inhalts einer Element- oder Textknotens als Zeichenfolge an. Diese Methode wird bei verarbeitungsanweisungen und Kommentare beendet.<br /><br /> Weitere Informationen zur Behandlung von bestimmten Knotentypen aufgeführt, die in dieser Methode finden Sie unter den <xref:System.Xml.XmlReader.ReadString%2A> Referenzseite.|  
|<xref:System.Xml.XmlReader.ReadInnerXml%2A> und <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A> Methoden|Rufen Sie alle Inhalte des aktuellen Knotens einschließlich Markup, aber ausschließlich Start- und Endtags. Z. B. für:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A> Gibt zurück:<br /><br /> `this<child id="123"/>`|  
|<xref:System.Xml.XmlReader.ReadOuterXml%2A> und <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A> Methoden|Gesamten Inhalt der den aktuellen Knoten und seine untergeordneten Elemente, einschließlich Markup und Start-/Endtags zu erhalten. Z. B. für:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A> Gibt zurück:<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>Konvertieren CLR-Typen  
 Können Sie die Mitglieder der <xref:System.Xml.XmlReader> Klasse (in der folgenden Tabelle aufgeführt) XML-Daten zu lesen und die Rückgabewerte als common Language Runtime (CLR)-Typen anstelle von Zeichenfolgen. Diese Member können Sie Werte in der Darstellung zu erhalten, die für die Codierung Aufgabe am besten geeignet ist, ohne manuell analysieren oder konvertieren Zeichenfolgenwerte.  
  
-   Die **ReadElementContentAs** Methoden können nur für Elementknotentypen aufgerufen werden. Diese Methoden können nicht auf Elemente verwendet werden, die untergeordnete Elemente oder gemischten Inhalt enthalten. Beim Aufruf der <xref:System.Xml.XmlReader> Objekt liest das Anfangstag und liest den Elementinhalt, und klicken Sie dann direkt hinter das Endelementtag verschoben. Verarbeitungsanweisungen und Kommentare werden ignoriert und Entitäten erweitert.  
  
-   Die **ReadContentAs** Methoden lesen den Textinhalt an der aktuellen Readerposition ab, und wenn die XML-Daten keine Schema- oder Typinformationen zugeordnet, Daten, konvertieren Sie den Textinhalt in den angeforderten Rückgabetyp. Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte sind verkettet. Kommentare und verarbeitungsanweisungen werden übersprungen und Entitätsverweise automatisch aufgelöst werden.  
  
 Die <xref:System.Xml.XmlReader> Klasse verwendet die Regeln der [W3C XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/) Empfehlung.  
  
|Verwenden Sie diese Option <xref:System.Xml.XmlReader> Methode|Um diese CLR-Typ zurückzugeben.|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> und <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|Der Typ, die Sie angeben, mit der `returnType` Parameter|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> und <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|Am besten geeigneten Typs, laut der <xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType> Eigenschaft. Finden Sie unter [Typenunterstützung in den System.Xml-Klassen](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) für Zuordnungsinformationen.|  
  
 Wenn ein Element einfach um einen CLR-Typ aufgrund dessen Format konvertiert werden kann, können Sie eine schemazuordnung, um eine erfolgreiche Konvertierung sicherzustellen. Im folgenden Beispiel wird eine XSD-Datei konvertieren die `hire-date` Element, das `xs:date` Typ und verwendet dann die <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> Methode, um das Element als zurückzugeben eine <xref:System.DateTime> Objekt.  
  
 **Eingabe (hireDate.xml):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **Schema (hireDate.xsd):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **Code:**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **Ausgabe:**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>Asynchrone Programmierung  
 Die meisten der <xref:System.Xml.XmlReader> Methoden verfügen über asynchrone Gegenstücke, die "Async" am Ende den Namen haben. Z. B. das asynchrone Äquivalent von <xref:System.Xml.XmlReader.ReadContentAsObject%2A> ist <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 Die folgenden Methoden können mit asynchrone Methodenaufrufe verwendet werden:  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 Asynchrone Verwendung für Methoden, die keine asynchrone Entsprechungen haben Sie in den folgenden Abschnitten.  
  
 **ReadStartElement-Methode**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **ReadEndElement-Methode**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **ReadToNextSibling-Methode**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **ReadToFollowing-Methode**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **ReadToDescendant-Methode**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 Beachten Sie Folgendes bei der Arbeit mit der <xref:System.Xml.XmlReader> Klasse:  
  
-   Ausnahmen in der <xref:System.Xml.XmlReader> können offen legen, die an die Informationen über Pfade, die Sie nicht möchten, können bis zu Ihrer app. Ihre app muss die Ausnahmen abfangen und diese entsprechend verarbeiten.  
  
-   Aktivieren Sie nicht DTD-Verarbeitung, wenn Sie Bedenken bezüglich eines Denial-of-Service-Problemen-sind oder wenn Sie mit nicht vertrauenswürdigen Quellen arbeiten. DTD-Verarbeitung ist standardmäßig deaktiviert, um <xref:System.Xml.XmlReader> Objekten von erstellt die <xref:System.Xml.XmlReader.Create%2A> Methode.  
  
     Wenn die DTD-Verarbeitung aktiviert ist, können die Ressourcen, auf die der <xref:System.Xml.XmlSecureResolver> Zugriff hat, mit dem <xref:System.Xml.XmlReader> eingeschränkt werden. Sie können auch Ihre app entwerfen, sodass die XML-Verarbeitung bezüglich Arbeitsspeicher und Zeit eingeschränkt. Beispielsweise können Sie die Timeouts in Ihrer ASP.NET-App konfigurieren.  
  
-   XML-Daten können Verweise auf externe Ressourcen wie z. B. eine Schemadatei enthalten. Standardmäßig werden externe Ressourcen aufgelöst, mit einem <xref:System.Xml.XmlUrlResolver> Objekt ohne Benutzeranmeldeinformationen. Durch die folgenden Aktionen können Sie die Sicherheit weiter erhöhen:  
  
    -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
  
    -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
-   Die <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> und <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> Validierungsflag eines ein <xref:System.Xml.XmlReaderSettings> Objekt werden nicht standardmäßig festgelegt. Dies trägt zum Schutz der <xref:System.Xml.XmlReader> vor schemabasierten Angriffen, bei der XML-Daten aus einer nicht vertrauenswürdigen Quelle verarbeitet wird. Wenn diese Flags festgelegt sind, wird der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> des <xref:System.Xml.XmlReaderSettings>-Objekts verwendet, um die im Instanzdokument des <xref:System.Xml.XmlReader> erkannten Schemaspeicherorte aufzulösen. Wenn die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> -Eigenschaftensatz auf `null`, Schemaspeicherorte nicht aufgelöst sind. auch wenn die <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> und <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> Validierungsflag festgelegt sind.  
  
     Durch während der Validierung hinzugefügte Schemas werden neue Typen hinzugefügt, sodass das Validierungsergebnis des überprüften Dokuments möglicherweise geändert wird. Daher sollten externe Schemata nur von vertrauenswürdigen Quellen aufgelöst werden.  
  
     Es wird empfohlen, das Deaktivieren der <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> zu kennzeichnen, wenn nicht vertrauenswürdige, große XML-Dokumente in Szenarien mit hochverfügbarkeit anhand eines Schemas zu überprüfen, die Identity-Einschränkung über einen großen Teil des Dokuments besitzt. Dieses Flag ist standardmäßig aktiviert.  
  
-   XML-Daten können eine Vielzahl von Attributen, Namespacedeklarationen, geschachtelten Elementen usw. enthalten, deren Verarbeitung sehr zeitaufwendig ist. Um die Größe der Eingabe zu begrenzen, die an gesendet wird die <xref:System.Xml.XmlReader>, können Sie:  
  
    -   Begrenzen Sie die Größe des Dokuments durch Festlegen der <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A> Eigenschaft.  
  
    -   Die Anzahl der Zeichen, die sich ergeben, Erweitern von Entitäten durch Festlegen der <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A> Eigenschaft.  
  
    -   Erstellen eines benutzerdefinierten `IStream` Implementierung für die <xref:System.Xml.XmlReader>.  
  
-   Die <xref:System.Xml.XmlReader.ReadValueChunk%2A> Methode kann verwendet werden, um große Datenströme behandeln. Mit dieser Methode wird jeweils eine kleine Anzahl von Zeichen gelesen, anstatt dem ganzen Wert eine einzelne Zeichenfolge zuzuweisen.  
  
-   Beim Lesen eines XML-Dokuments mit einer großen Anzahl von eindeutigen lokalen Namen, Namespaces oder Präfixen kann ein Problem auftreten. Bei Verwendung eine Klasse, die von abgeleitet <xref:System.Xml.XmlReader>, und rufen Sie die <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A>, oder <xref:System.Xml.XmlReader.NamespaceURI%2A> Eigenschaft für die einzelnen Elemente, die zurückgegebene Zeichenfolge hinzugefügt wird eine <xref:System.Xml.NameTable>. Die Auflistung frei, die die <xref:System.Xml.NameTable> nimmt Größe der in ein virtueller Speicherverlust Zeichenfolgenhandles nie ab. Eine Lösung hierfür ist eine Ableitung der <xref:System.Xml.NameTable> Klasse und ein maximales Größenkontingent zu erzwingen. (Es gibt keine Möglichkeit, um zu verhindern, dass die Verwendung von einer <xref:System.Xml.NameTable>, oder Wechseln der <xref:System.Xml.NameTable> vollen). Eine andere Lösung ist, verwenden Sie die Eigenschaften, die bereits erwähnt, und verwenden Sie stattdessen die <xref:System.Xml.XmlReader.MoveToAttribute%2A> -Methode mit dem <xref:System.Xml.XmlReader.IsStartElement%2A> Methode möglichst; diese Methoden nicht Zeichenfolgen zurück und umgehen somit das Problem eines Überlaufs der <xref:System.Xml.NameTable> Auflistung.  
  
-   <xref:System.Xml.XmlReaderSettings> -Objekte können vertraulichen Informationen wie z. B. die Anmeldeinformationen des Benutzers enthalten. Eine nicht vertrauenswürdige Komponente könnte mithilfe der <xref:System.Xml.XmlReaderSettings> -Objekt und den Anmeldeinformationen des Benutzers erstellen <xref:System.Xml.XmlReader> Objekte zum Lesen von Daten. Seien Sie vorsichtig beim Zwischenspeichern von <xref:System.Xml.XmlReaderSettings> Objekte oder bei der Übergabe der <xref:System.Xml.XmlReaderSettings> Objekt von einer Komponente zu einem anderen.  
  
-   Achten Sie darauf, keine Unterstützung für Komponenten aus einer nicht vertrauenswürdigen Quelle zu gewähren (z. B. den Objekten <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager> und <xref:System.Xml.XmlResolver>).  
  
   
  
## Examples  
 Der folgende Beispielcode veranschaulicht die asynchrone API zu verwenden, um XML zu analysieren.  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/data/xml/index.md">XML-Dokumente und XML-Daten</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see langword="XmlReader" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von abgeleiteten Klassenkonstruktoren zum Initialisieren der Zustand in diesem Typ aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die Anzahl der Attribute für den aktuellen Knoten ab.</summary>
        <value>Die Anzahl der Attribute im aktuellen Knoten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist relevant für `Element`, `DocumentType` und `XmlDeclaration` nur Knoten. (Andere Knotentypen Attribute keine.)  
  
   
  
## Examples  
 Im folgende Beispiel werden alle Attribute angezeigt, auf dem aktuellen Knoten.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Basis-URI des aktuellen Knotens ab.</summary>
        <value>Der Basis-URI des aktuellen Knotens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Netzwerk XML-Dokument besteht aus Datenblöcke aggregiert mithilfe verschiedener W3C standard und enthält daher Knoten, die aus unterschiedlichen Quellen stammen. DTD-Entitäten sind ein Beispiel dafür, aber dies ist nicht beschränkt auf DTDs. Die Basis-URI gibt, in dem dieser Knoten stammen. Es ist kein Basis-URI für die Knoten zurückgegeben wird (z. B. sie ermittelt wurden aus einer in-Memory-Zeichenfolge), `String.Empty` zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Xml.XmlReader" /> die Methoden für das Lesen von Inhalt im Binärformat implementiert.</summary>
        <value><see langword="true" /> Wenn der binäre Inhalt read-Methode implementiert werden; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inhalt im Binärformat zu lesen, zu den Methoden der <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, und <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A> Methoden. Wenn diese Eigenschaft gibt `false` eine <xref:System.NotSupportedException> wird zurückgegeben, wenn keines der Binärdatei lesen-Methoden aufgerufen wird.  
  
 Alle Microsoft .NET Framework-Implementierungen von der <xref:System.Xml.XmlReader> Klasse Rückgabe `true` für diese Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Xml.XmlReader" /> die angegebene <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />-Methode implementiert.</summary>
        <value><see langword="true" /> Wenn die <see cref="T:System.Xml.XmlReader" /> implementiert die <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> Methode; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parsen von Texten <xref:System.Xml.XmlReader> Objekte, die aus der statischen erstellt <xref:System.Xml.XmlReader.Create%2A> immer-Methodenrückgabe `true`. Alle anderen Microsoft .NET Framework-Implementierungen von der <xref:System.Xml.XmlReader> Klasse, einschließlich der <xref:System.Xml.XmlTextReader> , geben Sie `false`.  
  
 Wenn diese Eigenschaft gibt `false` eine <xref:System.NotSupportedException> wird zurückgegeben, wenn die <xref:System.Xml.XmlReader.ReadValueChunk%2A> Methode wird aufgerufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieser Reader Entitäten analysieren und auflösen kann.</summary>
        <value><see langword="true" /> Wenn der Reader kann Entitäten analysieren und Auflösen; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt diese Eigenschaft immer `false` für Implementierungen der <xref:System.Xml.XmlReader> DTD-Informationen, die nicht unterstützt. In diesem Fall aufrufen <xref:System.Xml.XmlReader.ResolveEntity%2A> löst eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="xmlReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ändert beim Überschreiben in einer abgeleiteten Klassen den <see cref="P:System.Xml.XmlReader.ReadState" /> in <see cref="F:System.Xml.ReadState.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt auch alle Ressourcen frei, die während des Lesens frei. Wenn <xref:System.Xml.XmlReader.Close%2A> wurde bereits aufgerufen wird, wird keine Aktion ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die meisten der <xref:System.Xml.XmlReader.Create%2A> -Überladungen enthalten eine `settings` von akzeptierten Parameter ein <xref:System.Xml.XmlReaderSettings> Objekt. Sie können dieses Objekt zu verwenden:  
  
-   Angeben, welche Funktionen unterstützt werden soll die <xref:System.Xml.XmlReader> Objekt.  
  
-   Wiederverwenden der <xref:System.Xml.XmlReaderSettings> Objekt, das mehrere Leser zu erstellen. Sie können die gleichen Einstellungen verwenden, um mehrere Reader mit denselben Funktionen zu erstellen. Oder Sie können die Einstellungen ändern, auf eine <xref:System.Xml.XmlReaderSettings> -Instanz, und erstellen Sie einen neuen Reader mit einem anderen Satz von Features.  
  
-   Hinzufügen von Funktionen zu einer vorhandenen XML-Reader. Die <xref:System.Xml.XmlReader.Create%2A>-Methode kann ein anderes <xref:System.Xml.XmlReader>-Objekt annehmen. Die zugrunde liegende <xref:System.Xml.XmlReader> Objekt kann es sich um einen benutzerdefinierten Reader, ein <xref:System.Xml.XmlTextReader> Objekt oder einen anderen <xref:System.Xml.XmlReader> -Instanz, die Sie zusätzliche Funktionen hinzufügen möchten.  
  
-   Features wie z. B. verbesserte übereinstimmungsprüfung und Übereinstimmung mit voll ausnutzen der [XML 1.0 (fourth Edition)](https://www.w3.org/TR/2006/REC-xml-20060816/) Empfehlungen, die nur auf verfügbaren <xref:System.Xml.XmlReader> Objekte, die von der statischen erstellt <xref:System.Xml.XmlReader.Create%2A> Methode.  
  
> [!NOTE]
>  Zwar .NET Framework konkrete Implementierungen der enthält die <xref:System.Xml.XmlReader> Klasse, z. B. die <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>, und die <xref:System.Xml.XmlValidatingReader> Klassen, es wird empfohlen, die Sie erstellen <xref:System.Xml.XmlReader> Instanzen mit der <xref:System.Xml.XmlReader.Create%2A> -Methode.  
  
## <a name="default-settings"></a>Standardeinstellungen  
 Bei Verwendung einer <xref:System.Xml.XmlReader.Create%2A> Überladung, die akzeptiert eine <xref:System.Xml.XmlReaderSettings> Objekt ist, werden die folgenden Standardeinstellungen Reader verwendet:  
  
|Einstellung|Standard|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|Ein leeres <xref:System.Xml.Schema.XmlSchemaSet> Objekt|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> enabled|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|Ein neues <xref:System.Xml.XmlUrlResolver>-Objekt.  Ab der .NET Framework-Version 4.5.2 hat diese Einstellung den Standardwert `null`.|  
  
## <a name="settings-for-common-scenarios"></a>Einstellungen für allgemeine Szenarien  
 Hier sind die <xref:System.Xml.XmlReaderSettings> Eigenschaften Sie, für einige typische Szenarien, XML-Reader festlegen sollten.  
  
|Anforderung|Set|  
|-----------------|---------|  
|Daten müssen es sich um ein wohlgeformtes XML-Dokument sein.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> an <xref:System.Xml.ConformanceLevel.Document>.|  
|Daten müssen eine wohlgeformte analysierte XML-Entität sein.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> an <xref:System.Xml.ConformanceLevel.Fragment>.|  
|Daten müssen anhand einer DTD validiert werden.|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> auf <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A> an <xref:System.Xml.ValidationType.DTD>.|  
|Daten müssen anhand eines XML-Schemas überprüft werden.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> auf <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> um die <xref:System.Xml.Schema.XmlSchemaSet> zur Validierung verwendet. Beachten Sie, dass <xref:System.Xml.XmlReader> unterstützt keine XML-Data Reduced (XDR)-Schema-Validierung.|  
|Daten müssen anhand eines XML-Inlineschemas überprüft werden.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> auf <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> an <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>.|  
|Geben Sie die Unterstützung.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> auf <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A> um die <xref:System.Xml.Schema.XmlSchemaSet> verwenden.|  
  
 <xref:System.Xml.XmlReader> Schema-Validierung von XML-Data Reduced (XDR) nicht unterstützt werden.  
  
## <a name="asynchronous-programming"></a>Asynchrone Programmierung  
 Im synchronen Modus die <xref:System.Xml.XmlReader.Create%2A> Methode liest den ersten Datenblock aus dem Puffer für die Datei, diesen Stream oder Text-Reader. Dies kann eine Ausnahme auslösen, wenn ein e/a-Vorgang fehlschlägt. Im asynchronen Modus tritt auf, der erste e/a-Vorgang mit einem Lesevorgang, damit auftretenden Ausnahmen ausgelöst werden, wenn der Lesevorgang auftritt.  
  
## <a name="security-considerations"></a>Sicherheitsüberlegungen  
 In der Standardeinstellung die <xref:System.Xml.XmlReader> verwendet eine <xref:System.Xml.XmlUrlResolver> Objekt ohne Benutzeranmeldeinformationen, um Ressourcen zu öffnen. Dies bedeutet, dass standardmäßig der XML-Reader einen beliebigen Speicherort zugreifen kann, die keine Anmeldeinformationen erfordert. Verwenden der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> Eigenschaft, um den Zugriff auf Ressourcen zu steuern:  
  
-   Legen Sie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> auf eine <xref:System.Xml.XmlSecureResolver> Objekt, das die Ressourcen zu beschränken, die der XML-Reader zugreifen können.  
  
 - oder -  
  
-   Legen Sie <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> zu `null` um zu verhindern, dass den XML-Reader keine externen Ressourcen öffnen.  
  
   
  
## Examples  
 Dieses Beispiel erstellt einen XML-Reader, der nicht signifikanten Leerraum entfernt, werden Kommentare entfernt und führt auf Konformität überprüft.  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 Im folgenden Beispiel wird ein <xref:System.Xml.XmlUrlResolver> mit Standardanmeldeinformationen für den Zugriff auf eine Datei.  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 Der folgende Code dient als Wrapper für eine Readerinstanz in einem anderen Reader.  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 In diesem Beispiel verkettet Leser zum Hinzufügen einer DTD und XML-Schema-Validierung.  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Der Stream, der die XML-Daten enthält.  
  
Der <see cref="T:System.Xml.XmlReader" /> überprüft die ersten Bytes des Streams und durchsucht sie nach einer Bytereihenfolgemarkierung oder einem anderen Codierungszeichen. Nachdem die Codierung bestimmt wurde, wird sie zum weiteren Lesen des Streams verwendet, und die Eingabe wird weiterhin als Stream von (Unicode-)Zeichen analysiert.</param>
        <summary>Erstellt mit dem angegebenen Stream mit den Standardeinstellungen eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Xml.XmlReaderSettings> Objekt mit den Standardeinstellungen wird verwendet, um den Reader zu erstellen. Wenn Sie die Features zur Unterstützung des erstellten Readers angeben möchten, verwenden Sie die Überladung, die akzeptiert eine <xref:System.Xml.XmlReaderSettings> -Objekt als eines ihrer Argumente aus, und übergeben ein <xref:System.Xml.XmlReaderSettings> Objekt mit den richtigen Einstellungen.  
  
 Eine standardmäßige <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen greift auf externen Ressourcen wie z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erfordert gespeichert ist, geben Sie eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen, die mit der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Xml.XmlReader> -Objekt, das aus dem liest eine <xref:System.IO.FileStream>.  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der <see cref="T:System.Xml.XmlReader" /> besitzt keine ausreichenden Berechtigungen für den Zugriff auf den Speicherort der XML-Daten.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Der Text-Reader, aus dem die XML-Daten gelesen werden sollen. Ein Text-Reader gibt einen Stream von Unicode-Zeichen zurück, sodass die in der XML-Deklaration angegebene Codierung nicht vom XML-Reader zum Decodieren des Datenstreams verwendet wird.</param>
        <summary>Erstellt mit dem angegebenen Text-Reader eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Xml.XmlReaderSettings> Objekt mit den Standardeinstellungen wird verwendet, um den Reader zu erstellen. Wenn Sie die Features zur Unterstützung des erstellten Readers angeben möchten, verwenden Sie die Überladung, die akzeptiert eine <xref:System.Xml.XmlReaderSettings> -Objekt als eines ihrer Argumente aus, und übergeben ein <xref:System.Xml.XmlReaderSettings> Objekt mit den richtigen Einstellungen.  
  
 Eine standardmäßige <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen greift auf externen Ressourcen wie z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erfordert gespeichert ist, geben Sie eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen, die mit der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.IO.StringReader> Klasse, um eine XML-Zeichenfolge zu lesen.  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create inputUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inputUri">Der URI der Datei, die die XML-Daten enthält. Mit der <see cref="T:System.Xml.XmlUrlResolver" />-Klasse wird der Pfad in eine kanonische Datendarstellung konvertiert.</param>
        <summary>Erstellt eine neue <see cref="T:System.Xml.XmlReader" />-Instanz mit angegebenem URI.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Xml.XmlReaderSettings> Objekt mit den Standardeinstellungen wird verwendet, um den Reader zu erstellen. Wenn Sie die Features zur Unterstützung des erstellten Readers angeben möchten, verwenden Sie die Überladung, die akzeptiert eine <xref:System.Xml.XmlReaderSettings> -Objekt als eines ihrer Argumente aus, und übergeben ein <xref:System.Xml.XmlReaderSettings> Objekt mit den richtigen Einstellungen.  
  
 Eine standardmäßige <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen greift auf externen Ressourcen wie z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erfordert gespeichert ist, geben Sie eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen, die mit der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Xml.XmlReader> -Objekt, das vom URI angegebenen XML-Datendatei liest.  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="inputUri" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der <see cref="T:System.Xml.XmlReader" /> besitzt keine ausreichenden Berechtigungen für den Zugriff auf den Speicherort der XML-Daten.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch den URI bezeichnete Datei ist nicht vorhanden.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.FormatException" /> ab.  
  
</para>
          </block>  
  
 Das URI-Format ist falsch.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Der Stream, der die XML-Daten enthält.  
  
Der <see cref="T:System.Xml.XmlReader" /> überprüft die ersten Bytes des Streams und durchsucht sie nach einer Bytereihenfolgemarkierung oder einem anderen Codierungszeichen. Nachdem die Codierung bestimmt wurde, wird sie zum weiteren Lesen des Streams verwendet, und die Eingabe wird weiterhin als Stream von (Unicode-)Zeichen analysiert.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt eine neue <see cref="T:System.Xml.XmlReader" />-Instanz mit dem angegebenen Stream und den angegebenen Einstellungen.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen greift auf externen Ressourcen wie z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden steuern, welche Ressourcen die <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -  
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Der Text-Reader, aus dem die XML-Daten gelesen werden sollen. Ein Text-Reader gibt einen Stream von Unicode-Zeichen zurück, sodass die in der XML-Deklaration angegebene Codierung nicht vom XML-Reader zum Decodieren des Datenstreams verwendet wird.</param>
        <param name="settings">Die Einstellungen für den neuen <see cref="T:System.Xml.XmlReader" />. Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt mit dem angegebenen Text-Reader und den angegebenen Einstellungen eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen greift auf externen Ressourcen wie z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden steuern, welche Ressourcen die <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -  
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inputUri">Der URI der Datei, die die XML-Daten enthält. Das <see cref="T:System.Xml.XmlResolver" />-Objekt für das <see cref="T:System.Xml.XmlReaderSettings" />-Objekt wird zum Konvertieren des Pfads in eine kanonische Datendarstellung verwendet. Wenn <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> <see langword="null" /> ist, wird ein neues <see cref="T:System.Xml.XmlUrlResolver" />-Objekt verwendet.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt mit dem angegebenen URI und den angegebenen Einstellungen eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen greift auf externen Ressourcen wie z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Dies bedeutet, dass die <xref:System.Xml.XmlReader> stehen für alle Standorte, die keine Authentifizierung erforderlich ist. Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können die Ressourcen einschränken, die die <xref:System.Xml.XmlReader> zugreifen können, indem Sie festlegen der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> Eigenschaft, um eine <xref:System.Xml.XmlSecureResolver> Objekt.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Xml.XmlReader> -Objekt, das Validierung Document Type Definition (DTD) unterstützt.  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="inputUri" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch den URI angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.FormatException" /> ab.  
  
</para>
          </block>  
  
 Das URI-Format ist falsch.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (reader As XmlReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::Xml::XmlReader ^ reader, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (reader, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reader">Das Objekt, dass Sie als zugrunde liegenden XML-Reader verwenden möchten.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz.  
  
Der Konformitätsgrad des <see cref="T:System.Xml.XmlReaderSettings" />-Objekts muss mit dem Konformitätsgrad des zugrunde liegenden Readers übereinstimmen oder auf <see cref="F:System.Xml.ConformanceLevel.Auto" /> festgelegt werden.</param>
        <summary>Erstellt mit dem angegebenen XML-Reader und den angegebenen Einstellungen eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, das das angegebene <see cref="T:System.Xml.XmlReader" />-Objekt umschließt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie zusätzliche Funktionen hinzufügen, auf ein zugrundeliegendes <xref:System.Xml.XmlReader> Objekt. Die zugrunde liegende <xref:System.Xml.XmlReader> Objekt kann es sich um einen anderen <xref:System.Xml.XmlReader> Objekt erstellt wurde, indem Sie die <xref:System.Xml.XmlReader.Create%2A> -Methode oder ein <xref:System.Xml.XmlReader> Objekt erstellt wurde, verwenden eine der konkreten <xref:System.Xml.XmlReader> Implementierungen.  
  
 Eine standardmäßige <xref:System.Xml.XmlUrlResolver> wird ohne Anmeldeinformationen Zugriff auf externe Ressourcen, z. B. ein Schema verwendet.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erfordert gespeichert ist, geben Sie eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen, die mit der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden steuern, welche Ressourcen die <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -  
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein validierendes <xref:System.Xml.XmlReader> Objekt, das umschließt ein <xref:System.Xml.XmlNodeReader> Objekt.  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="reader" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wenn das <see cref="T:System.Xml.XmlReaderSettings" />-Objekt einen Konformitätsgrad angibt, der mit dem Konformitätsgrad des zugrunde liegenden Readers nicht übereinstimmt.  
  
- oder - 
Der zugrunde liegende <see cref="T:System.Xml.XmlReader" /> befindet im Zustand <see cref="F:System.Xml.ReadState.Error" /> oder <see cref="F:System.Xml.ReadState.Closed" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="baseUri" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="input">Der Stream, der die XML-Daten enthält.  
  
Der <see cref="T:System.Xml.XmlReader" /> überprüft die ersten Bytes des Streams und durchsucht sie nach einer Bytereihenfolgemarkierung oder einem anderen Codierungszeichen. Nachdem die Codierung bestimmt wurde, wird sie zum weiteren Lesen des Streams verwendet, und die Eingabe wird weiterhin als Stream von (Unicode-)Zeichen analysiert.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="baseUri">Der Basis-URI der gelesenen Entität oder des gelesenen Dokuments. Dieser Wert kann <see langword="null" /> sein.  
  
 **Sicherheitshinweis** Der Basis-URI wird verwendet, um den relativen URI des XML-Dokuments aufzulösen. Verwenden Sie keinen Basis-URI von einer nicht vertrauenswürdigen Quelle.</param>
        <summary>Erstellt mit dem angegebenen Stream, dem Basis-URI und den Einstellungen eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen greift auf externen Ressourcen wie z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden steuern, welche Ressourcen die <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -  
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Der Stream, der die XML-Daten enthält.  
  
Der <see cref="T:System.Xml.XmlReader" /> überprüft die ersten Bytes des Streams und durchsucht sie nach einer Bytereihenfolgemarkierung oder einem anderen Codierungszeichen. Nachdem die Codierung bestimmt wurde, wird sie zum weiteren Lesen des Streams verwendet, und die Eingabe wird weiterhin als Stream von (Unicode-)Zeichen analysiert.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="inputContext">Die Kontextinformationen, die zum Analysieren des XML-Fragments erforderlich sind. Die Kontextinformationen können die zu verwendende <see cref="T:System.Xml.XmlNameTable" />, die Codierung, den Namespacebereich, den aktuellen <c>xml:lang</c>- und <c>xml:space</c>-Bereich, Basis-URI und Dokumenttypdefinition enthalten.  
  
Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt mit dem angegebenen Stream, den Einstellungen und den Kontextinformationen für Analysezwecke eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen greift auf externen Ressourcen wie z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden steuern, welche Ressourcen die <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -  
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="baseUri" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="input">Der Text-Reader, aus dem die XML-Daten gelesen werden sollen. Ein Text-Reader gibt einen Stream von Unicode-Zeichen zurück, sodass die in der XML-Deklaration angegebene Codierung nicht vom <see cref="T:System.Xml.XmlReader" /> zum Decodieren des Datenstreams verwendet wird.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="baseUri">Der Basis-URI der gelesenen Entität oder des gelesenen Dokuments. Dieser Wert kann <see langword="null" /> sein.  
  
 **Sicherheitshinweis** Der Basis-URI wird verwendet, um den relativen URI des XML-Dokuments aufzulösen. Verwenden Sie keinen Basis-URI von einer nicht vertrauenswürdigen Quelle.</param>
        <summary>Erstellt mit dem angegebenen Text-Reader, den angegebenen Einstellungen und dem angegebenen Basis-URI eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen greift auf externen Ressourcen wie z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden steuern, welche Ressourcen die <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -  
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">Der Text-Reader, aus dem die XML-Daten gelesen werden sollen. Ein Text-Reader gibt einen Stream von Unicode-Zeichen zurück, sodass die in der XML-Deklaration angegebene Codierung nicht vom XML-Reader zum Decodieren des Datenstreams verwendet wird.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="inputContext">Die Kontextinformationen, die zum Analysieren des XML-Fragments erforderlich sind. Die Kontextinformationen können die zu verwendende <see cref="T:System.Xml.XmlNameTable" />, die Codierung, den Namespacebereich, den aktuellen <c>xml:lang</c>- und <c>xml:space</c>-Bereich, Basis-URI und Dokumenttypdefinition enthalten.  
  
Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt mit dem angegebenen Text-Reader, den Einstellungen und den Kontextinformationen für Analysezwecke eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen greift auf externen Ressourcen wie z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können eine der folgenden Methoden steuern, welche Ressourcen die <xref:System.Xml.XmlReader> zugreifen können:  
>   
>  -   Beschränken Sie die Ressourcen, auf die der <xref:System.Xml.XmlReader> zugreifen kann, indem Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>-Eigenschaft auf ein <xref:System.Xml.XmlSecureResolver>-Objekt festlegen.  
>   
>  - oder -  
>   
>  -   Wenn Sie die <xref:System.Xml.XmlReader>-Eigenschaft auf <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> festlegen, kann der `null` keine externen Ressourcen öffnen.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Xml.XmlReader> -Objekt, das Lesen eines XML-Fragments.  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="input" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> und die <see cref="P:System.Xml.XmlParserContext.NameTable" />-Eigenschaften enthalten Werte. (Nur eine dieser <see langword="NameTable" />-Eigenschaften kann festgelegt sein und verwendet werden.)</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inputUri">Der URI der Datei, die die XML-Daten enthält. Das <see cref="T:System.Xml.XmlResolver" />-Objekt für das <see cref="T:System.Xml.XmlReaderSettings" />-Objekt wird zum Konvertieren des Pfads in eine kanonische Datendarstellung verwendet. Wenn <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> <see langword="null" /> ist, wird ein neues <see cref="T:System.Xml.XmlUrlResolver" />-Objekt verwendet.</param>
        <param name="settings">Die Einstellungen für die neue <see cref="T:System.Xml.XmlReader" />-Instanz. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="inputContext">Die Kontextinformationen, die zum Analysieren des XML-Fragments erforderlich sind. Die Kontextinformationen können die zu verwendende <see cref="T:System.Xml.XmlNameTable" />, die Codierung, den Namespacebereich, den aktuellen <c>xml:lang</c>- und <c>xml:space</c>-Bereich, Basis-URI und Dokumenttypdefinition enthalten.  
  
Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Erstellt mit dem angegebenen URI, den Einstellungen und den Kontextinformationen für Analysezwecke eine neue <see cref="T:System.Xml.XmlReader" />-Instanz.</summary>
        <returns>Ein Objekt, mit dem die im Stream enthaltenen XML-Daten gelesen werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.Xml.XmlUrlResolver> ohne Anmeldeinformationen greift auf externen Ressourcen wie z. B. eine Dokumenttypdefinition (DTD), Entitäten, Schemas und So weiter.  
  
> [!IMPORTANT]
>  Ab .NET Framework 4.5.2 keinen Standardwert <xref:System.Xml.XmlUrlResolver> wird bereitgestellt. Wenn Ihre Lösung die .NET Framework 4.5.2 oder höher ausgerichtet ist, geben Sie eine <xref:System.Xml.XmlResolver> mithilfe der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Dies bedeutet, dass die <xref:System.Xml.XmlReader> stehen für alle Standorte, die keine Authentifizierung erforderlich ist. Wenn die externe Ressource auf einer Netzwerkressource, die eine Authentifizierung erforderlich ist gespeichert ist, verwenden Sie die <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> -Eigenschaft an eine <xref:System.Xml.XmlResolver> mit den erforderlichen Anmeldeinformationen.  
  
> [!IMPORTANT]
>  Sie können die Ressourcen einschränken, die die <xref:System.Xml.XmlReader> zugreifen können, indem Sie festlegen der <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> Eigenschaft, um eine <xref:System.Xml.XmlSecureResolver> Objekt.  
  
 Das erstellte <xref:System.Xml.XmlReader> -Objekt Entitätsverweise erweitert, und führt die XML-Normalisierung neue-Zeile-Zeichen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <see langword="inputUri" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der <see cref="T:System.Xml.XmlReader" /> besitzt keine ausreichenden Berechtigungen für den Zugriff auf den Speicherort der XML-Daten.</exception>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> und die <see cref="P:System.Xml.XmlParserContext.NameTable" />-Eigenschaften enthalten Werte. (Nur eine dieser <see langword="NameTable" />-Eigenschaften kann festgelegt sein und verwendet werden.)</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch den URI angegebene Datei kann nicht gefunden werden.</exception>
        <exception cref="T:System.UriFormatException">Das URI-Format ist falsch.</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die Tiefe des aktuellen Knotens im XML-Dokument ab.</summary>
        <value>Die Tiefe des aktuellen Knotens im XML-Dokument.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Finden Sie unter <xref:System.Xml.XmlTextReader.Depth%2A> (in der `XmlTextReader` Klasse) ein Beispiel für diese Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Gibt die von der <see cref="T:System.Xml.XmlReader" />-Klasse verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="xmlReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Xml.XmlReader" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="xmlReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> , um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, wenn ausschließlich nicht verwaltete Ressourcen freigegeben werden sollen.</param>
        <summary>Gibt die von <see cref="T:System.Xml.XmlReader" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob sich der Reader am Ende des Streams befindet.</summary>
        <value><see langword="true" /> Wenn der Reader am Ende des Streams positioniert ist; andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert eines Attributs ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : int -&gt; string" Usage="xmlReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Der Index des Attributs. Der Index ist nullbasiert. (Das erste Attribut hat den Index 0.)</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen Index ab.</summary>
        <returns>Der Wert des angegebenen Attributs. Diese Methode verschiebt den Reader nicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel ruft den Wert des dritten-Attributs ab.  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="i" /> liegt außerhalb des Bereichs. Es darf nicht negativ sein und muss kleiner als die Größe der Attributauflistung sein.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string -&gt; string" Usage="xmlReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Attributs.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen <see cref="P:System.Xml.XmlReader.Name" /> ab.</summary>
        <returns>Der Wert des angegebenen Attributs. Wenn das Attribut nicht gefunden wird oder Wert <see langword="String.Empty" /> ist, wird <see langword="null" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verschiebt den Reader nicht.  
  
 Wenn der Reader positioniert ist, auf eine `DocumentType` Knoten diese Methode kann verwendet werden, um die PUBLIC und SYSTEM-Literale, z. B. abzurufen `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 Im folgende Beispiel ruft den Wert des Attributs ISBN-Nummer ab.  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string * string -&gt; string" Usage="xmlReader.GetAttribute (name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der lokale Name des Attributs.</param>
        <param name="namespaceURI">Der Namespace-URI dieses Attributs.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen <see cref="P:System.Xml.XmlReader.LocalName" /> und <see cref="P:System.Xml.XmlReader.NamespaceURI" /> ab.</summary>
        <returns>Der Wert des angegebenen Attributs. Wenn das Attribut nicht gefunden wird oder Wert <see langword="String.Empty" /> ist, wird <see langword="null" /> zurückgegeben. Diese Methode verschiebt den Reader nicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das folgende XML enthält ein Attribut in einem bestimmten Namespace:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Sie können nach der suchen die `dt:type` -Attribut mit einem Argument (Präfix und lokalen Namen) oder zwei Argumente (lokalen Namen und Namespace-URI):  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 Für die Suche die `xmlns:dt` Attribut, verwenden Sie eine der folgenden Argumente:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Sie können auch abrufen, diese Informationen mithilfe der <xref:System.Xml.XmlReader.Prefix%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetValueAsync();" />
      <MemberSignature Language="F#" Value="abstract member GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.GetValueAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Wert des aktuellen Knotens asynchron ab.</summary>
        <returns>Der Wert des aktuellen Knotens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAttributes : bool" Usage="System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Knoten über Attribute verfügt.</summary>
        <value><see langword="true" /> Wenn der aktuelle Knoten über Attribute verfügt; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden alle Attribute angezeigt, auf dem aktuellen Knoten.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob der aktuelle Knoten einen <see cref="P:System.Xml.XmlReader.Value" /> aufweisen kann.</summary>
        <value><see langword="true" /> Wenn der Knoten, auf dem der Reader derzeit positioniert ist, kann eine <see langword="Value" />ist, andernfalls <see langword="false" />. Wenn <see langword="false" />, weist der Knoten den Wert <see langword="String.Empty" /> auf.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle sind Knotentypen aufgeführt, die einen zurückzugebenden Wert haben.  
  
|Knotentyp|Wert|  
|---------------|-----------|  
|`Attribute`|Der Wert des Attributs.|  
|`CDATA`|Der Inhalt des CDATA-Abschnitts.|  
|`Comment`|Der Inhalt des Kommentars.|  
|`DocumentType`|Die interne Teilmenge.|  
|`ProcessingInstruction`|Der gesamte Inhalt mit Ausnahme des Ziels.|  
|`SignificantWhitespace`|Der Leerraum zwischen Markups bei einem Modell für gemischten Inhalt.|  
|`Text`|Der Inhalt des Textknotens.|  
|`Whitespace`|Der Leerraum zwischen Markups.|  
|`XmlDeclaration`|Der Inhalt der Deklaration.|  
  
   
  
## Examples  
 Finden Sie unter <xref:System.Xml.XmlTextReader.HasValue%2A> (in der `XmlTextReader` Klasse) ein Beispiel, das mit dieser Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob der aktuelle Knoten ein Attribut ist, das aus dem in der DTD oder dem Schema definierten Standardwert generiert wurde.</summary>
        <value><see langword="true" /> Wenn der aktuelle Knoten ein Attribut ist, dessen Wert aus dem in der DTD oder Schema definierten Standardwert generiert wurde; <see langword="false" /> , wenn der Attributwert explizit festgelegt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault` Gibt immer `false` für Implementierungen der `XmlReader` , die unterstützen keine Schema- oder DTD-Informationen. Diese Eigenschaft gilt nur für ein Attributknoten.  
  
   
  
## Examples  
 Im folgende Beispiel werden alle Attribute für das Stammelement angezeigt.  
  
```csharp  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 Im Beispiel werden die folgenden Dateien als Eingabe verwendet.  
  
 `book4.xml`  
  
```xml  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse einen Wert ab, der angibt, ob der aktuelle Knoten ein leeres Element ist (z.B. <c>&lt;MyElement/&gt;</c>).</summary>
        <value><see langword="true" /> Wenn der aktuelle Knoten ein Element ist (<see cref="P:System.Xml.XmlReader.NodeType" /> gleich <see langword="XmlNodeType.Element" />) endet mit <c> / &gt; </c>ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ermöglicht Ihnen, die Unterschiede zwischen den folgenden Elementen zu bestimmen:  
  
 `<item num="123"/>` (`IsEmptyElement` ist `true`).  
  
 `<item num="123"></item>` (`IsEmptyElement` ist `false`, obwohl der Inhalt des Elements leer ist).  
  
 Eine entsprechende `EndElement` Knoten wird nicht für leere Elemente generiert.  
  
 Wenn ein Element aufgrund der schemaüberprüfung Standardinhalt hinzugefügt wurden `IsEmptyElement` weiterhin zurückgibt `true`. Es hat keinen Einfluss auf, und zwar unabhängig davon, ob das Element einen Standardwert verfügt. Das heißt, `IsEmptyElement` einfach Berichte, und zwar unabhängig davon, ob das Element im Quelldokument ein Endtag verfügt.  
  
   
  
## Examples  
 Im folgende Beispiel wird der Textinhalt der einzelnen Elemente angezeigt.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 Im Beispiel wird die Datei `elems.xml`als Eingabe.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsName (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsName(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsName : string -&gt; bool" Usage="System.Xml.XmlReader.IsName str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Der Name, dessen Gültigkeit validiert werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob das Zeichenfolgenargument ein gültiger XML-Name ist.</summary>
        <returns><see langword="true" /> , wenn der Name gültig ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [W3C XML 1.0 Recommendation](https://go.microsoft.com/fwlink/?LinkId=49863) zu bestimmen, ob der Name gültig ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="str" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNameToken (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNameToken(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsNameToken : string -&gt; bool" Usage="System.Xml.XmlReader.IsNameToken str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Das zu validierende Namenstoken.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob das Zeichenfolgenargument ein gültiges XML-Namenstoken ist.</summary>
        <returns><see langword="true" /> , wenn es sich um ein gültiges Namenstoken handelt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verwendet die [W3C XML 1.0 Recommendation](https://go.microsoft.com/fwlink/?LinkId=49863) zu bestimmen, ob das Namenstoken gültig ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="str" />-Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Überprüft, ob der aktuelle Inhaltsknoten ein Starttag ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement();" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : unit -&gt; bool&#xA;override this.IsStartElement : unit -&gt; bool" Usage="xmlReader.IsStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft <see cref="M:System.Xml.XmlReader.MoveToContent" /> auf und überprüft, ob der aktuelle Inhaltsknoten ein Starttag oder ein leeres Elementtag ist.</summary>
        <returns><see langword="true" /> , wenn <see cref="M:System.Xml.XmlReader.MoveToContent" /> ein Starttag oder ein leeres Elementtag findet. <see langword="false" />, wenn ein anderer Knotentyp als <see langword="XmlNodeType.Element" /> gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode lässt Leerzeichen, Kommentare und verarbeitungsanweisungen, bis der Reader auf einen Inhaltsknoten befindet. Die Methode testet dann, wenn der aktuelle Knoten ein Element ist.  
  
   
  
## Examples  
 Im folgende Beispiel wird der Textinhalt der einzelnen Elemente angezeigt.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 Im Beispiel wird die Datei `elems.xml`als Eingabe.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Im Eingabestream wurde unzulässiger XML-Code gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string -&gt; bool&#xA;override this.IsStartElement : string -&gt; bool" Usage="xmlReader.IsStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Die mit der <see langword="Name" />-Eigenschaft des gefundenen Elements verglichene Zeichenfolge.</param>
        <summary>Ruft <see cref="M:System.Xml.XmlReader.MoveToContent" /> auf und überprüft, ob der aktuelle Inhaltsknoten ein Starttag oder ein leeres Elementtag ist und die <see cref="P:System.Xml.XmlReader.Name" />-Eigenschaft des gefundenen Elements mit dem angegebenen Argument übereinstimmt.</summary>
        <returns><see langword="true" /> , wenn der resultierende Knoten ein Element ist und die <see langword="Name" />-Eigenschaft mit der angegebenen Zeichenfolge übereinstimmt. <see langword="false" /> , wenn ein anderer Knotentyp als <see langword="XmlNodeType.Element" /> gefunden wurde oder die Elementeigenschaft <see langword="Name" /> nicht mit der angegebenen Zeichenfolge übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode lässt Leerzeichen, Kommentare und verarbeitungsanweisungen, bis der Reader auf einen Inhaltsknoten befindet. Die Methode testet dann, wenn der aktuelle Knoten ein Element ist.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt jede Price-Element.  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Im Eingabestream wurde unzulässiger XML-Code gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (localname As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string * string -&gt; bool&#xA;override this.IsStartElement : string * string -&gt; bool" Usage="xmlReader.IsStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Die mit der <see langword="LocalName" />-Eigenschaft des gefundenen Elements zu vergleichende Zeichenfolge.</param>
        <param name="ns">Die mit der <see langword="NamespaceURI" />-Eigenschaft des gefundenen Elements zu vergleichende Zeichenfolge.</param>
        <summary>Ruft <see cref="M:System.Xml.XmlReader.MoveToContent" /> auf und überprüft, ob der aktuelle Inhaltsknoten ein Starttag oder ein leeres Elementtag ist und ob die <see cref="P:System.Xml.XmlReader.LocalName" />-Eigenschaft und die <see cref="P:System.Xml.XmlReader.NamespaceURI" />-Eigenschaft des gefundenen Elements mit den angegebenen Zeichenfolgen übereinstimmen.</summary>
        <returns><see langword="true" /> , wenn der resultierende Knoten ein Element ist. <see langword="false" /> , wenn ein anderer Knotentyp als <see langword="XmlNodeType.Element" /> gefunden wurde oder die <see langword="LocalName" />-Eigenschaft und die <see langword="NamespaceURI" />-Eigenschaft des Elements nicht mit den angegebenen Zeichenfolgen übereinstimmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode lässt Leerzeichen, Kommentare und verarbeitungsanweisungen, bis der Reader auf einen Inhaltsknoten befindet. Die Methode testet dann, wenn der aktuelle Knoten ein Element ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Im Eingabestream wurde unzulässiger XML-Code gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Der Index des Attributs.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen Index ab.</summary>
        <value>Der Wert des angegebenen Attributs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft den Reader nicht bewegen.  
  
   
  
## Examples  
 Im folgende Beispiel werden alle Attribute angezeigt, auf dem aktuellen Knoten.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Attributs.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen <see cref="P:System.Xml.XmlReader.Name" /> ab.</summary>
        <value>Der Wert des angegebenen Attributs. Wenn das Attribut nicht gefunden wurde, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft den Reader nicht bewegen.  
  
 Wenn der Reader positioniert ist, auf eine `DocumentType` Knoten diese Methode kann verwendet werden, um die PUBLIC und SYSTEM-Literale, z. B. abzurufen `reader["PUBLIC"]`  
  
   
  
## Examples  
 Im folgende Beispiel ruft den Wert des Attributs ISBN-Nummer ab.  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der lokale Name des Attributs.</param>
        <param name="namespaceURI">Der Namespace-URI dieses Attributs.</param>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Wert des Attributs mit dem angegebenen <see cref="P:System.Xml.XmlReader.LocalName" /> und <see cref="P:System.Xml.XmlReader.NamespaceURI" /> ab.</summary>
        <value>Der Wert des angegebenen Attributs. Wenn das Attribut nicht gefunden wurde, wird <see langword="null" /> zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft den Reader nicht bewegen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den lokalen Namen des aktuellen Knotens ab.</summary>
        <value>Der Name des aktuellen Knotens ohne das Präfix. Z. B. <see langword="LocalName" /> ist <see langword="book" /> für das Element <c> &lt;bk: book&gt;</c>.  
  
Bei unbenannten Knotentypen wie <see langword="Text" />, <see langword="Comment" /> usw. gibt diese Eigenschaft <see langword="String.Empty" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt den lokalen Namen der einzelnen Knoten, und, sofern sie vorhanden sind, das Präfix und Namespace-URI.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 Im Beispiel wird die Datei book2.xml, als Eingabe verwendet.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="P:System.Xml.XmlReader.Name" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member LookupNamespace : string -&gt; string" Usage="xmlReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Das Präfix, dessen Namespace-URI aufgelöst werden soll. Um eine Übereinstimmung mit dem Standardnamespace zu erhalten, übergeben Sie eine leere Zeichenfolge.</param>
        <summary>Löst beim Überschreiben in einer abgeleiteten Klasse ein Namespacepräfix im Gültigkeitsbereich des aktuellen Elements auf.</summary>
        <returns>Der Namespace-URI, dem das Präfix zugeordnet ist, oder <see langword="null" />, wenn kein entsprechendes Präfix gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden XML-Zeichenfolge, wenn der Reader positioniert ist, auf die `href` Attribut, das Präfix `a` durch den Aufruf von `reader.LookupNamespace("a")`. Die zurückgegebene Zeichenfolge `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zum angegebenen Attribut.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : int -&gt; unit&#xA;override this.MoveToAttribute : int -&gt; unit" Usage="xmlReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Der Index des Attributs.</param>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zum Attribut mit dem angegebenen Index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel werden alle Attribute angezeigt, auf dem aktuellen Knoten.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Parameter hat einen negativen Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string -&gt; bool" Usage="xmlReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Attributs.</param>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zum Attribut mit dem angegebenen <see cref="P:System.Xml.XmlReader.Name" />.</summary>
        <returns><see langword="true" /> , wenn das Attribut gefunden wurde, andernfalls <see langword="false" />. Bei einem Wert von <see langword="false" /> ändert sich die Position des Readers nicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Aufruf `MoveToAttribute`, <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, und <xref:System.Xml.XmlReader.Prefix%2A> Eigenschaften stellen nur die Eigenschaften dieses Attributs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentException">Der Parameter ist eine leere Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string * string -&gt; bool" Usage="xmlReader.MoveToAttribute (name, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der lokale Name des Attributs.</param>
        <param name="ns">Der Namespace-URI dieses Attributs.</param>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zum Attribut mit dem angegebenen <see cref="P:System.Xml.XmlReader.LocalName" /> und <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <returns><see langword="true" /> , wenn das Attribut gefunden wurde, andernfalls <see langword="false" />. Bei einem Wert von <see langword="false" /> ändert sich die Position des Readers nicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach dem Aufruf `MoveToAttribute`, <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, und <xref:System.Xml.XmlReader.Prefix%2A> Eigenschaften stellen nur die Eigenschaften dieses Attributs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentNullException">Beide Parameterwerte sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContent () As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeType MoveToContent();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContent : unit -&gt; System.Xml.XmlNodeType&#xA;override this.MoveToContent : unit -&gt; System.Xml.XmlNodeType" Usage="xmlReader.MoveToContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überprüft, ob der aktuelle Knoten ein Inhaltsknoten (Textknoten ohne Leerraum, <see langword="CDATA" />-, <see langword="Element" />-, <see langword="EndElement" />-, <see langword="EntityReference" />- oder <see langword="EndEntity" />-Knoten) ist. Wenn der Knoten kein Inhaltsknoten ist, springt der Reader zum nächsten Inhaltsknoten oder an das Ende der Datei. Knoten folgender Typen werden übersprungen: <see langword="ProcessingInstruction" />, <see langword="DocumentType" />, <see langword="Comment" />, <see langword="Whitespace" /> und <see langword="SignificantWhitespace" />.</summary>
        <returns>Der <see cref="P:System.Xml.XmlReader.NodeType" /> des von der Methode gefundenen aktuellen Knotens oder <see langword="XmlNodeType.None" />, wenn der Reader das Ende des Eingabestreams erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der aktuelle Knoten ein Attributknoten ist, verschiebt diese Methode den Reader zurück auf das Element, das das Attribut besitzt.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.MoveToContentAsync%2A>.  
  
   
  
## Examples  
 Dies ist nützlich, wenn Sie möchten Code schreiben, die vom zufälligen XML-Markup ohne Unterbrechung überspringen können. Nehmen wir beispielsweise an, dass Sie den folgenden Code haben:  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 Dieser Code kann die folgenden Eingaben ohne Unterbrechung behandelt:  
  
```xml  
<price>123.4</price>  
```  
  
 und  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 und  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTITY p  
  "123.4">]><price>&p;</price>  
```  
  
 und  
  
```xml  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Im Eingabestream wurde unzulässiger XML-Code gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContentAsync () As Task(Of XmlNodeType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Xml::XmlNodeType&gt; ^ MoveToContentAsync();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;&#xA;override this.MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;" Usage="xmlReader.MoveToContentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchrone Überprüfungen, ob der aktuelle Knoten ein Inhaltsknoten ist. Wenn der Knoten kein Inhaltsknoten ist, springt der Reader zum nächsten Inhaltsknoten oder an das Ende der Datei.</summary>
        <returns>Der <see cref="P:System.Xml.XmlReader.NodeType" /> des von der Methode gefundenen aktuellen Knotens oder <see langword="XmlNodeType.None" />, wenn der Reader das Ende des Eingabestreams erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.MoveToContent%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToElement();" />
      <MemberSignature Language="F#" Value="abstract member MoveToElement : unit -&gt; bool" Usage="xmlReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zu dem Element, das den aktuellen Attributknoten enthält.</summary>
        <returns><see langword="true" /> , wenn der Reader auf einem Attribut positioniert ist (der Reader wechselt zu dem Element, das das Attribut besitzt); <see langword="false" />, wenn der Reader nicht auf einem Attribut positioniert ist (die Position des Readers bleibt unverändert).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um auf ein Element zurückzugeben, nach der Navigation durch die Attribute. Diese Methode verschiebt den Reader auf einen der folgenden Knotentypen: `Element`, `DocumentType`, oder `XmlDeclaration`.  
  
   
  
## Examples  
 Im folgende Beispiel werden alle Attribute angezeigt, auf dem aktuellen Knoten.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToFirstAttribute : unit -&gt; bool" Usage="xmlReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zum ersten Attribut.</summary>
        <returns><see langword="true" /> , wenn ein Attribut vorhanden ist (der Reader wechselt zum ersten Attribut), andernfalls <see langword="false" /> (die Position des Readers bleibt unverändert).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel ruft den Wert des ersten Attributs ab.  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToNextAttribute : unit -&gt; bool" Usage="xmlReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wechselt beim Überschreiben in einer abgeleiteten Klasse zum nächsten Attribut.</summary>
        <returns><see langword="true" /> , wenn ein nächstes Attribut vorhanden ist; <see langword="false" />, wenn keine weiteren Attribute vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der aktuelle Knoten ein Elementknoten ist, entspricht diese Methode <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>. Wenn `MoveToNextAttribute` gibt `true`, der Reader wechselt zum nächsten Attribut; andernfalls wird die Position des Readers nicht geändert.  
  
   
  
## Examples  
 Im folgende Beispiel werden alle Attribute angezeigt, auf dem aktuellen Knoten.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den gekennzeichneten Namen des aktuellen Knotens ab.</summary>
        <value>Der gekennzeichnete Name des aktuellen Knotens. Z. B. <see langword="Name" /> ist <see langword="bk:book" /> für das Element <c> &lt;bk: book&gt;</c>.  
  
Der zurückgegebene Name hängt vom <see cref="P:System.Xml.XmlReader.NodeType" /> des Knotens ab. Die folgenden Knotentypen geben die jeweils aufgeführten Werte zurück. Alle anderen Knotentypen geben eine leere Zeichenfolge zurück.  
  
 <list type="table"><listheader><term> Knotentyp 
 </term><description> name 
 </description></listheader><item><term><see langword="Attribute" /></term><description> Der Name des Attributs.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Der Name des Dokumenttyps.  
  
 </description></item><item><term><see langword="Element" /></term><description> Der Tagname.  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> Der Name der Entität, auf die verwiesen wird.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Das Ziel der Verarbeitungsanweisung.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Das <see langword="xml" />-Zeichenfolgenliteral.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel liest eine XML-Datei und zeigt jeden Knoten.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 Das Beispiel verwendet die `items.xml` Datei.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="P:System.Xml.XmlReader.LocalName" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Namespace-URI (entsprechend der Definition in der Namespacespezifikation des W3C) des Knotens ab, auf dem der Reader positioniert ist.</summary>
        <value>Der Namespace-URI des aktuellen Knotens, andernfalls eine leere Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist relevant für `Element` und `Attribute` nur Knoten.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den lokalen Namen der einzelnen Knoten, und, sofern sie vorhanden sind, das Präfix und Namespace-URI.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 Im Beispiel wird die Datei book2.xml, als Eingabe verwendet.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse die <see cref="T:System.Xml.XmlNameTable" /> ab, die dieser Implementierung zugeordnet ist.</summary>
        <value>Die <see langword="XmlNameTable" />, die das Abrufen der atomisierten Version einer Zeichenfolge innerhalb des Knotens erlaubt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Namen von Knoten und Attribut Merry <xref:System.Xml.XmlReader> werden mit der atomisiert die `NameTable`. Wenn auf der gleiche Namen mehrere Male zurückgegeben wird (z. B. `Customer`), klicken Sie dann in der gleichen `String` Objekt für diesen Namen zurückgegeben. Dadurch können Sie effizient Code schreiben, der Vergleiche für diese Zeichenfolgen und aufwendige Zeichenfolgenvergleiche Objekt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Typ des aktuellen Knotens ab.</summary>
        <value>Einer der Enumerationswerte, die den Typ des aktuellen Knotens angeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel liest eine XML-Datei und zeigt jeden Knoten.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 Das Beispiel verwendet die `items.xml` Datei.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse das dem aktuellen Knoten zugeordnete Namespacepräfix ab.</summary>
        <value>Das dem aktuellen Knoten zugeordnete Namespacepräfix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt den lokalen Namen der einzelnen Knoten, und, sofern sie vorhanden sind, das Präfix und Namespace-URI.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 Im Beispiel wird die Datei book2.xml, als Eingabe verwendet.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse das Anführungszeichen ab, mit dem der Wert eines Attributknotens eingeschlossen wird.</summary>
        <value>Das Anführungszeichen (" oder '), mit dem der Wert eines Attributknotens eingeschlossen ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gilt nur für ein Attributknoten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; bool" Usage="xmlReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest beim Überschreiben in einer abgeleiteten Klasse den nächsten Knoten aus dem Stream.</summary>
        <returns><see langword="true" /> , wenn der nächste Knoten erfolgreich gelesen wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein <xref:System.Xml.XmlReader> ersten erstellt und initialisiert, es gibt keine Informationen verfügbar. Rufen Sie <xref:System.Xml.XmlReader.Read%2A> , lesen den ersten Knoten. Die <xref:System.Xml.XmlReader.Read%2A> Methode legt den Status der XML-Reader zum Initiieren <xref:System.Xml.ReadState> und durchläuft die XML-Datei nacheinander bis zu diesem Zeitpunkt gibt die Methode den Wert zurück, mit das Ende der Datei erreicht `false`.  
  
 Diese Methode erfordert mindestens 4 Bytes aus dem Datenstrom, um die Analyse beginnen. Die Methode gibt zurück, wenn weniger als vier Bytes zurückgegeben werden, und es keine weiteren Daten im Datenstrom gibt, `false`. Wenn mehr Daten in den Datenstrom vorhanden ist, blockiert die Methode die Analyse bis zum Empfang von das vierte Byte an.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadAsync%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine XML-Datei und zeigt jeden der Knoten an:
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 Das Beispiel verwendet die `items.xml` Datei.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **Ausgabe:**  

 [!INCLUDE [xmlreader-read-sample-output](~/includes/xmlreader-read-sample-output.md)] 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Beim Analysieren des XML-Codes ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync () As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;bool&gt; ^ ReadAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="xmlReader.ReadAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den nächsten Knoten aus dem Stream asynchron.</summary>
        <returns><see langword="true" /> , wenn der nächste Knoten erfolgreich gelesen wurde; <see langword="false" />, wenn keine weiteren zu lesenden Knoten vorhanden sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.Read%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="abstract member ReadAttributeValue : unit -&gt; bool" Usage="xmlReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst beim Überschreiben in einer abgeleiteten Klasse den Attributwert in einen oder mehrere Knoten vom Typ <see langword="Text" />, <see langword="EntityReference" /> oder <see langword="EndEntity" /> auf.</summary>
        <returns><see langword="true" /> , wenn zurückzugebende Knoten vorhanden sind.  
  
 <see langword="false" /> , wenn der Reader beim ersten Aufruf nicht auf einem Attributknoten positioniert ist oder alle Attributwerte gelesen wurden.  
  
Ein leeres Attribut, z.B. <c>misc=""</c>, gibt <see langword="true" /> mit einem einzelnen Knoten mit dem Wert <see langword="String.Empty" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode nach dem Aufruf <xref:System.Xml.XmlReader.MoveToAttribute%2A> lesen Sie den Text oder Entitätsverweisknoten, die den Wert des Attributs bilden. Die <xref:System.Xml.XmlReader.Depth%2A> die Attribut-Wert-Knoten ist 1 plus die Tiefe des Attributknotens; inkrementiert und dekrementiert durch eine Einzelschritts in und aus allgemeine Entitätsverweise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">Der Typ des zurückzugebenden Werts.  
  
 **Hinweis** Seit der Veröffentlichung von .NET Framework 3.5 kann der Wert des <paramref name="returnType" />-Parameters nun auch auf den <see cref="T:System.DateTimeOffset" />-Typ festgelegt werden.</param>
        <param name="namespaceResolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" />-Objekt, das für die Auflösung von Präfixen von Namespaces verwendet wird, die im Zusammenhang mit der Typkonvertierung stehen. Dieses kann zum Beispiel beim Konvertieren eines <see cref="T:System.Xml.XmlQualifiedName" />-Objekts in einen <c>xs:string</c> verwendet werden.  
  
Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Liest den Inhalt als Objekt vom angegebenen Typ.</summary>
        <returns>Der verkettete Textinhalt oder Attributwert, der in den angeforderten Typ konvertiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest den Textinhalt an der aktuellen Readerposition ab und konvertiert sie in den angeforderten Rückgabetyp. Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte sind verkettet. Kommentare und verarbeitungsanweisungen werden übersprungen und Entitätsverweise automatisch aufgelöst werden.  
  
 Diese Methode wird verwendet, lesen, die bei Bedarf zu konvertieren und die atomaren Wertelemente aus dem aktuellen Knoten Inhalt zurück. Wenn der Eingabetyp eine gültige Zuordnung für den Typ des aktuellen Knotens klicken Sie dann eine Instanz des Zieltyps, die mit dem Wert des aktuellen Knotens ist wird zurückgegeben. Finden Sie im Abschnitt "Hinweise" in der <xref:System.Xml.XmlReader> Referenzseite für das eine Liste der standardzuordnungen.  
  
 Angenommen, mussten Sie den folgenden XML-Text:  
  
```xml  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 Wenn die Daten typisiert ist und ein Zeichenfolgen-Array, um angegeben wird die <xref:System.Xml.XmlReader.ReadContentAs%2A> Methodenaufruf, und klicken Sie dann auf die ganzzahligen Werte in Zeichenfolgen gemäß der Liste der gültigen CLR-typenzuordnungen konvertiert werden.  
  
 Wenn die Daten nicht typisiert ist und ein Zeichenfolgen-Array, um angegeben wird die <xref:System.Xml.XmlReader.ReadContentAs%2A> -Methode aufrufen, und klicken Sie dann die Inhalte als separate Zeichenfolgen analysiert werden. Ein Array, das zwei Zeichenfolgen enthält, wird mit den Werten "123" und "456" zurückgegeben. Die Leerzeichen werden nicht aus dem Inhalt beibehalten.  
  
 Im Allgemeinen beim Lesen von nicht typisierter Daten wird der Inhalt gemäß dem angegebenen Typ analysiert. Angenommen, ein Array von Ganzzahlen angegeben wird, um die <xref:System.Xml.XmlReader.ReadContentAs%2A> Methode aufrufen, wird die Zeichenfolge in ein Array von ganzen Zahlen analysiert {123,456}.  
  
 Im folgenden Beispiel wird der XML-Text nicht durch Leerzeichen getrennt  
  
```xml  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 Wenn der Inhalt nicht typisiert ist und ein Zeichenfolgen-Array, um angegeben wird die <xref:System.Xml.XmlReader.ReadContentAs%2A> Methodenaufruf klicken Sie dann ein Array mit einer verketteten Zeichenfolge mit dem Wert "123456789" zurückgegeben.  
  
 In der folgende Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, die in den angeforderten Typ konvertiert werden.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit Aufrufen `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die verarbeitungsanweisung (PI) oder einen Kommentar und liest den verketteten Textinhalt, der die Verarbeitungsanweisung oder den Kommentar folgt.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert ist, auch wenn der Reader in der Regel in der aktuellen Position bleibt.|  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadContentAsAsync%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Xml.XmlReader.ReadContentAs%2A> Methode, um den Inhalt des Elements Farben in ein Array von String-Objekte zurückzugeben.  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 In diesem Beispiel wird die Datei `dataFile_2.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">Der Inhalt weist nicht das richtige Format für den Zieltyp auf.</exception>
        <exception cref="T:System.InvalidCastException">Die versuchte Typumwandlung ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="returnType" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Knoten ist kein unterstützter Knotentyp. Weitere Informationen finden Sie in der nachfolgenden Tabelle.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.OverflowException">Lesen von <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">Der Typ des zurückzugebenden Werts.</param>
        <param name="namespaceResolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" />-Objekt, das für die Auflösung von Präfixen von Namespaces verwendet wird, die im Zusammenhang mit der Typkonvertierung stehen.</param>
        <summary>Liest den Inhalt asynchron als Objekt vom angegebenen Typ.</summary>
        <returns>Der verkettete Textinhalt oder Attributwert, der in den angeforderten Typ konvertiert wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadContentAs%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest den Inhalt und gibt die Base64-decodierten binären Bytes zurück.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Inhalt, decodiert der `Base64` Inhalt, und gibt die decodierten Binärbytes zurück (z. B. ein Inlineschema `Base64` codiertes GIF-Bild) in den Puffer. Diese Methode kann nacheinander aufgerufen werden, um umfangreiche Streams mit eingebettetem Text zu lesen. Weitere Informationen finden Sie unter RFC 1521, "MIME (Multipurpose Internet Mail Extensions)-Teil einer: Mechanismen zum angeben, und beschreiben das Format der Internetnachrichtentexte". Sie erhalten RFCs auf der [Request for Comments-Website](https://go.microsoft.com/fwlink/?LinkId=37119).  
  
> [!NOTE]
>  Greifen Sie auf keine Leser Eigenschaften zwischen den Aufrufen der <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> Methode, bis die Methode den Wert zurückgibt `0`.  
  
 Diese Methode hat das folgende Verhalten:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> Gibt den Wert `0` Wenn das Ende des Datenstroms es ausgeführt wurde, auf erreicht wurde. Der Reader befindet sich auf dem ersten Knoten für nicht-Inhalt.  
  
-   Wenn Sie weniger anfordern oder die genaue Anzahl von Bytes, die als der Reader seine aktuelle Position behält im Stream überlassen werden.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> wird auf die folgenden Typen von XML-Knoten nicht unterstützt: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" /> wird auf dem aktuellen Knoten nicht unterstützt.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Index im Puffer oder Index + Anzahl übersteigen die Größe des zugeordneten Puffers.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Xml.XmlReader" />-Implementierung unterstützt diese Methode nicht.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest den Inhalt asynchron und gibt die Base64-decodierten binären Bytes zurück.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest den Inhalt und gibt die <see langword="BinHex" />-decodierten binären Bytes zurück.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den Inhalt, decodiert der `BinHex` Inhalt, und gibt die decodierten Binärbytes zurück (z. B. ein Inlineschema `BinHex` codiertes GIF-Bild) in den Puffer. Diese Methode kann nacheinander aufgerufen werden, um umfangreiche Streams mit eingebettetem Text zu lesen.  
  
> [!NOTE]
>  Greifen Sie auf keine Leser Eigenschaften zwischen den Aufrufen der <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> Methode, bis die Methode den Wert zurückgibt `0`.  
  
 Diese Methode hat das folgende Verhalten:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> Gibt den Wert `0` Wenn das Ende des Datenstroms es ausgeführt wurde, auf erreicht wurde. Der Reader befindet sich auf dem ersten Knoten für nicht-Inhalt.  
  
-   Wenn Sie, weniger Fragen oder genaue die verbleibende Anzahl von Bytes, die als in den Stream den Leser überlassen werden in der aktuellen Position bleibt.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> wird auf die folgenden Typen von XML-Knoten nicht unterstützt: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation, Entity`, `DocumentFragment`.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" /> wird auf dem aktuellen Knoten nicht unterstützt.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Index im Puffer oder Index + Anzahl übersteigen die Größe des zugeordneten Puffers.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Xml.XmlReader" />-Implementierung unterstützt diese Methode nicht.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest den Inhalt asynchron und gibt die <see langword="BinHex" />-decodierten binären Bytes zurück.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBoolean : unit -&gt; bool&#xA;override this.ReadContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see langword="Boolean" />.</summary>
        <returns>Der Textinhalt als <see cref="T:System.Boolean" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:boolean`, gibt der Reader zurück, ein Unboxing <xref:System.Boolean> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:boolean`, versucht der Reader konvertiert eine <xref:System.Boolean> -Objekts gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 In der folgende Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, die in den angeforderten Typ konvertiert werden.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit Aufrufen `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die verarbeitungsanweisung (PI) oder einen Kommentar und liest den verketteten Textinhalt, der die Verarbeitungsanweisung oder den Kommentar folgt.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert ist, auch wenn der Reader in der Regel in der aktuellen Position bleibt.|  
  
 Weitere Informationen finden Sie unter den <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> Methode, um das Attribut als lesen eine `Boolean` Wert.  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 In diesem Beispiel wird die Datei `dataFile_2.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Typumwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see cref="T:System.DateTime" />-Objekt.</summary>
        <returns>Der Textinhalt als <see cref="T:System.DateTime" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:dateTime`, gibt der Reader zurück, ein Unboxing <xref:System.DateTime> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:dateTime`, versucht der Reader konvertiert eine <xref:System.DateTime> -Objekts gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
> [!NOTE]
>  Wenn der Inhalt den Typ <xref:System.DateTime.Year%2A?displayProperty=nameWithType> hat, ist der `xsd:gMonthDay`-Wert nicht verlässlich. <xref:System.Xml.XmlReader> Legt die <xref:System.DateTime.Year%2A?displayProperty=nameWithType> in diesem Fall auf 1904 Wert.  
  
 In der folgende Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, die in den angeforderten Typ konvertiert werden.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit Aufrufen `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die verarbeitungsanweisung (PI) oder einen Kommentar und liest den verketteten Textinhalt, der die Verarbeitungsanweisung oder den Kommentar folgt.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert ist, auch wenn der Reader in der Regel in der aktuellen Position bleibt.|  
  
 Weitere Informationen finden Sie unter den <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Typumwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTimeOffset ReadContentAsDateTimeOffset();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset&#xA;override this.ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset" Usage="xmlReader.ReadContentAsDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see cref="T:System.DateTimeOffset" />-Objekt.</summary>
        <returns>Der Textinhalt als <see cref="T:System.DateTimeOffset" />-Objekt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see cref="T:System.Decimal" />-Objekt.</summary>
        <returns>Der Textinhalt an der aktuellen Position als <see cref="T:System.Decimal" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:decimal`, gibt der Reader zurück, ein Unboxing <xref:System.Decimal> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:decimal`, versucht der Reader konvertiert eine <xref:System.Decimal> -Objekts gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 In der folgende Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, die in den angeforderten Typ konvertiert werden.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit Aufrufen `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die verarbeitungsanweisung (PI) oder einen Kommentar und liest den verketteten Textinhalt, der die Verarbeitungsanweisung oder den Kommentar folgt.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert ist, auch wenn der Reader in der Regel in der aktuellen Position bleibt.|  
  
 Weitere Informationen finden Sie unter den <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Typumwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDouble : unit -&gt; double&#xA;override this.ReadContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Der Textinhalt als Gleitkommazahl mit doppelter Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:double`, gibt der Reader eine Gleitkommazahl mit doppelter Genauigkeit zurück. Wenn der Inhalt nicht typisiert ist `xsd:double`, versucht der Reader konvertieren in eine Gleitkommazahl mit doppelter Genauigkeit Gleitkommazahl gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 In der folgende Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, die in den angeforderten Typ konvertiert werden.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit Aufrufen `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die verarbeitungsanweisung (PI) oder einen Kommentar und liest den verketteten Textinhalt, der die Verarbeitungsanweisung oder den Kommentar folgt.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert ist, auch wenn der Reader in der Regel in der aktuellen Position bleibt.|  
  
 Weitere Informationen finden Sie unter den <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Typumwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsFloat : unit -&gt; single&#xA;override this.ReadContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als Gleitkommazahl mit einfacher Genauigkeit.</summary>
        <returns>Der Textinhalt an der aktuellen Position als Gleitkommazahl mit einfacher Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:float`, vom Reader zurückgegeben ein mittels Unboxing konvertiert eine Gleitkommazahl mit einfacher Genauigkeit. Wenn der Inhalt nicht typisiert ist `xsd:float`, versucht der Reader, um ihn in eine Gleitkommazahl mit einfacher Genauigkeit gemäß den Regeln, die definiert, die durch Konvertieren der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 In der folgende Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, die in den angeforderten Typ konvertiert werden.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit Aufrufen `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die verarbeitungsanweisung (PI) oder einen Kommentar und liest den verketteten Textinhalt, der die Verarbeitungsanweisung oder den Kommentar folgt.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert ist, auch wenn der Reader in der Regel in der aktuellen Position bleibt.|  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Typumwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsInt : unit -&gt; int&#xA;override this.ReadContentAsInt : unit -&gt; int" Usage="xmlReader.ReadContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Der Textinhalt als 32-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:integer`, gibt der Reader eine Unboxing 32-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:integer`, versucht der Reader, um ihn in eine 32-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln, die definiert, die durch Konvertieren der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 In der folgende Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, die in den angeforderten Typ konvertiert werden.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit Aufrufen `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die verarbeitungsanweisung (PI) oder einen Kommentar und liest den verketteten Textinhalt, der die Verarbeitungsanweisung oder den Kommentar folgt.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert ist, auch wenn der Reader in der Regel in der aktuellen Position bleibt.|  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Typumwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsLong : unit -&gt; int64&#xA;override this.ReadContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Der Textinhalt als 64-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Wenn der Inhalt typisiert ist `xsd:long`, gibt der Reader eine Unboxing 64-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:long`, versucht der Reader in eine 64-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln, die definiert, die durch Konvertieren der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die folgende Tabelle zeigt, wie diese Methode behandelt jeden Knotentyp.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, die in den angeforderten Typ konvertiert werden.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit `XmlConvert.ToXxx` für den Attributwert.|Der Reader behält die aktuelle Position|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die verarbeitungsanweisung (PI) oder einen Kommentar und liest den verketteten Textinhalt, der die Verarbeitungsanweisung oder den Kommentar folgt.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert ist, auch wenn der Reader in der Regel in der aktuellen Position bleibt.|  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Typumwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObject : unit -&gt; obj&#xA;override this.ReadContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see cref="T:System.Object" />.</summary>
        <returns>Der Textinhalt als geeignetstes CLR-Objekt (Common Language Runtime).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Vom Reader zurückgegeben, wenn der Inhalt typisiert ist, eine geschachtelte CLR des am besten geeigneten Typs gemäß der <xref:System.Xml.XmlReader.ValueType%2A> Eigenschaft. Wenn der Inhalt einem Listentyp ist, gibt der Reader ein Array der geschachtelten Objekte des entsprechenden Typs.  
  
> [!NOTE]
>  Wenn ein Validierungsfehler, beim Analysieren des Inhalts auftritt und der Reader befindet sich ein <xref:System.Xml.XmlReader> Objekt erstellt wurde, indem die <xref:System.Xml.XmlReader.Create%2A> -Methode, gibt der Reader den Inhalt als Zeichenfolge zurück. Anders ausgedrückt: tritt ein Validierungsfehler oder eine Warnung, werden der Inhalt gilt nicht typisiert sein.  
  
 Wenn der Inhalt nicht typisiert ist, gibt der Reader den Inhalt als Zeichenfolge zurück.  
  
 In der folgende Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, die in den angeforderten Typ konvertiert werden.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit Aufrufen `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die verarbeitungsanweisung (PI) oder einen Kommentar und liest den verketteten Textinhalt, der die Verarbeitungsanweisung oder den Kommentar folgt.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Der Wert des Elements, sofern der Reader befindet sich ein Schema überprüfen Reader (<xref:System.Xml.XmlReaderSettings.ValidationType%2A> nastaven NA hodnotu <xref:System.Xml.ValidationType.Schema>); andernfalls eine leere Zeichenfolge.|Der Reader behält die aktuelle Position.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert ist, auch wenn der Reader in der Regel in der aktuellen Position bleibt.|  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Typumwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt asynchron an der aktuellen Position als ein <see cref="T:System.Object" />.</summary>
        <returns>Der Textinhalt als geeignetstes CLR-Objekt (Common Language Runtime).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadContentAsObject%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsString : unit -&gt; string&#xA;override this.ReadContentAsString : unit -&gt; string" Usage="xmlReader.ReadContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt an der aktuellen Position als <see cref="T:System.String" />-Objekt.</summary>
        <returns>Der Textinhalt als <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verkettet, Text, Leerraum, signifikanter Leerraum und CDATA-Abschnitte und überspringt alle Kommentare und verarbeitungsanweisungen. Entitätsverweise werden automatisch aufgelöst.  
  
 Diese Methode kann verwendet werden, konvertieren Sie typisierte Werte in eine Zeichenfolge oder den Textinhalt lesen, während wird übersprungen, Kommentare und verarbeitungsanweisungen.  
  
 In der folgende Tabelle wird beschrieben, wie diese Methode für jeden Knotentyp behandelt.  
  
|XmlNodeType|Rückgabewert|Verhalten des Readers|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Verketteter Inhalt von Text, CDATA, Leerraum und signifikantem Leerraumknoten, die in den angeforderten Typ konvertiert werden.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`Attribute`|Identisch mit Aufrufen `XmlConvert.ToXxx` auf den Wert des Attributs.|Der Reader behält die aktuelle Position.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignoriert die verarbeitungsanweisung (PI) oder einen Kommentar und liest den verketteten Textinhalt, der die Verarbeitungsanweisung oder den Kommentar folgt.|Wechselt zum nächsten start-Element oder Endelementtag. Entitätsverweise werden automatisch erweitert.|  
|`EndElement`|Eine leere Zeichenfolge.|Der Reader behält die aktuelle Position.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|Es wird eine <xref:System.InvalidOperationException> ausgelöst.|Nicht definiert ist, auch wenn der Reader in der Regel in der aktuellen Position bleibt.|  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Die versuchte Typumwandlung ist ungültig.</exception>
        <exception cref="T:System.FormatException">Das Zeichenfolgenformat ist nicht gültig.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Textinhalt asynchron an der aktuellen Position als <see cref="T:System.String" />-Objekt.</summary>
        <returns>Der Textinhalt als <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadContentAsString%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAs">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest das aktuelle Element und gibt den Inhalt als Objekt vom angegebenen Typ zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">Der Typ des zurückzugebenden Werts.  
  
 **Hinweis** Seit der Veröffentlichung von .NET Framework 3.5 kann der Wert des <paramref name="returnType" />-Parameters nun auch auf den <see cref="T:System.DateTimeOffset" />-Typ festgelegt werden.</param>
        <param name="namespaceResolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" />-Objekt, das für die Auflösung von Präfixen von Namespaces verwendet wird, die im Zusammenhang mit der Typkonvertierung stehen.</param>
        <summary>Liest den Elementinhalt als angeforderten Typ.</summary>
        <returns>Der in das angeforderte typisierte Objekt konvertierte Elementinhalt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Xml.XmlReader.ReadElementContentAs%2A> Methode, um den Inhalt Lesen der `date` Knoten.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
        <exception cref="T:System.OverflowException">Lesen von <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver, localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="localName" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">Der Typ des zurückzugebenden Werts.  
  
 **Hinweis** Seit der Veröffentlichung von .NET Framework 3.5 kann der Wert des <paramref name="returnType" />-Parameters nun auch auf den <see cref="T:System.DateTimeOffset" />-Typ festgelegt werden.</param>
        <param name="namespaceResolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" />-Objekt, das für die Auflösung von Präfixen von Namespaces verwendet wird, die im Zusammenhang mit der Typkonvertierung stehen.</param>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, und liest dann den Elementinhalt als angeforderten Typ.</summary>
        <returns>Der in das angeforderte typisierte Objekt konvertierte Elementinhalt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene lokale Name und der Namespace-URI stimmen nicht mit dem Element überein, das gerade gelesen wird.</exception>
        <exception cref="T:System.OverflowException">Lesen von <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">Der Typ des zurückzugebenden Werts.</param>
        <param name="namespaceResolver">Ein <see cref="T:System.Xml.IXmlNamespaceResolver" />-Objekt, das für die Auflösung von Präfixen von Namespaces verwendet wird, die im Zusammenhang mit der Typkonvertierung stehen.</param>
        <summary>Liest das Elementinhalt asynchron als angeforderten Typ.</summary>
        <returns>Der in das angeforderte typisierte Objekt konvertierte Elementinhalt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadElementContentAs%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.
- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest das Element und decodiert den <see langword="Base64" />-Inhalt.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest den Elementinhalt, decodiert Sie es mit `Base64` Codierungs- und gibt die decodierten Binärbytes zurück (z. B. ein Inlineschema `Base64`-codiertes GIF-Bild) in den Puffer. Weitere Informationen finden Sie unter RFC 1521, "MIME (Multipurpose Internet Mail Extensions)-Teil einer: Mechanismen zum angeben, und beschreiben das Format der Internetnachrichtentexte". Sie erhalten RFCs auf der [Request for Comments-Website](https://go.microsoft.com/fwlink/?LinkId=37119).  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A> Elemente mit einfachem Inhalt können nur gelesen werden. Das Element kann es sich um Text, Leerraum, signifikanter Leerraum, CDATA-Abschnitten, Kommentare und verarbeitungsanweisungen enthalten. Es kann auch Entitätsverweise, die automatisch erweitert werden, enthalten. Das Element keine untergeordneten Elemente.  
  
 Diese Methode ähnelt der <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> Methode, aber sie kann nur für Elementknotentypen aufgerufen werden.  
  
 Wenn die `count` Wert ist größer als die Anzahl der Bytes im Dokument oder gleich der Anzahl der Bytes im Dokument ist die <xref:System.Xml.XmlReader> liest alle verbleibenden Bytes im Dokument und gibt die Anzahl der gelesenen Bytes zurück. Die nächste <xref:System.Xml.XmlReader> Methodenaufruf gibt 0 zurück, und verschiebt den Reader auf den Knoten hinter dem `EndElement`.  
  
 Aufrufen <xref:System.Xml.XmlReader.Read%2A> , bevor der gesamte der Inhalt des Elements verwendet, kann der Reader verhält, als ob der erste Inhalt verwendet wurde, und klicken Sie dann die <xref:System.Xml.XmlReader.Read%2A> Methode wurde aufgerufen. Dies bedeutet, dass der Leser wird der gesamte Text lesen, bis das EndElement gefunden wird. Es wird dann lesen den Knoten am Endtag, lesen den nächsten Knoten und positionieren selbst klicken Sie dann auf dem nächsten folgenden Knoten.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine Inline `Base64` -codiertes Bild. Die `Base64` Daten sind eingebettet, in der `<image>` Element. Ein <xref:System.IO.BinaryWriter> wird verwendet, um eine neue binäre Datei zu erstellen.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Knoten ist kein Elementknoten.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Index im Puffer oder Index + Anzahl übersteigen die Größe des zugeordneten Puffers.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Xml.XmlReader" />-Implementierung unterstützt diese Methode nicht.</exception>
        <exception cref="T:System.Xml.XmlException">Das Element enthält gemischten Inhalt.</exception>
        <exception cref="T:System.FormatException">Der Inhalt kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest das Element asynchron und decodiert den <see langword="Base64" />-Inhalt.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest das Element und decodiert den <see langword="BinHex" />-Inhalt.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest den Elementinhalt, decodiert Sie es mit `BinHex` Codierungs- und gibt die decodierten Binärbytes zurück (z. B. ein Inlineschema `BinHex`-codiertes GIF-Bild) in den Puffer.  
  
 Diese Methode kann nur Elemente mit einfachem Inhalt gelesen. Das Element kann es sich um Text, Leerraum, signifikanter Leerraum, CDATA-Abschnitten, Kommentare und verarbeitungsanweisungen enthalten. Es kann auch Entitätsverweise, die automatisch erweitert werden, enthalten. Das Element keine untergeordneten Elemente.  
  
 Diese Methode ähnelt der <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> Methode, aber sie kann nur für Elementknotentypen aufgerufen werden.  
  
 Wenn die `count` Wert ist größer als die Anzahl der Bytes im Dokument oder gleich der Anzahl der Bytes im Dokument ist die <xref:System.Xml.XmlReader> liest alle verbleibenden Bytes im Dokument und gibt die Anzahl der gelesenen Bytes zurück. Die nächste <xref:System.Xml.XmlReader> Methodenaufruf gibt 0 zurück, und verschiebt den Reader auf den Knoten hinter dem `EndElement`.  
  
 Aufrufen <xref:System.Xml.XmlReader.Read%2A> , bevor der gesamte der Inhalt des Elements verwendet, kann der Reader verhält, als ob der erste Inhalt verwendet wurde, und klicken Sie dann die <xref:System.Xml.XmlReader.Read%2A> Methode wurde aufgerufen. Dies bedeutet, dass der Leser wird der gesamte Text lesen, bis das EndElement gefunden wird. Es wird dann lesen den Knoten am Endtag, lesen den nächsten Knoten und positionieren selbst klicken Sie dann auf dem nächsten folgenden Knoten.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine Inline `BinHex` -codiertes Bild. Die `BinHex` Daten sind eingebettet, in der `<image>` Element. Ein <xref:System.IO.BinaryWriter> wird verwendet, um eine neue binäre Datei zu erstellen.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Knoten ist kein Elementknoten.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Index im Puffer oder Index + Anzahl übersteigen die Größe des zugeordneten Puffers.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Xml.XmlReader" />-Implementierung unterstützt diese Methode nicht.</exception>
        <exception cref="T:System.Xml.XmlException">Das Element enthält gemischten Inhalt.</exception>
        <exception cref="T:System.FormatException">Der Inhalt kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den der resultierende Text kopiert werden soll. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, an dem mit dem Kopieren des Ergebnisses begonnen werden soll.</param>
        <param name="count">Die maximale Anzahl von Bytes, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl von kopierten Bytes zurück.</param>
        <summary>Liest das Element asynchron und decodiert den <see langword="BinHex" />-Inhalt.</summary>
        <returns>Die Anzahl der in den Puffer geschriebenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsBoolean">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest den aktuellen Elementwert als <see cref="T:System.Boolean" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : unit -&gt; bool&#xA;override this.ReadElementContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.Boolean" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.Boolean" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Wenn der Inhalt des Elements typisiert ist `xsd:boolean`, gibt der Reader zurück, ein Unboxing <xref:System.Boolean> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:boolean`, versucht der Reader konvertiert eine <xref:System.Boolean> -Objekts gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in ein <see cref="T:System.Boolean" />-Objekt konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : string * string -&gt; bool&#xA;override this.ReadElementContentAsBoolean : string * string -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als <see cref="T:System.Boolean" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.Boolean" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:boolean`, gibt der Reader zurück, ein Unboxing <xref:System.Boolean> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:boolean`, versucht der Reader konvertiert eine <xref:System.Boolean> -Objekts gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene lokale Name und der Namespace-URI stimmen nicht mit dem Element überein, das gerade gelesen wird.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDateTime">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.DateTime" />-Objekt zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.DateTime" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.DateTime" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:dateTime`, gibt der Reader zurück, ein Unboxing <xref:System.DateTime> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:dateTime`, versucht der Reader konvertiert eine <xref:System.DateTime> -Objekts gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
> [!NOTE]
>  Wenn der Inhalt den Typ <xref:System.DateTime.Year%2A?displayProperty=nameWithType> hat, ist der `xsd:gMonthDay`-Wert nicht verlässlich. <xref:System.Xml.XmlReader> Legt die <xref:System.DateTime.Year%2A?displayProperty=nameWithType> in diesem Fall auf 1904 Wert.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> Methode, um den Inhalt Lesen der `date` Element.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in ein <see cref="T:System.DateTime" />-Objekt konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime (localName As String, namespaceURI As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : string * string -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : string * string -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als <see cref="T:System.DateTime" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.DateTime" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:dateTime`, gibt der Reader zurück, ein Unboxing <xref:System.DateTime> Objekt. Wenn der Inhalt nicht typisiert ist `xsd:dateTime`, versucht der Reader konvertiert eine <xref:System.DateTime> -Objekts gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
> [!NOTE]
>  Wenn der Inhalt den Typ <xref:System.DateTime.Year%2A?displayProperty=nameWithType> hat, ist der `xsd:gMonthDay`-Wert nicht verlässlich. <xref:System.Xml.XmlReader> Legt die <xref:System.DateTime.Year%2A?displayProperty=nameWithType> in diesem Fall auf 1904 Wert.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene lokale Name und der Namespace-URI stimmen nicht mit dem Element überein, das gerade gelesen wird.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDecimal">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest den aktuellen Elementwert als <see cref="T:System.Decimal" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.Decimal" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.Decimal" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Versucht der Reader der Elementinhalt zu konvertieren eine <xref:System.Decimal> -Objekts gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in <see cref="T:System.Decimal" /> konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal (localName As String, namespaceURI As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : string * string -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : string * string -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als <see cref="T:System.Decimal" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.Decimal" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Versucht der Reader der Elementinhalt zu konvertieren eine <xref:System.Decimal> -Objekts gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in <see cref="T:System.Decimal" /> konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene lokale Name und der Namespace-URI stimmen nicht mit dem Element überein, das gerade gelesen wird.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDouble">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest das aktuelle Element und gibt den Inhalt als Gleitkommazahl mit doppelter Genauigkeit zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : unit -&gt; double&#xA;override this.ReadElementContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadElementContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als Gleitkommazahl mit doppelter Genauigkeit zurück.</summary>
        <returns>Der Elementinhalt als Gleitkommazahl mit doppelter Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:double`, gibt der Reader eine Gleitkommazahl mit doppelter Genauigkeit zurück. Wenn der Inhalt nicht typisiert ist `xsd:double`, versucht der Reader konvertieren in eine Gleitkommazahl mit doppelter Genauigkeit Gleitkommazahl gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
   
  
## Examples  
 Im folgende Beispiel verwendet die Methode, um den Elementinhalt als Gleitkommazahl mit doppelter Genauigkeit zurück.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in eine Gleitkommazahl mit doppelter Genauigkeit konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble (localName As String, namespaceURI As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : string * string -&gt; double&#xA;override this.ReadElementContentAsDouble : string * string -&gt; double" Usage="xmlReader.ReadElementContentAsDouble (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als Gleitkommazahl mit doppelter Genauigkeit zurück.</summary>
        <returns>Der Elementinhalt als Gleitkommazahl mit doppelter Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:double`, gibt der Reader eine Gleitkommazahl mit doppelter Genauigkeit zurück. Wenn der Inhalt nicht typisiert ist `xsd:double`, versucht der Reader konvertieren in eine Gleitkommazahl mit doppelter Genauigkeit Gleitkommazahl gemäß den Regeln der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene lokale Name und der Namespace-URI stimmen nicht mit dem Element überein, das gerade gelesen wird.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsFloat">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest den aktuellen Elementwert als Gleitkommazahl mit einfacher Genauigkeit.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : unit -&gt; single&#xA;override this.ReadElementContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadElementContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als Gleitkommazahl mit einfacher Genauigkeit zurück.</summary>
        <returns>Der Elementinhalt als Gleitkommazahl mit einfacher Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Versucht der Reader, den Inhalt des Elements in eine Gleitkommazahl mit einfacher Genauigkeit gemäß den Regeln, die definiert, die durch Konvertieren der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in eine Gleitkommazahl mit einfacher Genauigkeit konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat (localName As String, namespaceURI As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : string * string -&gt; single&#xA;override this.ReadElementContentAsFloat : string * string -&gt; single" Usage="xmlReader.ReadElementContentAsFloat (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als Gleitkommazahl mit einfacher Genauigkeit zurück.</summary>
        <returns>Der Elementinhalt als Gleitkommazahl mit einfacher Genauigkeit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Versucht der Reader, den Inhalt des Elements in eine Gleitkommazahl mit einfacher Genauigkeit gemäß den Regeln, die definiert, die durch Konvertieren der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder - 
Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in eine Gleitkommazahl mit einfacher Genauigkeit konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene lokale Name und der Namespace-URI stimmen nicht mit dem Element überein, das gerade gelesen wird.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsInt">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest das aktuelle Element und gibt den Inhalt als 32-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : unit -&gt; int&#xA;override this.ReadElementContentAsInt : unit -&gt; int" Usage="xmlReader.ReadElementContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als 32-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Der Elementinhalt als 32-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:integer`, gibt der Reader eine Unboxing 32-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:integer`, versucht der Reader, um ihn in eine 32-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln, die definiert, die durch Konvertieren der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder - 
Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in eine 32-Bit-Ganzzahl mit Vorzeichen konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt (localName As String, namespaceURI As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : string * string -&gt; int&#xA;override this.ReadElementContentAsInt : string * string -&gt; int" Usage="xmlReader.ReadElementContentAsInt (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als 32-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Der Elementinhalt als 32-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:integer`, gibt der Reader eine Unboxing 32-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:integer`, versucht der Reader, um ihn in eine 32-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln, die definiert, die durch Konvertieren der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder - 
Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in eine 32-Bit-Ganzzahl mit Vorzeichen konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene lokale Name und der Namespace-URI stimmen nicht mit dem Element überein, das gerade gelesen wird.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsLong">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest das aktuelle Element und gibt den Inhalt als 64-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : unit -&gt; int64&#xA;override this.ReadElementContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadElementContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als 64-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Der Elementinhalt als 64-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:long`, gibt der Reader eine Unboxing 64-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:long`, versucht der Reader in eine 64-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln, die definiert, die durch Konvertieren der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A> Methode, um den Inhalt Lesen der `longValue` Element.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder - 
Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in eine 64-Bit-Ganzzahl mit Vorzeichen konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong (localName As String, namespaceURI As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : string * string -&gt; int64&#xA;override this.ReadElementContentAsLong : string * string -&gt; int64" Usage="xmlReader.ReadElementContentAsLong (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als 64-Bit-Ganzzahl mit Vorzeichen zurück.</summary>
        <returns>Der Elementinhalt als 64-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Wenn der Inhalt typisiert ist `xsd:long`, gibt der Reader eine Unboxing 64-Bit-Ganzzahl mit Vorzeichen zurück. Wenn der Inhalt nicht typisiert ist `xsd:long`, versucht der Reader in eine 64-Bit-Ganzzahl mit Vorzeichen gemäß den Regeln, die definiert, die durch Konvertieren der [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Weitere Informationen finden Sie im Abschnitt Hinweise unter der <xref:System.Xml.XmlReader> Referenzseite.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder - 
Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in eine 64-Bit-Ganzzahl mit Vorzeichen konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene lokale Name und der Namespace-URI stimmen nicht mit dem Element überein, das gerade gelesen wird.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsObject">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.Object" /> zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : unit -&gt; obj&#xA;override this.ReadElementContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadElementContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.Object" /> zurück.</summary>
        <returns>Ein geschachteltes CLR-Objekt (Common Language Runtime) des geeignetsten Typs. Die <see cref="P:System.Xml.XmlReader.ValueType" />-Eigenschaft bestimmt den geeigneten CLR-Typ. Wenn der Inhalt als Listentyp typisiert ist, gibt der Reader ein Array der geschachtelten Objekte des geeigneten Typs zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Methode, um den Inhalt Lesen der `price` Knoten. Der Reader verwendet die Informationen im Schema, das Zuordnen zu den richtigen Datentyp.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 Im Beispiel werden die folgenden beiden Dateien als Eingabe verwendet.  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder - 
Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject (localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : string * string -&gt; obj&#xA;override this.ReadElementContentAsObject : string * string -&gt; obj" Usage="xmlReader.ReadElementContentAsObject (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als <see cref="T:System.Object" /> zurück.</summary>
        <returns>Ein geschachteltes CLR-Objekt (Common Language Runtime) des geeignetsten Typs. Die <see cref="P:System.Xml.XmlReader.ValueType" />-Eigenschaft bestimmt den geeigneten CLR-Typ. Wenn der Inhalt als Listentyp typisiert ist, gibt der Reader ein Array der geschachtelten Objekte des geeigneten Typs zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder - 
Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in den angeforderten Typ konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene lokale Name und der Namespace-URI stimmen nicht mit dem Element überein, das gerade gelesen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element asynchron und gibt den Inhalt als <see cref="T:System.Object" /> zurück.</summary>
        <returns>Ein geschachteltes CLR-Objekt (Common Language Runtime) des geeignetsten Typs. Die <see cref="P:System.Xml.XmlReader.ValueType" />-Eigenschaft bestimmt den geeigneten CLR-Typ. Wenn der Inhalt als Listentyp typisiert ist, gibt der Reader ein Array der geschachtelten Objekte des geeigneten Typs zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.String" />-Objekt zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : unit -&gt; string&#xA;override this.ReadElementContentAsString : unit -&gt; string" Usage="xmlReader.ReadElementContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element und gibt den Inhalt als <see cref="T:System.String" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel liest der `stringValue` Element und gibt den Textinhalt (den Kommentar wird ignoriert, und die Anweisung zur Verarbeitung) zurück.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in ein <see cref="T:System.String" />-Objekt konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : string * string -&gt; string&#xA;override this.ReadElementContentAsString : string * string -&gt; string" Usage="xmlReader.ReadElementContentAsString (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der angegebene lokale Name und der angegebene Namespace-URI mit denen des aktuellen Elements übereinstimmen, liest dann das aktuelle Element und gibt den Inhalt als <see cref="T:System.String" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest das Anfangstag und den Inhalt des Elements, und verschiebt den Reader direkt hinter das Endelementtag. Es wird erweitert, Entitäten und verarbeitungsanweisungen und Kommentare werden ignoriert. Das Element kann nur mit einfachen Inhalt enthalten. Es kann nicht, also die untergeordneten Elemente aufweisen.  
  
 Weitere Informationen finden Sie im Abschnitt "Hinweise" der <xref:System.Xml.XmlReader> Referenzseite und [W3C XML Schema Part 2: Datatypes](https://go.microsoft.com/fwlink/?LinkId=4871) Empfehlung.  
  
   
  
## Examples  
 Das folgende Beispiel liest der `stringValue` Element und gibt den Textinhalt (den Kommentar wird ignoriert, und die Anweisung zur Verarbeitung) zurück.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 In diesem Beispiel wird die Datei `dataFile.xml` als Eingabe verwendet.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Xml.XmlReader" /> wird nicht auf einem Element positioniert.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.Xml.XmlException">Das aktuelle Element enthält untergeordnete Elemente.  
  
- oder - 
Der Elementinhalt kann nicht in ein <see cref="T:System.String" />-Objekt konvertiert werden.</exception>
        <exception cref="T:System.ArgumentNullException">Die Methode wird mit <see langword="null" />-Argumenten aufgerufen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene lokale Name und der Namespace-URI stimmen nicht mit dem Element überein, das gerade gelesen wird.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadElementContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadElementContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das aktuelle Element asynchron und gibt den Inhalt als <see cref="T:System.String" />-Objekt zurück.</summary>
        <returns>Der Elementinhalt als <see cref="T:System.String" />-Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest die einfachen Nur-Text-Elemente. Sie sollten stattdessen allerdings die <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" />-Methode verwenden, da sie eine einfachere Möglichkeit zum Verarbeiten dieses Vorgangs bietet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wir empfehlen die Verwendung der <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> Methode, um ein Textelement zu lesen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : unit -&gt; string&#xA;override this.ReadElementString : unit -&gt; string" Usage="xmlReader.ReadElementString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest ein Nur-Text-Element. Sie sollten stattdessen allerdings die <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />-Methode verwenden, da sie eine einfachere Möglichkeit zum Verarbeiten dieses Vorgangs bietet.</summary>
        <returns>Der Text in dem gelesenen Element. Eine leere Zeichenfolge, wenn das Element leer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wir empfehlen die Verwendung der <xref:System.Xml.XmlReader.ReadElementContentAsString> Methode, um ein Textelement zu lesen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der nächste Inhaltsknoten ist kein Starttag, oder das gefundene Element enthält keinen Wert für einfachen Text.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string -&gt; string&#xA;override this.ReadElementString : string -&gt; string" Usage="xmlReader.ReadElementString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Der zu überprüfende Name.</param>
        <summary>Überprüft vor dem Lesen eines Nur-Text-Elements, ob die <see cref="P:System.Xml.XmlReader.Name" />-Eigenschaft des gefundenen Elements mit der angegebenen Zeichenfolge übereinstimmt. Sie sollten stattdessen allerdings die <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" />-Methode verwenden, da sie eine einfachere Möglichkeit zum Verarbeiten dieses Vorgangs bietet.</summary>
        <returns>Der Text in dem gelesenen Element. Eine leere Zeichenfolge, wenn das Element leer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wir empfehlen die Verwendung der <xref:System.Xml.XmlReader.ReadElementContentAsString> Methode, um ein Textelement zu lesen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wenn der nächste Inhaltsknoten kein Starttag ist, wenn der Element <see langword="Name" /> mit dem angegebenen Argument nicht übereinstimmt oder wenn das gefundene Element keinen Wert für einfachen Text enthält.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (localname As String, ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string * string -&gt; string&#xA;override this.ReadElementString : string * string -&gt; string" Usage="xmlReader.ReadElementString (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ns" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="localname">Der zu überprüfende lokale Name.</param>
        <param name="ns">Der zu überprüfende Namespace-URI.</param>
        <summary>Überprüft vor dem Lesen eines Nur-Text-Elements, ob die <see cref="P:System.Xml.XmlReader.LocalName" />-Eigenschaft und die <see cref="P:System.Xml.XmlReader.NamespaceURI" />-Eigenschaft des gefundenen Elements mit den angegebenen Zeichenfolgen übereinstimmen. Sie sollten stattdessen allerdings die <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />-Methode verwenden, da sie eine einfachere Möglichkeit zum Verarbeiten dieses Vorgangs bietet.</summary>
        <returns>Der Text in dem gelesenen Element. Eine leere Zeichenfolge, wenn das Element leer ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wir empfehlen die Verwendung der <xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29> Methode, um ein Textelement zu lesen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Wenn der nächste Inhaltsknoten kein Starttag ist, wenn der <see langword="LocalName" /> oder <see langword="NamespaceURI" /> des Elements nicht mit den angegebenen Argumenten übereinstimmen oder wenn das gefundene Element keinen Wert für einfachen Text enthält.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadEndElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadEndElement : unit -&gt; unit&#xA;override this.ReadEndElement : unit -&gt; unit" Usage="xmlReader.ReadEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überprüft, ob der aktuelle Inhaltsknoten ein Endtag ist, und verschiebt den Reader auf den nächsten Knoten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel wird der Textinhalt der einzelnen Elemente angezeigt.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 Im Beispiel wird die `book3.xml` Datei.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Der aktuelle Knoten ist kein Endtag, oder im Eingabestream wurde unzulässiger XML-Code gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadStartElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadInnerXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXml : unit -&gt; string&#xA;override this.ReadInnerXml : unit -&gt; string" Usage="xmlReader.ReadInnerXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest beim Überschreiben in einer abgeleiteten Klasse den gesamten Inhalt, einschließlich Markup, als Zeichenfolge.</summary>
        <returns>Der gesamte XML-Inhalt (einschließlich Markup) im aktuellen Knoten. Wenn der aktuelle Knoten keine untergeordneten Elemente besitzt, wird eine leere Zeichenfolge zurückgegeben.  
  
Wenn der aktuelle Knoten weder ein Element noch ein Attribut ist, wird eine leere Zeichenfolge zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt alle Inhalte des aktuellen Knotens einschließlich Markup zurück. Der aktuelle Knoten (Starttag) und der entsprechende Endknoten (Endtag) werden nicht zurückgegeben. Angenommen, betrachten Sie Folgendes:  
  
```xml  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` gibt `this <child id="123"/>`  
  
 Diese Methode verarbeitet die Element-und Attributknoten auf folgende Weise:  
  
|Knotentyp|Die Position vor dem Aufruf|XML-fragment|Rückgabewert|Position nach dem Aufruf|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Auf der `item1` Starttag.|\<Item1 > text1\</item1 >\<item2 > "Text2"\</item2 >|Text1|Auf der `item2` Starttag.|  
|`Attribute`|Auf der `attr1` Attributknoten.|\<Element attr1 = "Wert1" attr2 = "Wert2" > Text \< /item >|Wert1|Verbleibt auf dem `attr1` Attributknoten.|  
  
 Wenn der Reader auf einem Endknoten positioniert ist, wird beim Aufrufen `ReadInnerXml` entspricht dem Aufruf <xref:System.Xml.XmlReader.Read%2A>. Gibt die Methode zurück `String.Empty` (außer bei Attributknoten in diesem Fall wird der Wert des Attributs zurückgegeben wird).  
  
 Diese Methode überprüft für wohlgeformtes XML. Wenn `ReadInnerXml` aufgerufen wird ein <xref:System.Xml.XmlValidatingReader>, diese Methode überprüft auch den Inhalt, der zurückgegeben wird.  
  
 Gemäß der Implementierung in der <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> und `XmlValidatingReader` Klassen die `ReadOuterXml` besteht im Namespace beachten.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `ReadInnerXml` und <xref:System.Xml.XmlReader.ReadOuterXml%2A> Methoden.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 Im Beispiel wird `2books.xml` als Eingabe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Das XML war nicht wohlgeformt, oder bei der XML-Analyse ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadInnerXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadInnerXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest asynchron den gesamten Inhalt, einschließlich Markup als Zeichenfolge.</summary>
        <returns>Der gesamte XML-Inhalt (einschließlich Markup) im aktuellen Knoten. Wenn der aktuelle Knoten keine untergeordneten Elemente besitzt, wird eine leere Zeichenfolge zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadInnerXml%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadOuterXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXml : unit -&gt; string&#xA;override this.ReadOuterXml : unit -&gt; string" Usage="xmlReader.ReadOuterXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Inhalt (einschließlich Markup) ab, der diesen Knoten und alle untergeordneten Elemente darstellt.</summary>
        <returns>Wenn der Reader auf einem Elementknoten oder einem Attributknoten positioniert ist, gibt diese Methode den gesamten XML-Inhalt (einschließlich Markup) des aktuellen Knotens sowie aller untergeordneten Elemente zurück. Andernfalls wird eine leere Zeichenfolge zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ähnelt <xref:System.Xml.XmlReader.ReadInnerXml%2A> mit der Ausnahme wird auch die Start- und Endtags zurückgegeben.  
  
 Diese Methode verarbeitet die Element-und Attributknoten auf folgende Weise:  
  
|Knotentyp|Die Position vor dem Aufruf|XML-fragment|Rückgabewert|Position nach dem Aufruf|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Auf der `item1` Starttag.|\<Item1 > text1\</item1 >\<item2 > "Text2"\</item2 >|\<Item1 > text1\</item1 >|Auf der `item2` Starttag.|  
|`Attribute`|Auf der `attr1` Attributknoten.|\<Element attr1 = "Wert1" attr2 = "Wert2" > Text \< /item >|attr1 = "Wert1"|Verbleibt auf dem `attr1` Attributknoten.|  
  
 Wenn der Reader auf einem Endknoten positioniert ist, wird beim Aufrufen `ReadOuterXml` entspricht dem Aufruf <xref:System.Xml.XmlReader.Read%2A>. Gibt die Methode zurück `String.Empty` (außer bei Attributknoten in diesem Fall wird das Attributmarkup zurückgegeben wird).  
  
 Diese Methode überprüft für wohlgeformtes XML. Wenn `ReadOuterXml` aufgerufen wird ein <xref:System.Xml.XmlValidatingReader>, diese Methode überprüft auch den zurückgegebenen Inhalt.  
  
 Gemäß der Implementierung in der <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> und `XmlValidatingReader` Klassen die `ReadOuterXml` besteht im Namespace beachten. Den XML-Text `<A xmlns:S="urn:1"><S:B>hello</S:B></A>`, wenn der Reader auf wurden die `S:B` Starttag, `ReadOuterXml` gibt `<S:B xmlns:S="urn:1">hello<S:B/>`.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `ReadInnerXml` und `ReadOuterXml` Methoden.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 Im Beispiel wird `2books.xml` als Eingabe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Das XML war nicht wohlgeformt, oder bei der XML-Analyse ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadOuterXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadOuterXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest den Inhalt, einschließlich Markup, das diesen Knoten und alle untergeordneten Elemente darstellt, asynchron.</summary>
        <returns>Wenn der Reader auf einem Elementknoten oder einem Attributknoten positioniert ist, gibt diese Methode den gesamten XML-Inhalt (einschließlich Markup) des aktuellen Knotens sowie aller untergeordneten Elemente zurück. Andernfalls wird eine leere Zeichenfolge zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadOuterXml%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Überprüft, ob der aktuelle Knoten ein Element ist, und verschiebt den Reader auf den nächsten Knoten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : unit -&gt; unit&#xA;override this.ReadStartElement : unit -&gt; unit" Usage="xmlReader.ReadStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überprüft, ob der aktuelle Knoten ein Element ist, und verschiebt den Reader auf den nächsten Knoten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft <xref:System.Xml.XmlReader.IsStartElement%2A> gefolgt von <xref:System.Xml.XmlReader.Read%2A> auf, um den Inhalt dieses Elements finden Sie in den Eingabestream.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Im Eingabestream wurde unzulässiger XML-Code gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string -&gt; unit&#xA;override this.ReadStartElement : string -&gt; unit" Usage="xmlReader.ReadStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Elements.</param>
        <summary>Überprüft, ob der aktuelle Inhaltsknoten ein Element mit dem angegebenen <see cref="P:System.Xml.XmlReader.Name" /> ist, und verschiebt den Reader auf den nächsten Knoten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf dieser Methode entspricht, für einen Aufruf von <xref:System.Xml.XmlReader.IsStartElement%2A> gefolgt von einem Aufruf von <xref:System.Xml.XmlReader.Read%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird der Textinhalt der einzelnen Elemente angezeigt.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 Im Beispiel wird die `book3.xml` Datei.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Im Eingabestream wurde unzulässiger XML-Code gefunden.  
  
- oder - 
Der <see cref="P:System.Xml.XmlReader.Name" /> des Elements entspricht nicht dem angegebenen <paramref name="name" />.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (localname As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string * string -&gt; unit&#xA;override this.ReadStartElement : string * string -&gt; unit" Usage="xmlReader.ReadStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">Der lokale Name des Elements.</param>
        <param name="ns">Der Namespace-URI des Elements.</param>
        <summary>Überprüft, ob der aktuelle Inhaltsknoten ein Element mit dem angegebenen <see cref="P:System.Xml.XmlReader.LocalName" /> und <see cref="P:System.Xml.XmlReader.NamespaceURI" /> ist, und verschiebt den Reader auf den nächsten Knoten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Aufruf dieser Methode entspricht, für einen Aufruf von <xref:System.Xml.XmlReader.IsStartElement%2A> gefolgt von einem Aufruf von <xref:System.Xml.XmlReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Im Eingabestream wurde unzulässiger XML-Code gefunden.  
  
- oder - 
Die Eigenschaften <see cref="P:System.Xml.XmlReader.LocalName" /> und <see cref="P:System.Xml.XmlReader.NamespaceURI" /> des gefundenen Elements stimmen nicht mit den angegebenen Argumenten überein.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Zustand des Readers ab.</summary>
        <value>Einer der Enumerationswerte, der den Zustand des Readers angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xml.XmlReader.ReadState%2A> Eigenschaft hat einen der folgenden Werte:  
  
-   <xref:System.Xml.ReadState.Initial>, wenn die <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> Methode wird aufgerufen.  
  
-   <xref:System.Xml.ReadState.Interactive>, wenn die <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> Methode aufgerufen wurde, und zusätzliche Methoden für den Reader aufgerufen werden können.  
  
-   <xref:System.Xml.ReadState.EndOfFile>, wenn das Ende des XML-Dokuments wurde erreicht erfolgreich.  
  
-   <xref:System.Xml.ReadState.Closed>, wenn die <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> Methode wird aufgerufen.  
  
-   <xref:System.Xml.ReadState.Error>, wenn ein Fehler verhindert den Lesevorgang nicht fortgesetzt werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="abstract member ReadString : unit -&gt; string&#xA;override this.ReadString : unit -&gt; string" Usage="xmlReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest beim Überschreiben in einer abgeleiteten Klasse den Inhalt eines Element- oder Textknotens als Zeichenfolge. Sie sollten stattdessen allerdings die <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" />-Methode verwenden, da sie eine einfachere Möglichkeit zum Verarbeiten dieses Vorgangs bietet.</summary>
        <returns>Der Inhalt des Elements oder eine leere Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wir empfehlen die Verwendung der <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> Methode, um den Inhalt eines Knotens Element- oder Textknotens als Zeichenfolge zu lesen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Beim Analysieren des XML-Codes ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSubtree () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlReader ^ ReadSubtree();" />
      <MemberSignature Language="F#" Value="abstract member ReadSubtree : unit -&gt; System.Xml.XmlReader&#xA;override this.ReadSubtree : unit -&gt; System.Xml.XmlReader" Usage="xmlReader.ReadSubtree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine neue <see langword="XmlReader" />-Instanz zurück, die zum Lesen des aktuellen Knotens und aller Nachfolgerknoten verwendet werden kann.</summary>
        <returns>Eine neue auf <see cref="F:System.Xml.ReadState.Initial" /> festgelegte XML-Reader-Instanz. Durch den Aufruf der <see cref="M:System.Xml.XmlReader.Read" />-Methode wird der neue Reader auf dem Knoten positioniert, der vor dem Aufruf der <see cref="M:System.Xml.XmlReader.ReadSubtree" />-Methode aktuell war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A> kann nur auf Knoten "Element" aufgerufen werden. Wenn die gesamte Teilstruktur gelesen wurde, Aufrufe von der <xref:System.Xml.XmlReader.Read%2A> Methodenrückgabe `false`. Wenn der neue XML-Reader geschlossen wurde, befindet sich der ursprüngliche Reader auf den `EndElement` Knoten der untergeordneten Struktur. Daher bei einem Aufruf der <xref:System.Xml.XmlReader.ReadSubtree%2A> Methode für das Starttag des das Book-Element, nachdem die Teilstruktur lesen und die neue XML-Reader wurde geschlossen wurde, die der ursprüngliche XML-Reader im Endtag des Buchelements positioniert ist.  
  
 Sie sollten alle Vorgänge für den ursprünglichen Reader nicht ausführen, bis der neue Reader geschlossen wurde. Diese Aktion wird nicht unterstützt und kann zu unvorhersehbarem Verhalten führen.  
  
> [!NOTE]
>  Die <xref:System.Xml.XmlReader.ReadSubtree%2A> Methode ist nicht vorgesehen, für die Erstellung der XML-Daten, die Sie unabhängig voneinander arbeiten können. Es wurde entwickelt, um eine Grenze um ein XML-Element zu erstellen. Dies ist nützlich, wenn Daten an eine andere Komponente für die Verarbeitung übergeben werden sollen und wie viele Ihrer Daten zu begrenzen, die die Komponente zugreifen kann sollen. Wenn Sie einen XML-Reader zurückgegeben durch Übergeben der <xref:System.Xml.XmlReader.ReadSubtree%2A> Methode, um eine andere Anwendung, die Anwendung kann nur auf dieses XML-Element, nicht das gesamte XML-Dokument zugreifen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Xml.XmlReader.ReadSubtree%2A>-Methode gezeigt.  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 Verwenden Sie die folgenden XML-Daten, um in den Beispielen in diesem Thema ausführen:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der XML-Reader wird nicht in einem Element positioniert, wenn diese Methode aufgerufen wird.

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToDescendant">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Verschiebt den <see cref="T:System.Xml.XmlReader" /> auf das nächste übereinstimmende Nachfolgerelement.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string -&gt; bool&#xA;override this.ReadToDescendant : string -&gt; bool" Usage="xmlReader.ReadToDescendant name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Elements, zu dem Sie wechseln möchten.</param>
        <summary>Verschiebt den <see cref="T:System.Xml.XmlReader" /> auf das nächste Nachfolgerelement mit dem angegebenen qualifizierten Namen.</summary>
        <returns><see langword="true" /> , wenn ein übereinstimmendes Nachfolgerelement gefunden wurde, andernfalls <see langword="false" />. Wenn kein übereinstimmendes untergeordnetes Element gefunden wurde, wird der <see cref="T:System.Xml.XmlReader" /> auf dem Endtag (<see cref="P:System.Xml.XmlReader.NodeType" /> ist <see langword="XmlNodeType.EndElement" />) des Elements positioniert.  
  
Wenn beim Aufruf von <see cref="T:System.Xml.XmlReader" /> der <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" /> nicht in einem Element positioniert wird, gibt diese Methode <see langword="false" /> zurück, und die Position des <see cref="T:System.Xml.XmlReader" /> wird nicht geändert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgende Beispiel analysiert den zweiten Book-Knoten.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 Im Beispiel wird die Datei `2books.xml`als Eingabe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentException">Der Parameter ist eine leere Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string * string -&gt; bool&#xA;override this.ReadToDescendant : string * string -&gt; bool" Usage="xmlReader.ReadToDescendant (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements, zu dem Sie wechseln möchten.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements, zu dem Sie wechseln möchten.</param>
        <summary>Verschiebt den <see cref="T:System.Xml.XmlReader" /> auf das nächste Nachfolgerelement mit dem angegebenen lokalen Namen und dem angegebenen Namespace-URI.</summary>
        <returns><see langword="true" /> , wenn ein übereinstimmendes Nachfolgerelement gefunden wurde, andernfalls <see langword="false" />. Wenn kein übereinstimmendes untergeordnetes Element gefunden wurde, wird der <see cref="T:System.Xml.XmlReader" /> auf dem Endtag (<see cref="P:System.Xml.XmlReader.NodeType" /> ist <see langword="XmlNodeType.EndElement" />) des Elements positioniert.  
  
Wenn beim Aufruf von <see cref="T:System.Xml.XmlReader" /> der <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" /> nicht in einem Element positioniert wird, gibt diese Methode <see langword="false" /> zurück, und die Position des <see cref="T:System.Xml.XmlReader" /> wird nicht geändert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentNullException">Beide Parameterwerte sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToFollowing">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Liest, bis das benannte Element gefunden wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string -&gt; bool&#xA;override this.ReadToFollowing : string -&gt; bool" Usage="xmlReader.ReadToFollowing name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des Elements.</param>
        <summary>Liest, bis ein Element mit dem angegebenen qualifizierten Namen gefunden wird.</summary>
        <returns><see langword="true" /> , wenn ein übereinstimmendes Element gefunden wird, andernfalls <see langword="false" />, und der <see cref="T:System.Xml.XmlReader" /> befindet sich in einem Dateiendezustand.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist funktionell gleichwertig Ausführen der `following::name` XPath-Ausdruck aus dem aktuellen Knoten. Es bietet eine schnelle Möglichkeit, ein benanntes Element im XML-Dokument zu ermitteln. Er verschiebt den Reader zum nächsten folgenden Element, die dem angegebenen Namen entspricht, und gibt `true` Wenn kein übereinstimmendes Element gefunden wird. Verwenden das folgende Beispiel, würde der Leser lesen mit der ersten Instanz des angegebenen Elements beim Weiterleiten lesen.  
  
```xml  
<!--"sample.xml"-->  
<?xml version="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 Diese Methode kann auf alle Typen von Knoten aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentException">Der Parameter ist eine leere Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string * string -&gt; bool&#xA;override this.ReadToFollowing : string * string -&gt; bool" Usage="xmlReader.ReadToFollowing (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des Elements.</param>
        <param name="namespaceURI">Der Namespace-URI des Elements.</param>
        <summary>Liest, bis ein Element mit dem angegebenen lokalen Namen und dem angegebenen Namespace-URI gefunden wird.</summary>
        <returns><see langword="true" /> , wenn ein übereinstimmendes Element gefunden wird, andernfalls <see langword="false" />, und der <see cref="T:System.Xml.XmlReader" /> befindet sich in einem Dateiendezustand.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist funktionell gleichwertig Ausführen der `following::name` XPath-Ausdruck aus dem aktuellen Knoten. Es bietet eine schnelle Möglichkeit, ein benanntes Element im XML-Dokument zu ermitteln. Er verschiebt den Reader zum nächsten folgenden Element, die dem angegebenen Namen entspricht, und gibt `true` Wenn kein übereinstimmendes Element gefunden wird.  
  
```xml  
<!--"sample.xml"-->  
<?xml version="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 Diese Methode kann auf alle Typen von Knoten aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentNullException">Beide Parameterwerte sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToNextSibling">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <summary>Verschiebt den <see langword="XmlReader" /> auf das nächste übereinstimmende nebengeordnete Element.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string -&gt; bool&#xA;override this.ReadToNextSibling : string -&gt; bool" Usage="xmlReader.ReadToNextSibling name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Der qualifizierte Name des nebengeordneten Elements, zu dem Sie wechseln möchten.</param>
        <summary>Verschiebt den <see langword="XmlReader" /> auf das nächste nebengeordnete Element mit dem angegebenen qualifizierten Namen.</summary>
        <returns><see langword="true" /> , wenn ein übereinstimmendes nebengeordnetes Element gefunden wurde, andernfalls <see langword="false" />. Wenn kein übereinstimmendes nebengeordnetes Element gefunden wurde, wird der <see langword="XmlReader" /> auf dem Endtag (<see cref="P:System.Xml.XmlReader.NodeType" /> ist <see langword="XmlNodeType.EndElement" />) des übergeordneten Elements positioniert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Rufen Sie nicht <xref:System.Xml.XmlReader.ReadToNextSibling%2A> bei der `XmlReader` ist einem Ausgangsstatus (<xref:System.Xml.XmlReader.ReadState%2A> ist <xref:System.Xml.ReadState.Initial>). Rufen Sie <xref:System.Xml.XmlReader.Read%2A> , fahren Sie fort, die `XmlReader` und rufen Sie dann die <xref:System.Xml.XmlReader.ReadToNextSibling%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel liest die ISBN-Attribut auf jedem Buchknoten.  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentException">Der Parameter ist eine leere Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string * string -&gt; bool&#xA;override this.ReadToNextSibling : string * string -&gt; bool" Usage="xmlReader.ReadToNextSibling (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">Der lokale Name des nebengeordneten Elements, zu dem Sie wechseln möchten.</param>
        <param name="namespaceURI">Der Namespace-URI des nebengeordneten Elements, zu dem Sie wechseln möchten.</param>
        <summary>Verschiebt den <see langword="XmlReader" /> auf das nächste nebengeordnete Element mit dem angegebenen lokalen Namen und dem angegebenen Namespace-URI.</summary>
        <returns><see langword="true" /> , wenn ein übereinstimmendes nebengeordnetes Element gefunden wurde, andernfalls <see langword="false" />. Wenn kein übereinstimmendes nebengeordnetes Element gefunden wurde, wird der <see langword="XmlReader" /> auf dem Endtag (<see cref="P:System.Xml.XmlReader.NodeType" /> ist <see langword="XmlNodeType.EndElement" />) des übergeordneten Elements positioniert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Rufen Sie nicht <xref:System.Xml.XmlReader.ReadToNextSibling%2A> bei der `XmlReader` ist einem Ausgangsstatus (<xref:System.Xml.XmlReader.ReadState%2A> ist <xref:System.Xml.ReadState.Initial>). Rufen Sie <xref:System.Xml.XmlReader.Read%2A> , fahren Sie fort, die `XmlReader` und rufen Sie dann die <xref:System.Xml.XmlReader.ReadToNextSibling%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentNullException">Beide Parameterwerte sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunk (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadValueChunk(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunk : char[] * int * int -&gt; int&#xA;override this.ReadValueChunk : char[] * int * int -&gt; int" Usage="xmlReader.ReadValueChunk (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Array von Zeichen, das als Puffer dient, in den der Textinhalt geschrieben wird. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, ab dem der <see cref="T:System.Xml.XmlReader" /> die Ergebnisse kopieren kann.</param>
        <param name="count">Die maximale Anzahl von Zeichen, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl der kopierten Zeichen zurück.</param>
        <summary>Liest umfangreiche Streams von Text, der in ein XML-Dokument eingebettet ist.</summary>
        <returns>Die Anzahl der in den Puffer gelesenen Zeichen. Der Wert 0 (null) wird zurückgegeben, wenn kein weiterer Textinhalt vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ermöglicht das Lesen von sehr umfangreiche Streams von Text in einem XML-Dokument Binärdatenstreams als Stream, d. h. eingebetteten einer kleineren Anzahl von Zeichen zu einem Zeitpunkt, anstatt eine einzelne Zeichenfolge für den gesamten Wert zuzuweisen. Diese Methode kann aufgerufen werden, auf einem beliebigen Knoten, die einen Wert aufweist (<xref:System.Xml.XmlReader.HasValue%2A> ist `true`), aber der tatsächliche streaming von den Knotenwert erfolgt nur, wenn für einen Text, Leerraum und signifikantem Leerraumknoten aufgerufen. Andere Knoten Type-Werte werden zwischengespeichert, einschließlich Attributen und CDATA-Knoten.  
  
 Diese Methode gibt nur den Inhalt des der <xref:System.Xml.XmlReader.Value%2A> Eigenschaft wird nicht verschoben, und die <xref:System.Xml.XmlReader>.  
  
 Diese Methode liest die angegebene Anzahl von Zeichen (`count`) von den Knotenwert in einen Zeichenpuffer (`buffer`) an einem angegebenen Offset (`index`) und gibt die Anzahl der Zeichen, die in den Puffer geschrieben. Gibt die `0` Wenn das Ende des Werts erreicht wurde. Es kann nicht neu gestartet werden, um den Wert wieder gelesen wird.  
  
 Zwischen den Aufrufen von <xref:System.Xml.XmlReader.ReadValueChunk%2A> der <xref:System.Xml.XmlReader> Eigenschaften sind keine Änderungen mit Ausnahme der <xref:System.Xml.XmlReader.Value%2A> Eigenschaft. Wenn die <xref:System.Xml.XmlReader.Value%2A> Eigenschaft erfolgt entweder ein Teil eines Werts zurückgeben (mit Zeichen, die noch nicht von zurückgegebenen <xref:System.Xml.XmlReader.ReadValueChunk%2A>) oder ein vollständiger Wert je nach Implementierung. Alle der <xref:System.Xml.XmlReader> -Implementierungen in der <xref:System.Xml> Zurückgeben des Namespaces ein Teil eines Werts für die <xref:System.Xml.XmlReader.Value%2A> eigenschaftenimplementierung.  
  
 Lesevorgänge Methode kann aufgerufen werden, zwischen den Aufrufen von <xref:System.Xml.XmlReader.ReadValueChunk%2A>. In diesem Fall die <xref:System.Xml.XmlReader> wechselt zur nächsten <xref:System.Xml.XmlNodeType> in den Stream und alle Zeichen, die noch nicht zurückgegeben werden übersprungen.  
  
 Möglicherweise liegt ein Fall beim <xref:System.Xml.XmlReader.ReadValueChunk%2A> zurückgegeben, die kleiner als die angeforderte Anzahl von Zeichen. Wenn mussten Sie einen long-Wert von 200 Zeichen mit einem Ersatzzeichenpaar an der Position 127 und 128 Zeichen, und Sie wird aufgerufen, z. B. <xref:System.Xml.XmlReader.ReadValueChunk%2A> mit einem Puffer 128 Zeichen würde der Methodenaufruf 127 Zeichen anstelle der angeforderten 128 zurück. Das Ersatzzeichenpaar zurückgegeben würden dann in den nächsten <xref:System.Xml.XmlReader.ReadValueChunk%2A> aufrufen. In diesem Fall <xref:System.Xml.XmlReader.ReadValueChunk%2A> hat nicht die angeforderte 128 Zeichen zurückgegeben, da dies zu einer unvollständigen Ersatzzeichenpaar am Ende des Puffers geführt hätte.  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Knoten verfügt über keinen Wert (<see cref="P:System.Xml.XmlReader.HasValue" /> ist <see langword="false" />).

- oder - 
Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Wert ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Index im Puffer oder Index + Anzahl übersteigen die Größe des zugeordneten Puffers.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Xml.XmlReader" />-Implementierung unterstützt diese Methode nicht.</exception>
        <exception cref="T:System.Xml.XmlException">Die XML-Daten sind nicht wohlgeformt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunkAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadValueChunkAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadValueChunkAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Das Array von Zeichen, das als Puffer dient, in den der Textinhalt geschrieben wird. Dieser Wert darf nicht <see langword="null" /> sein.</param>
        <param name="index">Der Offset im Puffer, ab dem der <see cref="T:System.Xml.XmlReader" /> die Ergebnisse kopieren kann.</param>
        <param name="count">Die maximale Anzahl von Zeichen, die in den Puffer kopiert werden sollen. Diese Methode gibt die tatsächliche Anzahl der kopierten Zeichen zurück.</param>
        <summary>Liest asynchron umfangreiche Streams von Text, der in ein XML-Dokument eingebettet ist.</summary>
        <returns>Die Anzahl der in den Puffer gelesenen Zeichen. Der Wert 0 (null) wird zurückgegeben, wenn kein weiterer Textinhalt vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.ReadValueChunk%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.
- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResolveEntity();" />
      <MemberSignature Language="F#" Value="abstract member ResolveEntity : unit -&gt; unit" Usage="xmlReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löst beim Überschreiben in einer abgeleiteten Klasse den Entitätsverweis für <see langword="EntityReference" />-Knoten auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Reader positioniert ist, auf eine `EntityReference` Knoten (`XmlNodeType.EntityReference`), wenn <xref:System.Xml.XmlReader.Read%2A> wird aufgerufen, nach dem Aufruf dieser Methode wird der Ersetzungstext der Entität analysiert wird. Wenn der Ersetzungstext der Entität abgeschlossen ist, eine `EndEntity` Knoten zurückgegeben, um den Gültigkeitsbereich des Entitätsverweises zu schließen.  
  
> [!NOTE]
>  Nachdem diese Methode wird aufgerufen, wenn die Entität Teil eines Attributwerts ist müssen Sie aufrufen <xref:System.Xml.XmlReader.ReadAttributeValue%2A> Schritt mit der Entität.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Reader ist nicht auf einem <see langword="EntityReference" />-Knoten positioniert. Diese Implementierung des Readers kann Entitäten nicht auflösen (<see cref="P:System.Xml.XmlReader.CanResolveEntity" /> gibt <see langword="false" /> zurück).

- oder -

Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="P:System.Xml.XmlReader.CanResolveEntity" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Schemainformationen ab, die dem aktuellen Knoten nach der Schemavalidierung zugewiesen wurden.</summary>
        <value>Ein <see cref="T:System.Xml.Schema.IXmlSchemaInfo" />-Objekt, das die Schemainformationen für den aktuellen Knoten enthält. Schemainformationen können auf Elemente, Attribute oder Textknoten mit einem <see cref="P:System.Xml.XmlReader.ValueType" /> festgelegt werden, der nicht NULL (typisierte Werte) ist.  
  
Wenn der aktuelle Knoten keinem der oben angegebenen Knotentypen angehört oder wenn die <see langword="XmlReader" />-Instanz keine Schemainformationen übermittelt, gibt diese Eigenschaft <see langword="null" /> zurück.  
  
Wenn diese Eigenschaft von einem <see cref="T:System.Xml.XmlTextReader" />-Objekt oder einem <see cref="T:System.Xml.XmlValidatingReader" />-Objekt aufgerufen wird, gibt diese Eigenschaft stets <see langword="null" /> zurück. Die <see langword="XmlReader" />-Implementierungen machen über die <see langword="SchemaInfo" />-Eigenschaft keine Schemainformationen verfügbar.  
  
 <block subset="none" type="note"><para>  
 Wenn Sie den Informationensatz für die Post-Schema-Validierung (PSVI) für ein Element abrufen müssen, positionieren Sie den Reader im Endtag des Elements und nicht im Starttag. Der PSVI wird über die <see langword="SchemaInfo" />-Eigenschaft eines Readers abgerufen. Der überprüfende Reader, der durch <see cref="Overload:System.Xml.XmlReader.Create" /> mit der auf <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> festgelegten <see cref="F:System.Xml.ValidationType.Schema" />-Eigenschaft erstellt wird, verfügt nur über den vollständigen PSVI für ein Element, wenn der Reader im Endtag eines Elements positioniert ist.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xml.Schema.IXmlSchemaInfo> Schnittstelle verfügbar macht, eine Teilmenge des Post Schema Überprüfung Infoset (PSVI) eines XML-Knotens zugeordnet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das zum Erstellen dieser <see cref="T:System.Xml.XmlReaderSettings" />-Instanz verwendete <see cref="T:System.Xml.XmlReader" />-Objekt ab.</summary>
        <value>Das zum Erstellen dieser Reader-Instanz verwendete <see cref="T:System.Xml.XmlReaderSettings" />-Objekt. Wenn dieser Reader nicht mit der <see cref="Overload:System.Xml.XmlReader.Create" />-Methode erstellt wurde, gibt diese Eigenschaft <see langword="null" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Die <xref:System.Xml.XmlReaderSettings> Objekt kann vertrauliche Informationen wie z. B. die Anmeldeinformationen des Benutzers enthalten. Anwendungen müssen achten, wenn dieses Objekt Zwischenspeichern oder an eine andere Komponente übergeben.  
  
 Die <xref:System.Xml.XmlReaderSettings> Klasse wird verwendet, um den Satz von Features zur Unterstützung der erstellte Reader-Instanz angeben. Die <xref:System.Xml.XmlReaderSettings> von dieser Eigenschaft zurückgegebene Objekt nicht geändert werden. Jeder Versuch, Ändern einzelner Einstellungen führt eine Ausnahme ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Skip();" />
      <MemberSignature Language="F#" Value="abstract member Skip : unit -&gt; unit&#xA;override this.Skip : unit -&gt; unit" Usage="xmlReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überspringt die untergeordneten Elemente des aktuellen Knotens.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden XML-Eingabe, wenn der Reader positioniert ist, auf die `<a>` Knoten oder eines seiner Attribute, Aufrufen von `Skip` positioniert den Reader auf den `<b>` Knoten.  
  
 Wenn der Reader bereits auf einem Endknoten positioniert ist (z. B. die `<x>` Knoten oder dem Textknoten `abc`), wird beim Aufruf `Skip` entspricht dem Aufruf <xref:System.Xml.XmlReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 Diese Methode überprüft für wohlgeformtes XML.  
  
 Wenn der Reader ist eine <xref:System.Xml.XmlValidatingReader>, diese Methode überprüft auch den Inhalt wurde übersprungen.  
  
 Die `XmlReader` -Implementierung bestimmt, ob die `Skip` Methode externe Entitäten erweitert. Die folgende Tabelle beschreibt, ob die externen Entitäten, für die verschiedenen Typen von erweitert werden `XmlReader` Objekte.  
  
|Typ des "XmlReader"|Externe Entitäten erweitert|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|Nein.|  
|<xref:System.Xml.XmlReader> von erstellte Instanz der <xref:System.Xml.XmlReader.Create%2A> -Methode, die Text-Daten gelesen wird.|Nein.|  
|<xref:System.Xml.XmlReader> von erstellte Instanz der <xref:System.Xml.XmlReader.Create%2A> -Methode, die binäre Daten liest.|Nicht zutreffend.|  
|Ein Schema überprüfen <xref:System.Xml.XmlReader> von erstellte Instanz der <xref:System.Xml.XmlReader.Create%2A> Methode.|Ja.|  
|<xref:System.Xml.XmlValidatingReader>|Ja.|  
|<xref:System.Xml.XmlReader> vom zurückgegebene Instanz einen <xref:System.Xml.XPath.XPathNavigator> Objekt.|Nicht zutreffend.|  
|<xref:System.Xml.XmlNodeReader>|Nein.|  
|<xref:System.Xml.XmlReader> Umschließt eine andere Instanz <xref:System.Xml.XmlReader> Instanz.|Hängt von der Implementierung der zugrunde liegenden <xref:System.Xml.XmlReader>. (Die `Skip` Methode für den zugrunde liegenden <xref:System.Xml.XmlReader> aufgerufen wird).|  
  
 Die asynchrone Version dieser Methode finden Sie unter <xref:System.Xml.XmlReader.SkipAsync%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel analysiert die XML-Datei auf dem zweiten Book-Knoten ab.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 Im Beispiel wird die Datei `2books.xml`als Eingabe.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SkipAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ SkipAsync();" />
      <MemberSignature Language="F#" Value="abstract member SkipAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.SkipAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlReader.SkipAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Überspringt die untergeordneten Elemente des aktuellen Knotens asynchron.</summary>
        <returns>Der aktuelle Knoten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist die asynchrone Version von <xref:System.Xml.XmlReader.Skip%2A>, mit der gleichen Funktionalität. Um diese Methode verwenden zu können, müssen Sie festlegen der <xref:System.Xml.XmlReaderSettings.Async%2A> flag `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.

- oder -

Eine asynchrone <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, ohne das <see cref="P:System.Xml.XmlReaderSettings.Async" />-Flag auf <see langword="true" /> festzulegen. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Legen Sie 'XmlReaderSettings.Async' auf 'true' fest, wenn Sie asynchrone Methoden verwenden möchten.“ ausgelöst.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">Asynchrone Programmierung mit Async und Await (C# und Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IDisposable.Dispose" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Xml.XmlReader>-Instanz in eine <xref:System.IDisposable>-Schnittstelle umgewandelt wird.

Dieser Member verhält sich möglicherweise anders in Verwendung ist ein [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) Projekt. Weitere Informationen finden Sie unter [API-Unterschiede in der portablen Klassenbibliothek](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/gg597392(v=vs.100)).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Textwert des aktuellen Knotens ab.</summary>
        <value>Der zurückgegebene Wert hängt vom <see cref="P:System.Xml.XmlReader.NodeType" /> des Knotens ab. In der folgenden Tabelle sind Knotentypen aufgeführt, die einen zurückzugebenden Wert haben. Alle anderen Knotentypen geben <see langword="String.Empty" /> zurück.  
  
 <list type="table"><listheader><term> Knotentyp 
 </term><description> Wert 
 </description></listheader><item><term><see langword="Attribute" /></term><description> Der Wert des Attributs.  
  
 </description></item><item><term><see langword="CDATA" /></term><description> Der Inhalt des CDATA-Abschnitts.  
  
 </description></item><item><term><see langword="Comment" /></term><description> Der Inhalt des Kommentars.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Die interne Teilmenge.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Der gesamte Inhalt mit Ausnahme des Ziels.  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> Der Leerraum zwischen Markups bei einem Modell für gemischten Inhalt.  
  
 </description></item><item><term><see langword="Text" /></term><description> Der Inhalt des Textknotens.  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> Der Leerraum zwischen Markups.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Der Inhalt der Deklaration.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchrone Version dieser Eigenschaft finden Sie unter den <xref:System.Xml.XmlReader.GetValueAsync%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel liest eine XML-Datei und zeigt jeden Knoten.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 Das Beispiel verwendet die `items.xml` Datei.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueType : Type" Usage="System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den CLR-Typ (Common Language Runtime) für den aktuellen Knoten ab.</summary>
        <value>Der CLR-Typ, der dem typisierten Wert des Knotens entspricht. Die Standardeinstellung ist <see langword="System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter [Typenunterstützung in den System.Xml-Klassen](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) eine Liste der standardzuordnungen.  
  
 Ein Element des Typs `xs:int` verfügt über eine `ValueType` von `System.Int32` standardmäßig. Allerdings die `ValueType` kann einer der gültigen Typen, die zugeordnet werden können `xs:int`, z. B. `System.Int16` oder `System.Double`.  
  
 Wenn ein Knoten nicht typisierten ist, oder wenn der Knoten ein Element, der gemischten Inhalt enthält ist, der Knotenwert zugeordnet ist die `System.String` Typ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <block subset="none" type="overrides"><para>Implementierungen müssen Bereitstellen einer <see langword="ValueType" /> für jeden Knoten, auch wenn nur die <see langword="System.String" /> Typ.</para></block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den aktuellen <see langword="xml:lang" />-Bereich ab.</summary>
        <value>Der aktuelle <see langword="xml:lang" />-Bereich.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft stellt die `xml:lang` Bereich, in dem sich der aktuelle Knoten befindet. Hier ist beispielsweise ein XML-Fragment mit `xml:lang` in das Stammelement auf Englisch (USA) festgelegt:  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 Wenn der Reader positioniert ist, auf die `name` Element können Sie diese Eigenschaft fest, dass es im Rahmen einer US-Englisch ist `xml:lang` Attribut.  
  
   
  
## Examples  
 Finden Sie unter <xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType> ein Beispiel für die Verwendung dieser Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlSpace" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den aktuellen <see langword="xml:space" />-Bereich ab.</summary>
        <value>Einer der <see cref="T:System.Xml.XmlSpace" />-Werte. Wenn kein <see langword="xml:space" />-Bereich vorhanden ist, wird für diese Eigenschaft standardmäßig <see langword="XmlSpace.None" /> festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Finden Sie unter <xref:System.Xml.XmlTextReader.XmlSpace%2A> (in der `XmlTextReader` Klasse) ein Beispiel für diese Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Eine <see cref="T:System.Xml.XmlReader" />-Methode wurde aufgerufen, bevor ein vorheriger asynchroner Vorgang abgeschlossen wurde. In diesem Fall wird <see cref="T:System.InvalidOperationException" /> mit der Meldung „Es wird bereits ein asynchroner Vorgang ausgeführt“ ausgelöst.</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlLang" />
      </Docs>
    </Member>
  </Members>
</Type>