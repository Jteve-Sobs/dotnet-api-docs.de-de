<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0786322f5a7b09fbe754ecb9b8253c5a5da85f58" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53227672" /></Metadata><TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Container dar, der mehrere Datenobjekte speichern kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> ist eine abstrakte Klasse, die zum Organisieren von Objekten in einer einzelnen Entität mit einem definierten physischen Format für Portabilität und einen effizienten Zugriff verwendet werden kann.  
  
 Eine ZIP-Datei ist der primäre physische Format für die <xref:System.IO.Packaging.Package>.  Andere <xref:System.IO.Packaging.Package> Implementierungen möglicherweise andere physikalische Formate wie z. B. ein XML-Dokument, einer Datenbank verwenden oder einen Webdienst.  
  
 Wie ein Dateisystem, Elemente, die in enthaltenen eine <xref:System.IO.Packaging.Package> wird in eine hierarchische Organisation von Ordnern und Dateien verwiesen.  
  
 Obwohl <xref:System.IO.Packaging.Package> selbst ist eine abstrakte Klasse, die <xref:System.IO.Packaging.ZipPackage> abgeleiteten Klasse wird als standardmäßig verwendet die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Ein <xref:System.IO.Packaging.PackagePart> ("Part") ist die abstrakte Klasse, die ein Objekt darstellt, die in gespeichert ist eine <xref:System.IO.Packaging.Package>.  
  
 Ein <xref:System.IO.Packaging.PackageRelationship> ("Beziehung") definiert eine Zuordnung zwischen einer Quelle <xref:System.IO.Packaging.Package> oder <xref:System.IO.Packaging.PackagePart> und einem Zielobjekt.  Ein <xref:System.IO.Packaging.PackageRelationship> kann eine von zwei Typen, von denen jede eine von zwei Formen kann:  
  
-   Eine Beziehung auf Paketebene (erstellt durch die <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> Methode) bezieht sich ein <xref:System.IO.Packaging.Package> entweder:  
  
    -   Ein Zielteil im Paket.  
  
    -   Eine Ressource außerhalb des Pakets.  
  
-   Eine Beziehung auf Teilebene (erstellt durch die <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> Methode) bezieht sich eine Quelle <xref:System.IO.Packaging.PackagePart> entweder:  
  
    -   Ein anderes Zielteil im Paket.  
  
    -   Eine Ressource außerhalb des Pakets.  
  
 Die Beziehung der Quelle <xref:System.IO.Packaging.Package> oder Quelle <xref:System.IO.Packaging.PackagePart> gilt der "Besitzer" der Beziehung.  Wenn das Quellobjekt gelöscht wird, werden alle Beziehungen, die das Quellobjekt im Besitz ebenfalls gelöscht.  Der Prozess des Erstellens oder Löschen einer Beziehung wird nicht physisch entweder am Quell- oder Zielspeicherort Objekte in keiner Weise geändert werden.  
  
 Ein <xref:System.IO.Packaging.PackageDigitalSignature> ("digitale Signatur") ist eine Zusammensetzung der Teile und Beziehungen, die eine digitale Signatur, die in enthaltenen darstellt eine <xref:System.IO.Packaging.Package>.  Die digitale Signatur vom Absender identifiziert und überprüft, dass die signierten Teile und Beziehungen in enthalten die <xref:System.IO.Packaging.Package> nicht geändert wurde.  
  
 Pakete, unterstützen auch Verwaltung digitaler Rechte (Digital Rights Management, DRM) dadurch Inhaltselemente in einen <xref:System.IO.Packaging.Package> mit bestimmten Zugriffsrechten auf autorisierte Benutzer verschlüsselt werden.  
  
 Basierend auf den <xref:System.IO.Packaging.Package> Architektur eine <xref:System.Windows.Xps.Packaging.XpsDocument> ist vorgesehen, die zum Speichern von Dokumenten, die basierend auf dem offenen [XML Paper Specification (XPS)](https://go.microsoft.com/fwlink/?LinkID=65761).  
  
 .NET Framework verwendet Pakete zum Speichern von Inhalten, Ressourcen und Beziehungen für Seiten und Dokumente mithilfe einer standardmäßigen ZIP-Datei wird standardmäßig an. Wie bei jedem der ZIP-Datei Ihrer Anwendung die <xref:System.IO.Packaging> Klassen zum Speichern und optional einem beliebigen Typ oder die Anzahl der Datendateien in einem einzelnen Container Zugriff zu schützen.  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die grundlegenden Schritte zum Erstellen einer <xref:System.IO.Packaging.Package>.  In diesem Beispiel wird ein Paket erstellt, damit ein Dokument sowie eine Grafik enthält, die als Teil des Dokuments angezeigt wird.  (Dies ist vergleichbar mit der Fall, in dem eine HTML-Datei hat, eine \<IMG > Tag, eine externe Bilddatei verweist.)  Zwei <xref:System.IO.Packaging.PackageRelationship> Elemente sind ebenfalls im Paket enthalten.  Die erste, eine "Beziehung auf"Paketebene, definiert den Dokumentteil als Stammelement des Pakets an.  Eine zweite Beziehung "auf" definiert die Zuordnung zwischen den Dokumentteil (die "Quelle" der Beziehung auf Teilebene) und die Verwendung des Teils Image (das "Target" der Beziehung auf Teilebene).  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Sie Packaging Conventions (OPC)-Spezifikation</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=74494">Digital Signing Framework der Open Packaging Conventions</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Packaging.Package" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Die Datei-E/A-Berechtigungen für das Paket.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Packaging.Package" />-Klasse, die einen angegebenen <see cref="T:System.IO.FileAccess" /> verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> ist ein geschützter Konstruktor, der die <xref:System.IO.Packaging.Package> abstrakte Basisklasse. Bei Aufruf in einer abgeleiteten Klasse die <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor initialisiert eine neue Instanz der abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="openFileAccess" /> ist ungültig.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Die Datei-E/A-Berechtigungen für das Paket.</param>
        <param name="streaming"><see langword="true" />, um das Paket für Streaming zu öffnen, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Packaging.Package" />-Klasse, die einen angegebenen <see cref="T:System.IO.FileAccess" /> und eine angegebene Streamingoption verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> ist ein geschützter Konstruktor, der die <xref:System.IO.Packaging.Package> abstrakten Basisklasse. Bei Aufruf in einer abgeleiteten Klasse die <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor initialisiert eine neue Instanz der abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="openFileAccess" /> ist ungültig.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert und schließt das Paket sowie alle zugrunde liegenden Partstreams.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die <xref:System.IO.Packaging.Package> Klasse <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> führen den gleichen Vorgang – es gibt keinen Grund Aufrufen <xref:System.IO.Packaging.Package.Dispose%2A> Aufrufen <xref:System.IO.Packaging.Package.Close%2A>, oder umgekehrt.  
  
 <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> intern rufen <xref:System.IO.Packaging.Package.Flush%2A>.  
  
> [!NOTE]
>  Die `using` Anweisung (sich von der `using` Namespacedirektive) ist die empfohlene Methode zum <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> eines Pakets.  [Schreiben ein Beispiel für Paket](https://go.microsoft.com/fwlink/?LinkID=160055) und [eine Paket-Beispiel zum Lesen](https://go.microsoft.com/fwlink/?LinkID=160034) zeigen, wie Sie schließen und Freigeben eines Pakets mithilfe der `using` Anweisung.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein neues Paketpart.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Initialisiert eine leere <xref:System.IO.Stream> für das neue Part.  Die <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Methode kann verwendet werden, um einen Verweis auf die Streaminstanz, die dem Teil zugeordnet zu erhalten.  
  
 Weitere Informationen zu paketteilen, finden Sie unter Abschnitt 1.1 der Open Packaging Conventions (OPC)-Spezifikation zum Download zur Verfügung, die unter <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.PackagePart> und Speichern von Daten klicken Sie dann den Teil.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> Intern ruft die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> Methode, um das Part erstellen auf der Grundlage der Formats in der abgeleiteten Klasse implementiert.</para></block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] des neuen Teils.</param>
        <param name="contentType">Der Inhaltstyp des Datenstreams.</param>
        <summary>Erstellt ein neues unkomprimiertes Part mit einem angegebenen URI und Inhaltstyp.</summary>
        <returns>Das neu erstellte Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Initialisiert eine leere <xref:System.IO.Stream> für das neue Part.  Die <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Methode kann verwendet werden, um einen Verweis auf die Streaminstanz, die dem Teil zugeordnet zu erhalten.  
  
 Das Webpart <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> ist <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>.  
  
 Weitere Informationen zu paketteilen, finden Sie unter Abschnitt 1.1 in der Open Packaging Conventions (OPC)-Spezifikation, die zum Download zur Verfügung, die unter <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.PackagePart> und Speichern von Daten klicken Sie dann den Teil.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> oder <paramref name="contentType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Im Paket ist bereits ein Part mit dem angegebenen <paramref name="partUri" /> vorhanden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt (es kann kein neues Part hinzugefügt werden).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> Intern ruft der abgeleiteten Klasse <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> Methode, um das Part erstellen auf der Grundlage der Formats in der abgeleiteten Klasse implementiert.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] des neuen Teils.</param>
        <param name="contentType">Der Inhaltstyp des Datenstreams.</param>
        <param name="compressionOption">Die Komprimierungsoption für den Datenstream, <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> oder <see cref="F:System.IO.Packaging.CompressionOption.Normal" />-Komprimierung.</param>
        <summary>Erstellt ein neues Part mit einem angegebenen URI, einem angegebenen Inhaltstyp und einer angegebenen Komprimierungsoption.</summary>
        <returns>Das neu erstellte Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für den standardmäßigen <xref:System.IO.Packaging.ZipPackage> abgeleitete Klasse sein, die <xref:System.IO.Packaging.Package.CreatePart%2A> -Methode unterstützt nur zwei `compressionOption` Werte <xref:System.IO.Packaging.CompressionOption.NotCompressed> oder <xref:System.IO.Packaging.CompressionOption.Normal> Komprimierung.  Andere <xref:System.IO.Packaging.CompressionOption> Werte <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, oder <xref:System.IO.Packaging.CompressionOption.SuperFast> verwenden <xref:System.IO.Packaging.CompressionOption.Normal> Komprimierung.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> erstellt ein leeres <xref:System.IO.Stream> für das neue Part.  Die <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Methode kann verwendet werden, um einen Verweis auf die Streaminstanz, die dem Teil zugeordnet zu erhalten.  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.PackagePart> und Speichern von Daten klicken Sie dann den Teil.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> oder <paramref name="contentType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Im Paket ist bereits ein Part mit dem angegebenen <paramref name="partUri" /> vorhanden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="compressionOption" />-Wert ist nicht zulässig.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt (es kann kein neues Part hinzugefügt werden).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> Intern ruft der abgeleiteten Klasse <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> Methode, um das Part erstellen auf der Grundlage der Formats in der abgeleiteten Klasse implementiert.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] für das erstellte Part.</param>
        <param name="contentType">Der Inhaltstyp des Datenstreams.</param>
        <param name="compressionOption">Die Komprimierungsoption für den Datenstream.</param>
        <summary>Erstellt beim Überschreiben in einer abgeleiteten Klasse ein neues Part im Paket.</summary>
        <returns>Das erstellte Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die abgeleitete <xref:System.IO.Packaging.Package.CreatePartCore%2A> Methode wird aufgerufen, indem die <xref:System.IO.Packaging.Package.CreatePart%2A> Methode, um ein Element zu erstellen, auf der Grundlage der Formats in der abgeleiteten Klasse implementiert.  
  
 Standardmäßig eine <xref:System.IO.Packaging.ZipPackage> Implementierung der abgeleiteten Klasse der abstrakten <xref:System.IO.Packaging.Package> Klasse bereitgestellt und verwendet.  In der Standardvorgang <xref:System.IO.Packaging.Package.CreatePart%2A> ruft intern <xref:System.IO.Packaging.Package.CreatePartCore%2A> von der <xref:System.IO.Packaging.ZipPackage> Klasse, um ein neues Teil in einer Zipdatei zu erstellen.  
  
 Für den standardmäßigen <xref:System.IO.Packaging.ZipPackage> abgeleitete Klasse sein, die <xref:System.IO.Packaging.Package.CreatePartCore%2A> -Methode unterstützt nur zwei `compressionOption` Werte <xref:System.IO.Packaging.CompressionOption.NotCompressed> oder <xref:System.IO.Packaging.CompressionOption.Normal> Komprimierung.  Andere <xref:System.IO.Packaging.CompressionOption> Werte <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, oder <xref:System.IO.Packaging.CompressionOption.SuperFast> verwenden <xref:System.IO.Packaging.CompressionOption.Normal> Komprimierung.  
  
 Weitere Informationen über die Paketmodell und die Paketteile finden Sie unter Kapitel 1 der Open Packaging Conventions (OPC)-Spezifikation als Download im <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die abgeleitete <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> Implementierung sollte keine Annahmen über die Reihenfolge oder Operationen, die <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> Methode, die ihn aufruft.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Beziehung auf Paketebene zu einem angegebenen Part.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen dem Paket und zugeordnete Zielpart oder Ressource.  Eine Beziehung auf Paketebene ist einer der zwei Arten möglich.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> an ein Ziel <xref:System.IO.Packaging.PackagePart> im Paket.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> auf eine Ressource außerhalb des Pakets.  
  
 In einer Beziehung auf Paketebene gilt das Paket "Owner" der Beziehung.  Wenn das Paket gelöscht wird, werden alle Beziehungen, die im Besitz des Pakets ebenfalls gelöscht.  Der Prozess des Erstellens oder Löschen der Beziehung wird nicht physisch das Zielteil oder die Ressource in keiner Weise geändert.  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Erstellung einer <xref:System.IO.Packaging.PackageRelationship> zwischen einem <xref:System.IO.Packaging.Package> und Stammteil Dokument.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] des Zielteils.</param>
        <param name="targetMode">Gibt an, ob das Zielpart<see cref="F:System.IO.Packaging.TargetMode.Internal" /> oder <see cref="F:System.IO.Packaging.TargetMode.External" /> für das Paket ist.</param>
        <param name="relationshipType">Ein URI, der die Rolle der Beziehung eindeutig definiert.</param>
        <summary>Erstellt eine Beziehung auf Paketebene zu einem Part mit einem angegebenen URI, einem angegebenen Zielmodus und einem angegebenen Beziehungstyp.</summary>
        <returns>Die Beziehung auf Paketebene zu dem angegebenen Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen dem Paket und zugeordnete Zielpart oder Ressource.  Eine Beziehung auf Paketebene ist einer der zwei Arten möglich.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> zu einem Zielpart im Paket.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> auf eine Ressource außerhalb des Pakets.  
  
 In einer Beziehung auf Paketebene gilt das Paket "Owner" der Beziehung.  Wenn das Paket gelöscht wird, werden alle Beziehungen, die im Besitz des Pakets ebenfalls gelöscht.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> wird nicht physisch das Zielteil oder die Ressource in keiner Weise geändert.  
  
 Das Ziel einer Beziehung darf nicht auf eine andere Beziehung sein.  
  
 Wenn `targetMode` angegeben ist, als <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` muss ein relativer URI, der gemäß gebildet wird die [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI): Generic Syntax-Spezifikation.  Der interne relative URI kann ein absoluter Pfad sein, die mit einem Schrägstrich ("/"), z. B. beginnt "/" Page1.xaml "" oder "/ /images/picture4.jpg", oder ein relativer Pfad wie z. B. "... / imagespicture1.jpg ", der für den Paketstamm ("/ ") als Basis-URI auflöst.  
  
 Wenn `targetMode` angegeben ist, als <xref:System.IO.Packaging.TargetMode.External>, `targetUri` kann entweder ein absoluter oder relativer URI angegeben wird, gemäß der [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI): Generic Syntax-Spezifikation. `http://www.microsoft.com/page2.xml` ist ein Beispiel für einen absoluten URI, der auf einem externen Zielressource "page2.xml" verweist.  "images/picture1.jpg" ist ein Beispiel für einen relativen URI, der auch ein externes Ziel Resource "1.jpg" aber auflöst anhand des URI für das Paket selbst verweist.  
  
 `relationshipType` muss eine [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] sein, der gemäß der [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI): Generic Syntax-Spezifikation.  Die folgende Tabelle zeigt die Paketebene `relationshipType` URIs, die die Open Packaging Conventions (OPC)-Spezifikation definiert.  
  
|Beziehung auf Paketebene|Beziehungstyp URI|  
|---------------------------------|---------------------------|  
|Haupteigenschaften|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Digitale Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Zertifikat für digitale Signaturen|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Ursprung der digitalen Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Miniaturansicht|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Weitere Informationen über das Packen und paketbeziehungen finden Sie im Abschnitt 1.3 der Open Packaging Conventions (OPC)-Spezifikation zum Download zur Verfügung, die am <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht, wie Sie mit <xref:System.IO.Packaging.Package.CreateRelationship%2A> zum Erstellen einer <xref:System.IO.Packaging.PackageRelationship> zwischen einem <xref:System.IO.Packaging.Package> und Stammteil Dokument.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> oder <paramref name="relationshipType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="targetUri" />-Part ist eine <see cref="T:System.IO.Packaging.PackageRelationship" />, oder <paramref name="targetMode" /> ist <see cref="F:System.IO.Packaging.TargetMode.Internal" />, und <paramref name="targetUri" /> ist ein absoluter URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="targetMode" /> ist ungültig.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] des Zielteils.</param>
        <param name="targetMode">Gibt an, ob das Zielpart<see cref="F:System.IO.Packaging.TargetMode.Internal" /> oder <see cref="F:System.IO.Packaging.TargetMode.External" /> für das Paket ist.</param>
        <param name="relationshipType">Ein URI, der die Rolle der Beziehung eindeutig definiert.</param>
        <param name="id">Ein eindeutiger XML-Bezeichner.</param>
        <summary>Erstellt eine Beziehung auf Paketebene zu einem Part mit einem angegebenen URI, einem angegebenen Zielmodus, einem angegebenen Beziehungstyp und einer angegebenen [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>Die Beziehung auf Paketebene zu dem angegebenen Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen dem Paket und zugeordnete Zielpart oder Ressource.  Eine Beziehung auf Paketebene ist einer der zwei Arten möglich.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> zu einem Zielpart im Paket.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> auf eine Ressource außerhalb des Pakets.  
  
 In einer Beziehung auf Paketebene gilt das Paket "Owner" der Beziehung.  Wenn das Paket gelöscht wird, werden alle Beziehungen, die im Besitz des Pakets ebenfalls gelöscht.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> wird nicht physisch das Zielteil oder die Ressource in keiner Weise geändert.  
  
 Das Ziel einer Beziehung darf nicht auf eine andere Beziehung sein.  
  
 `id` Ein gültiger XML-Bezeichner muss sein.  Die `id` Typ xsd: ID lautet und muss die Benennungskonventionen, die in der XML Schema Part 2 vorgeschrieben: Datentypen-Spezifikation (finden Sie unter [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Wenn `id` angegeben ist, als `null` eine eindeutige ID automatisch generiert werden.  Ein `id` angegeben werden, indem Sie eine leere Zeichenfolge ist ungültig.  
  
 Wenn `targetMode` angegeben ist, als <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` muss ein relativer URI, der gemäß gebildet wird die [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI): Generic Syntax-Spezifikation.  Der interne relative URI kann ein absoluter Pfad sein, die mit einem Schrägstrich ("/"), z. B. beginnt "/" Page1.xaml "" oder "/ /images/picture4.jpg", oder ein relativer Pfad wie z. B. "... / imagespicture1.jpg ", der für den Paketstamm ("/ ") als Basis-URI auflöst.  
  
 Wenn `targetMode` angegeben ist, als <xref:System.IO.Packaging.TargetMode.External>, `targetUri` kann entweder ein absoluter oder relativer URI angegeben wird, gemäß der [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI): Generic Syntax-Spezifikation. `http://www.microsoft.com/page2.xml` ist ein Beispiel für einen absoluten URI, der auf einem externen Zielressource "page2.xml" verweist.  "images/picture1.jpg" ist ein Beispiel für einen relativen URI, der auch ein externes Ziel Resource "1.jpg" aber auflöst anhand des URI für das Paket selbst verweist.  
  
 `relationshipType` muss ein URI, der gemäß der [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI): Generic Syntax-Spezifikation.  Die folgende Tabelle zeigt die Paketebene `relationshipType` URIs, die die Open Packaging Conventions (OPC)-Spezifikation definiert.  
  
|Beziehung auf Paketebene|Beziehungstyp URI|  
|---------------------------------|---------------------------|  
|Haupteigenschaften|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Digitale Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Zertifikat für digitale Signaturen|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Ursprung der digitalen Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Miniaturansicht|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Weitere Informationen über das Packen und paketbeziehungen finden Sie im Abschnitt 1.3 der Open Packaging Conventions (OPC)-Spezifikation zum Download zur Verfügung, die am <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht, wie Sie mit <xref:System.IO.Packaging.Package.CreateRelationship%2A> zum Erstellen einer <xref:System.IO.Packaging.PackageRelationship> zwischen einem <xref:System.IO.Packaging.Package> und Stammteil Dokument.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> oder <paramref name="relationshipType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="targetUri" />-Part ist eine <see cref="T:System.IO.Packaging.PackageRelationship" />, oder <paramref name="targetMode" /> ist <see cref="F:System.IO.Packaging.TargetMode.Internal" />, und <paramref name="targetUri" /> ist ein absoluter URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="targetMode" /> ist ungültig.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> ist kein gültiger XML-Bezeichner, oder im Paket ist bereits ein Part mit der angegebenen <paramref name="id" /> vorhanden.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] des zu löschenden Parts.</param>
        <summary>Löscht ein Part mit einem angegebenen URI aus dem Paket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` muss ein relativer URI, der einen absoluten Pfad besteht, der mit einem Schrägstrich ("/") beginnt.  Der absolute Pfad ist relativ zum Stammverzeichnis Pakets und wird gebildet, gemäß der [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI): Generic Syntax-Spezifikation.  "/" Page1.xaml "" und "/ /images/picture4.jpg" finden Sie Beispiele für gültige Teil-URIs.  
  
 Es wird keine Ausnahme ausgelöst, wenn ein Part mit dem angegebenen `partUri` ist nicht im Paket.  (Sie können die <xref:System.IO.Packaging.Package.PartExists%2A> Methode, um zu bestimmen, ob ein Part mit einem angegebenen `partUri` ist im Paket.)  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> Intern ruft der abgeleiteten Klasse <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> Methode, um das Webpart tatsächlich löschen auf der Grundlage der Formats in der abgeleiteten Klasse implementiert.</para></block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der <see cref="P:System.IO.Packaging.PackagePart.Uri" /> des zu löschenden <see cref="T:System.IO.Packaging.PackagePart" />.</param>
        <summary>Löscht beim Überschreiben in einer abgeleiteten Klasse ein Part mit einem angegebenen URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig eine <xref:System.IO.Packaging.ZipPackage> Implementierung der abgeleiteten Klasse der abstrakten <xref:System.IO.Packaging.Package> Klasse bereitgestellt und verwendet.  In der Standardvorgang <xref:System.IO.Packaging.Package.DeletePart%2A> ruft intern <xref:System.IO.Packaging.Package.DeletePartCore%2A> von der <xref:System.IO.Packaging.ZipPackage> -Klasse, den tatsächlichen Löschvorgang basierend auf dem physischen Format in der abgeleiteten Klasse implementiert.  
  
 Weitere Informationen über die Paketmodell und die Paketteile finden Sie unter Kapitel 1 der Open Packaging Conventions (OPC)-Spezifikation als Download im <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> Implementierung wird aufgerufen, indem die <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> Methode für das angegebene Part basierend auf das physische Format in der abgeleiteten Klasse implementiert.  
  
Die abgeleitete <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> Implementierung sollte keine Annahmen über die Reihenfolge oder Operationen, die <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> Methode, die ihn aufruft.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Der <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> des zu löschenden <see cref="T:System.IO.Packaging.PackageRelationship" />.</param>
        <summary>Löscht eine Beziehung auf Paketebene.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen dem Paket und zugeordnete Zielpart oder Ressource.  Eine Beziehung auf Paketebene ist einer der zwei Arten möglich.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> zu einem Zielpart im Paket.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> auf eine Ressource außerhalb des Pakets.  
  
 In einer Beziehung auf Paketebene gilt das Paket "Owner" der Beziehung.  Wenn das Paket gelöscht wird, werden alle Beziehungen, die im Besitz des Pakets ebenfalls gelöscht.  
  
 Es wird keine Ausnahme ausgelöst, wenn eine Beziehung mit dem angegebenen `id` ist nicht im Paket.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> das Zielpart in keiner Weise werden nicht physisch geändert werden.  
  
 Weitere Informationen zu paketbeziehungen finden Sie im Abschnitt 1.3 der Open Packaging Conventions (OPC)-Spezifikation zum Download zur Verfügung, die am <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> ist kein gültiger XML-Bezeichner.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Leert und speichert den Inhalt von allen Parts und Beziehungen, schließt das Paket und gibt alle Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um sicherzustellen, dass alle Änderungen ordnungsgemäß gespeichert wurden, <xref:System.IO.Packaging.Package.Dispose%2A> auch schließt, leert und schließt alle Teile und Beziehungen, die im Paket enthalten sind.  
  
 Für die <xref:System.IO.Packaging.Package> -Klasse, <xref:System.IO.Packaging.Package.Dispose%2A> und <xref:System.IO.Packaging.Package.Close%2A> führen den gleichen Vorgang – es gibt keinen Grund Aufrufen <xref:System.IO.Packaging.Package.Dispose%2A> Aufrufen <xref:System.IO.Packaging.Package.Close%2A>, oder umgekehrt.  
  
 <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> intern rufen <xref:System.IO.Packaging.Package.Flush%2A>.  
  
 Abgeleitete Klassen, die zuordnen und Verwalten von Ressourcen ohne Speicher, sollte diese Methode zum Freigeben von Ressourcen überschreiben bei <xref:System.IO.Packaging.Package.Dispose%2A> aufgerufen wird. Außerkraftsetzungen von abgeleiteten Klassen aufgerufen werden soll <xref:System.IO.Packaging.Package.Flush%2A> und die Basisklasse <xref:System.IO.Packaging.Package.Dispose%2A> Methode, um sicherzustellen, dass diese Basisklasse der Cleanup wird immer ausgeführt.  
  
> [!NOTE]
>  Die `using` Anweisung (sich von der `using` Namespacedirektive) ist die empfohlene Methode zum <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> eines Pakets. [Schreiben ein Beispiel für Paket](https://go.microsoft.com/fwlink/?LinkID=160055) wird gezeigt, wie schließen und Freigeben eines Pakets mithilfe der `using` Anweisung.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Dateizugriffseinstellung für das Paket ab.</summary>
        <value>Einer der <see cref="T:System.IO.FileAccess" />-Werte: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> oder <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaft <xref:System.IO.Packaging.Package.FileOpenAccess%2A> hat keinen Standardwert.  Der Dateizugriff, die Einstellung wird angegeben, der <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor aufrufen, wenn Sie ein neues Paket erstellen oder in der <xref:System.IO.Packaging.Package.Open%2A> aufgerufen werden, wenn Sie ein vorhandenes Paket öffnen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert die Inhalte von allen Parts und Beziehungen, die im Paket enthalten sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> Intern ruft der abgeleiteten Klasse <xref:System.IO.Packaging.Package.FlushCore%2A> Implementierung die formatspezifischen Leerung ausführen.  Der abgeleiteten Klasse <xref:System.IO.Packaging.Package.FlushCore%2A> Methode ist verantwortlich für das Speichern von tatsächlich des Teil- und Inhalts für die Implementierung von bestimmten physischen abgeleiteten Klasse.  
  
 Standardmäßig eine <xref:System.IO.Packaging.ZipPackage> abgeleiteten Implementierung der abstrakten <xref:System.IO.Packaging.Package> Basisklasse bereitgestellt und verwendet. In der Standardvorgang <xref:System.IO.Packaging.Package.Flush%2A> ruft intern <xref:System.IO.Packaging.Package.FlushCore%2A> um Teile und Beziehungen in einem ZIP-Datei-Paket zu speichern.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> wird aufgerufen, automatisch von der <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> Methoden.  Wenn <xref:System.IO.Packaging.Package.Close%2A> oder <xref:System.IO.Packaging.Package.Dispose%2A> wird aufgerufen, Sie müssen keine Aufrufen <xref:System.IO.Packaging.Package.Flush%2A> getrennt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt und kann nicht geändert werden.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> Intern ruft der abgeleiteten Klasse <see cref="M:System.IO.Packaging.Package.FlushCore" /> Methode auf, um das Webpart leeren basierend auf das physische Format in der abgeleiteten Klasse implementiert.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert beim Überschreiben in einer abgeleiteten Klasse die Inhalte aller Parts und Beziehungen im Speicher der abgeleiteten Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> wird aufgerufen, indem die <xref:System.IO.Packaging.Package.Flush%2A> Methode, um die Leerung ausführen auf der Grundlage der Formats in der abgeleiteten Klasse implementiert.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die abgeleitete <see cref="M:System.IO.Packaging.Package.FlushCore" /> Implementierung sollten keine Annahmen über die Reihenfolge oder Operationen, die <see cref="M:System.IO.Packaging.Package.Flush" /> Methode, die ihn aufruft.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] des zurückzugebenden Parts.</param>
        <summary>Gibt das Part mit einem angegebenen URI zurück.</summary>
        <returns>Das Part mit dem angegebenen <paramref name="partUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn ein Part mit dem angegebenen `partUri` ist nicht vorhanden.  
  
 Die <xref:System.IO.Packaging.Package.PartExists%2A> Methode kann verwendet werden, um zu bestimmen, ob `partUri` verweist auf ein vorhandenes Teil.  
  
 Standardmäßig eine <xref:System.IO.Packaging.ZipPackage> abgeleiteten Implementierung der abstrakten <xref:System.IO.Packaging.Package> Basisklasse bereitgestellt und verwendet.  In der Standardvorgang <xref:System.IO.Packaging.Package.GetPart%2A> ruft intern <xref:System.IO.Packaging.Package.GetPartCore%2A> von der <xref:System.IO.Packaging.ZipPackage> Klasse, um eine angeforderte Part aus einer ZIP-Datei zurückzugeben.  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie suchen, abrufen und lesen die Teile, die in einem Paket enthalten sind.  Das vollständige Beispiel finden Sie unter [lesen eine-Paketbeispiel](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Ein Part mit dem angegebenen <paramref name="partUri" /> ist nicht im Paket enthalten.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> Intern ruft die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> Methode auf, um das Webpart leeren basierend auf das physische Format in der abgeleiteten Klasse implementiert.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] des abzurufenden Parts.</param>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse das von einem angegebenen URI adressierte Part zurück.</summary>
        <returns>Das angeforderte Part oder <see langword="null" />, wenn kein Part mit dem angegebenen <paramref name="partUri" /> im Paket vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig eine <xref:System.IO.Packaging.ZipPackage> abgeleiteten Implementierung der abstrakten <xref:System.IO.Packaging.Package> Klasse bereitgestellt und verwendet.  In der Standardvorgang <xref:System.IO.Packaging.Package.GetPart%2A> ruft intern <xref:System.IO.Packaging.Package.GetPartCore%2A> von der <xref:System.IO.Packaging.ZipPackage> Klasse, um ein Part aus einer ZIP-Datei abzurufen.  
  
 Weitere Informationen über die Paketmodell und die Paketteile finden Sie unter Kapitel 1 der Open Packaging Conventions (OPC)-Spezifikation als Download im <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> Implementierung wird aufgerufen, indem die <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> Methode, um Zugriff auf und das angegebene Part zurück auf der Grundlage der Formats in der abgeleiteten Klasse implementiert.  
  
Die abgeleitete <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> Implementierung sollte keine Annahmen über die Reihenfolge oder Operationen, die <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> Methode, die ihn aufruft.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Auflistung aller Parts im Paket zurück.</summary>
        <returns>Eine Auflistung aller <see cref="T:System.IO.Packaging.PackagePart" />-Elemente, die im Paket enthalten sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> Gibt eine Auflistung aller Parts, die enthalten sind, im Paket, einschließlich <xref:System.IO.Packaging.PackageRelationship> teilen.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> gibt nie `null`, aber die zurückgegebene Auflistung enthält NULL Elemente, wenn das Paket keine Teile enthält.  
  
 Standardmäßig eine <xref:System.IO.Packaging.ZipPackage> abgeleiteten Implementierung der abstrakten <xref:System.IO.Packaging.Package> Basisklasse bereitgestellt und verwendet.  In der Standardvorgang <xref:System.IO.Packaging.Package.GetParts%2A> Aufrufe der <xref:System.IO.Packaging.Package.GetPartsCore%2A> Methode der <xref:System.IO.Packaging.ZipPackage> Klasse, um die Parts aus einer ZIP-Datei zurückzugeben.  
  
 Weitere Informationen zu Paketen und Paketteile finden Sie im Abschnitt 1.1 der Open Packaging Conventions (OPC)-Spezifikation zum Download zur Verfügung, die am <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.IO.Packaging.Package.GetParts%2A> Methode, um eine Auflistung der Teile zu erhalten, die in enthaltenen eine <xref:System.IO.Packaging.Package>.  Der Quellcode des vollständigen Programms finden Sie unter [Erstellen eines Pakets mit einer digitalen Signatur](https://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> Intern ruft die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> Methode auf, um das Webpart leeren basierend auf das physische Format in der abgeleiteten Klasse implementiert.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse ein Array aller Parts im Paket zurück.</summary>
        <returns>Ein Array aller Parts, die im Paket enthalten sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die abgeleitete Klasse <xref:System.IO.Packaging.Package.GetPartsCore%2A> Implementierung wird aufgerufen, indem die <xref:System.IO.Packaging.Package.GetParts%2A> Methode, um Zugriff auf und das Array der Teile zurück auf der Grundlage der Formats in der abgeleiteten Klasse implementiert.  
  
 Standardmäßig eine <xref:System.IO.Packaging.ZipPackage> abgeleiteten Implementierung der abstrakten <xref:System.IO.Packaging.Package> Klasse bereitgestellt und verwendet.  In der Standardvorgang <xref:System.IO.Packaging.Package.GetParts%2A> ruft intern <xref:System.IO.Packaging.Package.GetPartCore%2A> von der <xref:System.IO.Packaging.ZipPackage> Klasse, um die Parts aus einer ZIP-Datei abzurufen.  
  
 Weitere Informationen über die Paketmodell und die Paketteile finden Sie unter Kapitel 1 der Open Packaging Conventions (OPC)-Spezifikation als Download im <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die abgeleitete <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> Implementierung sollte keine Annahmen über die Reihenfolge oder Operationen, die <see cref="M:System.IO.Packaging.Package.GetParts" /> Methode, die ihn aufruft.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> der zurückzugebenden Beziehung.</param>
        <summary>Gibt die Beziehung auf Paketebene zu einem angegebenen Bezeichner zurück.</summary>
        <returns>Die Beziehung auf Paketebene mit der angegebenen <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Ein gültiger XML-Bezeichner muss sein. Die `id` Typ xsd: ID und müssen die Benennungskonventionen vorgeschrieben befolgen die [Abschnitt 3.3.8 von der XML Schema Part 2: Datentypen-Spezifikation](https://www.w3.org/TR/xmlschema-2/#ID).  
  
 Weitere Informationen über das Packen und paketbeziehungen finden Sie im Abschnitt 1.3 der Open Packaging Conventions (OPC)-Spezifikation zum Download zur Verfügung, die am <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> ist kein gültiger XML-Bezeichner.</exception>
        <exception cref="T:System.InvalidOperationException">Das Paket enthält keine Beziehung mit der angegebenen <paramref name="id" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Auflistung aller Beziehungen auf Paketebene zurück.</summary>
        <returns>Eine Auflistung aller Beziehungen auf Paketebene, die im Paket enthalten werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> gibt nie `null`jedoch die zurückgegebene Auflistung NULL Elemente enthalten kann, wenn das Paket keine Beziehungen auf Paketebene enthält.  
  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen dem Paket und zugeordnete Zielpart oder Ressource.  Eine Beziehung auf Paketebene ist einer der zwei Arten möglich.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> zu einem Zielpart im Paket.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> auf eine Ressource außerhalb des Pakets.  
  
 In einer Beziehung auf Paketebene gilt das Paket "Owner" der Beziehung.  Wenn das Paket gelöscht wird, werden alle Beziehungen, die im Besitz des Pakets ebenfalls gelöscht.  Der Prozess des Erstellens oder Löschen der Beziehung wird nicht physisch das Zielteil oder die Ressource in keiner Weise geändert.  
  
 Weitere Informationen über das Packen und paketbeziehungen finden Sie im Abschnitt 1.3 der Open Packaging Conventions (OPC)-Spezifikation zum Download zur Verfügung, die am <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">Der <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />, der verglichen und in der Auflistung zurückgegeben werden soll.</param>
        <summary>Gibt eine Auflistung aller Beziehungen auf Paketebene zurück, die mit einem angegebenen <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> übereinstimmen.</summary>
        <returns>Eine Auflistung der Beziehungen auf Paketebene, die mit dem angegebenen <paramref name="relationshipType" /> übereinstimmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> gibt nie `null`jedoch die zurückgegebene Auflistung NULL Elemente enthalten kann, wenn keine auf Paketebene Beziehungen, die mit der angegebenen Zeichenfolge `relationshipType`.  
  
 Die folgende Tabelle zeigt die Paketebene `relationshipType` URIs, die die Open Packaging Conventions (OPC)-Spezifikation definiert.  
  
|Beziehung auf Paketebene|Beziehungstyp URI|  
|---------------------------------|---------------------------|  
|Haupteigenschaften|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Digitale Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Zertifikat für digitale Signaturen|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Ursprung der digitalen Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Miniaturansicht|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die Beziehungen abrufen, die für das Paket definiert wurden.  Das vollständige Beispiel finden Sie unter [lesen eine-Paketbeispiel](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relationshipType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein Paket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.Package> , enthält, die <xref:System.IO.Packaging.PackageRelationship> und <xref:System.IO.Packaging.PackagePart> zusammen mit der gespeicherten Daten.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der E/A-Stream, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet ein Paket in einem angegebenen E/A-Stream.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Für das zu öffnende Paket ist eine Lese- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist lesegeschützt. Oder für das zu öffnende Paket ist eine Schreib- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <summary>Öffnet ein Paket mit einem angegebenen Pfad und Dateinamen.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Dies <xref:System.IO.Packaging.Package.Open%2A> Methode öffnet das Paket mit dem Default-Attribute <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, und <xref:System.IO.FileShare.None> (zur Angabe der verschiedenen Attribute verwenden Sie eine der anderen Überladungen Open-Methode).  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.Package> , enthält, die <xref:System.IO.Packaging.PackageRelationship> und <xref:System.IO.Packaging.PackagePart> zusammen mit der gespeicherten Daten.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">Der E/A-Stream, in dem das Paket geöffnet werden soll.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet ein Paket mit einem angegebenen E/A-Stream und Dateimodus.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="packageMode" />-Wert ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Für das zu öffnende Paket ist eine Lese- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist lesegeschützt. Oder für das zu öffnende Paket ist eine Schreib- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet mithilfe einer angegebenen Dateimethode ein Paket in einem angegebenen Pfad.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Dies <xref:System.IO.Packaging.Package.Open%2A> Methode öffnet das Paket mit dem Default-Attribute <xref:System.IO.FileAccess.ReadWrite> und <xref:System.IO.FileShare.None> (zur Angabe der verschiedenen Attribute verwenden Sie eine der anderen Überladungen Open-Methode).  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.Package> , enthält, die <xref:System.IO.Packaging.PackageRelationship> und <xref:System.IO.Packaging.PackagePart> zusammen mit der gespeicherten Daten.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">Der E/A-Stream, in dem das Paket geöffnet werden soll.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <param name="packageAccess">Der Dateizugriff, mit dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet ein Paket mit einem angegebenen E/A-Stream, einem angegebenen Dateimodus und einer angegebenen Dateizugriffseinstellung.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" /> oder <paramref name="packageAccess" /> ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Für das zu öffnende Paket ist eine Lese- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist lesegeschützt. Oder für das zu öffnende Paket ist eine Schreib- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <param name="packageAccess">Der Dateizugriff, mit dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet mit einem angegebenen Dateimodus und einer angegebenen Dateizugriffseinstellung ein Paket in einem angegebenen Pfad.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Dies <xref:System.IO.Packaging.Package.Open%2A> Methode wird das Paket geöffnet, mit dem Standardwert <xref:System.IO.FileShare.None> Attribut (an ein anderes Attribut verwendet die <xref:System.IO.Packaging.Package.Open%2A> methodenüberladung).  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Öffnen und Lesen einer <xref:System.IO.Packaging.Package> , enthält <xref:System.IO.Packaging.PackageRelationship> und <xref:System.IO.Packaging.PackagePart> zusammen mit der gespeicherten Daten.  Das vollständige Beispiel finden Sie unter [lesen eine-Paketbeispiel](https://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" /> oder <paramref name="packageAccess" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <param name="packageAccess">Der Dateizugriff, mit dem das Paket geöffnet werden soll.</param>
        <param name="packageShare">Der Dateifreigabemodus, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet mit einem angegebenen Dateimodus, einer angegebenen Dateizugriffseinstellung und einer angegebenen Dateifreigabeeinstellung ein Paket in einem angegebenen Pfad.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.Package> , enthält, die <xref:System.IO.Packaging.PackageRelationship> und <xref:System.IO.Packaging.PackagePart> zusammen mit der gespeicherten Daten.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" />, <paramref name="packageAccess" /> oder <paramref name="packageShare" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Haupteigenschaften des Pakets ab.</summary>
        <value>Die Haupteigenschaften des Pakets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu den Eigenschaften der Core-Pakets, finden Sie unter Abschnitt 3.1 in der Open Packaging Conventions (OPC)-Spezifikation, die zum Download zur Verfügung, die unter <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der zu überprüfende <see cref="T:System.Uri" /> des Parts.</param>
        <summary>Gibt an, ob ein Part mit einem angegebenen URI im Paket vorhanden ist.</summary>
        <returns><see langword="true" />, wenn ein Part mit dem angegebenen <paramref name="partUri" /> im Paket enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `partUri` sollten beginnen mit einem Schrägstrich "/" und ein absoluter URI aus dem Stammverzeichnis des Pakets.  
  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt (Informationen können nicht gelesen werden).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die zu überprüfende <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> der Beziehung.</param>
        <summary>Gibt an, ob eine Beziehung auf Paketebene mit einer angegebenen ID im Paket enthalten ist.</summary>
        <returns><see langword="true" />, wenn eine Beziehung auf Paketebene mit der angegebenen <paramref name="id" /> im Paket vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie in der Open Packaging Conventions (OPC)-Spezifikation herunterladen: <https://go.microsoft.com/fwlink/?LinkID=71255>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> ist kein gültiger XML-Bezeichner.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dieser Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die Anwendungsverwendung vorgesehen.  Verwenden Sie stattdessen die typsichere <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />-Methode.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>