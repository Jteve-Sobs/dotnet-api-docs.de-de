<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7cb776e24756e60f4b8099bdd33ffb542983fbc1" /><Meta Name="ms.sourcegitcommit" Value="0084afad1b3b1cb2c8ad2c142ae3597d08bad4a7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/31/2019" /><Meta Name="ms.locfileid" Value="73388384" /></Metadata><TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type Package = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Container dar, der mehrere Datenobjekte speichern kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> ist eine abstrakte Klasse, die zum Organisieren von Objekten in einer einzelnen Entität eines definierten physischen Formats verwendet werden kann, um Portabilität und effizienten Zugriff zu erhalten.  
  
 Eine ZIP-Datei ist das primäre physische Format für die <xref:System.IO.Packaging.Package>.  Andere <xref:System.IO.Packaging.Package> Implementierungen können andere physische Formate verwenden, z. b. ein XML-Dokument, eine Datenbank oder einen Webdienst.  
  
 Wie bei einem Dateisystem wird in einer hierarchischen Organisation von Ordnern und Dateien auf Elemente verwiesen, die in einer <xref:System.IO.Packaging.Package> enthalten sind.  
  
 Obwohl <xref:System.IO.Packaging.Package> selbst eine abstrakte Klasse ist, wird die <xref:System.IO.Packaging.ZipPackage> abgeleitete Klasse standardmäßig von der <xref:System.IO.Packaging.Package.Open%2A>-Methode verwendet.  
  
 Eine <xref:System.IO.Packaging.PackagePart> ("Part") ist die abstrakte Klasse, die ein Objekt darstellt, das in einem <xref:System.IO.Packaging.Package>gespeichert ist.  
  
 Eine <xref:System.IO.Packaging.PackageRelationship> ("Beziehung") definiert eine Zuordnung zwischen einer Quell <xref:System.IO.Packaging.Package> oder <xref:System.IO.Packaging.PackagePart> und einem Zielobjekt.  Eine <xref:System.IO.Packaging.PackageRelationship> kann einen von zwei Typen aufweisen, von denen jede eine von zwei Formen sein kann:  
  
-   Eine Beziehung auf Paketebene (von der <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType>-Methode erstellt) verknüpft eine <xref:System.IO.Packaging.Package> mit einem der folgenden Optionen:  
  
    -   Ein Zielteil im Paket.  
  
    -   Eine Ziel Ressource außerhalb des Pakets.  
  
-   Eine auf teisebene (durch die <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType>-Methode erstellte) Beziehung zwischen einem Quell <xref:System.IO.Packaging.PackagePart> und einem der folgenden:  
  
    -   Ein weiterer Zielteil im Paket.  
  
    -   Eine Ziel Ressource außerhalb des Pakets.  
  
 Der Quell <xref:System.IO.Packaging.Package> oder Quell <xref:System.IO.Packaging.PackagePart> der Beziehung wird als "Besitzer" der Beziehung betrachtet.  Wenn das Quell Objekt gelöscht wird, werden alle Beziehungen im Besitz des Quell Objekts ebenfalls gelöscht.  Beim Erstellen oder Löschen einer Beziehung werden entweder die Quell-oder Zielobjekte nicht physisch geändert.  
  
 Eine <xref:System.IO.Packaging.PackageDigitalSignature> ("digitale Signatur") ist eine Komposition von Teilen und Beziehungen, die eine digitale Signatur darstellen, die in einem <xref:System.IO.Packaging.Package>enthalten ist.  Die digitale Signatur identifiziert den Absender und überprüft, ob die im <xref:System.IO.Packaging.Package> enthaltenen signierten Teile und Beziehungen nicht geändert wurden.  
  
 Pakete unterstützen außerdem Digital Rights Management (DRM), mit denen Inhaltselemente in einem <xref:System.IO.Packaging.Package> mit bestimmten Zugriffsrechten verschlüsselt werden können, die autorisierten Benutzern gewährt werden.  
  
 Basierend auf der <xref:System.IO.Packaging.Package>-Architektur ist ein <xref:System.Windows.Xps.Packaging.XpsDocument> ein Pakettyp, der für die Speicherung von Dokumenten basierend auf der Open [XML Paper Specification (XPS)](https://go.microsoft.com/fwlink/?LinkID=65761)konzipiert ist.  
  
 Der .NET Framework verwendet Pakete, um Inhalt, Ressourcen und Beziehungen für Seiten und Dokumente standardmäßig mit einer Standard-ZIP-Datei zu speichern. Wie bei jeder ZIP-Datei kann Ihre Anwendung die <xref:System.IO.Packaging>-Klassen verwenden, um jeden Typ oder jede beliebige Anzahl von Datendateien in einem einzelnen effizienten/zugriffscontainer zu speichern und optional zu schützen.  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die grundlegenden Schritte zum Erstellen eines <xref:System.IO.Packaging.Package>.  In diesem Beispiel wird ein Paket erstellt, das ein Dokument zusammen mit einem Grafik Bild enthält, das als Teil des Dokuments angezeigt wird.  (Dies ist vergleichbar mit der Groß-/Kleinschreibung, in der eine HTML-Datei über ein \<IMG >-Tag verfügt, das auf eine externe Bilddatei verweist.  Zwei <xref:System.IO.Packaging.PackageRelationship> Elemente sind ebenfalls im Paket enthalten.  Der erste, eine "Package-Level"-Beziehung definiert den Dokument Teil als Stamm Element des Pakets.  Eine zweite "Teil Ebene"-Beziehung definiert die Zuordnung zwischen dem Dokument Teil (der "Quelle" der Beziehung auf teichebene) und der Verwendung des Image Teils (dem "Ziel" der Beziehung auf teichebene).  Das komplette Beispiel finden Sie unter [Beispiel für das Schreiben eines Pakets](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=71255">Open Packaging Conventions (OPC)-Spezifikation</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=74494">Digitales Signatur Framework der geöffneten Verpackungs Konventionen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Packaging.Package" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package openFileAccess" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Die Datei-E/A-Berechtigungen für das Paket.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Packaging.Package" />-Klasse, die einen angegebenen <see cref="T:System.IO.FileAccess" /> verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> ist ein geschützter Konstruktor der <xref:System.IO.Packaging.Package> abstrakten Basisklasse. Beim Aufruf in einer abgeleiteten Klasse initialisiert der <xref:System.IO.Packaging.Package.%23ctor%2A>-Konstruktor eine neue Instanz der abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="openFileAccess" /> ist ungültig.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="F#" Value="new System.IO.Packaging.Package : System.IO.FileAccess * bool -&gt; System.IO.Packaging.Package" Usage="new System.IO.Packaging.Package (openFileAccess, streaming)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" Index="0" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="streaming" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Die Datei-E/A-Berechtigungen für das Paket.</param>
        <param name="streaming"><see langword="true" />, um das Paket für Streaming zu öffnen, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Packaging.Package" />-Klasse, die einen angegebenen <see cref="T:System.IO.FileAccess" /> und eine angegebene Streamingoption verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> ist ein geschützter Konstruktor der abstrakten Basisklasse <xref:System.IO.Packaging.Package> abstrakten Basisklasse. Beim Aufruf in einer abgeleiteten Klasse initialisiert der <xref:System.IO.Packaging.Package.%23ctor%2A>-Konstruktor eine neue Instanz der abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="openFileAccess" /> ist ungültig.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="package.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert und schließt das Paket sowie alle zugrunde liegenden Partstreams.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die <xref:System.IO.Packaging.Package>-Klasse <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> führen Sie denselben Vorgang aus. es gibt keinen Grund, <xref:System.IO.Packaging.Package.Dispose%2A> aufzurufen, wenn Sie <xref:System.IO.Packaging.Package.Close%2A>aufrufen oder umgekehrt.  
  
 <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> intern <xref:System.IO.Packaging.Package.Flush%2A>aufruft.  
  
> [!NOTE]
>  Die `using`-Anweisung (die von der `using` Namespace-Direktive abweicht) ist die empfohlene Vorgehensweise zum <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> eines Pakets.  Das [Schreiben eines Paket](https://go.microsoft.com/fwlink/?LinkID=160055) Beispiels und das [Lesen eines Paket](https://go.microsoft.com/fwlink/?LinkID=160034) Beispiels zeigen, wie Sie ein Paket mit der `using`-Anweisung schließen und verwerfen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein neues Paketpart.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Initialisiert eine leere <xref:System.IO.Stream> für den neuen Teil.  Die <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType>-Methode kann verwendet werden, um einen Verweis auf die dem Teil zugeordnete Datenstrom Instanz abzurufen.  
  
 Weitere Informationen zu Paket Teilen finden Sie in Abschnitt 1,1 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine neue <xref:System.IO.Packaging.PackagePart> erstellt und anschließend Daten im-Teil gespeichert werden.  Das komplette Beispiel finden Sie unter [Beispiel für das Schreiben eines Pakets](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> intern die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />-Methode aufrufen, um den Teil basierend auf dem in der abgeleiteten Klasse implementierten physischen Format tatsächlich zu erstellen.</para></block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">Der URI (Uniform Resource Identifier) des neuen Segments.</param>
        <param name="contentType">Der Inhaltstyp des Datenstreams.</param>
        <summary>Erstellt ein neues unkomprimiertes Part mit einem angegebenen URI und Inhaltstyp.</summary>
        <returns>Das neu erstellte Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Initialisiert eine leere <xref:System.IO.Stream> für den neuen Teil.  Die <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType>-Methode kann verwendet werden, um einen Verweis auf die dem Teil zugeordnete Datenstrom Instanz abzurufen.  
  
 Der Teil <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> ist <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>.  
  
 Weitere Informationen zu Paket Teilen finden Sie im Abschnitt 1,1 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine neue <xref:System.IO.Packaging.PackagePart> erstellt und anschließend Daten im-Teil gespeichert werden.  Das komplette Beispiel finden Sie unter [Beispiel für das Schreiben eines Pakets](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> oder <paramref name="contentType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" />-URI.</exception>
        <exception cref="T:System.InvalidOperationException">Im Paket ist bereits ein Part mit dem angegebenen <paramref name="partUri" /> vorhanden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt (es kann kein neues Part hinzugefügt werden).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> intern die <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />-Methode der abgeleiteten Klasse aufruft, um den Teil basierend auf dem in der abgeleiteten Klasse implementierten physischen Format tatsächlich zu erstellen.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="member this.CreatePart : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePart (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">Der URI des neuen Segments.</param>
        <param name="contentType">Der Inhaltstyp des Datenstreams.</param>
        <param name="compressionOption">Die Komprimierungsoption für den Datenstream, <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> oder <see cref="F:System.IO.Packaging.CompressionOption.Normal" />-Komprimierung.</param>
        <summary>Erstellt ein neues Part mit einem angegebenen URI, einem angegebenen Inhaltstyp und einer angegebenen Komprimierungsoption.</summary>
        <returns>Das neu erstellte Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die Standard <xref:System.IO.Packaging.ZipPackage> abgeleitete Klasse unterstützt die <xref:System.IO.Packaging.Package.CreatePart%2A>-Methode nur zwei `compressionOption`-Werte, <xref:System.IO.Packaging.CompressionOption.NotCompressed> oder <xref:System.IO.Packaging.CompressionOption.Normal>-Komprimierung.  Andere <xref:System.IO.Packaging.CompressionOption> Werte von <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>oder <xref:System.IO.Packaging.CompressionOption.SuperFast> <xref:System.IO.Packaging.CompressionOption.Normal> Komprimierung verwenden.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> erstellt eine leere <xref:System.IO.Stream> für den neuen Teil.  Die <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType>-Methode kann verwendet werden, um einen Verweis auf die dem Teil zugeordnete Datenstrom Instanz abzurufen.  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine neue <xref:System.IO.Packaging.PackagePart> erstellt und anschließend Daten im-Teil gespeichert werden.  Das komplette Beispiel finden Sie unter [Beispiel für das Schreiben eines Pakets](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> oder <paramref name="contentType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" />-URI (Uniform Resource Identifier).</exception>
        <exception cref="T:System.InvalidOperationException">Im Paket ist bereits ein Part mit dem angegebenen <paramref name="partUri" /> vorhanden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="compressionOption" />-Wert ist nicht zulässig.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt (es kann kein neues Part hinzugefügt werden).</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> intern die <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />-Methode der abgeleiteten Klasse aufruft, um den Teil basierend auf dem in der abgeleiteten Klasse implementierten physischen Format tatsächlich zu erstellen.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberSignature Language="F#" Value="abstract member CreatePartCore : Uri * string * System.IO.Packaging.CompressionOption -&gt; System.IO.Packaging.PackagePart" Usage="package.CreatePartCore (partUri, contentType, compressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">Der URI (Uniform Resource Identifier) für das Segment, das erstellt wird.</param>
        <param name="contentType">Der Inhaltstyp des Datenstreams.</param>
        <param name="compressionOption">Die Komprimierungsoption für den Datenstream.</param>
        <summary>Erstellt beim Überschreiben in einer abgeleiteten Klasse ein neues Part im Paket.</summary>
        <returns>Das erstellte Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die abgeleitete <xref:System.IO.Packaging.Package.CreatePartCore%2A>-Methode wird von der <xref:System.IO.Packaging.Package.CreatePart%2A>-Methode aufgerufen, um einen Teil basierend auf dem in der abgeleiteten Klasse implementierten physischen Format zu erstellen.  
  
 Standardmäßig wird eine <xref:System.IO.Packaging.ZipPackage> abgeleitete Klassen Implementierung der abstrakten <xref:System.IO.Packaging.Package>-Klasse bereitgestellt und verwendet.  Beim Standard Vorgang ruft <xref:System.IO.Packaging.Package.CreatePart%2A> intern <xref:System.IO.Packaging.Package.CreatePartCore%2A> der <xref:System.IO.Packaging.ZipPackage>-Klasse auf, um einen neuen Teil in einer ZIP-Datei zu erstellen.  
  
 Für die Standard <xref:System.IO.Packaging.ZipPackage> abgeleitete Klasse unterstützt die <xref:System.IO.Packaging.Package.CreatePartCore%2A>-Methode nur zwei `compressionOption`-Werte, <xref:System.IO.Packaging.CompressionOption.NotCompressed> oder <xref:System.IO.Packaging.CompressionOption.Normal>-Komprimierung.  Andere <xref:System.IO.Packaging.CompressionOption> Werte von <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>oder <xref:System.IO.Packaging.CompressionOption.SuperFast> <xref:System.IO.Packaging.CompressionOption.Normal> Komprimierung verwenden.  
  
 Weitere Informationen zum Paket Modell und den Paket Teilen finden Sie in Kapitel 1 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die abgeleitete <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> Implementierung sollte keine Annahmen über die Reihenfolge oder die Vorgänge treffen, die von der <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> Methode ausgeführt werden, die Sie aufruft.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Beziehung auf Paketebene zu einem angegebenen Part.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen dem Paket und einem zugeordneten Zielpart oder einer zugeordneten Ressource.  Eine Beziehung auf Paketebene kann eine von zwei Formen sein.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> zu einem Ziel <xref:System.IO.Packaging.PackagePart> innerhalb des Pakets.  
  
-   Zwischen einer <xref:System.IO.Packaging.Package> zu einer Ziel Ressource außerhalb des Pakets.  
  
 In einer Paket Beziehung wird das Paket als "Besitzer" der Beziehung betrachtet.  Wenn das Paket gelöscht wird, werden alle Beziehungen im Besitz des Pakets ebenfalls gelöscht.  Durch den Prozess der Erstellung oder Löschung der Beziehung wird der Zielteil oder die Ressource nicht physisch geändert.  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Erstellen einer <xref:System.IO.Packaging.PackageRelationship> zwischen einem <xref:System.IO.Packaging.Package> und einem Stamm Dokument Teil.  Das komplette Beispiel finden Sie unter [Beispiel für das Schreiben eines Pakets](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">Der URI (Uniform Resource Identifier) des Zielsegments.</param>
        <param name="targetMode">Gibt an, ob das Zielpart<see cref="F:System.IO.Packaging.TargetMode.Internal" /> oder <see cref="F:System.IO.Packaging.TargetMode.External" /> für das Paket ist.</param>
        <param name="relationshipType">Ein URI, der die Rolle der Beziehung eindeutig definiert.</param>
        <summary>Erstellt eine Beziehung auf Paketebene zu einem Part mit einem angegebenen URI, einem angegebenen Zielmodus und einem angegebenen Beziehungstyp.</summary>
        <returns>Die Beziehung auf Paketebene zu dem angegebenen Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen dem Paket und einem zugeordneten Zielpart oder einer zugeordneten Ressource.  Eine Beziehung auf Paketebene kann eine von zwei Formen sein.  
  
-   Zwischen einer <xref:System.IO.Packaging.Package> zu einem Zielteil im Paket.  
  
-   Zwischen einer <xref:System.IO.Packaging.Package> zu einer Ziel Ressource außerhalb des Pakets.  
  
 In einer Paket Beziehung wird das Paket als "Besitzer" der Beziehung betrachtet.  Wenn das Paket gelöscht wird, werden alle Beziehungen im Besitz des Pakets ebenfalls gelöscht.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> ändert den Zielteil oder die Ressource nicht physisch in irgendeiner Weise.  
  
 Das Ziel einer Beziehung darf keine andere Beziehung sein.  
  
 Wenn `targetMode` als <xref:System.IO.Packaging.TargetMode.Internal>angegeben ist, muss `targetUri` ein relativer URI sein, der gemäß der generischen Syntax Spezifikation von [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI) gebildet wird.  Der interne relative URI kann entweder ein absoluter Pfad sein, der mit einem Schrägstrich ("/") beginnt, wie z. b. "/Page1.XAML" oder "/Images/picture4.jpg", oder ein relativer Pfad wie ".. /imagespicture1.jpg ", die für den Paket Stamm ("/") als Basis-URI aufgelöst wird.  
  
 Wenn `targetMode` als <xref:System.IO.Packaging.TargetMode.External>angegeben ist, kann `targetUri` entweder ein absoluter oder ein relativer URI sein, der gemäß der generischen Syntax Spezifikation von [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI) gebildet wird. `http://www.microsoft.com/page2.xml` ist ein Beispiel für einen absoluten URI, der auf eine externe Ziel Ressource "Page2. xml" verweist.  "Images/picture1. jpg" ist ein Beispiel für einen relativen URI, der auch auf eine externe Ziel Ressource "1. jpg" verweist, die jedoch mit dem URI des Pakets selbst aufgelöst wird.  
  
 `relationshipType` muss ein URI sein, der gemäß der generischen Syntax Spezifikation von [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI) gebildet wird.  Die folgende Tabelle zeigt die `relationshipType` URIs auf Paketebene, die in der OPC-Spezifikation (Open Packaging Conventions) definiert sind.  
  
|Beziehung auf Paketebene|Beziehungstyp-URI|  
|---------------------------------|---------------------------|  
|Kerneigenschaften|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Digitale Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Digitales Signaturzertifikat|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Ursprung der digitalen Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Ein|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Weitere Informationen zu Paket-und Paket Beziehungen finden Sie in Abschnitt 1,3 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie <xref:System.IO.Packaging.Package.CreateRelationship%2A> verwendet wird, um eine <xref:System.IO.Packaging.PackageRelationship> zwischen einem <xref:System.IO.Packaging.Package> und einem Stamm Dokument Teil zu erstellen.  Das komplette Beispiel finden Sie unter [Beispiel für das Schreiben eines Pakets](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> oder <paramref name="relationshipType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="targetUri" />-Part ist eine <see cref="T:System.IO.Packaging.PackageRelationship" />, oder <paramref name="targetMode" /> ist <see cref="F:System.IO.Packaging.TargetMode.Internal" />, und <paramref name="targetUri" /> ist ein absoluter URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="targetMode" /> ist ungültig.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.CreateRelationship : Uri * System.IO.Packaging.TargetMode * string * string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.CreateRelationship (targetUri, targetMode, relationshipType, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">Der URI (Uniform Resource Identifier) des Zielsegments.</param>
        <param name="targetMode">Gibt an, ob das Zielpart<see cref="F:System.IO.Packaging.TargetMode.Internal" /> oder <see cref="F:System.IO.Packaging.TargetMode.External" /> für das Paket ist.</param>
        <param name="relationshipType">Ein URI, der die Rolle der Beziehung eindeutig definiert.</param>
        <param name="id">Ein eindeutiger XML-Bezeichner.</param>
        <summary>Erstellt eine Beziehung auf Paketebene zu einem Part mit einem angegebenen URI, einem angegebenen Zielmodus, einem angegebenen Beziehungstyp und einer angegebenen [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>Die Beziehung auf Paketebene zu dem angegebenen Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen dem Paket und einem zugeordneten Zielpart oder einer zugeordneten Ressource.  Eine Beziehung auf Paketebene kann eine von zwei Formen sein.  
  
-   Zwischen einer <xref:System.IO.Packaging.Package> zu einem Zielteil im Paket.  
  
-   Zwischen einer <xref:System.IO.Packaging.Package> zu einer Ziel Ressource außerhalb des Pakets.  
  
 In einer Paket Beziehung wird das Paket als "Besitzer" der Beziehung betrachtet.  Wenn das Paket gelöscht wird, werden alle Beziehungen im Besitz des Pakets ebenfalls gelöscht.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> ändert den Zielteil oder die Ressource nicht physisch in irgendeiner Weise.  
  
 Das Ziel einer Beziehung darf keine andere Beziehung sein.  
  
 `id` muss ein gültiger XML-Bezeichner sein.  Der `id` Typ ist "xsd: ID" und muss den in der Spezifikation "XML Schema Part 2: Datatypes" vorgeschriebenen Benennungs Konventionen entsprechen (siehe [https://www.w3.org/TR/xmlschema-2/#ID](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Wenn `id` als `null` angegeben wird, wird automatisch eine eindeutige ID generiert.  Eine `id`, die durch eine leere Zeichenfolge angegeben wird, ist ungültig.  
  
 Wenn `targetMode` als <xref:System.IO.Packaging.TargetMode.Internal>angegeben ist, muss `targetUri` ein relativer URI sein, der gemäß der generischen Syntax Spezifikation von [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI) gebildet wird.  Der interne relative URI kann entweder ein absoluter Pfad sein, der mit einem Schrägstrich ("/") beginnt, wie z. b. "/Page1.XAML" oder "/Images/picture4.jpg", oder ein relativer Pfad wie ".. /imagespicture1.jpg ", die für den Paket Stamm ("/") als Basis-URI aufgelöst wird.  
  
 Wenn `targetMode` als <xref:System.IO.Packaging.TargetMode.External>angegeben ist, kann `targetUri` entweder ein absoluter oder ein relativer URI sein, der gemäß der generischen Syntax Spezifikation von [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI) gebildet wird. `http://www.microsoft.com/page2.xml` ist ein Beispiel für einen absoluten URI, der auf eine externe Ziel Ressource "Page2. xml" verweist.  "Images/picture1. jpg" ist ein Beispiel für einen relativen URI, der auch auf eine externe Ziel Ressource "1. jpg" verweist, die jedoch mit dem URI des Pakets selbst aufgelöst wird.  
  
 `relationshipType` muss ein URI sein, der gemäß der generischen Syntax Spezifikation von [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI) gebildet wird.  Die folgende Tabelle zeigt die `relationshipType` URIs auf Paketebene, die in der OPC-Spezifikation (Open Packaging Conventions) definiert sind.  
  
|Beziehung auf Paketebene|Beziehungstyp-URI|  
|---------------------------------|---------------------------|  
|Kerneigenschaften|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Digitale Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Digitales Signaturzertifikat|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Ursprung der digitalen Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Ein|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Weitere Informationen zu Paket-und Paket Beziehungen finden Sie in Abschnitt 1,3 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie <xref:System.IO.Packaging.Package.CreateRelationship%2A> verwendet wird, um eine <xref:System.IO.Packaging.PackageRelationship> zwischen einem <xref:System.IO.Packaging.Package> und einem Stamm Dokument Teil zu erstellen.  Das komplette Beispiel finden Sie unter [Beispiel für das Schreiben eines Pakets](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetUri" /> oder <paramref name="relationshipType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="targetUri" />-Part ist eine <see cref="T:System.IO.Packaging.PackageRelationship" />, oder <paramref name="targetMode" /> ist <see cref="F:System.IO.Packaging.TargetMode.Internal" />, und <paramref name="targetUri" /> ist ein absoluter URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="targetMode" /> ist ungültig.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> ist kein gültiger XML-Bezeichner, oder im Paket ist bereits ein Part mit der angegebenen <paramref name="id" /> vorhanden.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.DeletePart : Uri -&gt; unit" Usage="package.DeletePart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der URI des zu löschenden Segments.</param>
        <summary>Löscht ein Part mit einem angegebenen URI aus dem Paket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` muss ein relativer URI sein, der aus einem absoluten Pfad besteht, der mit einem Schrägstrich ("/") beginnt.  Der absolute Pfad ist relativ zum Paket Stamm und wird entsprechend der generischen Syntax Spezifikation des [RFC 3986](https://tools.ietf.org/html/rfc3986) Uniform Resource Identifier (URI) gebildet.  "/Page1.XAML" und "/Images/picture4.jpg" sind Beispiele für gültige Teil-URIs.  
  
 Es wird keine Ausnahme ausgelöst, wenn ein Teil mit dem angegebenen `partUri` nicht im Paket enthalten ist.  (Sie können die <xref:System.IO.Packaging.Package.PartExists%2A>-Methode verwenden, um zu bestimmen, ob ein Part mit einem angegebenen `partUri` im Paket enthalten ist.)  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" />-URI.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> intern die <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />-Methode der abgeleiteten Klasse aufruft, um den Teil basierend auf dem in der abgeleiteten Klasse implementierten physischen Format tatsächlich zu löschen.</para></block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member DeletePartCore : Uri -&gt; unit" Usage="package.DeletePartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der <see cref="P:System.IO.Packaging.PackagePart.Uri" /> des zu löschenden <see cref="T:System.IO.Packaging.PackagePart" />.</param>
        <summary>Löscht beim Überschreiben in einer abgeleiteten Klasse ein Part mit einem angegebenen URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird eine <xref:System.IO.Packaging.ZipPackage> abgeleitete Klassen Implementierung der abstrakten <xref:System.IO.Packaging.Package>-Klasse bereitgestellt und verwendet.  Beim Standard Vorgang ruft <xref:System.IO.Packaging.Package.DeletePart%2A> intern <xref:System.IO.Packaging.Package.DeletePartCore%2A> der <xref:System.IO.Packaging.ZipPackage>-Klasse auf, um den eigentlichen Löschvorgang auf der Grundlage des in der abgeleiteten Klasse implementierten physischen Formats auszuführen.  
  
 Weitere Informationen zum Paket Modell und den Paket Teilen finden Sie in Kapitel 1 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> Implementierung der abgeleiteten Klasse wird von der <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />-Methode auf dem angegebenen Teil basierend auf dem in der abgeleiteten Klasse implementierten physischen Format aufgerufen.  
  
Die abgeleitete <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> Implementierung sollte keine Annahmen über die Reihenfolge oder die Vorgänge treffen, die von der <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> Methode ausgeführt werden, die Sie aufruft.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.DeleteRelationship : string -&gt; unit" Usage="package.DeleteRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Der <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> des zu löschenden <see cref="T:System.IO.Packaging.PackageRelationship" />.</param>
        <summary>Löscht eine Beziehung auf Paketebene.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen dem Paket und einem zugeordneten Zielpart oder einer zugeordneten Ressource.  Eine Beziehung auf Paketebene kann eine von zwei Formen sein.  
  
-   Zwischen einer <xref:System.IO.Packaging.Package> zu einem Zielteil im Paket.  
  
-   Zwischen einer <xref:System.IO.Packaging.Package> zu einer Ziel Ressource außerhalb des Pakets.  
  
 In einer Paket Beziehung wird das Paket als "Besitzer" der Beziehung betrachtet.  Wenn das Paket gelöscht wird, werden alle Beziehungen im Besitz des Pakets ebenfalls gelöscht.  
  
 Es wird keine Ausnahme ausgelöst, wenn sich eine Beziehung mit dem angegebenen `id` nicht im Paket befindet.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> ändert den Zielteil nicht physisch.  
  
 Weitere Informationen zu Paket Beziehungen finden Sie in Abschnitt 1,3 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> ist kein gültiger XML-Bezeichner.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="package.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Leert und speichert den Inhalt von allen Parts und Beziehungen, schließt das Paket und gibt alle Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um sicherzustellen, dass alle Änderungen ordnungsgemäß gespeichert werden, werden <xref:System.IO.Packaging.Package.Dispose%2A> auch alle im Paket enthaltenen Teile und Beziehungen abgeschlossen, geleert und geschlossen.  
  
 <xref:System.IO.Packaging.Package.Dispose%2A> und <xref:System.IO.Packaging.Package.Close%2A> für die <xref:System.IO.Packaging.Package>-Klasse denselben Vorgang ausführen. es gibt keinen Grund, <xref:System.IO.Packaging.Package.Dispose%2A> aufzurufen, wenn Sie <xref:System.IO.Packaging.Package.Close%2A>aufrufen oder umgekehrt.  
  
 <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> intern <xref:System.IO.Packaging.Package.Flush%2A>aufruft.  
  
 Abgeleitete Klassen, die nicht-Arbeitsspeicher Ressourcen zuweisen und verwalten, sollten diese Methode überschreiben, um Ressourcen freizugeben, wenn <xref:System.IO.Packaging.Package.Dispose%2A> aufgerufen wird. Außer Kraft setzungen für abgeleitete Klassen sollten auch <xref:System.IO.Packaging.Package.Flush%2A> und die <xref:System.IO.Packaging.Package.Dispose%2A> Methode der Basisklasse aufgerufen werden, um sicherzustellen, dass die Basisklassenbereinigung immer durchgeführt wird.  
  
> [!NOTE]
>  Die `using`-Anweisung (die von der `using` Namespace-Direktive abweicht) ist die empfohlene Vorgehensweise zum <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> eines Pakets. Das [Schreiben eines Paket](https://go.microsoft.com/fwlink/?LinkID=160055) Beispiels zeigt, wie Sie ein Paket mit der `using`-Anweisung schließen und verwerfen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberSignature Language="F#" Value="member this.FileOpenAccess : System.IO.FileAccess" Usage="System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Dateizugriffseinstellung für das Paket ab.</summary>
        <value>Einer der <see cref="T:System.IO.FileAccess" />-Werte: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> oder <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaft <xref:System.IO.Packaging.Package.FileOpenAccess%2A> hat keinen Standardwert.  Die Datei Zugriffs Einstellung wird beim Erstellen eines neuen Pakets im <xref:System.IO.Packaging.Package.%23ctor%2A> konstruktoraufzurufen oder beim Öffnen eines vorhandenen Pakets im <xref:System.IO.Packaging.Package.Open%2A> aufrufen angegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="package.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert die Inhalte von allen Parts und Beziehungen, die im Paket enthalten sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> intern die <xref:System.IO.Packaging.Package.FlushCore%2A> Implementierung der abgeleiteten Klasse aufruft, um den eigentlichen Format spezifischen Leerungs Vorgang auszuführen.  Die <xref:System.IO.Packaging.Package.FlushCore%2A>-Methode der abgeleiteten Klasse ist dafür verantwortlich, den Teil-und Beziehungs Inhalt tatsächlich in der spezifischen Implementierung der physischen abgeleiteten Klasse zu speichern.  
  
 Standardmäßig wird eine <xref:System.IO.Packaging.ZipPackage> abgeleitete Implementierung der abstrakten <xref:System.IO.Packaging.Package> Basisklasse bereitgestellt und verwendet. Beim Standard Vorgang ruft <xref:System.IO.Packaging.Package.Flush%2A> intern <xref:System.IO.Packaging.Package.FlushCore%2A> auf, um die Teile und Beziehungen in einem ZIP-Dateipaket zu speichern.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> wird von den Methoden <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> automatisch aufgerufen.  Wenn <xref:System.IO.Packaging.Package.Close%2A> oder <xref:System.IO.Packaging.Package.Dispose%2A> aufgerufen wird, muss <xref:System.IO.Packaging.Package.Flush%2A> nicht separat aufgerufen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt und kann nicht geändert werden.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> intern die <see cref="M:System.IO.Packaging.Package.FlushCore" />-Methode der abgeleiteten Klasse aufruft, um den Teil basierend auf dem in der abgeleiteten Klasse implementierten physischen Format tatsächlich zu leeren.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberSignature Language="F#" Value="abstract member FlushCore : unit -&gt; unit" Usage="package.FlushCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert beim Überschreiben in einer abgeleiteten Klasse die Inhalte aller Parts und Beziehungen im Speicher der abgeleiteten Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> wird von der <xref:System.IO.Packaging.Package.Flush%2A>-Methode aufgerufen, um den eigentlichen Löschvorgang auf der Grundlage des in der abgeleiteten Klasse implementierten physischen Formats auszuführen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die abgeleitete <see cref="M:System.IO.Packaging.Package.FlushCore" /> Implementierung sollte keine Annahmen über die Reihenfolge oder die Vorgänge treffen, die von der <see cref="M:System.IO.Packaging.Package.Flush" /> Methode ausgeführt werden, die Sie aufruft.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="member this.GetPart : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPart partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der URI (Uniform Resource Identifier) des zurückzugebenden Segments.</param>
        <summary>Gibt das Part mit einem angegebenen URI zurück.</summary>
        <returns>Das Part mit dem angegebenen <paramref name="partUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.InvalidOperationException> wird ausgelöst, wenn ein Teil mit der angegebenen `partUri` nicht vorhanden ist.  
  
 Die <xref:System.IO.Packaging.Package.PartExists%2A>-Methode kann verwendet werden, um zu bestimmen, ob `partUri` auf einen vorhandenen Teil verweist.  
  
 Standardmäßig wird eine <xref:System.IO.Packaging.ZipPackage> abgeleitete Implementierung der abstrakten <xref:System.IO.Packaging.Package> Basisklasse bereitgestellt und verwendet.  Beim Standard Vorgang ruft <xref:System.IO.Packaging.Package.GetPart%2A> intern <xref:System.IO.Packaging.Package.GetPartCore%2A> der <xref:System.IO.Packaging.ZipPackage>-Klasse auf, um einen angeforderten Teil aus einer ZIP-Datei zurückzugeben.  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie in einem Paket enthaltene Teile suchen, abrufen und lesen.  Das komplette Beispiel finden Sie unter [Lesen eines Paket](https://go.microsoft.com/fwlink/?LinkID=160034)Beispiels.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" />-URI (Uniform Resource Identifier).</exception>
        <exception cref="T:System.InvalidOperationException">Ein Part mit dem angegebenen <paramref name="partUri" /> ist nicht im Paket enthalten.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> intern die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />-Methode aufrufen, um den Teil basierend auf dem in der abgeleiteten Klasse implementierten physischen Format tatsächlich zu leeren.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member GetPartCore : Uri -&gt; System.IO.Packaging.PackagePart" Usage="package.GetPartCore partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der URI (Uniform Resource Identifier) des abzurufenden Segments.</param>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse das von einem angegebenen URI adressierte Part zurück.</summary>
        <returns>Das angeforderte Part oder <see langword="null" />, wenn kein Part mit dem angegebenen <paramref name="partUri" /> im Paket vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig wird eine <xref:System.IO.Packaging.ZipPackage> abgeleitete Implementierung der abstrakten <xref:System.IO.Packaging.Package>-Klasse bereitgestellt und verwendet.  Beim Standard Vorgang ruft <xref:System.IO.Packaging.Package.GetPart%2A> intern <xref:System.IO.Packaging.Package.GetPartCore%2A> der <xref:System.IO.Packaging.ZipPackage>-Klasse auf, um einen Teil aus einer ZIP-Datei abzurufen.  
  
 Weitere Informationen zum Paket Modell und den Paket Teilen finden Sie in Kapitel 1 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> Implementierung der abgeleiteten Klasse wird von der <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />-Methode aufgerufen, um auf Grundlage des in der abgeleiteten Klasse implementierten physischen Formats auf den angegebenen Teil zuzugreifen und ihn zurückzugeben.  
  
Die abgeleitete <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> Implementierung sollte keine Annahmen über die Reihenfolge oder die Vorgänge treffen, die von der <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> Methode ausgeführt werden, die Sie aufruft.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberSignature Language="F#" Value="member this.GetParts : unit -&gt; System.IO.Packaging.PackagePartCollection" Usage="package.GetParts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Auflistung aller Parts im Paket zurück.</summary>
        <returns>Eine Auflistung aller <see cref="T:System.IO.Packaging.PackagePart" />-Elemente, die im Paket enthalten sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> gibt eine Auflistung aller Teile zurück, die im Paket enthalten sind, einschließlich <xref:System.IO.Packaging.PackageRelationship> Teile.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> wird nie `null`zurückgeben. die zurückgegebene Auflistung enthält jedoch 0 (null) Elemente, wenn das Paket keine Teile enthält.  
  
 Standardmäßig wird eine <xref:System.IO.Packaging.ZipPackage> abgeleitete Implementierung der abstrakten <xref:System.IO.Packaging.Package> Basisklasse bereitgestellt und verwendet.  Beim Standard Vorgang ruft <xref:System.IO.Packaging.Package.GetParts%2A> die <xref:System.IO.Packaging.Package.GetPartsCore%2A>-Methode der <xref:System.IO.Packaging.ZipPackage>-Klasse auf, um die Teile aus einer ZIP-Datei zurückzugeben.  
  
 Weitere Informationen zu Paketen und Paket Teilen finden Sie in Abschnitt 1,1 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die <xref:System.IO.Packaging.Package.GetParts%2A>-Methode verwendet wird, um eine Auflistung der Teile abzurufen, die in einem <xref:System.IO.Packaging.Package>enthalten sind.  Den gesamten Programm Quellcode finden Sie unter [Erstellen eines Pakets mit einem Beispiel für eine digitale Signatur](https://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> intern die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.GetPartsCore" />-Methode aufrufen, um den Teil basierend auf dem in der abgeleiteten Klasse implementierten physischen Format tatsächlich zu leeren.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberSignature Language="F#" Value="abstract member GetPartsCore : unit -&gt; System.IO.Packaging.PackagePart[]" Usage="package.GetPartsCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse ein Array aller Parts im Paket zurück.</summary>
        <returns>Ein Array aller Parts, die im Paket enthalten sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.Packaging.Package.GetPartsCore%2A> Implementierung der abgeleiteten Klasse wird von der <xref:System.IO.Packaging.Package.GetParts%2A>-Methode aufgerufen, um auf Grundlage des in der abgeleiteten Klasse implementierten physischen Formats auf das Array von Teilen zuzugreifen und es zurückzugeben.  
  
 Standardmäßig wird eine <xref:System.IO.Packaging.ZipPackage> abgeleitete Implementierung der abstrakten <xref:System.IO.Packaging.Package>-Klasse bereitgestellt und verwendet.  Beim Standard Vorgang ruft <xref:System.IO.Packaging.Package.GetParts%2A> intern <xref:System.IO.Packaging.Package.GetPartCore%2A> der <xref:System.IO.Packaging.ZipPackage>-Klasse auf, um die Teile aus einer ZIP-Datei abzurufen.  
  
 Weitere Informationen zum Paket Modell und den Paket Teilen finden Sie in Kapitel 1 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Die abgeleitete <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> Implementierung sollte keine Annahmen über die Reihenfolge oder die Vorgänge treffen, die von der <see cref="M:System.IO.Packaging.Package.GetParts" /> Methode ausgeführt werden, die Sie aufruft.</para></block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetRelationship : string -&gt; System.IO.Packaging.PackageRelationship" Usage="package.GetRelationship id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> der zurückzugebenden Beziehung.</param>
        <summary>Gibt die Beziehung auf Paketebene zu einem angegebenen Bezeichner zurück.</summary>
        <returns>Die Beziehung auf Paketebene mit der angegebenen <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` muss ein gültiger XML-Bezeichner sein. Der `id` Typ ist "xsd: ID" und muss den Benennungs Konventionen folgen, die im [Abschnitt "3.3.8" der Spezifikation "XML Schema Part 2: Datatypes](https://www.w3.org/TR/xmlschema-2/#ID)" vorgeschrieben sind.  
  
 Weitere Informationen zu Paket-und Paket Beziehungen finden Sie in Abschnitt 1,3 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> ist kein gültiger XML-Bezeichner.</exception>
        <exception cref="T:System.InvalidOperationException">Das Paket enthält keine Beziehung mit der angegebenen <paramref name="id" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberSignature Language="F#" Value="member this.GetRelationships : unit -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationships " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Auflistung aller Beziehungen auf Paketebene zurück.</summary>
        <returns>Eine Auflistung aller Beziehungen auf Paketebene, die im Paket enthalten werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> wird nie `null`zurückgeben. die zurückgegebene Auflistung enthält jedoch möglicherweise 0 (null) Elemente, wenn das Paket keine Beziehungen auf Paketebene enthält.  
  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen dem Paket und einem zugeordneten Zielpart oder einer zugeordneten Ressource.  Eine Beziehung auf Paketebene kann eine von zwei Formen sein.  
  
-   Zwischen einer <xref:System.IO.Packaging.Package> zu einem Zielteil im Paket.  
  
-   Zwischen einer <xref:System.IO.Packaging.Package> zu einer Ziel Ressource außerhalb des Pakets.  
  
 In einer Paket Beziehung wird das Paket als "Besitzer" der Beziehung betrachtet.  Wenn das Paket gelöscht wird, werden alle Beziehungen im Besitz des Pakets ebenfalls gelöscht.  Durch den Prozess der Erstellung oder Löschung der Beziehung wird der Zielteil oder die Ressource nicht physisch geändert.  
  
 Weitere Informationen zu Paket-und Paket Beziehungen finden Sie in Abschnitt 1,3 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipsByType : string -&gt; System.IO.Packaging.PackageRelationshipCollection" Usage="package.GetRelationshipsByType relationshipType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">Der <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />, der verglichen und in der Auflistung zurückgegeben werden soll.</param>
        <summary>Gibt eine Auflistung aller Beziehungen auf Paketebene zurück, die mit einem angegebenen <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> übereinstimmen.</summary>
        <returns>Eine Auflistung der Beziehungen auf Paketebene, die mit dem angegebenen <paramref name="relationshipType" /> übereinstimmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> wird nie `null`zurückgeben. die zurückgegebene Auflistung enthält jedoch möglicherweise 0 (null) Elemente, wenn keine Beziehungen auf Paketebene vorhanden sind, die dem angegebenen `relationshipType`entsprechen.  
  
 Die folgende Tabelle zeigt die `relationshipType` URIs auf Paketebene, die in der OPC-Spezifikation (Open Packaging Conventions) definiert sind.  
  
|Beziehung auf Paketebene|Beziehungstyp-URI|  
|---------------------------------|---------------------------|  
|Kerneigenschaften|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties`|  
|Digitale Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature`|  
|Digitales Signaturzertifikat|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/certificate`|  
|Ursprung der digitalen Signatur|`http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/origin`|  
|Ein|`http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail`|  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie die für das Paket definierten Beziehungen abgerufen werden.  Das komplette Beispiel finden Sie unter [Lesen eines Paket](https://go.microsoft.com/fwlink/?LinkID=160034)Beispiels.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="relationshipType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="relationshipType" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein Paket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standard Pakettyp, der von der <xref:System.IO.Packaging.Package.Open%2A>-Methode verwendet wird.  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine neue <xref:System.IO.Packaging.Package> erstellt wird, die <xref:System.IO.Packaging.PackageRelationship>-und <xref:System.IO.Packaging.PackagePart>-Elemente mit gespeicherten Daten enthält.  Das komplette Beispiel finden Sie unter [Beispiel für das Schreiben eines Pakets](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der E/A-Stream, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet ein Paket in einem angegebenen E/A-Stream.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standard Pakettyp, der von der <xref:System.IO.Packaging.Package.Open%2A>-Methode verwendet wird.  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Für das zu öffnende Paket ist eine Lese- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist lesegeschützt. Oder für das zu öffnende Paket ist eine Schreib- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Open : string -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <summary>Öffnet ein Paket mit einem angegebenen Pfad und Dateinamen.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standard Pakettyp, der von der <xref:System.IO.Packaging.Package.Open%2A>-Methode verwendet wird.  
  
 Diese <xref:System.IO.Packaging.Package.Open%2A> Methode öffnet das Paket mit Standard Attributen <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>und <xref:System.IO.FileShare.None> (um unterschiedliche Attribute anzugeben, verwenden Sie eine der anderen geöffneten Methoden Überladungen).  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine neue <xref:System.IO.Packaging.Package> erstellt wird, die <xref:System.IO.Packaging.PackageRelationship>-und <xref:System.IO.Packaging.PackagePart>-Elemente mit gespeicherten Daten enthält.  Das komplette Beispiel finden Sie unter [Beispiel für das Schreiben eines Pakets](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">Der E/A-Stream, in dem das Paket geöffnet werden soll.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet ein Paket mit einem angegebenen E/A-Stream und Dateimodus.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standard Pakettyp, der von der <xref:System.IO.Packaging.Package.Open%2A>-Methode verwendet wird.  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="packageMode" />-Wert ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Für das zu öffnende Paket ist eine Lese- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist lesegeschützt. Oder für das zu öffnende Paket ist eine Schreib- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet mithilfe einer angegebenen Dateimethode ein Paket in einem angegebenen Pfad.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standard Pakettyp, der von der <xref:System.IO.Packaging.Package.Open%2A>-Methode verwendet wird.  
  
 Diese <xref:System.IO.Packaging.Package.Open%2A> Methode öffnet das Paket mit Standard Attributen <xref:System.IO.FileAccess.ReadWrite> und <xref:System.IO.FileShare.None> (um unterschiedliche Attribute anzugeben, verwenden Sie eine der anderen geöffneten Methoden Überladungen).  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine neue <xref:System.IO.Packaging.Package> erstellt wird, die <xref:System.IO.Packaging.PackageRelationship>-und <xref:System.IO.Packaging.PackagePart>-Elemente mit gespeicherten Daten enthält.  Das komplette Beispiel finden Sie unter [Beispiel für das Schreiben eines Pakets](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : System.IO.Stream * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (stream, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">Der E/A-Stream, in dem das Paket geöffnet werden soll.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <param name="packageAccess">Der Dateizugriff, mit dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet ein Paket mit einem angegebenen E/A-Stream, einem angegebenen Dateimodus und einer angegebenen Dateizugriffseinstellung.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standard Pakettyp, der von der <xref:System.IO.Packaging.Package.Open%2A>-Methode verwendet wird.  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" /> oder <paramref name="packageAccess" /> ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Für das zu öffnende Paket ist eine Lese- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist lesegeschützt. Oder für das zu öffnende Paket ist eine Schreib- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <param name="packageAccess">Der Dateizugriff, mit dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet mit einem angegebenen Dateimodus und einer angegebenen Dateizugriffseinstellung ein Paket in einem angegebenen Pfad.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standard Pakettyp, der von der <xref:System.IO.Packaging.Package.Open%2A>-Methode verwendet wird.  
  
 Diese <xref:System.IO.Packaging.Package.Open%2A> Methode öffnet das Paket mit einem Standard <xref:System.IO.FileShare.None> Attribut (um ein anderes Attribut anzugeben, verwenden Sie die <xref:System.IO.Packaging.Package.Open%2A>-Methoden Überladung).  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie eine <xref:System.IO.Packaging.Package> öffnen und lesen können, die <xref:System.IO.Packaging.PackageRelationship>-und <xref:System.IO.Packaging.PackagePart>-Elemente mit gespeicherten Daten enthält.  Das komplette Beispiel finden Sie unter [Lesen eines Paket](https://go.microsoft.com/fwlink/?LinkID=160034)Beispiels.  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" /> oder <paramref name="packageAccess" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.Packaging.Package" Usage="System.IO.Packaging.Package.Open (path, packageMode, packageAccess, packageShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <param name="packageAccess">Der Dateizugriff, mit dem das Paket geöffnet werden soll.</param>
        <param name="packageShare">Der Dateifreigabemodus, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet mit einem angegebenen Dateimodus, einer angegebenen Dateizugriffseinstellung und einer angegebenen Dateifreigabeeinstellung ein Paket in einem angegebenen Pfad.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standard Pakettyp, der von der <xref:System.IO.Packaging.Package.Open%2A>-Methode verwendet wird.  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie eine neue <xref:System.IO.Packaging.Package> erstellt wird, die <xref:System.IO.Packaging.PackageRelationship>-und <xref:System.IO.Packaging.PackagePart>-Elemente mit gespeicherten Daten enthält.  Das komplette Beispiel finden Sie unter [Beispiel für das Schreiben eines Pakets](https://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" />, <paramref name="packageAccess" /> oder <paramref name="packageShare" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PackageProperties : System.IO.Packaging.PackageProperties" Usage="System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Haupteigenschaften des Pakets ab.</summary>
        <value>Die Haupteigenschaften des Pakets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu den Kern Paket Eigenschaften finden Sie im Abschnitt 3,1 der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberSignature Language="F#" Value="abstract member PartExists : Uri -&gt; bool&#xA;override this.PartExists : Uri -&gt; bool" Usage="package.PartExists partUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der zu überprüfende <see cref="T:System.Uri" /> des Parts.</param>
        <summary>Gibt an, ob ein Part mit einem angegebenen URI im Paket vorhanden ist.</summary>
        <returns><see langword="true" />, wenn ein Part mit dem angegebenen <paramref name="partUri" /> im Paket enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `partUri` sollte mit einem Schrägstrich ("/") beginnen und vom Stamm des Pakets absolut sein.  
  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" />-URI (Uniform Resource Identifier).</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt (Informationen können nicht gelesen werden).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.RelationshipExists : string -&gt; bool" Usage="package.RelationshipExists id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die zu überprüfende <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> der Beziehung.</param>
        <summary>Gibt an, ob eine Beziehung auf Paketebene mit einer angegebenen ID im Paket enthalten ist.</summary>
        <returns><see langword="true" />, wenn eine Beziehung auf Paketebene mit der angegebenen <paramref name="id" /> im Paket vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie in der OPC-Spezifikation (Open Packaging Conventions), die unter <https://go.microsoft.com/fwlink/?LinkID=71255>heruntergeladen werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="id" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException"><paramref name="id" /> ist kein gültiger XML-Bezeichner.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dieser Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die Anwendungsverwendung vorgesehen.  Verwenden Sie stattdessen die typsichere <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />-Methode.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
