<Type Name="Package" FullName="System.IO.Packaging.Package">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="26e89d81152bf959a5f5d5e7816e69f656353584" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683145" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Package&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Package abstract : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Container dar, der mehrere Datenobjekte speichern kann.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package> ist eine abstrakte Klasse, die zum Organisieren von Objekten in einer einzelnen Entität mit einem definierten physischen Format für Portabilität und effizienten Zugriff verwendet werden kann.  
  
 Eine ZIP-Datei ist das primäre physische Format für die <xref:System.IO.Packaging.Package>.  Andere <xref:System.IO.Packaging.Package> Implementierungen möglicherweise verwenden Sie andere physische Formate wie z. B. ein XML-Dokument, eine Datenbank oder einen Webdienst.  
  
 Wie ein Dateisystem Elemente einem <xref:System.IO.Packaging.Package> in eine hierarchische Organisation von Dateien und Ordnern verwiesen wird.  
  
 Obwohl <xref:System.IO.Packaging.Package> selbst ist eine abstrakte Klasse, die <xref:System.IO.Packaging.ZipPackage> abgeleiteten Klasse wird als standardmäßig verwendet die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Ein <xref:System.IO.Packaging.PackagePart> ("Teil") ist die abstrakte Klasse, die ein Objekt darstellt, die in gespeichert ist eine <xref:System.IO.Packaging.Package>.  
  
 Ein <xref:System.IO.Packaging.PackageRelationship> ("Beziehung") definiert eine Zuordnung zwischen einer Quelle <xref:System.IO.Packaging.Package> oder <xref:System.IO.Packaging.PackagePart> und einem Zielobjekt.  Ein <xref:System.IO.Packaging.PackageRelationship> kann eine von zwei Typen, von denen jeder eine von zwei Formen kann:  
  
-   Eine Beziehung auf Paketebene (erstellt, indem die <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> Methode) bezieht sich eine <xref:System.IO.Packaging.Package> entweder:  
  
    -   Ein Ziel-Webpart im Paket.  
  
    -   Eine Zielressource außerhalb des Pakets.  
  
-   Eine Beziehung Teil-Ebene (erstellt, indem die <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> Methode) bezieht sich eine Quelle <xref:System.IO.Packaging.PackagePart> entweder:  
  
    -   Ein anderes Ziel-Webpart im Paket.  
  
    -   Eine Zielressource außerhalb des Pakets.  
  
 Die Beziehung Quelle <xref:System.IO.Packaging.Package> oder Quelle <xref:System.IO.Packaging.PackagePart> gilt, dass der "Besitzer" der Beziehung.  Wenn das Quellobjekt, das gelöscht wird, werden alle Beziehungen, die das Quellobjekt, das im Besitz ebenfalls gelöscht.  Der Prozess zum Erstellen oder Löschen einer Beziehung werden nicht physisch entweder am Quell- oder Zielspeicherort Objekte in keiner Weise geändert werden.  
  
 Ein <xref:System.IO.Packaging.PackageDigitalSignature> ("digitale Signatur") ist eine Zusammenstellung von Teile und Beziehungen, die eine digitale Signatur enthaltene darstellt eine <xref:System.IO.Packaging.Package>.  Die digitale Signatur der Absender identifiziert und überprüft, dass die signierten Teile und Beziehungen in enthalten die <xref:System.IO.Packaging.Package> nicht geändert wurden.  
  
 Pakete unterstützen auch Digital Rights Management (DRM) dadurch Inhaltselemente in einem <xref:System.IO.Packaging.Package> mit bestimmten Zugriffsrechten auf autorisierte Benutzer verschlüsselt werden.  
  
 Basierend auf den <xref:System.IO.Packaging.Package> Architektur, eine <xref:System.Windows.Xps.Packaging.XpsDocument> ist ein Paket zum Speichern von Dokumenten, die basierend auf der Open entwickelt [XML Paper Specification (XPS)](http://go.microsoft.com/fwlink/?LinkID=65761).  
  
 .NET Framework verwendet Pakete zum Speichern von Inhalt, Ressourcen und Beziehungen für Seiten und Dokumente mithilfe einer standard-ZIP-Datei wird standardmäßig an. Wie bei jeder ZIP-Datei die Anwendung die <xref:System.IO.Packaging> Klassen zum Speichern und optional alle Typ oder die Anzahl der Dateien in einem einzelnen Container Zugriff zu schützen.  
  
 Weitere Informationen finden Sie in der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die grundlegenden Schritte zum Erstellen einer <xref:System.IO.Packaging.Package>.  In diesem Beispiel wird ein Paket erstellt, um ein Dokument sowie ein Bild enthalten, die als Teil des Dokuments angezeigt wird.  (Dies ist vergleichbar mit der Fall, in dem eine HTML-Datei hat, eine \<IMG >-Tag, das eine externe Bilddatei verweist.)  Zwei <xref:System.IO.Packaging.PackageRelationship> Elemente sind ebenfalls im Paket enthalten.  Die erste Seite einer Beziehung "Paketebene" definiert den Dokumentteil als Stammelement des Pakets an.  Eine zweite Beziehung "auf" definiert die Zuordnung zwischen den Dokumentteil (der "Quelle" der Beziehung Teil-Ebene) und dessen Verwendung des Image Teils (der "Target" der Beziehung Teil-Ebene).  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Packaging.PackagePart" />
    <altmember cref="T:System.Windows.Xps.Packaging.XpsDocument" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Packaging.Package" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Die Datei-E/A-Berechtigungen für das Paket.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Packaging.Package" />-Klasse, die einen angegebenen <see cref="T:System.IO.FileAccess" /> verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> wird von ein geschützter Konstruktor, der die <xref:System.IO.Packaging.Package> abstrakte Basisklasse. Beim Aufruf in einer abgeleiteten Klasse die <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor initialisiert eine neue Instanz der abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="openFileAccess" /> ist ungültig.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (openFileAccess As FileAccess, streaming As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Package(System::IO::FileAccess openFileAccess, bool streaming);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">Die Datei-E/A-Berechtigungen für das Paket.</param>
        <param name="streaming">
          <see langword="true" />, um das Paket für Streaming zu öffnen, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.Packaging.Package" />-Klasse, die einen angegebenen <see cref="T:System.IO.FileAccess" /> und eine angegebene Streamingoption verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A> wird von ein geschützter Konstruktor, der die <xref:System.IO.Packaging.Package> abstrakten Basisklasse. Beim Aufruf in einer abgeleiteten Klasse die <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor initialisiert eine neue Instanz der abgeleiteten Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="openFileAccess" /> ist ungültig.</exception>
        <altmember cref="P:System.IO.Packaging.Package.FileOpenAccess" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert und schließt das Paket sowie alle zugrunde liegenden Partstreams.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die <xref:System.IO.Packaging.Package> Klasse <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> führen den gleichen Vorgang – es besteht kein Grund Aufrufen <xref:System.IO.Packaging.Package.Dispose%2A> beim Aufrufen <xref:System.IO.Packaging.Package.Close%2A>, oder umgekehrt.  
  
 <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> intern rufen <xref:System.IO.Packaging.Package.Flush%2A>.  
  
> [!NOTE]
>  Die `using` Anweisung (sich von der `using` Namespacedirektive) ist die empfohlene Vorgehensweise für <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> eines Pakets.  [Schreiben einen Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055) und [lesen eine Package Sample](http://go.microsoft.com/fwlink/?LinkID=160034) wird gezeigt, wie schließen und Freigeben von einem Paket mithilfe der `using` Anweisung.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt ein neues Paketpart.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Initialisiert eine leere <xref:System.IO.Stream> des neuen Teils.  Die <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Methode kann verwendet werden, um einen Verweis auf die Streaminstanz, die dem Teil zugeordnet zu erhalten.  
  
 Weitere Informationen zu paketteilen, finden Sie in Abschnitt 1.1 der Spezifikation (Open Packaging Conventions, OPC) zum Download zur Verfügung, die am [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.PackagePart> und speichern Sie Daten in den Teil.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> Intern ruft die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> Methode, um das Element zu erstellen basierend auf das physische Format in der abgeleiteten Klasse implementiert.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreatePart (partUri As Uri, contentType As String) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] des neuen Teils.</param>
        <param name="contentType">Der Inhaltstyp des Datenstreams.</param>
        <summary>Erstellt ein neues unkomprimiertes Part mit einem angegebenen URI und Inhaltstyp.</summary>
        <returns>Das neu erstellte Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A> Initialisiert eine leere <xref:System.IO.Stream> des neuen Teils.  Die <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Methode kann verwendet werden, um einen Verweis auf die Streaminstanz, die dem Teil zugeordnet zu erhalten.  
  
 Das Webpart <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> ist <xref:System.IO.Packaging.CompressionOption.NotCompressed?displayProperty=nameWithType>.  
  
 Weitere Informationen zu paketteilen, finden Sie im Abschnitt 1.1 in der Spezifikation (Open Packaging Conventions, OPC) zum Download zur Verfügung, die am [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.PackagePart> und speichern Sie Daten in den Teil.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> oder <paramref name="contentType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Im Paket ist bereits ein Part mit dem angegebenen <paramref name="partUri" /> vorhanden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt (es kann kein neues Part hinzugefügt werden).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" /> Intern ruft der abgeleiteten Klasse <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> Methode, um das Element zu erstellen basierend auf das physische Format in der abgeleiteten Klasse implementiert.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ CreatePart(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] des neuen Teils.</param>
        <param name="contentType">Der Inhaltstyp des Datenstreams.</param>
        <param name="compressionOption">Die Komprimierungsoption für den Datenstream, <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> oder <see cref="F:System.IO.Packaging.CompressionOption.Normal" />-Komprimierung.</param>
        <summary>Erstellt ein neues Part mit einem angegebenen URI, einem angegebenen Inhaltstyp und einer angegebenen Komprimierungsoption.</summary>
        <returns>Das neu erstellte Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für den standardmäßigen <xref:System.IO.Packaging.ZipPackage> abgeleitete Klasse, die <xref:System.IO.Packaging.Package.CreatePart%2A> Methode unterstützt nur zwei `compressionOption` Werte <xref:System.IO.Packaging.CompressionOption.NotCompressed> oder <xref:System.IO.Packaging.CompressionOption.Normal> Komprimierung.  Andere <xref:System.IO.Packaging.CompressionOption> Werte <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, oder <xref:System.IO.Packaging.CompressionOption.SuperFast> verwenden <xref:System.IO.Packaging.CompressionOption.Normal> Komprimierung.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A> erstellt ein leeres <xref:System.IO.Stream> des neuen Teils.  Die <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> Methode kann verwendet werden, um einen Verweis auf die Streaminstanz, die dem Teil zugeordnet zu erhalten.  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.PackagePart> und speichern Sie Daten in den Teil.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> oder <paramref name="contentType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Im Paket ist bereits ein Part mit dem angegebenen <paramref name="partUri" /> vorhanden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="compressionOption" />-Wert ist nicht zulässig.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt (es kann kein neues Part hinzugefügt werden).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> Intern ruft der abgeleiteten Klasse <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> Methode, um das Element zu erstellen basierend auf das physische Format in der abgeleiteten Klasse implementiert.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.ZipPackagePart" />
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ CreatePartCore(Uri ^ partUri, System::String ^ contentType, System::IO::Packaging::CompressionOption compressionOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] für das erstellte Part.</param>
        <param name="contentType">Der Inhaltstyp des Datenstreams.</param>
        <param name="compressionOption">Die Komprimierungsoption für den Datenstream.</param>
        <summary>Erstellt beim Überschreiben in einer abgeleiteten Klasse ein neues Part im Paket.</summary>
        <returns>Das erstellte Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die abgeleitete <xref:System.IO.Packaging.Package.CreatePartCore%2A> Methode wird aufgerufen, indem Sie die <xref:System.IO.Packaging.Package.CreatePart%2A> Methode, um ein Element zu erstellen, basierend auf das physische Format in der abgeleiteten Klasse implementiert.  
  
 Wird standardmäßig ein <xref:System.IO.Packaging.ZipPackage> Implementierung der abstrakten Klasse abgeleitet <xref:System.IO.Packaging.Package> Klasse bereitgestellt und verwendet wird.  In der Standardvorgang <xref:System.IO.Packaging.Package.CreatePart%2A> intern ruft <xref:System.IO.Packaging.Package.CreatePartCore%2A> von der <xref:System.IO.Packaging.ZipPackage> Klasse, um ein neues Teil in einer Zipdatei zu erstellen.  
  
 Für den standardmäßigen <xref:System.IO.Packaging.ZipPackage> abgeleitete Klasse, die <xref:System.IO.Packaging.Package.CreatePartCore%2A> Methode unterstützt nur zwei `compressionOption` Werte <xref:System.IO.Packaging.CompressionOption.NotCompressed> oder <xref:System.IO.Packaging.CompressionOption.Normal> Komprimierung.  Andere <xref:System.IO.Packaging.CompressionOption> Werte <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, oder <xref:System.IO.Packaging.CompressionOption.SuperFast> verwenden <xref:System.IO.Packaging.CompressionOption.Normal> Komprimierung.  
  
 Weitere Informationen zum Paketmodell und paketteilen finden Sie unter Chapter 1 der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die abgeleitete <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> Implementierung sollten keine Annahmen über die Reihenfolge oder Operationen der <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> Methode, die ihn aufruft.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Beziehung auf Paketebene zu einem angegebenen Part.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen das Paket und ein Zielteil der zugeordneten oder eine Ressource.  Eine Beziehung auf Paketebene kann zwei Formen besitzen.  
  
-   Zwischen einer <xref:System.IO.Packaging.Package> an ein Ziel <xref:System.IO.Packaging.PackagePart> innerhalb des Pakets.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> mit einer Zielressource außerhalb des Pakets.  
  
 In einer Beziehung auf Paketebene gilt das Paket der "Besitzer" der Beziehung.  Wenn das Paket gelöscht wird, werden alle Beziehungen, die im Besitz des Pakets ebenfalls gelöscht.  Der Prozess zum Erstellen oder Löschen der Beziehung wird nicht physisch der Zielteil bzw. die Ressource in irgendeiner Weise verändert.  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Erstellung einer <xref:System.IO.Packaging.PackageRelationship> zwischen einem <xref:System.IO.Packaging.Package> und Stammteil Dokument.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] des Zielteils.</param>
        <param name="targetMode">Gibt an, ob das Zielpart<see cref="F:System.IO.Packaging.TargetMode.Internal" /> oder <see cref="F:System.IO.Packaging.TargetMode.External" /> für das Paket ist.</param>
        <param name="relationshipType">Ein URI, der die Rolle der Beziehung eindeutig definiert.</param>
        <summary>Erstellt eine Beziehung auf Paketebene zu einem Part mit einem angegebenen URI, einem angegebenen Zielmodus und einem angegebenen Beziehungstyp.</summary>
        <returns>Die Beziehung auf Paketebene zu dem angegebenen Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen das Paket und ein Zielteil der zugeordneten oder eine Ressource.  Eine Beziehung auf Paketebene kann zwei Formen besitzen.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> an einen Zielteil des Pakets.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> mit einer Zielressource außerhalb des Pakets.  
  
 In einer Beziehung auf Paketebene gilt das Paket der "Besitzer" der Beziehung.  Wenn das Paket gelöscht wird, werden alle Beziehungen, die im Besitz des Pakets ebenfalls gelöscht.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> wird nicht physisch der Zielteil bzw. die Ressource in keiner Weise geändert.  
  
 Das Ziel einer Beziehung kann nicht auf eine andere Beziehung sein.  
  
 Wenn `targetMode` angegeben ist, als <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` muss ein relativer URI, der gemäß der [RFC 3986](http://tools.ietf.org/html/rfc3986) generische Syntax Uniform Resource Identifier (URI)-Spezifikation.  Der interne relative URI kann entweder ein absoluter Pfad, der mit einem Schrägstrich ("/"), z. B. beginnt "/ page1.xaml" oder "/ /images/picture4.jpg", oder ein relativer Pfad wie ".. / imagespicture1.jpg ", die für das Stammverzeichnis des Pakets ("/ ") als Basis-URI auflöst.  
  
 Wenn `targetMode` angegeben ist, als <xref:System.IO.Packaging.TargetMode.External>, `targetUri` kann entweder ein absoluter oder relativer URI angegeben wird, gemäß der [RFC 3986](http://tools.ietf.org/html/rfc3986) generische Syntax Uniform Resource Identifier (URI)-Spezifikation.  "http://www.microsoft.com/page2.xml" ist ein Beispiel für ein absoluter URI, der auf eine externe Zielressource "page2.xml" verweist.  "images/picture1.jpg" ist ein Beispiel für einen relativen URI, der auch eine externe Ressource "1.jpg" jedoch aufgelöst wird anhand des URI für das Paket selbst verweist.  
  
 `relationshipType` muss ein [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] , wird gebildet, gemäß der [RFC 3986](http://tools.ietf.org/html/rfc3986) generische Syntax Uniform Resource Identifier (URI)-Spezifikation.  Die folgende Tabelle zeigt die Paketebene `relationshipType` URIs durch die Spezifikation (Open Packaging Conventions, OPC) definiert.  
  
|Beziehung auf Paketebene|Beziehungstyp URI|  
|---------------------------------|---------------------------|  
|Haupteigenschaften|http://schemas.openxmlformats.org/package/2006/relationships/meta Daten/Core-Eigenschaften|  
|Digitale Signatur|http://schemas.openxmlformats.org/package/2006/relationships/digit Al-Signatur/Signatur|  
|Zertifikat für digitale Signaturen|http://schemas.openxmlformats.org/package/2006/relationships/digit Al-Signaturzertifikat|  
|Ursprung der digitalen Signatur|http://schemas.openxmlformats.org/package/2006/relationships/digit Al-Signatur/origin|  
|Miniaturansicht|http://schemas.openxmlformats.org/package/2006/relationships/meta Daten/Miniaturansicht|  
  
 Weitere Informationen zum Verpacken und paketbeziehungen finden Sie im Abschnitt 1.3 der Spezifikation (Open Packaging Conventions, OPC) zum Download zur Verfügung, die am [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie <xref:System.IO.Packaging.Package.CreateRelationship%2A> zum Erstellen einer <xref:System.IO.Packaging.PackageRelationship> zwischen einem <xref:System.IO.Packaging.Package> und Stammteil Dokument.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> oder <paramref name="relationshipType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="targetUri" />-Part ist eine <see cref="T:System.IO.Packaging.PackageRelationship" />, oder <paramref name="targetMode" /> ist <see cref="F:System.IO.Packaging.TargetMode.Internal" />, und <paramref name="targetUri" /> ist ein absoluter URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="targetMode" /> ist ungültig.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ CreateRelationship(Uri ^ targetUri, System::IO::Packaging::TargetMode targetMode, System::String ^ relationshipType, System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] des Zielteils.</param>
        <param name="targetMode">Gibt an, ob das Zielpart<see cref="F:System.IO.Packaging.TargetMode.Internal" /> oder <see cref="F:System.IO.Packaging.TargetMode.External" /> für das Paket ist.</param>
        <param name="relationshipType">Ein URI, der die Rolle der Beziehung eindeutig definiert.</param>
        <param name="id">Ein eindeutiger XML-Bezeichner.</param>
        <summary>Erstellt eine Beziehung auf Paketebene zu einem Part mit einem angegebenen URI, einem angegebenen Zielmodus, einem angegebenen Beziehungstyp und einer angegebenen [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>Die Beziehung auf Paketebene zu dem angegebenen Part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen das Paket und ein Zielteil der zugeordneten oder eine Ressource.  Eine Beziehung auf Paketebene kann zwei Formen besitzen.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> an einen Zielteil des Pakets.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> mit einer Zielressource außerhalb des Pakets.  
  
 In einer Beziehung auf Paketebene gilt das Paket der "Besitzer" der Beziehung.  Wenn das Paket gelöscht wird, werden alle Beziehungen, die im Besitz des Pakets ebenfalls gelöscht.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A> wird nicht physisch der Zielteil bzw. die Ressource in keiner Weise geändert.  
  
 Das Ziel einer Beziehung kann nicht auf eine andere Beziehung sein.  
  
 `id` Ein gültiger XML-Bezeichner muss sein.  Die `id` Typ lautet xsd: ID und muss den in der XML Schema Part 2: Datatypes-Spezifikation (finden Sie unter [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Wenn `id` angegeben ist, als `null` eine eindeutige ID wird automatisch generiert.  Ein `id` angegeben werden, indem Sie eine leere Zeichenfolge ist ungültig.  
  
 Wenn `targetMode` angegeben ist, als <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` muss ein relativer URI, der gemäß der [RFC 3986](http://tools.ietf.org/html/rfc3986) generische Syntax Uniform Resource Identifier (URI)-Spezifikation.  Der interne relative URI kann entweder ein absoluter Pfad, der mit einem Schrägstrich ("/"), z. B. beginnt "/ page1.xaml" oder "/ /images/picture4.jpg", oder ein relativer Pfad wie ".. / imagespicture1.jpg ", die für das Stammverzeichnis des Pakets ("/ ") als Basis-URI auflöst.  
  
 Wenn `targetMode` angegeben ist, als <xref:System.IO.Packaging.TargetMode.External>, `targetUri` kann entweder ein absoluter oder relativer URI angegeben wird, gemäß der [RFC 3986](http://tools.ietf.org/html/rfc3986) generische Syntax Uniform Resource Identifier (URI)-Spezifikation.  "http://www.microsoft.com/page2.xml" ist ein Beispiel für ein absoluter URI, der auf eine externe Zielressource "page2.xml" verweist.  "images/picture1.jpg" ist ein Beispiel für einen relativen URI, der auch eine externe Ressource "1.jpg" jedoch aufgelöst wird anhand des URI für das Paket selbst verweist.  
  
 `relationshipType` muss ein URI, der gemäß der [RFC 3986](http://tools.ietf.org/html/rfc3986) generische Syntax Uniform Resource Identifier (URI)-Spezifikation.  Die folgende Tabelle zeigt die Paketebene `relationshipType` URIs durch die Spezifikation (Open Packaging Conventions, OPC) definiert.  
  
|Beziehung auf Paketebene|Beziehungstyp URI|  
|---------------------------------|---------------------------|  
|Haupteigenschaften|http://schemas.openxmlformats.org/package/2006/relationships/meta Daten/Core-Eigenschaften|  
|Digitale Signatur|http://schemas.openxmlformats.org/package/2006/relationships/digit Al-Signatur/Signatur|  
|Zertifikat für digitale Signaturen|http://schemas.openxmlformats.org/package/2006/relationships/digit Al-Signaturzertifikat|  
|Ursprung der digitalen Signatur|http://schemas.openxmlformats.org/package/2006/relationships/digit Al-Signatur/origin|  
|Miniaturansicht|http://schemas.openxmlformats.org/package/2006/relationships/meta Daten/Miniaturansicht|  
  
 Weitere Informationen zum Verpacken und paketbeziehungen finden Sie im Abschnitt 1.3 der Spezifikation (Open Packaging Conventions, OPC) zum Download zur Verfügung, die am [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie <xref:System.IO.Packaging.Package.CreateRelationship%2A> zum Erstellen einer <xref:System.IO.Packaging.PackageRelationship> zwischen einem <xref:System.IO.Packaging.Package> und Stammteil Dokument.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> oder <paramref name="relationshipType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Das <paramref name="targetUri" />-Part ist eine <see cref="T:System.IO.Packaging.PackageRelationship" />, oder <paramref name="targetMode" /> ist <see cref="F:System.IO.Packaging.TargetMode.Internal" />, und <paramref name="targetUri" /> ist ein absoluter URI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="targetMode" /> ist ungültig.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> ist kein gültiger XML-Bezeichner, oder im Paket ist bereits ein Part mit der angegebenen <paramref name="id" /> vorhanden.</exception>
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeletePart (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeletePart(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] des zu löschenden Parts.</param>
        <summary>Löscht ein Part mit einem angegebenen URI aus dem Paket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri` ein relativer URI muss sein, die einen absoluten Pfad besteht aus der mit einem Schrägstrich ("/") beginnt.  Der absolute Pfad ist relativ zum Paketstamm und wird gebildet, gemäß der [RFC 3986](http://tools.ietf.org/html/rfc3986) generische Syntax Uniform Resource Identifier (URI)-Spezifikation.  "/ page1.xaml" und "/ /images/picture4.jpg" sind Beispiele für gültige Teil-URIs.  
  
 Es wird keine Ausnahme ausgelöst, wenn ein Teil mit dem angegebenen `partUri` ist nicht im Paket.  (Sie können die <xref:System.IO.Packaging.Package.PartExists%2A> Methode, um zu bestimmen, ob ein Teil mit einem angegebenen `partUri` im Paket ist.)  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> Intern ruft der abgeleiteten Klasse <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> Methode, um das Webpart tatsächlich löschen basierend auf das physische Format in der abgeleiteten Klasse implementiert.</para>
        </block>
        <altmember cref="Overload:System.IO.Packaging.Package.CreatePart" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeletePartCore (partUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeletePartCore(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der <see cref="P:System.IO.Packaging.PackagePart.Uri" /> des zu löschenden <see cref="T:System.IO.Packaging.PackagePart" />.</param>
        <summary>Löscht beim Überschreiben in einer abgeleiteten Klasse ein Part mit einem angegebenen URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.IO.Packaging.ZipPackage> Implementierung der abstrakten Klasse abgeleitet <xref:System.IO.Packaging.Package> Klasse bereitgestellt und verwendet wird.  In der Standardvorgang <xref:System.IO.Packaging.Package.DeletePart%2A> intern ruft <xref:System.IO.Packaging.Package.DeletePartCore%2A> von der <xref:System.IO.Packaging.ZipPackage> -Klasse, die tatsächlichen Löschvorgang basierend auf dem physischen Format in der abgeleiteten Klasse implementiert.  
  
 Weitere Informationen zum Paketmodell und paketteilen finden Sie unter Chapter 1 der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> Implementierung wird aufgerufen, indem Sie die <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> Methode mit dem angegebenen Webpart basierend auf das physische Format in der abgeleiteten Klasse implementiert.  
  
 Die abgeleitete <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> Implementierung sollten keine Annahmen über die Reihenfolge oder Operationen der <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> Methode, die ihn aufruft.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteRelationship (id As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteRelationship(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Der <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> des zu löschenden <see cref="T:System.IO.Packaging.PackageRelationship" />.</param>
        <summary>Löscht eine Beziehung auf Paketebene.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen das Paket und ein Zielteil der zugeordneten oder eine Ressource.  Eine Beziehung auf Paketebene kann zwei Formen besitzen.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> an einen Zielteil des Pakets.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> mit einer Zielressource außerhalb des Pakets.  
  
 In einer Beziehung auf Paketebene gilt das Paket der "Besitzer" der Beziehung.  Wenn das Paket gelöscht wird, werden alle Beziehungen, die im Besitz des Pakets ebenfalls gelöscht.  
  
 Es wird keine Ausnahme ausgelöst, wenn eine Beziehung mit dem angegebenen `id` ist nicht im Paket.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A> das Zielteil in keiner Weise werden nicht physisch geändert werden.  
  
 Weitere Informationen zu paketbeziehungen, finden Sie im Abschnitt 1.3 der Spezifikation (Open Packaging Conventions, OPC) zum Download zur Verfügung, die am [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> ist kein gültiger XML-Bezeichner.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Leert und speichert den Inhalt von allen Parts und Beziehungen, schließt das Paket und gibt alle Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um sicherzustellen, dass alle Änderungen ordnungsgemäß gespeichert wurden, <xref:System.IO.Packaging.Package.Dispose%2A> auch abschließt, wird geleert und schließt alle Teile und Beziehungen, die im Paket enthalten sind.  
  
 Für die <xref:System.IO.Packaging.Package> -Klasse, <xref:System.IO.Packaging.Package.Dispose%2A> und <xref:System.IO.Packaging.Package.Close%2A> führen den gleichen Vorgang: Es besteht kein Grund Aufrufen <xref:System.IO.Packaging.Package.Dispose%2A> beim Aufrufen <xref:System.IO.Packaging.Package.Close%2A>, oder umgekehrt.  
  
 <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> intern rufen <xref:System.IO.Packaging.Package.Flush%2A>.  
  
 Abgeleitete Klassen, die zuordnen und Verwalten von nicht-Speicherressourcen sollten diese Methode zum Freigeben von Ressourcen überschreiben beim <xref:System.IO.Packaging.Package.Dispose%2A> aufgerufen wird. Abgeleiteten Klasse überschreibt sollten auch aufrufen, <xref:System.IO.Packaging.Package.Flush%2A> und die Basisklasse <xref:System.IO.Packaging.Package.Dispose%2A> Methode, um sicherzustellen, dass diese Basisklasse der Cleanup wird immer ausgeführt.  
  
> [!NOTE]
>  Die `using` Anweisung (sich von der `using` Namespacedirektive) ist die empfohlene Vorgehensweise für <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> eines Pakets. [Schreiben einen Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055) wird gezeigt, wie schließen und Freigeben von einem Paket mithilfe der `using` Anweisung.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.Packaging.Package.Flush" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FileOpenAccess As FileAccess" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::FileAccess FileOpenAccess { System::IO::FileAccess get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Dateizugriffseinstellung für das Paket ab.</summary>
        <value>Einer der <see cref="T:System.IO.FileAccess" />-Werte: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" /> oder <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaft <xref:System.IO.Packaging.Package.FileOpenAccess%2A> hat keinen Standardwert.  Der Dateizugriff Einstellung wird angegeben, der <xref:System.IO.Packaging.Package.%23ctor%2A> Konstruktor aufrufen, wenn Sie ein neues Paket erstellen oder in der <xref:System.IO.Packaging.Package.Open%2A> aufgerufen wird, wenn Sie ein vorhandenes Paket öffnen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert die Inhalte von allen Parts und Beziehungen, die im Paket enthalten sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A> Intern ruft der abgeleiteten Klasse <xref:System.IO.Packaging.Package.FlushCore%2A> Implementierung die Format-spezifische Leerung ausführen.  Der abgeleiteten Klasse <xref:System.IO.Packaging.Package.FlushCore%2A> Methode ist verantwortlich für das Speichern von Inhalt der Rahmen und Beziehung tatsächlich für die Implementierung von bestimmten physischen abgeleiteten Klasse.  
  
 Wird standardmäßig ein <xref:System.IO.Packaging.ZipPackage> Implementierung der abstrakten abgeleiteten <xref:System.IO.Packaging.Package> Basisklasse bereitgestellt und verwendet wird. In der Standardvorgang <xref:System.IO.Packaging.Package.Flush%2A> intern ruft <xref:System.IO.Packaging.Package.FlushCore%2A> um die Teile und Beziehungen in einem ZIP-Datei-Paket zu speichern.  
  
 <xref:System.IO.Packaging.Package.Flush%2A> wird aufgerufen, automatisch von der <xref:System.IO.Packaging.Package.Close%2A> und <xref:System.IO.Packaging.Package.Dispose%2A> Methoden.  Wenn <xref:System.IO.Packaging.Package.Close%2A> oder <xref:System.IO.Packaging.Package.Dispose%2A> wird aufgerufen, Sie müssen keine Aufrufen <xref:System.IO.Packaging.Package.Flush%2A> getrennt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist schreibgeschützt und kann nicht geändert werden.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.Flush" /> Intern ruft der abgeleiteten Klasse <see cref="M:System.IO.Packaging.Package.FlushCore" /> Methode auf, um das Webpart leeren basierend auf das physische Format in der abgeleiteten Klasse implementiert.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FlushCore ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FlushCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Speichert beim Überschreiben in einer abgeleiteten Klasse die Inhalte aller Parts und Beziehungen im Speicher der abgeleiteten Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A> wird aufgerufen, indem Sie die <xref:System.IO.Packaging.Package.Flush%2A> Methode zum Ausführen der Leerung basierend auf das physische Format in der abgeleiteten Klasse implementiert.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die abgeleitete <see cref="M:System.IO.Packaging.Package.FlushCore" /> Implementierung sollten keine Annahmen über die Reihenfolge oder Operationen der <see cref="M:System.IO.Packaging.Package.Flush" /> Methode, die ihn aufruft.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPart (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePart ^ GetPart(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] des zurückzugebenden Parts.</param>
        <summary>Gibt das Part mit einem angegebenen URI zurück.</summary>
        <returns>Das Part mit dem angegebenen <paramref name="partUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn ein Teil mit dem angegebenen `partUri` ist nicht vorhanden.  
  
 Die <xref:System.IO.Packaging.Package.PartExists%2A> Methode kann verwendet werden, um zu bestimmen, ob `partUri` verweist auf einen vorhandenen Teil.  
  
 Wird standardmäßig ein <xref:System.IO.Packaging.ZipPackage> Implementierung der abstrakten abgeleiteten <xref:System.IO.Packaging.Package> Basisklasse bereitgestellt und verwendet wird.  In der Standardvorgang <xref:System.IO.Packaging.Package.GetPart%2A> intern ruft <xref:System.IO.Packaging.Package.GetPartCore%2A> von der <xref:System.IO.Packaging.ZipPackage> Klasse, um eine angeforderte Teil aus einem ZIP-Datei zurückzugeben.  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht das Suchen, abrufen und lesen die Teile, die in einem Paket enthalten sind.  Das vollständige Beispiel finden Sie unter [lesen eine Package Sample](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Ein Part mit dem angegebenen <paramref name="partUri" /> ist nicht im Paket enthalten.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> Intern ruft die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> Methode auf, um das Webpart leeren basierend auf das physische Format in der abgeleiteten Klasse implementiert.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetParts" />
        <altmember cref="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartCore (partUri As Uri) As PackagePart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IO::Packaging::PackagePart ^ GetPartCore(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] des abzurufenden Parts.</param>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse das von einem angegebenen URI adressierte Part zurück.</summary>
        <returns>Das angeforderte Part oder <see langword="null" />, wenn kein Part mit dem angegebenen <paramref name="partUri" /> im Paket vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird standardmäßig ein <xref:System.IO.Packaging.ZipPackage> Implementierung der abstrakten abgeleiteten <xref:System.IO.Packaging.Package> Klasse bereitgestellt und verwendet wird.  In der Standardvorgang <xref:System.IO.Packaging.Package.GetPart%2A> intern ruft <xref:System.IO.Packaging.Package.GetPartCore%2A> von der <xref:System.IO.Packaging.ZipPackage> Klasse, um einen Teil aus einem ZIP-Datei abzurufen.  
  
 Weitere Informationen zum Paketmodell und paketteilen finden Sie unter Chapter 1 der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> Implementierung wird aufgerufen, indem Sie die <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> Methode zugreifen und Zurückgeben des angegebenen Teils basierend auf das physische Format in der abgeleiteten Klasse implementiert.  
  
 Die abgeleitete <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> Implementierung sollten keine Annahmen über die Reihenfolge oder Operationen der <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> Methode, die ihn aufruft.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartsCore" />
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParts () As PackagePartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackagePartCollection ^ GetParts();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Auflistung aller Parts im Paket zurück.</summary>
        <returns>Eine Auflistung aller <see cref="T:System.IO.Packaging.PackagePart" />-Elemente, die im Paket enthalten sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A> Gibt eine Auflistung aller Teile, die enthalten sind, im Paket, einschließlich <xref:System.IO.Packaging.PackageRelationship> teilen.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A> wird niemals zurückgegeben `null`, aber die zurückgegebene Auflistung enthält 0 (null) Elemente aus, wenn das Paket keine Teile enthält.  
  
 Wird standardmäßig ein <xref:System.IO.Packaging.ZipPackage> Implementierung der abstrakten abgeleiteten <xref:System.IO.Packaging.Package> Basisklasse bereitgestellt und verwendet wird.  In der Standardvorgang <xref:System.IO.Packaging.Package.GetParts%2A> Aufrufe der <xref:System.IO.Packaging.Package.GetPartsCore%2A> Methode der <xref:System.IO.Packaging.ZipPackage> Klasse, um die Teile aus einem ZIP-Datei zurückzugeben.  
  
 Weitere Informationen zu Paketen und paketteilen finden Sie in Abschnitt 1.1 der Spezifikation (Open Packaging Conventions, OPC) zum Download zur Verfügung, die am [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.IO.Packaging.Package.GetParts%2A> Methode zum Abrufen einer Auflistung der Teile, die in enthaltenen eine <xref:System.IO.Packaging.Package>.  Die vollständige Programmquellcode finden Sie unter [Erstellen eines Pakets mit einer digitalen Signatur](http://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetParts" /> Intern ruft die abgeleitete Klasse <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> Methode auf, um das Webpart leeren basierend auf das physische Format in der abgeleiteten Klasse implementiert.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPartsCore () As PackagePart()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::IO::Packaging::PackagePart ^&gt; ^ GetPartsCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse ein Array aller Parts im Paket zurück.</summary>
        <returns>Ein Array aller Parts, die im Paket enthalten sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die abgeleitete Klasse <xref:System.IO.Packaging.Package.GetPartsCore%2A> Implementierung wird aufgerufen, indem Sie die <xref:System.IO.Packaging.Package.GetParts%2A> Methode, um Zugriff auf und gibt das Array der Teile zurück basierend auf das physische Format in der abgeleiteten Klasse implementiert.  
  
 Wird standardmäßig ein <xref:System.IO.Packaging.ZipPackage> Implementierung der abstrakten abgeleiteten <xref:System.IO.Packaging.Package> Klasse bereitgestellt und verwendet wird.  In der Standardvorgang <xref:System.IO.Packaging.Package.GetParts%2A> intern ruft <xref:System.IO.Packaging.Package.GetPartCore%2A> von der <xref:System.IO.Packaging.ZipPackage> Klasse, um die Teile aus einem ZIP-Datei abzurufen.  
  
 Weitere Informationen zum Paketmodell und paketteilen finden Sie unter Chapter 1 der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Die abgeleitete <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> Implementierung sollten keine Annahmen über die Reihenfolge oder Operationen der <see cref="M:System.IO.Packaging.Package.GetParts" /> Methode, die ihn aufruft.</para>
        </block>
        <altmember cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationship (id As String) As PackageRelationship" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationship ^ GetRelationship(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> der zurückzugebenden Beziehung.</param>
        <summary>Gibt die Beziehung auf Paketebene zu einem angegebenen Bezeichner zurück.</summary>
        <returns>Die Beziehung auf Paketebene mit der angegebenen <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id` Ein gültiger XML-Bezeichner muss sein.  Die `id` Typ lautet xsd: ID und muss den in der XML Schema Part 2: Datatypes-Spezifikation (finden Sie unter [ https://www.w3.org/TR/xmlschema-2/#ID ](https://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Weitere Informationen zum Verpacken und paketbeziehungen finden Sie im Abschnitt 1.3 der Spezifikation (Open Packaging Conventions, OPC) zum Download zur Verfügung, die am [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> ist kein gültiger XML-Bezeichner.</exception>
        <exception cref="T:System.InvalidOperationException">Das Paket enthält keine Beziehung mit der angegebenen <paramref name="id" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationships () As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationships();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Auflistung aller Beziehungen auf Paketebene zurück.</summary>
        <returns>Eine Auflistung aller Beziehungen auf Paketebene, die im Paket enthalten werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> wird niemals zurückgegeben `null`; jedoch die zurückgegebene Auflistung 0 (null) Elemente enthalten kann, wenn das Paket keine Paketebene Beziehungen enthält.  
  
 Eine Beziehung auf Paketebene definiert eine Zuordnung zwischen das Paket und ein Zielteil der zugeordneten oder eine Ressource.  Eine Beziehung auf Paketebene kann zwei Formen besitzen.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> an einen Zielteil des Pakets.  
  
-   Zwischen einem <xref:System.IO.Packaging.Package> mit einer Zielressource außerhalb des Pakets.  
  
 In einer Beziehung auf Paketebene gilt das Paket der "Besitzer" der Beziehung.  Wenn das Paket gelöscht wird, werden alle Beziehungen, die im Besitz des Pakets ebenfalls gelöscht.  Der Prozess zum Erstellen oder Löschen der Beziehung wird nicht physisch der Zielteil bzw. die Ressource in irgendeiner Weise verändert.  
  
 Weitere Informationen zum Verpacken und paketbeziehungen finden Sie im Abschnitt 1.3 der Spezifikation (Open Packaging Conventions, OPC) zum Download zur Verfügung, die am [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipsByType (relationshipType As String) As PackageRelationshipCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Packaging::PackageRelationshipCollection ^ GetRelationshipsByType(System::String ^ relationshipType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">Der <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />, der verglichen und in der Auflistung zurückgegeben werden soll.</param>
        <summary>Gibt eine Auflistung aller Beziehungen auf Paketebene zurück, die mit einem angegebenen <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> übereinstimmen.</summary>
        <returns>Eine Auflistung der Beziehungen auf Paketebene, die mit dem angegebenen <paramref name="relationshipType" /> übereinstimmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A> wird niemals zurückgegeben `null`; jedoch die zurückgegebene Auflistung 0 (null) Elemente enthalten kann, wenn es sind keine Paketebene Beziehungen, die mit der angegebenen Zeichenfolge `relationshipType`.  
  
 Die folgende Tabelle zeigt die Paketebene `relationshipType` URIs durch die Spezifikation (Open Packaging Conventions, OPC) definiert.  
  
|Beziehung auf Paketebene|Beziehungstyp URI|  
|---------------------------------|---------------------------|  
|Haupteigenschaften|http://schemas.openxmlformats.org/package/2006/relationships/meta Daten/Core-Eigenschaften|  
|Digitale Signatur|http://schemas.openxmlformats.org/package/2006/relationships/digit Al-Signatur/Signatur|  
|Zertifikat für digitale Signaturen|http://schemas.openxmlformats.org/package/2006/relationships/digit Al-Signaturzertifikat|  
|Ursprung der digitalen Signatur|http://schemas.openxmlformats.org/package/2006/relationships/digit Al-Signatur/origin|  
|Miniaturansicht|http://schemas.openxmlformats.org/package/2006/relationships/meta Daten/Miniaturansicht|  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die Beziehungen abrufen, die für das Paket definiert wurden.  Das vollständige Beispiel finden Sie unter [lesen eine Package Sample](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" /> ist eine leere Zeichenfolge.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.GetRelationships" />
        <altmember cref="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
        <altmember cref="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Öffnet ein Paket.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.Package> integriert, die <xref:System.IO.Packaging.PackageRelationship> und <xref:System.IO.Packaging.PackagePart> Elemente zusammen mit gespeicherten Daten.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der E/A-Stream, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet ein Paket in einem angegebenen E/A-Stream.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Für das zu öffnende Paket ist eine Lese- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist lesegeschützt. Oder für das zu öffnende Paket ist eine Schreib- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <summary>Öffnet ein Paket mit einem angegebenen Pfad und Dateinamen.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Dies <xref:System.IO.Packaging.Package.Open%2A> Methode öffnet das Paket mit dem Standardattribute <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, und <xref:System.IO.FileShare.None> (zur Angabe von verschiedene Attributen verwenden Sie eine der anderen Überladungen auf Open-Methode).  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.Package> integriert, die <xref:System.IO.Packaging.PackageRelationship> und <xref:System.IO.Packaging.PackagePart> Elemente zusammen mit gespeicherten Daten.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">Der E/A-Stream, in dem das Paket geöffnet werden soll.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet ein Paket mit einem angegebenen E/A-Stream und Dateimodus.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Der <paramref name="packageMode" />-Wert ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Für das zu öffnende Paket ist eine Lese- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist lesegeschützt. Oder für das zu öffnende Paket ist eine Schreib- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet mithilfe einer angegebenen Dateimethode ein Paket in einem angegebenen Pfad.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Dies <xref:System.IO.Packaging.Package.Open%2A> Methode öffnet das Paket mit dem Standardattribute <xref:System.IO.FileAccess.ReadWrite> und <xref:System.IO.FileShare.None> (zur Angabe von verschiedene Attributen verwenden Sie eine der anderen Überladungen auf Open-Methode).  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.Package> integriert, die <xref:System.IO.Packaging.PackageRelationship> und <xref:System.IO.Packaging.PackagePart> Elemente zusammen mit gespeicherten Daten.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::IO::Stream ^ stream, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">Der E/A-Stream, in dem das Paket geöffnet werden soll.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <param name="packageAccess">Der Dateizugriff, mit dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet ein Paket mit einem angegebenen E/A-Stream, einem angegebenen Dateimodus und einer angegebenen Dateizugriffseinstellung.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" /> oder <paramref name="packageAccess" /> ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Für das zu öffnende Paket ist eine Lese- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist lesegeschützt. Oder für das zu öffnende Paket ist eine Schreib- oder Lese-/Schreibberechtigung erforderlich, und der angegebene <paramref name="stream" /> ist schreibgeschützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <param name="packageAccess">Der Dateizugriff, mit dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet mit einem angegebenen Dateimodus und einer angegebenen Dateizugriffseinstellung ein Paket in einem angegebenen Pfad.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Dies <xref:System.IO.Packaging.Package.Open%2A> Methode öffnet das Paket hat den Standardwert <xref:System.IO.FileShare.None> Attribut (So geben Sie ein anderes Attribut mithilfe der <xref:System.IO.Packaging.Package.Open%2A> methodenüberladung).  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Öffnen und Lesen einer <xref:System.IO.Packaging.Package> enthält <xref:System.IO.Packaging.PackageRelationship> und <xref:System.IO.Packaging.PackagePart> Elemente zusammen mit gespeicherten Daten.  Das vollständige Beispiel finden Sie unter [lesen eine Package Sample](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" /> oder <paramref name="packageAccess" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (path As String, packageMode As FileMode, packageAccess As FileAccess, packageShare As FileShare) As Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Packaging::Package ^ Open(System::String ^ path, System::IO::FileMode packageMode, System::IO::FileAccess packageAccess, System::IO::FileShare packageShare);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Der Pfad und Dateiname des Pakets.</param>
        <param name="packageMode">Der Dateimodus, in dem das Paket geöffnet werden soll.</param>
        <param name="packageAccess">Der Dateizugriff, mit dem das Paket geöffnet werden soll.</param>
        <param name="packageShare">Der Dateifreigabemodus, in dem das Paket geöffnet werden soll.</param>
        <summary>Öffnet mit einem angegebenen Dateimodus, einer angegebenen Dateizugriffseinstellung und einer angegebenen Dateifreigabeeinstellung ein Paket in einem angegebenen Pfad.</summary>
        <returns>Das geöffnete Paket.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage> ist der Standardtyp für das Paket, mit dem die <xref:System.IO.Packaging.Package.Open%2A> Methode.  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 Im folgende Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.IO.Packaging.Package> integriert, die <xref:System.IO.Packaging.PackageRelationship> und <xref:System.IO.Packaging.PackagePart> Elemente zusammen mit gespeicherten Daten.  Das vollständige Beispiel finden Sie unter [Writing a Package Sample](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert für <paramref name="packageMode" />, <paramref name="packageAccess" /> oder <paramref name="packageShare" /> ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PackageProperties As PackageProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Packaging::PackageProperties ^ PackageProperties { System::IO::Packaging::PackageProperties ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Haupteigenschaften des Pakets ab.</summary>
        <value>Die Haupteigenschaften des Pakets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu den Paketeigenschaften Core, finden Sie unter Abschnitt 3.1 in der Spezifikation (Open Packaging Conventions, OPC) zum Download zur Verfügung, die unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PartExists (partUri As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PartExists(Uri ^ partUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">Der zu überprüfende <see cref="T:System.Uri" /> des Parts.</param>
        <summary>Gibt an, ob ein Part mit einem angegebenen URI im Paket vorhanden ist.</summary>
        <returns>
          <see langword="true" />, wenn ein Part mit dem angegebenen <paramref name="partUri" /> im Paket enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `partUri` muss mit einem Schrägstrich beginnen "/" und aus dem Stammverzeichnis des Pakets absolut sein.  
  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" /> ist kein gültiger <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt (Informationen können nicht gelesen werden).</exception>
        <altmember cref="M:System.IO.Packaging.PackUriHelper.CreatePartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.GetPartUri(System.Uri)" />
        <altmember cref="M:System.IO.Packaging.PackUriHelper.ResolvePartUri(System.Uri,System.Uri)" />
        <altmember cref="T:System.IO.Packaging.PackagePart" />
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RelationshipExists (id As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RelationshipExists(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Die zu überprüfende <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> der Beziehung.</param>
        <summary>Gibt an, ob eine Beziehung auf Paketebene mit einer angegebenen ID im Paket enthalten ist.</summary>
        <returns>
          <see langword="true" />, wenn eine Beziehung auf Paketebene mit der angegebenen <paramref name="id" /> im Paket vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter der Spezifikation (Open Packaging Conventions, OPC) zum Download verfügbar unter [ http://go.microsoft.com/fwlink/?LinkID=71255 ](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" /> ist kein gültiger XML-Bezeichner.</exception>
        <exception cref="T:System.ObjectDisposedException">Das Paket ist nicht geöffnet (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> oder <see cref="M:System.IO.Packaging.Package.Close" /> wurde aufgerufen).</exception>
        <exception cref="T:System.IO.IOException">Das Paket ist lesegeschützt.</exception>
        <altmember cref="T:System.IO.Packaging.PackageRelationship" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dieser Member unterstützt die [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]-Infrastruktur und ist nicht für die Anwendungsverwendung vorgesehen.  Verwenden Sie stattdessen die typsichere <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />-Methode.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>