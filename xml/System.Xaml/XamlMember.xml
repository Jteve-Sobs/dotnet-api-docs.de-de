<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6a1a3c6f21332c02e5194428660fd5b7fbc4bdf3" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70407106" /></Metadata><TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt den XAML-Typsystembezeichner für Member von XAML-Typen bereit. Der Bezeichner wird während der Verarbeitung von Memberknoten (wenn der XAML-Reader in einem <see cref="F:System.Xaml.XamlNodeType.StartMember" /> positioniert ist) von XAML-Readern und XAML-Writern sowie für die allgemeine XAML-Typsystemlogik verwendet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember>kann drei Methoden zum Zurückgeben von Informationen zu einem XAML-Member verwenden: Standard Common Language Runtime Reflektion (CLR). ein Verweis basiertes Reflektionsverfahren zum Aufrufen interner APIs, die optimierte Bitflags verwenden; oder Aufrufen von virtuellen über schreibungen der `Lookup*` API, die von möglichen <xref:System.Xaml.XamlMember> Unterklassen bereitgestellt wird. Für die meisten Verwendungen von .NET Framework XAML-Dienste <xref:System.Xaml.XamlMember> -APIs und der-API verwenden Sie den standardmäßigen XAML-Schema Kontext. Der standardmäßige XAML-Schema Kontext für .NET Framework XAML-Dienste verwendet die CLR-Unterstützung für das Typsystem. Dadurch können XAML-Reader und XAML-Writer mit allen Typen oder Membern arbeiten, die in der CLR und den zugehörigen reflektionstechniken definiert bzw. anderweitig verfügbar sind.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>Suche * APIs und abgeleitete XamlMember-Klassen  
 <xref:System.Xaml.XamlMember>definiert mehrere virtuelle Member, die von abgeleiteten Klassen überschrieben werden können. Diese Member haben Namen, die immer mit der Zeichen `Lookup`Folge beginnen. Der Rest des API-namens verweist dann auf die Eigenschaft, die von der virtuellen Methode beeinflusst wird. Beispielsweise kann eine <xref:System.Xaml.XamlMember> abgeleitete Klasse über <xref:System.Xaml.XamlMember.LookupTargetType%2A> schreiben, um zu beeinflussen, was die <xref:System.Xaml.XamlMember.TargetType%2A> Basis definierte Eigenschaft in einer abgeleiteten Klasse zurückgibt. Sie können Rückgabewerte für diese Eigenschaften in <xref:System.Xaml.XamlMember> oder vorhandenen abgeleiteten Klassen Vorhersagen, indem Sie die Dokumentation für die relevanten `Lookup*` Methoden lesen.  
  
 Der Zweck `Lookup*` der Methoden besteht darin, eine XAML-Typsystem-Erweiterungs Technik bereitzustellen <xref:System.Xaml.XamlMember> , die die Basisklasse enthält. Durch Ableiten von <xref:System.Xaml.XamlMember> und überschreiben `Lookup` der virtuellen Member können Sie das Konzept eines XAML-Members für ein XAML-Schema in einem XAML-Typsystem definieren, ohne an die Besonderheiten eines Unterstützungs Typs System oder einer Technologie gebunden zu sein. Sie können auch einen bereitgestellten XAML-Schema Kontext unter diesem Schema verwenden und trotzdem die gewünschten Ergebnisse zurückgeben.  
  
 Sehen Sie sich als Beispiel die <xref:System.Xaml.XamlMember> - <xref:System.Xaml.XamlMember.IsWritePublic%2A>Eigenschaft an. Diese Eigenschaft informiert Aufrufer darüber, dass Vorgänge <xref:System.Xaml.XamlWriter> wie z. b. die Verwendung von für die Serialisierung einen Wert für diesen Member für ein Zielobjekt schreiben können. In der Standard Implementierung wird festgelegt, ob der Member beschreibbar ist, indem reflektionstechniken für die unterstützende <xref:System.Type> CLR und deren Member <xref:System.Reflection.MemberInfo>() verwendet werden. Daher ist das XAML-Typsystem standardmäßig vom CLR-Typsystem abhängig. Sie können diese Abhängigkeit jedoch für die XAML-Typsystem Berichterstattung von <xref:System.Xaml.XamlMember.IsWritePublic%2A> entfernen, indem Sie die-API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>überschreiben. Innerhalb der Überschreibung können Sie andere Determinationen verwenden, wie z. b. für Ihre technologiespezifische Metadaten, eine Master Such Tabelle, die für ein festes XAML-Vokabular optimiert ist, oder eine Vielzahl anderer Strategien, um zu bestimmen, ob ein XAML-Member in Ihrem XAML-Vokabular.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Erstellen von XamlMember ohne XAML-Schema Kontext  
 Die meisten Konstruktoren <xref:System.Xaml.XamlMember> von <xref:System.Xaml.XamlSchemaContext> erfordern als Teil der Initialisierung. Der <xref:System.Xaml.XamlSchemaContext> ist auch für viele interne <xref:System.Xaml.XamlSchemaContext> Vorgänge erforderlich, z. b. das Abrufen von Informationen, die vom Sicherungstyp weitergeleitet werden. Wenn Sie mit der <xref:System.Xaml.XamlMember> -API arbeiten, verfügen Sie in der Regel über einen <xref:System.Xaml.XamlSchemaContext> , der über ein umgebendes Konstrukt <xref:System.Xaml.XamlWriter>wie eine verfügbar ist. In diesem Fall können Sie den <xref:System.Xaml.XamlSchemaContext> Verweis an alle XAML-Typsystem Aufrufe übergeben, die einen XAML-Schema Kontext erfordern.  
  
 Ein bestimmter Konstruktor, <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>, <xref:System.Xaml.XamlSchemaContext>erfordert keine. Allerdings gibt <xref:System.Xaml.XamlMember> eine, die mit der <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> Signatur erstellt `true` wird <xref:System.Xaml.XamlMember.IsUnknown%2A>, für zurück.  
  
 Bei einem Auslastungs Pfad <xref:System.Xaml.XamlObjectWriter>, der einschließt, kann ein solcher Member nicht in ein Objekt Diagramm geschrieben werden. Mithilfe der .NET Framework XAML-Dienst Implementierung löst <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> der-Befehl <xref:System.Xaml.XamlObjectWriterException> eine aus, <xref:System.Xaml.XamlMember> wenn die <xref:System.Xaml.XamlMember.IsUnknown%2A>relevanten Berichte `true` für.  
  
 Sie sollten <xref:System.Xaml.XamlMember> keinen erstellen, der den `true` Wert für <xref:System.Xaml.XamlMember.IsUnknown%2A> hat, es sei denn, ihre Implementierung kann die <xref:System.Xaml.XamlObjectWriter>Ausnahmen von verarbeiten, oder Sie haben andere Möglichkeiten <xref:System.Xaml.XamlObjectWriter> , das Verhalten anzupassen. Beispielsweise kann eine oder mehrere der folgenden Aktionen für Ihre Implementierung zutreffen:  
  
-   Der XAML-Schema Kontext ist später verfügbar.  
  
-   Sie verwenden ein Element Aufruf Muster.  
  
-   Sie überschreiben <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> absichtlich in einem benutzerdefinierten XAML-Writer.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
    <related type="Article" href="https://msdn.microsoft.com/library/7c11abec-1075-474c-9d9b-778e5dab21c3">Grundlagen zu XAML-Knotenstreamstrukturen und -konzepten</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Die <see cref="T:System.Reflection.EventInfo" /> des CLR-Typsystems, die den Ereignismember darstellt.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse mit der <see cref="T:System.Reflection.EventInfo" /> des CLR-Typsystems und einem <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member ein Ereignis darstellt (Ereignishandler-Verbindungspunkt Eigenschaft).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Die <see cref="T:System.Reflection.PropertyInfo" /> des CLR-Typsystems, die den Eigenschaftsmember darstellt.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse mit der <see cref="T:System.Reflection.PropertyInfo" /> des CLR-Typsystems und einem <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member eine Eigenschaft darstellt (und insbesondere keine ereignishandlerverbindung ist).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Die <see cref="T:System.Reflection.EventInfo" /> des CLR-Typsystems, die den Ereignismember darstellt.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <param name="invoker">Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung, die die Reflektionslaufzeitaufrufe der <see cref="T:System.Xaml.XamlMember" />-Klasse verarbeitet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse mit der <see cref="T:System.Reflection.EventInfo" /> des CLR-Typsystems und einem <see cref="T:System.Xaml.XamlSchemaContext" />, einschließlich von <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Informationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member ein Ereignis (oder eine Verbindungspunkt Eigenschaft für den Ereignishandler) darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Die <see cref="T:System.Reflection.PropertyInfo" /> des CLR-Typsystems, die den Eigenschaftsmember darstellt.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <param name="invoker">Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung, die die Laufzeitaufrufe der <see cref="T:System.Xaml.XamlMember" />-Klasse verarbeitet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse mit Reflektions-<see cref="T:System.Reflection.PropertyInfo" /> und einem <see cref="T:System.Xaml.XamlSchemaContext" />, einschließlich von <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Informationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor nur, wenn der Member eine Eigenschaft darstellt und wenn es sich nicht um eine ereignishandlerverbindung handelt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Der Zeichenfolgenname des anfügbaren Ereignisses.</param>
        <param name="adder">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für die <see langword="Add" />-Methode des Handlers der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse für einen <see cref="T:System.Xaml.XamlMember" />, der ein anfügbares Ereignis darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member einen anfügbaren Ereignismember darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Zeichenfolgenname des Members.</param>
        <param name="declaringType">Die <see cref="T:System.Xaml.XamlType" />-Informationen für den deklarierenden Typ.</param>
        <param name="isAttachable"><see langword="true" />, um anzugeben, dass der Member anfügbar ist, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse mit einem Zeichenfolgennamen und deklarierenden <see cref="T:System.Xaml.XamlType" />-Informationen. Ein mit dieser Signatur erstellter <see cref="T:System.Xaml.XamlMember" /> weist deutliche Einschränkungen auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Xaml.XamlMember> , der mit der Signatur <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> erstellt wird, <xref:System.Xaml.XamlMember.IsUnknown%2A>die für zurück `true` gegeben wird.  
  
 Bei einem Auslastungs Pfad <xref:System.Xaml.XamlObjectWriter>, der einschließt, kann ein solcher Member nicht in ein Objekt Diagramm geschrieben werden. Mithilfe der .NET Framework XAML-Dienst Implementierung löst <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> der-Befehl <xref:System.Xaml.XamlObjectWriterException> eine aus, <xref:System.Xaml.XamlMember> wenn die <xref:System.Xaml.XamlMember.IsUnknown%2A>relevanten Berichte `true` für.  
  
 Sie <xref:System.Xaml.XamlMember> sollten keinen <xref:System.Xaml.XamlObjectWriter> mit <xref:System.Xaml.XamlMember.IsUnknown%2A> erstellen, es sei denn, die-Implementierung kann <xref:System.Xaml.XamlObjectWriter>die Ausnahmen von verarbeiten, oder Sie haben andere Möglichkeiten, das Verhalten anzupassen. `true` Beispielsweise kann eine oder mehrere der folgenden Aktionen für Ihre Implementierung zutreffen:  
  
-   Der XAML-Schema Kontext ist später verfügbar.  
  
-   Sie verwenden ein Element Aufruf Muster.  
  
-   Sie überschreiben <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> absichtlich in einem benutzerdefinierten XAML-Writer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> oder <paramref name="declaringType" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Der Zeichenfolgenname der anfügbaren Eigenschaft.</param>
        <param name="getter">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für den <see langword="get" />-Accessor der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="setter">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für den <see langword="set" />-Accessor der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse für ein <see cref="T:System.Xaml.XamlMember" />-Objekt, das eine anfügbare Eigenschaft darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member eine anfügbare Eigenschaft darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Der Zeichenfolgenname des anfügbaren Ereignisses.</param>
        <param name="adder">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für die <see langword="Add" />-Methode des Handlers der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <param name="invoker">Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung, die die Laufzeitaufrufe der <see cref="T:System.Xaml.XamlMember" />-Klasse verarbeitet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse für einen <see cref="T:System.Xaml.XamlMember" />, der ein anfügbares Ereignis darstellt, einschließlich von <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Informationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member einen anfügbaren Ereignismember darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Der Zeichenfolgenname der anfügbaren Eigenschaft.</param>
        <param name="getter">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für den <see langword="get" />-Accessor der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="setter">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für den <see langword="set" />-Accessor der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <param name="invoker">Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung, die die Laufzeitaufrufe der <see cref="T:System.Xaml.XamlMember" />-Klasse verarbeitet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse für einen <see cref="T:System.Xaml.XamlMember" />, der eine anfügbare Eigenschaft darstellt, einschließlich von <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Informationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member einen anfügbaren Eigenschaftenmember darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xaml.XamlType" />-Objekt für den Typ ab, durch den der dem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnete Member deklariert wird.</summary>
        <value>Das <see cref="T:System.Xaml.XamlType" />-Objekt für den Typ, durch den der dem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnete Member deklariert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird in der Regel während der Initialisierung festgelegt `null`und ist in der Regel nicht.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A>Informationen können von Konstruktoren für die Initialisierung übergeben werden. Durch Aufrufen von direkt in Basiskonstruktoren kann die <xref:System.Xaml.XamlMember> Initialisierung für abgeleitete Klassen einige der Wert Überprüfungen, die in der Basisklasse vorgenommen werden, weglassen. Daher kann die abgeleitete Initialisierung die gemeldeten Typmember-Beziehungs Informationen eines XAML-Members ändern, sodass Sie nicht mehr erwartungsgemäß mit den typsysteminformationen der zugrunde liegenden CLR-Deklaration ausgerichtet wird. Verwenden Sie für alle sicherheitskritischen Überprüfungen der Deklaration von Typinformationen stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt ab, das für verzögertes Laden von in XAML deklarierten Objekten verwendet wird.</summary>
        <value>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit <see cref="T:System.Xaml.XamlDeferringLoader" />-Einschränkung für den generischen Typ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.DeferringLoader%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> Dieses Verhalten tritt auf, wenn die anfängliche interne reflektionslogik die Informationen nicht bereits festgelegt hat.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Liste von <see cref="T:System.Xaml.XamlMember" />-Objekten ab. Von diesen werden die Member gemeldet, in denen Abhängigkeitsbeziehungen für die Initialisierungsreihenfolge relativ zu diesem <see cref="T:System.Xaml.XamlMember" />-Objekt vorhanden sind.</summary>
        <value>Eine Liste von <see cref="T:System.Xaml.XamlMember" />-Objekten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.DependsOn%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupDependsOn%2A> Dieses Verhalten tritt auf, wenn die anfängliche interne reflektionslogik die Informationen nicht bereits festgelegt hat.  
  
 Das `DependsOn` Muster kann auf Objektmodell Fälle angewendet werden, die absichtlich einer allgemeinen XAML-Regel widersprechen. Die allgemeine XAML-Regel besteht darin, dass Member eines Typs, die nicht als Initialisierungs Text (oder durch eine Factorymethode in XAML 2009) übermittelt werden können, in beliebiger Reihenfolge zugewiesen werden können. Indem Sie ein `DependsOn` Muster auf einen Member anwenden, können Sie XAML-Writer anweisen, den referenzierten Member immer vor diesem Member zu verarbeiten. Sie können dieses Muster in Situationen anwenden, in denen der Wert des aktuellen Members Kontext oder andere Informationen erfordert, die nur verfügbar sind, nachdem der andere Member festgelegt wurde.  
  
 Das `DependsOn` Muster sollte umsichtig angewendet und für Eigenschafts Szenarios reserviert werden, in denen es zu einem architektonischen Zweck dient. Eine große Anzahl von Abhängigkeiten hat die Möglichkeit, die XAML-Verarbeitung zu verlangsamen. Außerdem ist es möglich, zirkuläre Abhängigkeiten zu verursachen. in diesem Fall ist das XAML-Verarbeitungs Verhalten nicht definiert.  
  
 Beispiel `DependsOn` Szenarien aus WPF enthalten bestimmte <xref:System.Windows.Controls.ControlTemplate> Eigenschaften von und <xref:System.Windows.DataTemplate>, on <xref:System.Windows.Trigger>und on <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob das aktuelle Objekt einem anderen Objekt entspricht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das mit diesem Objekt verglichen werden soll.</param>
        <summary>Gibt an, ob das aktuelle Objekt einem anderen Objekt entspricht.</summary>
        <returns><see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="obj" />-Parameter ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
        <summary>Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
        <returns><see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für dieses Objekt zurück.</summary>
        <returns>Ein ganzzahliger Hashcode.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste von XAML-Namespaces zurück, in dem dieser XAML-Member vorhanden sein kann.</summary>
        <returns>Eine Liste von XAML-Namespacebezeichnern als Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt das <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> Ergebnis des Aufrufes aus dem <xref:System.Xaml.XamlMember.DeclaringType%2A> zurück, <xref:System.Xaml.XamlMember>das diesem zugeordnet ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung ab, die diesem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnet ist.</summary>
        <value>Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung, die diesem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das `Invoker` Muster ist eine erweiterte XAML-Typsystem-Erweiterungs Technik. Das `Invoker` -Muster bietet eine Möglichkeit, ein anderes Verhalten bei der Schema Typzuordnung einzufügen, während XAML-typsystemdefinitionen von .NET Framework XAML-Diensten verwendet werden.  
  
 Wenn eine <xref:System.Xaml.XamlMember.LookupInvoker%2A> außer Kraft `null`Setzung zurückgibt oder wenn die Standard `null` Implementierung <xref:System.Xaml.XamlMember.UnderlyingMember%2A> zurückgibt, da Sie <xref:System.Xaml.XamlMember>nicht für <xref:System.Xaml.XamlMember.Invoker%2A> dieses- <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>Objekt fehlt, gibt die-Eigenschaft zurück.  
  
 Standardmäßig ist <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> festgelegt. Dies gilt für die meisten Vorgänge, die .NET Framework XAML-Dienste und den XAML-Standardschema Kontext verwenden, und bei `Invoker` denen keine spezifischen Überschreibungs Muster für die Erstellung von XAML-typsystementitäten übergebenen werden.  
  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.Invoker%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupInvoker%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieser <see cref="T:System.Xaml.XamlMember" /> als Ambient-Eigenschaft gemeldet wird.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt als Ambient-Eigenschaft gemeldet wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.IsAmbient%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> Dieses Verhalten tritt bei Implementierungen auf, bei denen die anfängliche interne reflektionslogik die Informationen nicht bereits festgelegt hat.  
  
 Die Überprüfung auf Ambient-Eigenschaften ist in der Regel Teil der XAML-Verarbeitungslogik, um sicherzustellen, dass Objekte und Werte, die auf Umgebungs Verwendung für die typqualifizierung basieren, ordnungsgemäß funktionieren. Der .NET Framework XAML-Dienste-APIs und der XAML-Standardschema Kontext füllen diesen Wert auf der <xref:System.Windows.Markup.AmbientAttribute>Grundlage der Zuordnung mit auf. Die Standard Implementierung von <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> verwendet diese vorhandene <xref:System.Windows.Markup.AmbientAttribute> Technik und gibt zurück `true` , wenn <xref:System.Windows.Markup.AmbientAttribute> für eine Element Deklaration vorhanden ist.  
  
 <xref:System.Windows.Markup.AmbientAttribute>befindet sich auf Membern mehrerer WPF-Typen, einschließlich <xref:System.Windows.Application>, <xref:System.Windows.Setter>und <xref:System.Windows.Style>. Es ist auch für den <xref:System.Windows.ResourceDictionary> -Typ zu finden, mit dem festgestellt wird, dass ein Member, der als Typ verwendet <xref:System.Windows.ResourceDictionary> , auch dann als Ambient angesehen werden soll, wenn der Member nicht explizit attributiert ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt ein anfügbarer Member ist.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt ein anfügbarer Member ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Xaml.XamlMember.IsAttachable%2A> -Wert wird basierend auf dem Konstruktor initialisiert, der verwendet wurde <xref:System.Xaml.XamlMember>, um eine zu erstellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob es sich bei diesem <see cref="T:System.Xaml.XamlMember" />-Objekt um eine XAML-Direktive handelt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt eine XAML-Direktive ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Xaml.XamlMember.IsDirective%2A> -Wert wird basierend auf dem Konstruktor initialisiert, der verwendet wurde <xref:System.Xaml.XamlMember>, um eine zu erstellen. Die Basiskonstruktoren <xref:System.Xaml.XamlMember> initialisieren, <xref:System.Xaml.XamlMember.IsDirective%2A> sodass `false`ist. Die <xref:System.Xaml.XamlDirective> -Klasse (eine <xref:System.Xaml.XamlMember> abgeleitete Klasse) wird jedoch so initialisiert `true`, dass <xref:System.Xaml.XamlMember.IsDirective%2A> ist.  
  
 Wenn Sie als <xref:System.Xaml.XamlMember.IsDirective%2A> `true` an Aufrufer einer benutzerdefinierten XAML-Schema Klasse für XAML-Member berichten möchten, stellen Sie <xref:System.Xaml.XamlDirective> sicher, dass Sie von ableiten, da dies die einzige Möglichkeit ist, dieses Verhalten zu aktivieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieser <see cref="T:System.Xaml.XamlMember" /> einen Ereignismember darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt ein Ereignis darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.IsEvent%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupIsEvent%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt mit einer gültigen <see langword="xamlName" />-Zeichenfolge als <see cref="P:System.Xaml.XamlMember.Name" />-Eigenschaft initialisiert wird.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt mit einer gültigen <see langword="xamlName" />-Zeichenfolge initialisiert wird, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen schreibgeschützten Member darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen schreibgeschützten Member darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.IsReadOnly%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen Member mit einem aufrufbaren öffentlichen <see langword="get" />-Accessor darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen aufrufbaren öffentlichen <see langword="get" />-Accessor darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Xaml.XamlMember.IsReadPublic%2A> -Wert überprüft, <xref:System.Xaml.XamlMember.DeclaringType%2A> ob öffentlich ist. Wenn <xref:System.Xaml.XamlMember.DeclaringType%2A> nicht öffentlich ist, kann `get` der-Accessor nicht auf praktische Weise aufgerufen werden und <xref:System.Xaml.XamlMember.IsReadPublic%2A> gibt zurück `false`.  
  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.IsReadPublic%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A>  
  
> [!IMPORTANT]
>  Die <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Methode ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung kann die gemeldeten Zugriffs Informationen eines XAML-Members (böswillig oder anderweitig) ändern, sodass er nicht mehr erwartungsgemäß mit den Typsystem-Zugriffs Informationen der zugrunde liegenden CLR-Deklaration ausgerichtet wird. Verwenden Sie für alle sicherheitskritischen Prüfungen von Zugriffsebenen stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Member durch das für Typ- und Memberauflösung verwendete Unterstützungssystem nicht aufgelöst werden kann.</summary>
        <value><see langword="true" />, wenn der Member nicht aufgelöst werden kann. <see langword="false" />, wenn der Member aufgelöst werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Xaml.XamlMember> , der mit der Signatur <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> erstellt wird, <xref:System.Xaml.XamlMember.IsUnknown%2A>die für zurück `true` gegeben wird.  
  
 Bei einem Auslastungs Pfad <xref:System.Xaml.XamlObjectWriter>, der <xref:System.Xaml.XamlMember> einschließt, <xref:System.Xaml.XamlMember.IsUnknown%2A> kann ein mit `true` for nicht in ein Objekt Diagramm geschrieben werden. Unter den Standard Implementierungen in .NET Framework XAML-Dienste-APIs <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> löst der- <xref:System.Xaml.XamlObjectWriterException> Befehl eine aus <xref:System.Xaml.XamlMember> , wenn <xref:System.Xaml.XamlMember.IsUnknown%2A>die relevanten Berichte `true` für.  
  
 Sie sollten <xref:System.Xaml.XamlMember> keinen erstellen, der den `true` Wert für <xref:System.Xaml.XamlMember.IsUnknown%2A> hat, es sei denn, ihre Implementierung kann die <xref:System.Xaml.XamlObjectWriter>Ausnahmen von verarbeiten, oder Sie haben andere Möglichkeiten <xref:System.Xaml.XamlObjectWriter> , das Verhalten anzupassen.  
  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.IsUnknown%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupIsUnknown%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen lesegeschützten Member darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen lesegeschützten Member darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.IsWriteOnly%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen Member mit einem aufrufbaren öffentlichen <see langword="set" />-Accessor darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen aufrufbaren öffentlichen <see langword="set" />-Accessor darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Xaml.XamlMember.IsWritePublic%2A> Wert gibt an, <xref:System.Xaml.XamlMember.DeclaringType%2A> ob der im Rahmen der Bestimmung öffentlich ist. Wenn <xref:System.Xaml.XamlMember.DeclaringType%2A> nicht öffentlich ist, kann `set` der-Accessor nicht auf praktische Weise aufgerufen werden und <xref:System.Xaml.XamlMember.IsWritePublic%2A> gibt zurück `false`.  
  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.IsWritePublic%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>  
  
> [!IMPORTANT]
>  Die <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Methode ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung kann die gemeldeten Zugriffs Informationen eines XAML-Members (böswillig oder anderweitig) ändern, sodass er nicht mehr erwartungsgemäß mit den Typsystem-Zugriffs Informationen der zugrunde liegenden CLR-Deklaration ausgerichtet wird. Verwenden Sie für alle sicherheitskritischen Prüfungen von Zugriffsebenen stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt bei der Implementierung in einer abgeleiteten Klasse eine <see cref="T:System.Reflection.ICustomAttributeProvider" />-Implementierung zurück.</summary>
        <returns>Eine <see cref="T:System.Reflection.ICustomAttributeProvider" />-Implementierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie diese Methode, um die interne Reflektion mit einer alternativen Methode zum Abrufen von CLR-Attributwerten bereitzustellen. Wenn keine außer Kraft Setzung vorhanden ist, verwendet der interne Reflektor typische CLR-reflektionslogik wie Aufrufe <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>von.  
  
 Die Standardimplementierung gibt `null` zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt zurück, das für verzögertes Laden von in XAML deklarierten Objekten verwendet wird.</summary>
        <returns>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, der eine <see cref="T:System.Xaml.XamlDeferringLoader" />-Einschränkung für den generischen Typ besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert <xref:System.Xaml.XamlMember.DeferringLoader%2A> aus der-Eigenschaft abruft. Überschreiben Sie diese Methode, <xref:System.Xaml.XamlMember.DeferringLoader%2A> Wenn Sie einen Wert zurückgeben möchten, der sich von dem Wert unterscheidet, der standardmäßig mit interner Reflektion aktiviert <xref:System.Xaml.Schema.XamlMemberInvoker> ist, und wenn Sie auch benutzerdefinierte Informationen bereitstellen.  
  
 Die Standard Implementierung gibt ein Objekt zurück, indem <xref:System.Windows.Markup.XamlDeferLoadAttribute> ein <xref:System.Xaml.XamlDeferringLoader> -Objekt aus dem deklarierenden Typ gelesen oder verwendet wird. Wenn keines der Objekte verfügbar ist, gibt diese Methode `null`möglicherweise zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste von <see cref="T:System.Xaml.XamlMember" />-Objekten zurück. Von Elementen in der Liste werden die Member gemeldet, in denen Abhängigkeitsbeziehungen für die Initialisierungsreihenfolge relativ zu diesem <see cref="T:System.Xaml.XamlMember" /> vorhanden sind.</summary>
        <returns>Eine Liste von <see cref="T:System.Xaml.XamlMember" />-Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert <xref:System.Xaml.XamlMember.DependsOn%2A> aus der-Eigenschaft abruft. Überschreiben Sie diese Methode, <xref:System.Xaml.XamlMember.DependsOn%2A> Wenn Sie einen Wert zurückgeben möchten, der sich von dem Wert unterscheidet, der standardmäßig mit interner Reflektion aktiviert <xref:System.Xaml.Schema.XamlMemberInvoker> ist, und wenn Sie auch benutzerdefinierte Informationen bereitstellen.  
  
 Die WPF-XAML-Reader-und-Writer- <xref:System.Windows.Markup.DependsOnAttribute>Implementierungen führen diesen Fall mit aus. Die Standard Implementierung verwendet diese vorhandene <xref:System.Windows.Markup.DependsOnAttribute> Technik.  
  
 Überschreiben Sie diese Methode, wenn Sie <xref:System.Windows.Markup.DependsOnAttribute> zu diesem Zweck nicht verwenden und diese Technik ersetzen möchten, um die Reihenfolge der Eigenschaften Verarbeitung mit ihrer eigenen Technik anzugeben. Wenn Sie nicht beabsichtigen, eine Eigenschaften Verarbeitungsreihenfolge zu unterstützen, können Sie die Standard Implementierung verwenden, da Sie keine entsprechenden Ergebnisse zurückgibt.  
  
 Die Liste ist schreibgeschützt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> zurück, der diesem <see cref="T:System.Xaml.XamlMember" /> zugeordnet ist.</summary>
        <returns>Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Informationen für diesen <see cref="T:System.Xaml.XamlMember" /> oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird durch Aufrufe <xref:System.Xaml.XamlMember.Invoker%2A>von aufgerufen.  
  
 Die Standard Implementierung erfordert nicht, dass eine <xref:System.Xaml.XamlMember> mit einem der Konstruktoren erstellt wird, die einen anfänglichen <xref:System.Xaml.Schema.XamlMemberInvoker>übergeben. Allerdings muss <xref:System.Xaml.XamlMember.UnderlyingMember%2A> ein-Wert für das <xref:System.Xaml.XamlMember>vorhanden sein; andernfalls gibt die Standard `null`Implementierung zurück.  
  
 Überschreiben Sie diese Methode, wenn Sie <xref:System.Xaml.Schema.XamlMemberInvoker> auch von ableiten und die abgeleitete-Klasse zurückgeben möchten. Wenn Sie zurück `null`geben <xref:System.Xaml.XamlMember.Invoker%2A> , <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> kehrt zu Aufrufern zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob das <see cref="T:System.Xaml.XamlMember" />-Objekt als Ambient-Eigenschaft gemeldet wird.</summary>
        <returns><see langword="true" />, wenn dieser <see cref="T:System.Xaml.XamlMember" /> als Ambient-Eigenschaft gemeldet werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von internen aufrufen aufgerufen, die eine Überprüfung auf Umgebungs Informationen zur XAML-Eigenschaft durchsuchen. Das Verhalten der Ambient-Eigenschaft wird im öffentlichen API-Verhalten von XAML-Readern und XAML-Writern berücksichtigt. Die internen Aufrufe, die <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> auf verweisen, sind in der Regel Teil der XAML-Verarbeitungslogik, um sicherzustellen, dass Objekte und Werte, die auf Umgebungs Verwendung für die typqualifizierung basieren, ordnungsgemäß funktionieren. Die Standard-.NET Framework XAML-Dienst Implementierung verwendet CLR-Attribute, um diese Informationen von Reflektion über Unterstützungs Typen abzurufen. Die Standard <xref:System.Windows.Markup.AmbientAttribute> Implementierung überprüft und gibt für <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> zurück `true` , wenn <xref:System.Windows.Markup.AmbientAttribute> für eine Element Definition vorhanden ist.  
  
 Überschreiben Sie diese Methode, wenn Sie <xref:System.Windows.Markup.AmbientAttribute> zu diesem Zweck nicht verwenden und diese Technik ersetzen möchten, um Ambient-XAML-Eigenschaften mit ihrer eigenen Technik anzugeben.  
  
 Beispiel-APIs von WPF, bei <xref:System.Windows.Markup.AmbientAttribute> denen <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> das <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>-Attribut mit und ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob diese <see cref="T:System.Xaml.XamlMember" />-Klasse ein Ereignis darstellt.</summary>
        <returns><see langword="true" />, wenn gemeldet werden soll, dass dieser <see cref="T:System.Xaml.XamlMember" /> ein Ereignis darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung überprüft, <xref:System.Xaml.XamlMember.UnderlyingMember%2A> ob vom Typ <xref:System.Reflection.EventInfo>ist. wenn dies der Fall ist `true`, wird zurückgegeben.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.IsEvent%2A>Wert aus abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn Sie über spezialisierte Metadaten verfügen, die so interpretiert werden können, dass XAML-Typsystem Darstellungen auf Einzelfallbasis bestimmt werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob die <see cref="T:System.Xaml.XamlMember" />-Klasse eine beabsichtigte schreibgeschützte Eigenschaft darstellt.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt als gewünschte schreibgeschützte Eigenschaft gemeldet werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt `true` zurück <xref:System.Xaml.XamlMember.UnderlyingMember%2A> , wenn vorhanden ist, `set` aber kein öffentlicher-Accessor vorhanden ist, wie durch die interne Reflektion festgelegt.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.IsReadOnly%2A>Wert aus abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn Sie über spezialisierte Metadaten verfügen, die so interpretiert werden können, dass XAML-Typsystem Darstellungen auf Einzelfallbasis bestimmt werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob das <see cref="T:System.Xaml.XamlMember" />-Objekt eine Eigenschaft darstellt, die über einen öffentlichen <see langword="get" />-Accessor verfügt.</summary>
        <returns><see langword="true" />, wenn dieser <see cref="T:System.Xaml.XamlMember" /> eine Eigenschaft mit einem öffentlichen <see langword="get" />-Accessor darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt Ergebnisse basierend auf der internen Reflektion oder der Negation <xref:System.Xaml.XamlMember.IsWriteOnly%2A>der-Verarbeitung in dieser Reihenfolge zurück.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A>Gibt zurück, ob der Member selbst öffentlich ist. Sie gibt `true` für einen öffentlichen Member für einen nicht öffentlichen deklarierenden Typ zurück. Verwenden <xref:System.Xaml.XamlMember.IsReadPublic%2A> Sie stattdessen, wenn Sie auch die Sichtbarkeit des deklarierenden Typs überprüfen möchten.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.IsReadPublic%2A>Wert aus abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn spezielle Metadaten verfügbar sind, um dies für einzelne Fälle zu ermitteln.  
  
> [!IMPORTANT]
>  Die <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Methode ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung kann die gemeldeten Zugriffs Informationen eines XAML-Members (böswillig oder anderweitig) ändern, sodass er nicht mehr erwartungsgemäß mit den Typsystem-Zugriffs Informationen der zugrunde liegenden CLR-Deklaration ausgerichtet wird. Verwenden Sie für alle sicherheitskritischen Prüfungen von Zugriffsebenen stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob diese <see cref="T:System.Xaml.XamlMember" />-Klasse ein Element darstellt, das vom Sicherungssystem für Typ- und Elementauflösung nicht aufgelöst werden kann.</summary>
        <returns><see langword="true" />, wenn diese <see cref="T:System.Xaml.XamlMember" />-Klasse ein nicht auflösbares Element darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.IsUnknown%2A>Wert aus abruft. Die Standard Implementierung gibt Ergebnisse zurück, die entweder auf interner Reflektion basieren, oder `null` auf den <xref:System.Xaml.XamlMember.UnderlyingMember%2A>Wert, der in dieser Reihenfolge verarbeitet wird.  
  
 Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn spezielle Metadaten verfügbar sind, um dies für einzelne Fälle zu ermitteln.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen Member darstellt, der über einen öffentlichen <see langword="set" />-Accessor, jedoch nicht über einen öffentlichen <see langword="get" />-Accessor verfügt.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen lesegeschützten Member darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt `true` zurück, <xref:System.Xaml.XamlMember.UnderlyingMember%2A> wenn ein vorhanden ist, `set` das über einen öffentlichen-Accessor und einen nicht öffentlichen `get` -Accessor verfügt, wie durch interne Reflektion festgelegt.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.IsWriteOnly%2A>Wert aus abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn spezielle Metadaten verfügbar sind, um dies für einzelne Fälle zu ermitteln.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen Member darstellt, der über einen öffentlichen <see langword="set" />-Accessor verfügt.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen schreibbaren Member darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt Ergebnisse entweder basierend auf der internen Reflektion oder <xref:System.Xaml.XamlMember.IsReadOnly%2A>der Negation der Verarbeitung in dieser Reihenfolge zurück.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.IsWritePublic%2A>Wert aus abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn spezielle Metadaten verfügbar sind, um dies für einzelne Fälle zu ermitteln.  
  
> [!IMPORTANT]
>  Die <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Methode ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung kann die gemeldeten Zugriffs Informationen eines XAML-Members (böswillig oder anderweitig) ändern, sodass er nicht mehr erwartungsgemäß mit den Typsystem-Zugriffs Informationen der zugrunde liegenden CLR-Deklaration ausgerichtet wird. Verwenden Sie für alle sicherheitskritischen Prüfungen von Zugriffsebenen stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Zeichen für öffnende und schließende Klammern einer Markuperweiterung zurück.</summary>
        <returns>Eine Auflistung, die die Zeichen für öffnende und schließende Klammern enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die <see cref="T:System.Xaml.XamlType" />-Klasse des Typs zurück, in dem das <see cref="T:System.Xaml.XamlMember" />-Objekt vorhanden sein kann.</summary>
        <returns>Der Typ, auf dem das <see cref="T:System.Xaml.XamlMember" />-Objekt vorhanden sein kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung unterscheidet zwischen anfügbaren und nicht anfügbaren Membern. Für nicht anfügbare <xref:System.Xaml.XamlMember.LookupTargetType%2A> Member gibt immer <xref:System.Xaml.XamlMember.DeclaringType%2A>zurück. Gibt für anfügbare Member ein Ergebnis zurück, <xref:System.Xaml.XamlMember.LookupTargetType%2A> das auf der Untersuchung des accessorparametertyps basiert und diesen Typ basierend auf dem <xref:System.Xaml.XamlMember.UnderlyingMember%2A> XAML-Schema Kontext interpretiert.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.TargetType%2A>Wert aus abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn spezielle Metadaten verfügbar sind, um dies für einzelne Fälle zu ermitteln.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das <see cref="T:System.Xaml.XamlType" />-Objekt des vom Member verwendeten Typs zurück.</summary>
        <returns>Das <see cref="T:System.Xaml.XamlType" />-Objekt des vom Member verwendeten Typs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.Type%2A>Wert aus abruft. Überschreiben Sie diese Methode, <xref:System.Xaml.XamlMember.Type%2A> Wenn Sie einen Wert zurückgeben möchten, der sich von dem Wert unterscheidet, der standardmäßig mit interner Reflektion aktiviert <xref:System.Xaml.Schema.XamlMemberInvoker> ist, und wenn Sie auch benutzerdefinierte Informationen bereitstellen.  
  
 Die Standard Implementierung verwendet unterschiedliche Codepfade und konzeptionelle Bedeutungen für <xref:System.Xaml.XamlType> das zurückgegebene, das darauf <xref:System.Xaml.XamlMember> basiert, ob dies eine Eigenschaft, eine Methode oder ein Ereignis darstellt.  
  
-   Bei einer-Eigenschaft ist der <xref:System.Xaml.XamlType> zurückgegebene der Typ, der die-Eigenschaft festlegt oder von der-Eigenschaft zurückgegeben wird.  
  
-   Bei einem-Ereignis ist der <xref:System.Xaml.XamlType> zurückgegebene der erforderliche ereignishandlertyp (ein Delegat in einer CLR-Implementierung).  
  
-   Bei einer Methode <xref:System.Xaml.XamlType> ist der Rückgabetyp.  
  
 In jedem Fall wird der XAML-Schema Kontext verwendet, um den XAML-Typ aus dem zugrunde liegenden Systemtyp auszuwerten.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.Type%2A>Wert aus abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn spezielle Metadaten verfügbar sind, um dies für einzelne Fälle zu ermitteln.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Typkonverterimplementierung zurück, die dieser <see cref="T:System.Xaml.XamlMember" />-Klasse zugeordnet ist.</summary>
        <returns>Eine <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Instanz mit der <see cref="T:System.ComponentModel.TypeConverter" />-Einschränkung oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung verwendet die folgende Logik und Verarbeitungsreihenfolge:  
  
-   Wenn die Attributierung auf der Element Ebene (<xref:System.ComponentModel.TypeConverterAttribute>) vorhanden ist, werden die Attributinformationen für einen- <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> Rückruf für den XAML-Schema Kontext verwendet.  
  
-   Wenn <xref:System.Xaml.XamlMember.Type%2A> gültig ist, wird ein Typkonverter zurückgegeben, der dem-Typ zugeordnet ist.  
  
-   Wenn der Member ein Ereignis ist, wird ein ereignisspezifischer Typkonverter zurückgegeben.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.TypeConverter%2A>Wert aus abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn spezielle Metadaten verfügbar sind, um dies für einzelne Fälle zu ermitteln.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see langword="get" />-Accessor zurück, der dieser <see cref="T:System.Xaml.XamlMember" />-Klasse zugeordnet ist.</summary>
        <returns>Die <see cref="T:System.Reflection.MethodInfo" /> für den zugeordneten <see langword="get" />-Accessor oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung interpretiert die <xref:System.Xaml.XamlMember.UnderlyingMember%2A> -Eigenschaft <xref:System.Reflection.PropertyInfo> als und gibt den Wert <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> von zurück (wobei der- `true`Parameter auf festgelegt ist). Dies bedeutet, dass die zurückgegebene Methode nicht öffentlich sein kann. Dieses Verhalten kann in `null` bestimmten Fällen zu einem Ergebnis führen. Dies gilt auch für Fälle, in denen kein zugeordneter Accessor vorhanden ist oder der Member keine Eigenschaft ist.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> aus der-Eigenschaft <xref:System.Xaml.Schema.XamlMemberInvoker>eines zugeordneten abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn spezielle Metadaten verfügbar sind, um dies für einzelne Fälle zu ermitteln. Stellen Sie sicher, <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>dass <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, und <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> implementiert, sodass alle korrelierte Ergebnisse zurückgeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine <see cref="T:System.Reflection.MemberInfo" /> des CLR-Typsystems zurück, die diesem <see cref="T:System.Xaml.XamlMember" /> zugeordnet ist.</summary>
        <returns>Ein <see cref="T:System.Reflection.MemberInfo" />-Objekt des CLR-Typsystems, das diesem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnet ist, oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt die zugrunde liegenden Element Informationen zurück, die auf der Erstellung basieren. Wenn das <xref:System.Reflection.MemberInfo> Objekt mit einer Signatur erstellt wird, die nicht genügend Informationen bereitstellt, um den zugrunde liegenden Member festzulegen `null`, gibt diese Methode zurück.  
  
 Wenn ein zugrunde liegendes Element während der Erstellung festgelegt wurde, sollte diese Methode nicht aufgerufen werden.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.UnderlyingMember%2A>Wert aus abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn spezielle Metadaten verfügbar sind, um dies für einzelne Fälle zu ermitteln. Stellen Sie sicher, <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>dass <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, und <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> implementiert, sodass alle korrelierte Ergebnisse zurückgeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see langword="set" />-Accessor zurück, der dieser <see cref="T:System.Xaml.XamlMember" />-Klasse zugeordnet ist.</summary>
        <returns>Die <see cref="T:System.Reflection.MethodInfo" /> für den zugeordneten <see langword="set" />-Accessor oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung interpretiert <xref:System.Xaml.XamlMember.UnderlyingMember%2A> als <xref:System.Reflection.PropertyInfo> und gibt den Wert von <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> (wobei der-Parameter auf `true`festgelegt ist) zurück. Dies bedeutet, dass die zurückgegebene Methode nicht öffentlich sein kann. Dies kann in bestimmten `null` Fällen zu einem Ergebnis führen, z. b. in Fällen, in denen kein solcher Accessor vorhanden ist, oder wenn der Member keine Eigenschaft ist.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> Wert aus einer <xref:System.Xaml.Schema.XamlMemberInvoker>zugeordneten abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn spezielle Metadaten verfügbar sind, um dies für einzelne Fälle zu ermitteln. Stellen Sie sicher, <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>dass <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, und <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> implementiert, sodass alle korrelierte Ergebnisse zurückgeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Wertserialisierungsprogramm-Implementierung zurück, die diesem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnet ist.</summary>
        <returns>Eine <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Instanz mit der <see cref="T:System.Windows.Markup.ValueSerializer" />-Einschränkung oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung verwendet die folgende Logik und Verarbeitungsreihenfolge:  
  
-   Wenn die Attributierung auf der Element Ebene (<xref:System.Windows.Markup.ValueSerializerAttribute>) vorhanden ist, werden die Attributinformationen für einen- <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> Rückruf für den XAML-Schema Kontext verwendet.  
  
-   Wenn <xref:System.Xaml.XamlMember.Type%2A> gültig ist, wird ein Wert Konverter zurückgegeben, der dem-Typ zugeordnet ist.  
  
-   Wenn die vorherigen Bedingungen nicht zutreffen, `null` wird zurückgegeben.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen <xref:System.Xaml.XamlMember.ValueSerializer%2A>Wert aus abruft. Überschreiben Sie diese Methode, wenn Sie einheitliche Ergebnisse für eine gesamte <xref:System.Xaml.XamlMember> abgeleitete Klasse melden möchten, oder wenn spezielle Metadaten verfügbar sind, um dies für einzelne Fälle zu ermitteln.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiert die Zeichen für öffnende und schließende Klammern einer Markuperweiterung.</summary>
        <value>Eine Auflistung, die die Zeichen für öffnende und schließende Klammern enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see langword="xamlName" />-Namenszeichenfolge ab, durch die dieses <see cref="T:System.Xaml.XamlMember" />-Objekt deklariert wird.</summary>
        <value>Die <see langword="xamlName" />-Namenszeichenfolge, durch die dieses <see cref="T:System.Xaml.XamlMember" />-Objekt deklariert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird immer während der Erstellung festgelegt. Die Konstruktoren, die von implementiert <xref:System.Xaml.XamlMember> werden, lösen normalerweise eine Ausnahme aus, wenn kein ursprünglicher Name angegeben ist. Daher sollten Sie nicht `null` erwarten, dass diese Eigenschaft oder eine leere Zeichenfolge ist, wenn Sie Standard .NET Framework XAML-Dienste verwenden. Protokol.  
  
 Die [XamlName-Grammatik](~/docs/framework/xaml-services/xamlname-grammar.md) und die Benennungs Regeln für CLR-Typen und-Member sind keine exakte Schnittmenge. Es ist möglich, einen Elementnamen zu deklarieren, der unter CLR zulässig ist, aber unter XAML-Benennung nicht gültig ist. Vermeiden Sie diese Situation, wenn möglich.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> oder <see langword="null" />.</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.Xaml.XamlMember" />-Objekte denselben Wert haben.</summary>
        <returns><see langword="true" />, wenn <paramref name="xamlMember1" /> und <paramref name="xamlMember2" /> denselben Wert haben, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> oder <see langword="null" />.</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.Xaml.XamlMember" />-Objekte verschiedene Werte haben.</summary>
        <returns><see langword="true" />, wenn der Wert von <paramref name="xamlMember1" /> vom Wert von <paramref name="xamlMember2" /> abweicht, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den einzelnen XAML-Namespace-URI ab, der den primären XAML-Namespace für dieses <see cref="T:System.Xaml.XamlMember" />-Objekt bezeichnet.</summary>
        <value>Der Bezeichner für den primären XAML-Namespace für dieses <see cref="T:System.Xaml.XamlMember" />-Objekt als Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> -Eigenschaft stellt denselben Wert bereit wie <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> das Aufrufen von und das Abrufen der ersten Wert Zeichenfolge aus der zurückgegebenen Liste. Der bevorzugte XAML-Namespace sollte verwendet werden, wenn der Member zurück in Text oder andere Darstellungen geschrieben wird, die XAML-Namespace Informationen erhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />-Wert ab, der angibt, wie der Member von einem visuellen Designer verarbeitet werden soll.</summary>
        <value>Ein Wert der <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />-Enumeration. Die Standardeinstellung ist <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xaml.XamlType" />-Objekt des Typs ab, in dem das <see cref="T:System.Xaml.XamlMember" />-Objekt vorhanden sein kann.</summary>
        <value>Der Typ, auf dem das <see cref="T:System.Xaml.XamlMember" />-Objekt vorhanden sein kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zurückgegebene Wert ist für anfügbare und nicht anfügbare Member unterschiedlich. Für nicht anfügbare <xref:System.Xaml.XamlMember.TargetType%2A> Member gibt <xref:System.Xaml.XamlMember.DeclaringType%2A>zurück. Für anfügbare <xref:System.Xaml.XamlMember.LookupTargetType%2A> Member gibt ein Ergebnis zurück, das auf dieser Logik basiert:  
  
-   Wenn die Reflektion keine Unterstützung<xref:System.Xaml.XamlMember.IsUnknown%2A> ( `true`) auflösen kann, gibt diese Methode eine interne Konstante zurück, die einen generischen Objekttyp darstellt.  
  
-   Wenn die vorherige Bedingung nicht zutrifft, <xref:System.Xaml.XamlMember.LookupTargetType%2A> wird aufgerufen. Die Standard Implementierung gibt einen <xref:System.Xaml.XamlType> zurück, der auf der Untersuchung der Methoden basiert `get` , `set` die die-und-Accessoren implementieren. Eine Klasse kann über <xref:System.Xaml.XamlMember.LookupTargetType%2A> schreiben, um ein anderes Verhalten wie andere metadatenformulare zu verwenden, die Zieltypen für anfügbare Member melden könnten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolgendarstellung für diese <see cref="T:System.Xaml.XamlMember" /> zurück.</summary>
        <returns>Eine Zeichenfolgendarstellung für diese <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung gibt <xref:System.Xaml.XamlMember.Name%2A>zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xaml.XamlType" />-Objekt des vom Member verwendeten Typs ab.</summary>
        <value>Das <see cref="T:System.Xaml.XamlType" />-Objekt des vom Member verwendeten Typs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.Type%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupType%2A> Dies tritt auf, wenn die erste interne reflektionslogik die Informationen nicht bereits festgelegt hat.  
  
 Im Standardverhalten (keine über <xref:System.Xaml.XamlMember.LookupType%2A> Schreibung) kann die zurück <xref:System.Xaml.XamlType> gegebene eine andere konzeptionelle Bedeutung haben. Welche Bedeutung zutrifft, hängt davon ab <xref:System.Xaml.XamlMember> , ob dies eine Eigenschaft, eine Methode oder ein Ereignis darstellt, wie in der folgenden Liste gezeigt:  
  
-   Bei einer-Eigenschaft ist der <xref:System.Xaml.XamlType> zurückgegebene der Typ, der die-Eigenschaft festlegt oder von der-Eigenschaft zurückgegeben wird.  
  
-   Bei einem-Ereignis ist der <xref:System.Xaml.XamlType> zurückgegebene der erforderliche ereignishandlertyp (ein Delegat in einer CLR-Implementierung).  
  
-   Bei einer Methode <xref:System.Xaml.XamlType> ist der Rückgabetyp dieser Methode, die sein `null`kann.  
  
 In jedem Fall wird der XAML-Schema Kontext verwendet, um den XAML-Typ aus dem Unterstützungstyp auszuwerten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt ab, das für die Typkonvertierungserstellung von in XAML deklarierten Objekten verwendet wird.</summary>
        <value>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Wert mit einer <see cref="T:System.ComponentModel.TypeConverter" />-Einschränkung für den generischen Typ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.TypeConverter%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> Dieses Verhalten tritt auf, wenn die erste interne reflektionslogik die Informationen nicht bereits festgelegt hat.  
  
 Implementierungen, die einen nicht-NULL-Eigenschafts <xref:System.Xaml.XamlMember.TypeConverter%2A> Wert für zurückgeben, <xref:System.ComponentModel.TypeConverter>sind nicht notwendigerweise Funktions intensiv. Im folgenden finden Sie eine Liste möglicher Rückgabewerte ungleich NULL für <xref:System.Xaml.XamlMember.TypeConverter%2A> und die folgenden Werte:  
  
-   Der Rückgabewert meldet einen Typkonverter, der speziell für diesen Member oder eher für den Zieltyp des Konverters zugewiesen wird. Dieses Verhalten ist in der Regel das, was die meisten XAML-Typsysteme und XAML-Prozessoren suchen, um einen Typkonverter zu instanziieren und seine Methoden aufzurufen.  
  
-   Der Rückgabewert meldet einen integrierten Wert Konverter. Diese Konverter sind für bestimmte interne Vorgänge vorhanden, die von einem XAML-Writer ausgeführt werden. Insbesondere konvertieren diese integrierten Wert Konverter die Zeichen folgen Werte für unformatierte Attribute in XAML auf Sprachebene. Für die .NET Framework XAML-Dienst Implementierung werden diese integrierten Typkonvertierungen häufig an einen Typkonverter weiterleiten, der in der Systemassembly definiert ist. Eine Konvertierung für einen <xref:System.Int32> -Wert hat z. b. eine integrierte weitergeleitete Konvertierung und somit den <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> Wert Verweise. <xref:System.ComponentModel.Int32Converter>  
  
-   Der Rückgabewert meldet den Sonderfall eines nicht eingeschränkten Objektmodells. Das heißt, das <xref:System.Xaml.XamlMember> <xref:System.Xaml.XamlMember.Type%2A> hat den Wert <xref:System.Object>. In diesem Fall meldet das <xref:System.Xaml.Schema.XamlValueConverter%601> , <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> dass {`Object}`ist. <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> Ist `null`  jedoch, weil kein tatsächlicher Typ oder keine tatsächliche Instanz verfügbar ist, um diese Konvertierung auszuführen. Stattdessen kann das Objektmodell Verhalten erst zur Laufzeit bestimmt werden, wenn die Laufzeit der spezifischen Technologie die Handhabung seines Objekt Diagramms bestimmt.  
  
 Wenn Sie auf eine Arbeit <xref:System.ComponentModel.TypeConverter> von <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>zugreifen können, können Sie die zugehörigen Konvertierungs Methoden aufrufen. Viele Konvertierungs Methoden basieren jedoch auf Dienst Kontext. Wenn nicht der gleiche Dienst Kontext verfügbar ist, den der Typkonverter für die typische Rolle beim Schreiben von Objekten für Objekt Diagramme erwartet, können die konvertermethoden Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Reflection.MemberInfo" /> des CLR-Typsystems ab, die für einen Member verfügbar ist, der von <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" /> oder <see cref="T:System.Reflection.EventInfo" /> erstellt wird.</summary>
        <value><see cref="T:System.Reflection.MemberInfo" />-Informationen des CLR-Typsystems entsprechend der Umwandlung von den ursprünglichen Konstruktorparametern. Ein <see cref="T:System.Xaml.XamlMember" />-Objekt, das mit der <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />-Signatur erstellt wird, gibt <see langword="null" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.UnderlyingMember%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt ab, das für die Wertserialisierung von in XAML deklarierten Objekten verwendet wird.</summary>
        <value>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit <see cref="T:System.Windows.Markup.ValueSerializer" />-Einschränkung für den generischen Typ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von Aufrufen <xref:System.Xaml.XamlMember.ValueSerializer%2A> oder eine bestimmte außer Kraft setzung dieser Methode. <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> Dieses Verhalten tritt auf, wenn die erste interne reflektionslogik die Informationen nicht bereits festgelegt hat.  
  
 Nicht alle Fälle, die einen Eigenschafts Wert ungleich NULL für <xref:System.Xaml.XamlMember.ValueSerializer%2A> zurückgeben, sind <xref:System.Windows.Markup.ValueSerializer>notwendigerweise ein funktionierungstyp. Siehe <xref:System.Xaml.XamlMember.TypeConverter%2A>; die gleichen Überlegungen gelten <xref:System.Xaml.XamlMember.ValueSerializer%2A>für.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
