<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a5bf358cf5bbfc2549fa0d48319a913cdf514495" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51938068" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt den XAML-Typsystembezeichner für Member von XAML-Typen bereit. Der Bezeichner wird während der Verarbeitung von Memberknoten (wenn der XAML-Reader in einem <see cref="F:System.Xaml.XamlNodeType.StartMember" /> positioniert ist) von XAML-Readern und XAML-Writern sowie für die allgemeine XAML-Typsystemlogik verwendet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember> drei Methoden zur Rückgabe von Informationen zu einem XAML-Member können: standard common Language Runtime (CLR) Reflektion; Ein Verweis nur Reflektionsverfahren Aufrufen von internen flags APIs dieses Bit für die Verwendung optimierter; oder virtuellen Aufruf überschreibt, der die `Lookup*` -API, die von möglichen bereitgestellt wird <xref:System.Xaml.XamlMember> Unterklassen. Für die meisten Verwendungen von .NET Framework-XAML-Dienste-APIs und die <xref:System.Xaml.XamlMember> -API verwenden Sie den Standard-XAML-Schemakontext. Der Standard-XAML-Schemakontext für .NET Framework-XAML-Dienste verwendet die CLR-Unterstützung für das System der Typen. Dies ermöglicht XAML-Reader und XAML-Writer mit einen beliebigen Typ oder Element, oder anderweitig zur Verfügung definiert wird, die CLR und seine Reflektion Methoden funktioniert.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>Suche *-APIs und XamlMember abgeleitete Klassen  
 <xref:System.Xaml.XamlMember> definiert verschiedene virtuelle Member, die abgeleitete Klassen können außer Kraft gesetzt. Diese Member haben Namen, die immer mit der Zeichenfolge beginnen `Lookup`. Der Rest der API nennen Sie die Verweise die Eigenschaft, die die virtuelle Methode beeinflusst. Z. B. eine <xref:System.Xaml.XamlMember> abgeleiteten Klasse außer Kraft setzen kann <xref:System.Xaml.XamlMember.LookupTargetType%2A> zu beeinflussen, welche die Basis-definierte Eigenschaft <xref:System.Xaml.XamlMember.TargetType%2A> gibt, die in einer abgeleiteten Klasse zurück. Sie können die Rückgabe von Werten für solche Eigenschaften in prognostizieren <xref:System.Xaml.XamlMember> oder vorhandene abgeleiteten Klassen durch Lesen der Dokumentation für das entsprechende `Lookup*` Methoden.  
  
 Der Zweck der `Lookup*` Methoden ist ein XAML Typsystem-Erweiterungsmethode, die beinhaltet die <xref:System.Xaml.XamlMember> Basisklasse. Durch Ableiten von <xref:System.Xaml.XamlMember> und überschreiben die `Lookup` virtuelle Member, Sie können definieren, das Konzept eines XAML-Elements für ein XAML-Schema in einem XAML-Typsystem ohne unabhängig von der auf die Einzelheiten der ein System von Unterstützungstypen oder eine Technologie. Sie können auch bei diesem Schema einen bereitgestellten XAML-Schemakontext und weiterhin die gewünschten Ergebnisse zurückgegeben.  
  
 Betrachten Sie als Beispiel die <xref:System.Xaml.XamlMember> Eigenschaft <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Diese Eigenschaft informiert darüber Aufrufer, dass Vorgänge wie die Verwendung einer <xref:System.Xaml.XamlWriter> für Serialisierung, einen Wert für dieses Element auf einem Zielobjekt schreiben kann. In der Standardimplementierung, erfolgt die Bestimmung der gibt an, ob das Element schreibgeschützt ist. mithilfe von Reflektion Methoden zum Schutz vor der unterstützende CLR <xref:System.Type> und ihre Member (die <xref:System.Reflection.MemberInfo>). Aus diesem Grund hängt in der Standardeinstellung das XAML-Typsystem der CLR-Typsystems. Sie können diese Abhängigkeit jedoch entfernen, für die XAML Typ System Berichte der <xref:System.Xaml.XamlMember.IsWritePublic%2A> durch Überschreiben der API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>. In der Überschreibung können Sie andere Ermittlung, wie z. B. Metadaten, die für die Technologie, die einer Nachschlagetabelle für die master spezifisch sind, die für einen festen XAML-Vokabular oder eine Vielzahl von anderen Strategien zur Bestimmung optimiert ist, ob ein XAML-Member in beschreibbar ist Ihre XAML-Vokabular.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Erstellen von XamlMember ohne XAML-Schemakontext  
 Die meisten Konstruktoren von <xref:System.Xaml.XamlMember> erfordern eine <xref:System.Xaml.XamlSchemaContext> als Teil der Initialisierung. Die <xref:System.Xaml.XamlSchemaContext> ist auch erforderlich, für viele interne <xref:System.Xaml.XamlSchemaContext> Vorgänge, wie das Abrufen von Informationen, die aus dem unterstützenden Typ weitergeleitet wird. Bei der Arbeit mit der <xref:System.Xaml.XamlMember> -API müssen Sie normalerweise eine <xref:System.Xaml.XamlSchemaContext> , z. B. von einem umgebenden Konstrukt verfügbar ist eine <xref:System.Xaml.XamlWriter>. In diesem Fall können Sie übergeben die <xref:System.Xaml.XamlSchemaContext> über ein Verweis auf alle XAML Typ Systemaufrufe, die einen XAML-Schemakontext erfordern.  
  
 Einen bestimmten Konstruktor, <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>, erfordert keine <xref:System.Xaml.XamlSchemaContext>. Allerdings eine <xref:System.Xaml.XamlMember> erstellt, die mit der <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> gibt `true` für <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Für einen Ladepfad, bei der <xref:System.Xaml.XamlObjectWriter>, solchen Member kann nicht in ein Objektdiagramm geschrieben werden. Mit der Implementierung von .NET Framework XAML Services die <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> aufrufen, löst eine <xref:System.Xaml.XamlObjectWriterException> beim entsprechenden <xref:System.Xaml.XamlMember> Berichte `true` für <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Sie sollten nicht erstellen eine <xref:System.Xaml.XamlMember> mit dem Wert des `true` für <xref:System.Xaml.XamlMember.IsUnknown%2A> es sei denn, Ihre Implementierung von Ausnahmen zu behandeln kann <xref:System.Xaml.XamlObjectWriter>, oder Sie über andere Möglichkeiten zum Anpassen der <xref:System.Xaml.XamlObjectWriter> Verhalten. Beispielsweise kann eine oder mehrere der folgenden Ihrer Implementierung erfüllt sein:  
  
-   Der XAML-Schemakontext ist höher verfügbar.  
  
-   Sie verwenden ein Member-Invoker-Muster.  
  
-   Sie überschreiben, absichtlich <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> in einem benutzerdefinierten XAML-Writer.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
    <related type="Article" href="https://msdn.microsoft.com/library/7c11abec-1075-474c-9d9b-778e5dab21c3">Grundlagen zu XAML-Knotenstreamstrukturen und -konzepten</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Die <see cref="T:System.Reflection.EventInfo" /> des CLR-Typsystems, die den Ereignismember darstellt.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse mit der <see cref="T:System.Reflection.EventInfo" /> des CLR-Typsystems und einem <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member ein Ereignis (Ereignis-Handler Verbindungspunkt Eigenschaft) darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Die <see cref="T:System.Reflection.PropertyInfo" /> des CLR-Typsystems, die den Eigenschaftsmember darstellt.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse mit der <see cref="T:System.Reflection.PropertyInfo" /> des CLR-Typsystems und einem <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn das Element eine Eigenschaft stellt (und insbesondere keine Ereignis-Handler-Verbindung ist).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Die <see cref="T:System.Reflection.EventInfo" /> des CLR-Typsystems, die den Ereignismember darstellt.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <param name="invoker">Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung, die die Reflektionslaufzeitaufrufe der <see cref="T:System.Xaml.XamlMember" />-Klasse verarbeitet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse mit der <see cref="T:System.Reflection.EventInfo" /> des CLR-Typsystems und einem <see cref="T:System.Xaml.XamlSchemaContext" />, einschließlich von <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Informationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member ein Ereignis (oder eine Ereignis-Handler Verbindungspunkt Eigenschaft) darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Die <see cref="T:System.Reflection.PropertyInfo" /> des CLR-Typsystems, die den Eigenschaftsmember darstellt.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <param name="invoker">Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung, die die Laufzeitaufrufe der <see cref="T:System.Xaml.XamlMember" />-Klasse verarbeitet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse mit Reflektions-<see cref="T:System.Reflection.PropertyInfo" /> und einem <see cref="T:System.Xaml.XamlSchemaContext" />, einschließlich von <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Informationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, nur dann, wenn das Element eine Eigenschaft darstellt, und wenn es sich nicht um eine Verbindung der Ereignis-Handler ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Der Zeichenfolgenname des anfügbaren Ereignisses.</param>
        <param name="adder">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für die <see langword="Add" />-Methode des Handlers der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse für einen <see cref="T:System.Xaml.XamlMember" />, der ein anfügbares Ereignis darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member einen Member anfügbares Ereignis darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Zeichenfolgenname des Members.</param>
        <param name="declaringType">Die <see cref="T:System.Xaml.XamlType" />-Informationen für den deklarierenden Typ.</param>
        <param name="isAttachable">
          <see langword="true" />, um anzugeben, dass der Member anfügbar ist, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse mit einem Zeichenfolgennamen und deklarierenden <see cref="T:System.Xaml.XamlType" />-Informationen. Ein mit dieser Signatur erstellter <see cref="T:System.Xaml.XamlMember" /> weist deutliche Einschränkungen auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Xaml.XamlMember> erstellt, die mit der <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> gibt `true` für <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Für einen Ladepfad, bei der <xref:System.Xaml.XamlObjectWriter>, solchen Member kann nicht in ein Objektdiagramm geschrieben werden. Mit der .NET Framework-XAML-Dienste-Implementierung, die <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> aufrufen, löst eine <xref:System.Xaml.XamlObjectWriterException> beim entsprechenden <xref:System.Xaml.XamlMember> Berichte `true` für <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Sie sollten keinen erstellen eine <xref:System.Xaml.XamlMember> mit <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` es sei denn, Ihre Implementierung von Ausnahmen zu behandeln kann <xref:System.Xaml.XamlObjectWriter>, oder Sie über andere Möglichkeiten zum Anpassen der <xref:System.Xaml.XamlObjectWriter> Verhalten. Beispielsweise kann eine oder mehrere der folgenden Ihrer Implementierung erfüllt sein:  
  
-   Der XAML-Schemakontext ist höher verfügbar.  
  
-   Sie verwenden ein Member-Invoker-Muster.  
  
-   Sie überschreiben, absichtlich <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> in einem benutzerdefinierten XAML-Writer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> oder <paramref name="declaringType" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Der Zeichenfolgenname der anfügbaren Eigenschaft.</param>
        <param name="getter">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für den <see langword="get" />-Accessor der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="setter">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für den <see langword="set" />-Accessor der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse für ein <see cref="T:System.Xaml.XamlMember" />-Objekt, das eine anfügbare Eigenschaft darstellt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member eine anfügbare Eigenschaft darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Der Zeichenfolgenname des anfügbaren Ereignisses.</param>
        <param name="adder">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für die <see langword="Add" />-Methode des Handlers der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <param name="invoker">Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung, die die Laufzeitaufrufe der <see cref="T:System.Xaml.XamlMember" />-Klasse verarbeitet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse für einen <see cref="T:System.Xaml.XamlMember" />, der ein anfügbares Ereignis darstellt, einschließlich von <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Informationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member einen Member anfügbares Ereignis darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Der Zeichenfolgenname der anfügbaren Eigenschaft.</param>
        <param name="getter">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für den <see langword="get" />-Accessor der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="setter">Die <see cref="T:System.Reflection.MethodInfo" /> des CLR-Typsystems für den <see langword="set" />-Accessor der Unterstützungsimplementierung des anfügbaren Members.</param>
        <param name="schemaContext">Der <see cref="T:System.Xaml.XamlSchemaContext" />-Kontext, der den Member qualifiziert.</param>
        <param name="invoker">Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung, die die Laufzeitaufrufe der <see cref="T:System.Xaml.XamlMember" />-Klasse verarbeitet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlMember" />-Klasse für einen <see cref="T:System.Xaml.XamlMember" />, der eine anfügbare Eigenschaft darstellt, einschließlich von <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Informationen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor, wenn der Member einen Member anfügbare Eigenschaft darstellt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xaml.XamlType" />-Objekt für den Typ ab, durch den der dem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnete Member deklariert wird.</summary>
        <value>Das <see cref="T:System.Xaml.XamlType" />-Objekt für den Typ, durch den der dem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnete Member deklariert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird in der Regel während der Initialisierung festgelegt und ist nicht in der Regel `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A> Informationen können von den Konstruktoren für die Initialisierung übergeben werden. Durch den Aufruf direkt in die Basiskonstruktoren, Initialisierung für <xref:System.Xaml.XamlMember> abgeleitete Klassen können weglassen, einige der Wert-Überprüfungen, die in der Basisklasse vorgenommen werden. Aus diesem Grund kann die abgeleitete Initialisierung die Beziehungsinformationen gemeldeten Typmembers, eines XAML-Elements ändern, sodass sie nicht mehr auf eine erwartete Weise mit den Typinformationen System, von der zugrunde liegenden CLR-Deklaration entspricht. Verwenden Sie für die als sicherheitskritisch Überprüfungen Typinformationen zu deklarieren stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt ab, das für verzögertes Laden von in XAML deklarierten Objekten verwendet wird.</summary>
        <value>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit <see cref="T:System.Xaml.XamlDeferringLoader" />-Einschränkung für den generischen Typ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Xaml.XamlMember.DeferringLoader%2A> ruft <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> oder eine bestimmte Außerkraftsetzung der Methode. Dieses Verhalten tritt auf, in Fällen, in denen die Logik für die erste interne Reflektion nicht bereits die Informationen festgelegt hat.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Liste von <see cref="T:System.Xaml.XamlMember" />-Objekten ab. Von diesen werden die Member gemeldet, in denen Abhängigkeitsbeziehungen für die Initialisierungsreihenfolge relativ zu diesem <see cref="T:System.Xaml.XamlMember" />-Objekt vorhanden sind.</summary>
        <value>Eine Liste von <see cref="T:System.Xaml.XamlMember" />-Objekten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Xaml.XamlMember.DependsOn%2A> ruft <xref:System.Xaml.XamlMember.LookupDependsOn%2A> oder eine bestimmte Außerkraftsetzung der Methode. Dieses Verhalten tritt auf, in Fällen, in denen die Logik für die erste interne Reflektion nicht bereits die Informationen festgelegt hat.  
  
 Die `DependsOn` Muster auf Objektmodellfälle, die absichtlich widersprechen von XAML in der Regel angewendet werden kann. Die allgemeine XAML-Regel ist, dass Member eines Typs, die nicht als Initialisierungstext (oder eine Factorymethode in XAML 2009) übergeben werden können in beliebiger Reihenfolge zugewiesen werden müssen. Durch Anwenden einer `DependsOn` Muster auf einen Member, können Sie XAML-Writern anweisen, immer den referenzierten Member vor diesem Element zu verarbeiten. Sie können dieses Muster in Situationen anwenden, in denen der Wert des aktuellen Elements erfordert, Kontext oder andere Informationen, die nach dem Festlegen des anderen Members nur zur Verfügung steht.  
  
 Die `DependsOn` Muster sollte mit Bedacht angewendet und für Szenarios, in dem sie einen Architekturen Zweck dient, reserviert werden. Große Anzahl von Abhängigkeiten besteht das Risiko XAML-Verarbeitung verlangsamt. Darüber hinaus ist es möglich, erzeugt ringabhängigkeiten, in diesem Fall ist das Verhalten der XAML-Verarbeitung nicht definiert.  
  
 Beispiel `DependsOn` Szenarien von WPF gehören bestimmte Eigenschaften auf <xref:System.Windows.Controls.ControlTemplate> und <xref:System.Windows.DataTemplate>auf <xref:System.Windows.Trigger>, und klicken Sie auf <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob das aktuelle Objekt einem anderen Objekt entspricht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das mit diesem Objekt verglichen werden soll.</param>
        <summary>Gibt an, ob das aktuelle Objekt einem anderen Objekt entspricht.</summary>
        <returns>
          <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="obj" />-Parameter ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
        <summary>Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
        <returns>
          <see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für dieses Objekt zurück.</summary>
        <returns>Ein ganzzahliger Hashcode.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste von XAML-Namespaces zurück, in dem dieser XAML-Member vorhanden sein kann.</summary>
        <returns>Eine Liste von XAML-Namespacebezeichnern als Zeichenfolgen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt das <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> Ergebnis von Aufrufen der <xref:System.Xaml.XamlMember.DeclaringType%2A> , mit dieser verknüpft ist <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung ab, die diesem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnet ist.</summary>
        <value>Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Implementierung, die diesem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Invoker` Muster ist eine erweiterte XAML-Erweiterungsmethode für den Typ System. Die `Invoker` Muster bietet eine Möglichkeit, anderen Schema Zuordnungsverhalten, bei der Verwendung von XAML System Typdefinitionen aus .NET Framework-XAML-Dienste weiterhin einfügen.  
  
 Wenn eine <xref:System.Xaml.XamlMember.LookupInvoker%2A> außer Kraft setzen gibt `null`, oder die Standardimplementierung gibt `null` weil fehlt. die <xref:System.Xaml.XamlMember.UnderlyingMember%2A> für diese <xref:System.Xaml.XamlMember>, <xref:System.Xaml.XamlMember.Invoker%2A> -Eigenschaft gibt <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 Standardmäßig ist <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> festgelegt. Dies gilt für die meisten Vorgänge, die .NET Framework-XAML-Dienste und die XAML-Standardschemakontext verwenden, und, bei denen keine spezifischen überschreiben `Invoker` Muster für die Konstruktion von Systementitäten für XAML-Typ übergeben werden.  
  
 Aufrufen von <xref:System.Xaml.XamlMember.Invoker%2A> ruft <xref:System.Xaml.XamlMember.LookupInvoker%2A> oder eine bestimmte Außerkraftsetzung der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieser <see cref="T:System.Xaml.XamlMember" /> als Ambient-Eigenschaft gemeldet wird.</summary>
        <value>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt als Ambient-Eigenschaft gemeldet wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Xaml.XamlMember.IsAmbient%2A> ruft <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> oder eine bestimmte Außerkraftsetzung der Methode. Dieses Verhalten tritt auf, in den Implementierungen, in denen die Logik für die erste interne Reflektion nicht bereits die Informationen festgelegt hat.  
  
 Überprüfung auf Umgebungseigenschaften ist werden in der Regel Teil des XAML-Verarbeitungslogik, um sicherzustellen, dass die Objekte und Werte, die ambient-Verwendung für abhängen, ordnungsgemäß funktionieren können. Die .NET Framework XAML Services-APIs und der Standard-XAML-Schemakontext füllt diesen Wert, der basierend auf Attribution mit <xref:System.Windows.Markup.AmbientAttribute>. Die standardmäßige Implementierung des <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> verwendet diese vorhandene <xref:System.Windows.Markup.AmbientAttribute> Technik, und es wird `true` Wenn <xref:System.Windows.Markup.AmbientAttribute> auf einer Memberdeklaration vorhanden ist.  
  
 <xref:System.Windows.Markup.AmbientAttribute> befindet sich auf mehrere WPF-Typen, einschließlich der Mitglieder <xref:System.Windows.Application>, <xref:System.Windows.Setter>, und <xref:System.Windows.Style>. Es befindet sich auch auf die <xref:System.Windows.ResourceDictionary> Typ, der suggeriert, dass alle Member, die verwendet <xref:System.Windows.ResourceDictionary> wie der Typ als ambient betrachtet werden sollte, selbst wenn das Element nicht ausdrücklich zugeschrieben wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt ein anfügbarer Member ist.</summary>
        <value>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt ein anfügbarer Member ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xaml.XamlMember.IsAttachable%2A> Wert initialisiert wird, basierend darauf, welcher Konstruktor, zum Erstellen verwendet wurde einer <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob es sich bei diesem <see cref="T:System.Xaml.XamlMember" />-Objekt um eine XAML-Direktive handelt.</summary>
        <value>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt eine XAML-Direktive ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xaml.XamlMember.IsDirective%2A> Wert initialisiert wird, basierend darauf, welcher Konstruktor, zum Erstellen verwendet wurde einer <xref:System.Xaml.XamlMember>. Die Basis <xref:System.Xaml.XamlMember> Konstruktoren initialisieren, damit <xref:System.Xaml.XamlMember.IsDirective%2A> ist `false`. Allerdings die <xref:System.Xaml.XamlDirective> Klasse (ein <xref:System.Xaml.XamlMember> abgeleitete Klasse) initialisiert, damit <xref:System.Xaml.XamlMember.IsDirective%2A> ist `true`.  
  
 Wenn Sie melden möchten <xref:System.Xaml.XamlMember.IsDirective%2A> als `true` Aufrufern einer benutzerdefinierten XAML-Schema-Klasse für XAML-Elemente, stellen Sie sicher, dass Sie eine Ableitung von <xref:System.Xaml.XamlDirective> da dies die einzige Möglichkeit, dieses Verhalten zu aktivieren ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieser <see cref="T:System.Xaml.XamlMember" /> einen Ereignismember darstellt.</summary>
        <value>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt ein Ereignis darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Xaml.XamlMember.IsEvent%2A> ruft <xref:System.Xaml.XamlMember.LookupIsEvent%2A> oder eine bestimmte Außerkraftsetzung der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt mit einer gültigen <see langword="xamlName" />-Zeichenfolge als <see cref="P:System.Xaml.XamlMember.Name" />-Eigenschaft initialisiert wird.</summary>
        <value>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt mit einer gültigen <see langword="xamlName" />-Zeichenfolge initialisiert wird, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen schreibgeschützten Member darstellt.</summary>
        <value>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen schreibgeschützten Member darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Xaml.XamlMember.IsReadOnly%2A> ruft <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> oder eine bestimmte Außerkraftsetzung der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen Member mit einem aufrufbaren öffentlichen <see langword="get" />-Accessor darstellt.</summary>
        <value>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen aufrufbaren öffentlichen <see langword="get" />-Accessor darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xaml.XamlMember.IsReadPublic%2A> -Wert prüft, ob die <xref:System.Xaml.XamlMember.DeclaringType%2A> ist öffentlich. Wenn <xref:System.Xaml.XamlMember.DeclaringType%2A> nicht öffentlich ist, die `get` Accessor kann nicht auf praktische Weise aufgerufen und <xref:System.Xaml.XamlMember.IsReadPublic%2A> gibt `false`.  
  
 Aufrufen von <xref:System.Xaml.XamlMember.IsReadPublic%2A> ruft <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> oder eine bestimmte Außerkraftsetzung der Methode.  
  
> [!IMPORTANT]
>  Die <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Methode ist virtuell und kann daher überschrieben werden. Die Außerkraftsetzung kann (in böswilliger Absicht oder anderweitig) die gemeldeten Informationen eines XAML-Elements ändern, sodass sie nicht mehr auf eine erwartete Weise mit den Typinformationen für den Zugriff von System von der zugrunde liegenden CLR-Deklaration entspricht. Verwenden Sie für die als sicherheitskritisch Überprüfungen von Zugriffsebenen stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Member durch das für Typ- und Memberauflösung verwendete Unterstützungssystem nicht aufgelöst werden kann.</summary>
        <value>
          <see langword="true" />, wenn der Member nicht aufgelöst werden kann. <see langword="false" />, wenn der Member aufgelöst werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Xaml.XamlMember> erstellt, die mit der <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> gibt `true` für <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Für einen Ladepfad, bei der <xref:System.Xaml.XamlObjectWriter>, <xref:System.Xaml.XamlMember> mit `true` für <xref:System.Xaml.XamlMember.IsUnknown%2A> kann nicht in ein Objektdiagramm geschrieben werden. Unter den standardimplementierungen, die in .NET Framework XAML Services-APIs die <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> aufrufen, löst eine <xref:System.Xaml.XamlObjectWriterException> beim entsprechenden <xref:System.Xaml.XamlMember> Berichte `true` für <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Sie sollten nicht erstellen eine <xref:System.Xaml.XamlMember> mit dem Wert des `true` für <xref:System.Xaml.XamlMember.IsUnknown%2A> es sei denn, Ihre Implementierung von Ausnahmen zu behandeln kann <xref:System.Xaml.XamlObjectWriter>, oder Sie über andere Möglichkeiten zum Anpassen der <xref:System.Xaml.XamlObjectWriter> Verhalten.  
  
 Aufrufen von <xref:System.Xaml.XamlMember.IsUnknown%2A> ruft <xref:System.Xaml.XamlMember.LookupIsUnknown%2A> oder eine bestimmte Außerkraftsetzung der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen lesegeschützten Member darstellt.</summary>
        <value>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen lesegeschützten Member darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Xaml.XamlMember.IsWriteOnly%2A> ruft <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> oder eine bestimmte Außerkraftsetzung der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen Member mit einem aufrufbaren öffentlichen <see langword="set" />-Accessor darstellt.</summary>
        <value>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen aufrufbaren öffentlichen <see langword="set" />-Accessor darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xaml.XamlMember.IsWritePublic%2A> Wert berücksichtigt, ob die <xref:System.Xaml.XamlMember.DeclaringType%2A> ist öffentlich als Teil der Bestimmung. Wenn <xref:System.Xaml.XamlMember.DeclaringType%2A> nicht öffentlich ist, die `set` Accessor kann nicht auf praktische Weise aufgerufen und <xref:System.Xaml.XamlMember.IsWritePublic%2A> gibt `false`.  
  
 Aufrufen von <xref:System.Xaml.XamlMember.IsWritePublic%2A> ruft <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> oder eine bestimmte Außerkraftsetzung der Methode.  
  
> [!IMPORTANT]
>  Die <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Methode ist virtuell und kann daher überschrieben werden. Die Außerkraftsetzung kann (in böswilliger Absicht oder anderweitig) die gemeldeten Informationen eines XAML-Elements ändern, sodass sie nicht mehr auf eine erwartete Weise mit den Typinformationen für den Zugriff von System von der zugrunde liegenden CLR-Deklaration entspricht. Verwenden Sie für die als sicherheitskritisch Überprüfungen von Zugriffsebenen stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt bei der Implementierung in einer abgeleiteten Klasse eine <see cref="T:System.Reflection.ICustomAttributeProvider" />-Implementierung zurück.</summary>
        <returns>Eine <see cref="T:System.Reflection.ICustomAttributeProvider" />-Implementierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie diese Methode zum Bereitstellen der internen Reflektions eine alternative Möglichkeit zum Abrufen von CLR-Attributwerte. In einer Außerkraftsetzung vorhanden ist, verwendet die internen Reflector typische CLR-Reflektion-Logik, z. B. Aufrufe von <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 Die Standardimplementierung gibt `null` zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt zurück, das für verzögertes Laden von in XAML deklarierten Objekten verwendet wird.</summary>
        <returns>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, der eine <see cref="T:System.Xaml.XamlDeferringLoader" />-Einschränkung für den generischen Typ besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Aufrufer ruft einen Wert aus ab, der <xref:System.Xaml.XamlMember.DeferringLoader%2A> Eigenschaft. Diese Methode überschreiben, wenn Sie möchten <xref:System.Xaml.XamlMember.DeferringLoader%2A> einen Wert, der unterscheidet sich von dem Wert zurückgegeben, die durch die standardmäßige interne Reflektion, aktiviert ist und wenn Sie auch benutzerdefinierte bereitstellen <xref:System.Xaml.Schema.XamlMemberInvoker> Informationen.  
  
 Die Standardimplementierung gibt ein Objekt lesen <xref:System.Windows.Markup.XamlDeferLoadAttribute> oder mithilfe einer <xref:System.Xaml.XamlDeferringLoader> aus den deklarierenden Typ. Wenn kein Objekt verfügbar ist, kann diese Methode zurückgeben `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste von <see cref="T:System.Xaml.XamlMember" />-Objekten zurück. Von Elementen in der Liste werden die Member gemeldet, in denen Abhängigkeitsbeziehungen für die Initialisierungsreihenfolge relativ zu diesem <see cref="T:System.Xaml.XamlMember" /> vorhanden sind.</summary>
        <returns>Eine Liste von <see cref="T:System.Xaml.XamlMember" />-Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Aufrufer ruft einen Wert aus ab, der <xref:System.Xaml.XamlMember.DependsOn%2A> Eigenschaft. Diese Methode überschreiben, wenn Sie möchten <xref:System.Xaml.XamlMember.DependsOn%2A> einen Wert, der unterscheidet sich von dem Wert zurückgegeben, die durch die standardmäßige interne Reflektion, aktiviert ist und wenn Sie auch benutzerdefinierte bereitstellen <xref:System.Xaml.Schema.XamlMemberInvoker> Informationen.  
  
 Die WPF XAML-Reader und Writer-Implementierungen-Attribut bei diesem Fall <xref:System.Windows.Markup.DependsOnAttribute>. Die Standardimplementierung verwendet diese vorhandene <xref:System.Windows.Markup.DependsOnAttribute> Verfahren.  
  
 Diese Methode überschreiben, wenn Sie nicht verwenden <xref:System.Windows.Markup.DependsOnAttribute> für diesen Zweck und zu dieser Technik zum Angeben der Verarbeitungsreihenfolge der Eigenschaft mit einer eigenen Methode ersetzen möchten. Wenn Sie nicht beabsichtigen, um eine Verarbeitungsreihenfolge für die Eigenschaft zu unterstützen, können Sie die standardmäßige Implementierung, da es keine Ergebnisse zurückgibt, Dies eignet sich.  
  
 Die Liste ist schreibgeschützt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> zurück, der diesem <see cref="T:System.Xaml.XamlMember" /> zugeordnet ist.</summary>
        <returns>Die <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />-Informationen für diesen <see cref="T:System.Xaml.XamlMember" /> oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, durch Aufrufe von <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 Die Standardimplementierung ist nicht erforderlich, eine <xref:System.Xaml.XamlMember> erstellt werden, mithilfe einer der Konstruktoren verwenden, die einen anfänglichen übergeben <xref:System.Xaml.Schema.XamlMemberInvoker>. Allerdings eine <xref:System.Xaml.XamlMember.UnderlyingMember%2A> Wert muss vorhanden sein, für die <xref:System.Xaml.XamlMember>ist, andernfalls gibt die standardmäßige Implementierung `null`.  
  
 Diese Methode überschreiben, wenn Sie auch eine Ableitung aus <xref:System.Xaml.Schema.XamlMemberInvoker> und die abgeleitete Klasse zurückgeben möchten. Wenn Sie zurückkehren `null`, <xref:System.Xaml.XamlMember.Invoker%2A> gibt <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> Aufrufern.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob das <see cref="T:System.Xaml.XamlMember" />-Objekt als Ambient-Eigenschaft gemeldet wird.</summary>
        <returns>
          <see langword="true" />, wenn dieser <see cref="T:System.Xaml.XamlMember" /> als Ambient-Eigenschaft gemeldet werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird vom internen Aufrufe aufgerufen, die auf ambient XAML-Eigenschaftsinformationen überprüfen. Verhalten der Ambient-Eigenschaft wird in der öffentlichen API-Verhalten des XAML-Readern und XAML-Writern berücksichtigt. Diese internen Aufrufe, die auf verweisen <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> sind in der Regel Teil des XAML-Verarbeitungslogik, um sicherzustellen, dass Sie Objekte und Werte, die ambient-Verwendung für abhängen, ordnungsgemäß funktionieren können. Die standardmäßige .NET Framework-XAML-Dienste-Implementierung verwendet die CLR, um diese Informationen aus der Reflektion abzurufen, über die Unterstützungstypen Attributierung. Insbesondere sucht die standardmäßige Implementierung <xref:System.Windows.Markup.AmbientAttribute> und gibt `true` für <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> Wenn <xref:System.Windows.Markup.AmbientAttribute> auf eine Elementdefinition vorhanden ist.  
  
 Diese Methode überschreiben, wenn Sie nicht verwenden <xref:System.Windows.Markup.AmbientAttribute> für diesen Zweck und zu dieser Technik zum Angeben der Ambiente-XAML-Eigenschaften mit einer eigenen Methode ersetzen möchten.  
  
 Beispiel-APIs von WPF, die mit dem Attribut <xref:System.Windows.Markup.AmbientAttribute> sind <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> und <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob diese <see cref="T:System.Xaml.XamlMember" />-Klasse ein Ereignis darstellt.</summary>
        <returns>
          <see langword="true" />, wenn gemeldet werden soll, dass dieser <see cref="T:System.Xaml.XamlMember" /> ein Ereignis darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung überprüft, ob <xref:System.Xaml.XamlMember.UnderlyingMember%2A> ist vom Typ <xref:System.Reflection.EventInfo>, und gibt zurück, wenn es sich handelt, `true`.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.IsEvent%2A>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie spezielle Metadaten verfügbar, die interpretiert werden können, um zu bestimmen, XAML typdarstellungen System pro Fall zu Fall.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob die <see cref="T:System.Xaml.XamlMember" />-Klasse eine beabsichtigte schreibgeschützte Eigenschaft darstellt.</summary>
        <returns>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt als gewünschte schreibgeschützte Eigenschaft gemeldet werden soll, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt `true` Wenn <xref:System.Xaml.XamlMember.UnderlyingMember%2A> vorhanden, wird aber eine öffentliche `set` Accessor ist nicht für ihn gemäß der internen Reflektion.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.IsReadOnly%2A>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie spezielle Metadaten verfügbar, die interpretiert werden können, um zu bestimmen, XAML typdarstellungen System pro Fall zu Fall.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob das <see cref="T:System.Xaml.XamlMember" />-Objekt eine Eigenschaft darstellt, die über einen öffentlichen <see langword="get" />-Accessor verfügt.</summary>
        <returns>
          <see langword="true" />, wenn dieser <see cref="T:System.Xaml.XamlMember" /> eine Eigenschaft mit einem öffentlichen <see langword="get" />-Accessor darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt Ergebnisse basierend auf internen Reflektion oder die Negation des <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, die in dieser Reihenfolge verarbeiten.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Gibt zurück, ob das Element selbst öffentlich ist. Es gibt `true` für einen öffentlichen Member auf eine Nonpublic Typ deklarieren. Verwendung <xref:System.Xaml.XamlMember.IsReadPublic%2A> stattdessen sollten Sie auch die Sichtbarkeit des deklarierenden Typs berücksichtigt.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.IsReadPublic%2A>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie Metadaten verfügbar sind spezielle, diese pro-Fall zu Fall bestimmen.  
  
> [!IMPORTANT]
>  Die <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Methode ist virtuell und kann daher überschrieben werden. Die Außerkraftsetzung kann (in böswilliger Absicht oder anderweitig) die gemeldeten Informationen eines XAML-Elements ändern, sodass sie nicht mehr auf eine erwartete Weise mit den Typinformationen für den Zugriff von System von der zugrunde liegenden CLR-Deklaration entspricht. Verwenden Sie für die als sicherheitskritisch Überprüfungen von Zugriffsebenen stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob diese <see cref="T:System.Xaml.XamlMember" />-Klasse ein Element darstellt, das vom Sicherungssystem für Typ- und Elementauflösung nicht aufgelöst werden kann.</summary>
        <returns>
          <see langword="true" />, wenn diese <see cref="T:System.Xaml.XamlMember" />-Klasse ein nicht auflösbares Element darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.IsUnknown%2A>. Die Standardimplementierung gibt Ergebnisse, die basierend auf entweder interne Reflektion oder Suchen nach einer `null` Wert <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, die in dieser Reihenfolge verarbeiten.  
  
 Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie Metadaten verfügbar sind spezielle, diese pro-Fall zu Fall bestimmen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen Member darstellt, der über einen öffentlichen <see langword="set" />-Accessor, jedoch nicht über einen öffentlichen <see langword="get" />-Accessor verfügt.</summary>
        <returns>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen lesegeschützten Member darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt `true` Wenn ein <xref:System.Xaml.XamlMember.UnderlyingMember%2A> vorhanden ist, besitzt eine öffentliche `set` -Accessor und einen Nonpublic `get` Zugriffsmethode, gemäß der internen Reflektion.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.IsWriteOnly%2A>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie Metadaten verfügbar sind spezielle, diese pro-Fall zu Fall bestimmen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt zurück, ob dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen Member darstellt, der über einen öffentlichen <see langword="set" />-Accessor verfügt.</summary>
        <returns>
          <see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlMember" />-Objekt einen schreibbaren Member darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung gibt Ergebnisse basieren entweder interne Reflektion oder die Negation des <xref:System.Xaml.XamlMember.IsReadOnly%2A>, die in dieser Reihenfolge verarbeiten.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie Metadaten verfügbar sind spezielle, diese pro-Fall zu Fall bestimmen.  
  
> [!IMPORTANT]
>  Die <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> Methode ist virtuell und kann daher überschrieben werden. Die Außerkraftsetzung kann (in böswilliger Absicht oder anderweitig) die gemeldeten Informationen eines XAML-Elements ändern, sodass sie nicht mehr auf eine erwartete Weise mit den Typinformationen für den Zugriff von System von der zugrunde liegenden CLR-Deklaration entspricht. Verwenden Sie für die als sicherheitskritisch Überprüfungen von Zugriffsebenen stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Zeichen für öffnende und schließende Klammern einer Markuperweiterung zurück.</summary>
        <returns>Eine Auflistung, die die Zeichen für öffnende und schließende Klammern enthält.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die <see cref="T:System.Xaml.XamlType" />-Klasse des Typs zurück, in dem das <see cref="T:System.Xaml.XamlMember" />-Objekt vorhanden sein kann.</summary>
        <returns>Der Typ, auf dem das <see cref="T:System.Xaml.XamlMember" />-Objekt vorhanden sein kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung unterscheidet zwischen anfügbaren und nicht anfügbare Member. Für nicht-anfügbare Member <xref:System.Xaml.XamlMember.LookupTargetType%2A> gibt immer <xref:System.Xaml.XamlMember.DeclaringType%2A>. Für anfügbare Member <xref:System.Xaml.XamlMember.LookupTargetType%2A> gibt ein Ergebnis basierend auf der Auswertung der <xref:System.Xaml.XamlMember.UnderlyingMember%2A> Accessor Parametertyp und interpretiert, dass Typ auf XAML-Schemakontext basiert.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.TargetType%2A>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie Metadaten verfügbar sind spezielle, diese pro-Fall zu Fall bestimmen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das <see cref="T:System.Xaml.XamlType" />-Objekt des vom Member verwendeten Typs zurück.</summary>
        <returns>Das <see cref="T:System.Xaml.XamlType" />-Objekt des vom Member verwendeten Typs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.Type%2A>. Diese Methode überschreiben, wenn Sie möchten <xref:System.Xaml.XamlMember.Type%2A> einen Wert, der unterscheidet sich von dem Wert zurückgegeben, die durch die standardmäßige interne Reflektion, aktiviert ist und wenn Sie auch benutzerdefinierte bereitstellen <xref:System.Xaml.Schema.XamlMemberInvoker> Informationen.  
  
 Die Standardimplementierung verwendet unterschiedliche Codepfade und konzeptionellen Bedeutung für das zurückgegebene <xref:System.Xaml.XamlType> , ist abhängig davon, ob dies <xref:System.Xaml.XamlMember> stellt eine Eigenschaft, Methode oder das Ereignis.  
  
-   Für eine Eigenschaft, die den zurückgegebenen <xref:System.Xaml.XamlType> ist der Typ, der die Eigenschaft oder durch die Eigenschaft zurückgegeben.  
  
-   Für ein Ereignis, das zurückgegebene <xref:System.Xaml.XamlType> ist die erforderliche Ereignishandlertyp (ein Delegat in einer CLR-Implementierung).  
  
-   Bei einer Methode <xref:System.Xaml.XamlType> ist der Rückgabetyp ein.  
  
 In jedem Fall wird die XAML-Schemakontext verwendet, um den XAML-Typ aus dem zugrunde liegenden Systemtyp auszuwerten.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.Type%2A>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie Metadaten verfügbar sind spezielle, diese pro-Fall zu Fall bestimmen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Typkonverterimplementierung zurück, die dieser <see cref="T:System.Xaml.XamlMember" />-Klasse zugeordnet ist.</summary>
        <returns>Eine <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Instanz mit der <see cref="T:System.ComponentModel.TypeConverter" />-Einschränkung oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung verwendet die folgende Logik und die Verarbeitungsreihenfolge von Artikeln:  
  
-   Wenn Attributierung, die auf Memberebene vorhanden ist (<xref:System.ComponentModel.TypeConverterAttribute>), die Attributinformationen werden für einen Aufruf von <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> für den XAML-Schemakontext.  
  
-   Wenn <xref:System.Xaml.XamlMember.Type%2A> gültig ist, ein Typkonverter, der dem Typ zugeordnet ist, wird zurückgegeben.  
  
-   Wenn der Member ein Ereignis ist, wird ein ereignisspezifische Typkonverter zurückgegeben.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.TypeConverter%2A>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie Metadaten verfügbar sind spezielle, diese pro-Fall zu Fall bestimmen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see langword="get" />-Accessor zurück, der dieser <see cref="T:System.Xaml.XamlMember" />-Klasse zugeordnet ist.</summary>
        <returns>Die <see cref="T:System.Reflection.MethodInfo" /> für den zugeordneten <see langword="get" />-Accessor oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung interpretiert die <xref:System.Xaml.XamlMember.UnderlyingMember%2A> Eigenschaft als <xref:System.Reflection.PropertyInfo> und gibt den Wert der <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> (mit den Parameter auf `true`), was bedeutet, dass die zurückgegebene Methode nicht öffentlich sein kann. Dieses Verhalten kann dazu führen `null` für bestimmte Fälle. einschließlich der Fälle, in denen kein zugeordneten-Accessor vorhanden ist oder das Element ist keine Eigenschaft.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer ruft einen Wert aus ab, der <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> Eigenschaft eines zugeordneten <xref:System.Xaml.Schema.XamlMemberInvoker>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie Metadaten verfügbar sind spezielle, diese pro-Fall zu Fall bestimmen. Stellen Sie sicher, dass implementieren <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, und <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> , damit sie alle abhängigen Ergebnisse zurückgeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine <see cref="T:System.Reflection.MemberInfo" /> des CLR-Typsystems zurück, die diesem <see cref="T:System.Xaml.XamlMember" /> zugeordnet ist.</summary>
        <returns>Ein <see cref="T:System.Reflection.MemberInfo" />-Objekt des CLR-Typsystems, das diesem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnet ist, oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die standardmäßige Implementierung der zugrunde liegenden gibt Memberinformationen zurück, basierend auf der Erstellung. Wenn die <xref:System.Reflection.MemberInfo> Objekt erstellt wird, mit einer Signatur, die nicht genügend Informationen zum Festlegen von des zugrunde liegenden Members bereitstellt, die diese Methode gibt `null`.  
  
 Wenn ein Element mit zugrunde liegenden während der Erstellung festgelegt wurde, müssen Sie nicht diese Methode aufrufen.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie Metadaten verfügbar sind spezielle, diese pro-Fall zu Fall bestimmen. Stellen Sie sicher, dass implementieren <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, und <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> , damit sie alle abhängigen Ergebnisse zurückgeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see langword="set" />-Accessor zurück, der dieser <see cref="T:System.Xaml.XamlMember" />-Klasse zugeordnet ist.</summary>
        <returns>Die <see cref="T:System.Reflection.MethodInfo" /> für den zugeordneten <see langword="set" />-Accessor oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung interpretiert <xref:System.Xaml.XamlMember.UnderlyingMember%2A> als <xref:System.Reflection.PropertyInfo> und gibt den Wert der <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> (mit den Parameter auf `true`), was bedeutet, dass die zurückgegebene Methode nicht öffentlich sein kann. Dies kann dazu führen `null` in bestimmten Fällen, wo es ist kein solcher Accessor, oder das Element ist keine Eigenschaft.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> eines zugeordneten <xref:System.Xaml.Schema.XamlMemberInvoker>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie Metadaten verfügbar sind spezielle, diese pro-Fall zu Fall bestimmen. Stellen Sie sicher, dass implementieren <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, und <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> , damit sie alle abhängigen Ergebnisse zurückgeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Wertserialisierungsprogramm-Implementierung zurück, die diesem <see cref="T:System.Xaml.XamlMember" />-Objekt zugeordnet ist.</summary>
        <returns>Eine <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Instanz mit der <see cref="T:System.Windows.Markup.ValueSerializer" />-Einschränkung oder <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardimplementierung verwendet die folgende Logik und die Verarbeitungsreihenfolge von Artikeln:  
  
-   Wenn Attributierung, die auf Memberebene vorhanden ist (<xref:System.Windows.Markup.ValueSerializerAttribute>), die Attributinformationen werden für einen Aufruf von <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> für den XAML-Schemakontext.  
  
-   Wenn <xref:System.Xaml.XamlMember.Type%2A> gültig ist, ein Wertkonverter, der dem Typ zugeordnet ist, wird zurückgegeben.  
  
-   Wenn die Bedingungen nicht zutreffen, `null` zurückgegeben wird.  
  
 Diese Methode wird aufgerufen, wenn ein Aufrufer einen Wert aus erhält <xref:System.Xaml.XamlMember.ValueSerializer%2A>. Diese Methode überschreiben, falls Berichts einheitliche Ergebnisse für eine gesamte gewünscht <xref:System.Xaml.XamlMember> abgeleitete Klasse sein, oder wenn Sie Metadaten verfügbar sind spezielle, diese pro-Fall zu Fall bestimmen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Definiert die Zeichen für öffnende und schließende Klammern einer Markuperweiterung.</summary>
        <value>Eine Auflistung, die die Zeichen für öffnende und schließende Klammern enthält.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see langword="xamlName" />-Namenszeichenfolge ab, durch die dieses <see cref="T:System.Xaml.XamlMember" />-Objekt deklariert wird.</summary>
        <value>Die <see langword="xamlName" />-Namenszeichenfolge, durch die dieses <see cref="T:System.Xaml.XamlMember" />-Objekt deklariert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Wert wird immer während der Konstruktion festgelegt. Die Konstruktoren, die von implementiert werden <xref:System.Xaml.XamlMember> in der Regel eine Ausnahme ausgelöst, wenn ein ursprünglicher Name nicht angegeben wurde, daher erwarten nicht, diese Eigenschaft `null` oder eine leere Zeichenfolge sein, wenn Sie standardmäßige .NET Framework-XAML-Dienste verwenden Implementierungen.  
  
 [XamlName-Grammatik](~/docs/framework/xaml-services/xamlname-grammar.md) und Benennungsregeln für CLR-Typ und Member sind nicht genaue Schnittmenge. Es ist möglich, einen Elementnamen zu deklarieren, der unter CLR ist jedoch nicht gültig ist, in XAML zu benennen. Diese Situation vermeiden Sie wenn möglich.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
          <see cref="T:System.Xaml.XamlMember" /> oder <see langword="null" />.</param>
        <param name="xamlMember2">
          <see cref="T:System.Xaml.XamlMember" /> oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.Xaml.XamlMember" />-Objekte denselben Wert haben.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="xamlMember1" /> und <paramref name="xamlMember2" /> denselben Wert haben, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1">
          <see cref="T:System.Xaml.XamlMember" /> oder <see langword="null" />.</param>
        <param name="xamlMember2">
          <see cref="T:System.Xaml.XamlMember" /> oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.Xaml.XamlMember" />-Objekte verschiedene Werte haben.</summary>
        <returns>
          <see langword="true" />, wenn der Wert von <paramref name="xamlMember1" /> vom Wert von <paramref name="xamlMember2" /> abweicht, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den einzelnen XAML-Namespace-URI ab, der den primären XAML-Namespace für dieses <see cref="T:System.Xaml.XamlMember" />-Objekt bezeichnet.</summary>
        <value>Der Bezeichner für den primären XAML-Namespace für dieses <see cref="T:System.Xaml.XamlMember" />-Objekt als Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> Eigenschaft enthält den gleichen Wert wie das Aufrufen <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> und klicken Sie dann die erste Wertzeichenfolge aus der zurückgegebenen Liste abgerufen. Der bevorzugte XAML-Namespace sollte verwendet werden, wenn das Element zu schreiben, zurück zum Text oder anderen Darstellungen bereit, die XAML-Namespaceinformationen beibehalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />-Wert ab, der angibt, wie der Member von einem visuellen Designer verarbeitet werden soll.</summary>
        <value>Ein Wert der <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />-Enumeration. Der Standardwert ist <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xaml.XamlType" />-Objekt des Typs ab, in dem das <see cref="T:System.Xaml.XamlMember" />-Objekt vorhanden sein kann.</summary>
        <value>Der Typ, auf dem das <see cref="T:System.Xaml.XamlMember" />-Objekt vorhanden sein kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der zurückgegebene Wert unterscheidet sich für anfügbare und nicht anfügbare Member. Für nicht-anfügbare Member <xref:System.Xaml.XamlMember.TargetType%2A> gibt <xref:System.Xaml.XamlMember.DeclaringType%2A>. Für anfügbare Member <xref:System.Xaml.XamlMember.LookupTargetType%2A> ein Wert zurückgegeben, die diese Logik basiert:  
  
-   Wenn ein sichernder Reflektion nicht aufgelöst werden kann (<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`), diese Methode gibt eine interne-Konstante, die ein generisches Objekt darstellt.  
  
-   Wenn die vorherige Bedingung nicht zutrifft, <xref:System.Xaml.XamlMember.LookupTargetType%2A> aufgerufen wird. Die Standardimplementierung gibt eine <xref:System.Xaml.XamlType> , basiert auf untersucht die Methoden, implementieren die `get` und `set` Accessoren. Eine Klasse kann außer Kraft setzen <xref:System.Xaml.XamlMember.LookupTargetType%2A> auf ein anderes Verhalten zu verwenden, z. B. andere Metadaten, die forms meldet möglicherweise Zieltypen für anfügbare Member.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolgendarstellung für diese <see cref="T:System.Xaml.XamlMember" /> zurück.</summary>
        <returns>Eine Zeichenfolgendarstellung für diese <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung gibt <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xaml.XamlType" />-Objekt des vom Member verwendeten Typs ab.</summary>
        <value>Das <see cref="T:System.Xaml.XamlType" />-Objekt des vom Member verwendeten Typs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Xaml.XamlMember.Type%2A> ruft <xref:System.Xaml.XamlMember.LookupType%2A> oder eine bestimmte Außerkraftsetzung der Methode. Dies tritt auf, wenn die erste interne Reflektionslogik die Informationen nicht bereits festgelegt wurde.  
  
 Das Standardverhalten (keine <xref:System.Xaml.XamlMember.LookupType%2A> außer Kraft setzen), die zurückgegebene <xref:System.Xaml.XamlType> konzeptionellen eine andere Bedeutung haben. Welche Bedeutung gültig davon abhängig, ob dies <xref:System.Xaml.XamlMember> stellt eine Eigenschaft, Methode oder das Ereignis, wie in der folgenden Liste dargestellt:  
  
-   Für eine Eigenschaft, die den zurückgegebenen <xref:System.Xaml.XamlType> ist der Typ, der die Eigenschaft oder durch die Eigenschaft zurückgegeben.  
  
-   Für ein Ereignis, das zurückgegebene <xref:System.Xaml.XamlType> ist die erforderliche Ereignishandlertyp (ein Delegat in einer CLR-Implementierung).  
  
-   Bei einer Methode <xref:System.Xaml.XamlType> ist der Rückgabetyp dieser Methode, die möglicherweise `null`.  
  
 In jedem Fall wird der XAML-Schemakontext verwendet, um den XAML-Typ aus dem unterstützenden Typ auszuwerten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt ab, das für die Typkonvertierungserstellung von in XAML deklarierten Objekten verwendet wird.</summary>
        <value>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Wert mit einer <see cref="T:System.ComponentModel.TypeConverter" />-Einschränkung für den generischen Typ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Xaml.XamlMember.TypeConverter%2A> ruft <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> oder eine bestimmte Außerkraftsetzung der Methode. Dieses Verhalten tritt auf, wenn die erste interne Reflektionslogik die Informationen nicht bereits festgelegt wurde.  
  
 Value-Implementierungen, die eine nicht-Null-Eigenschaft zurückgeben für <xref:System.Xaml.XamlMember.TypeConverter%2A> sind nicht unbedingt eine funktionierende <xref:System.ComponentModel.TypeConverter>. Im folgenden werden eine Liste der möglichen Rückgabewerte ungleich Null für <xref:System.Xaml.XamlMember.TypeConverter%2A> und was diese Werte darstellen:  
  
-   Der Rückgabewert gibt einen Typkonverter, der speziell für diesen Member oder üblicher in den Zieltyp des Konverters attributiert ist. Dieses Verhalten ist in der Regel welche die meisten XAML-Typsysteme und XAML-Prozessoren, um einen Typkonverter zu instanziieren und Aufrufen ihrer Methoden gesucht.  
  
-   Der Rückgabewert gibt einen integrierten Wertkonverter. Diese Konverter sind für bestimmte interne Vorgänge, die von einem XAML-Writer ausgeführt werden. Diese integrierten Wertkonverter werden insbesondere die unformatierte Zeichenfolge Attributwerte, die XAML-Sprachebene primitive konvertieren. Für die .NET Framework-XAML-Dienste-Implementierung Weiterleiten dieser integrierten typkonvertierungen oft für einen Typkonverter, der in der System-Assembly definiert ist. Z. B. eine Konvertierung für einen <xref:System.Int32> Wert verfügt über integrierte Konvertierung weitergeleitete und somit die <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> Wert verweisen <xref:System.ComponentModel.Int32Converter>.  
  
-   Der Rückgabewert meldet besonderen Fall eines uneingeschränkte Objektmodells; d. h. die <xref:System.Xaml.XamlMember> verfügt über eine <xref:System.Xaml.XamlMember.Type%2A> Wert <xref:System.Object>. In diesem Fall die <xref:System.Xaml.Schema.XamlValueConverter%601> meldet, dass die <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> ist {`Object}`. Allerdings <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> ist `null` da kein tatsächlicher Typ oder Instanz verfügbar, um diese Konvertierung auszuführen. Stattdessen kann das Verhalten des Objektmodells bis zur Laufzeit bestimmt werden bei die Laufzeit von der jeweiligen Technologie für die Behandlung von seinem Objektdiagramm bestimmt.  
  
 Wenn Sie eine funktionierende zugreifen können <xref:System.ComponentModel.TypeConverter> aus <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>, Sie können die Methoden für die Konvertierung aufrufen. Dienstkontext jedoch abhängig viele Methoden für die Konvertierung. Wenn Sie den gleichen Dienstkontext nicht, dass der Typkonverter für das Schreiben von Objekten für Objektdiagramme seine typische Rolle erwartet haben, können die Konvertermethoden Ausnahmen auslösen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Reflection.MemberInfo" /> des CLR-Typsystems ab, die für einen Member verfügbar ist, der von <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" /> oder <see cref="T:System.Reflection.EventInfo" /> erstellt wird.</summary>
        <value>
          <see cref="T:System.Reflection.MemberInfo" />-Informationen des CLR-Typsystems entsprechend der Umwandlung von den ursprünglichen Konstruktorparametern. Ein <see cref="T:System.Xaml.XamlMember" />-Objekt, das mit der <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />-Signatur erstellt wird, gibt <see langword="null" /> zurück.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Xaml.XamlMember.UnderlyingMember%2A> ruft <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> oder eine bestimmte Außerkraftsetzung der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt ab, das für die Wertserialisierung von in XAML deklarierten Objekten verwendet wird.</summary>
        <value>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit <see cref="T:System.Windows.Markup.ValueSerializer" />-Einschränkung für den generischen Typ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Xaml.XamlMember.ValueSerializer%2A> ruft <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> oder eine bestimmte Außerkraftsetzung der Methode. Dieses Verhalten tritt auf, wenn die erste interne Reflektionslogik die Informationen nicht bereits festgelegt wurde.  
  
 Nicht alle Fälle, die eine nicht-Null-Eigenschaft zurückgeben Wert für <xref:System.Xaml.XamlMember.ValueSerializer%2A> sind notwendigerweise ein funktionierendes <xref:System.Windows.Markup.ValueSerializer>. Finden Sie unter <xref:System.Xaml.XamlMember.TypeConverter%2A>; die gleichen Überlegungen gelten für <xref:System.Xaml.XamlMember.ValueSerializer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>