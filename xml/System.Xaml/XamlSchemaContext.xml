<Type Name="XamlSchemaContext" FullName="System.Xaml.XamlSchemaContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5c526740d35054a09aeed4424a73623633956b2d" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82286927" /></Metadata><TypeSignature Language="C#" Value="public class XamlSchemaContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlSchemaContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlSchemaContext" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlSchemaContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlSchemaContext" />
  <TypeSignature Language="F#" Value="type XamlSchemaContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Definiert einen wiederverwendbaren Kontext zum Interpretieren oder Zuordnen von XAML-Typen und der Typen in den Assemblys, die ihnen zugrunde liegen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein XAML-Schema Kontext stellt eine Abstraktions Ebene zwischen einem Schema oder Vokabular für XAML und einer spezifischen Parser-Implementierung bereit. Durch Einfügen des Konzepts eines Schema Kontexts kann das Schema mit unterschiedlichen XAML-Parsers verwendet werden, und der Schema Kontext füllt die Details aus, die für die Interaktion mit einem bestimmten XAML-Parser benötigt werden. Der XAML-Schema Kontext stellt z. b. Abfrage-APIs bereit, die sich auf XAML-Konzepte oder die CLR-Bindung an das XAML-Typsystem beziehen. Der XAML-Schema Kontext ist auch für die Verwaltung der Assemblyliste geladener Assemblys zuständig, die definiert, wo ein XAML-Parser nach Unterstützungs Typen sucht.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>In einer <see cref="T:System.AppDomain" />kann ein <see cref="T:System.Xaml.XamlSchemaContext" /> von mehreren Aufrufern gemeinsam genutzt werden, die sowohl vollständige als auch teilweise vertrauenswürdige Aufrufer enthalten. Diese Situation besteht in Frameworks wie WPF, die teilweise vertrauenswürdigen Zugriff auf das XAML-laden für Teile des WPF-Anwendungs Modells bereitstellen. Die Standard <see cref="T:System.Xaml.XamlSchemaContext" />-Implementierung bietet Sicherheitsvorkehrungen in diesem Szenario, indem alle zugehörigen Eigenschaften und Einstellungen unveränderlich bleiben. Abgeleitete Implementierungen sollten auch das Befolgen dieses Modells der Unveränderlichkeit für Eigenschaften und Einstellungen eines XAML-Schema Kontexts in Erwägung gezogen werden.  
  
Die <see cref="T:System.Xaml.XamlSchemaContext" /> Basisklasse ist so konzipiert, dass suchen keine extern beobachtbaren Nebeneffekte haben. Die Typen, auf die von <see cref="T:System.Xaml.XamlSchemaContext" />-APIs in der Basisklasse verwiesen wird, z. b. <see cref="T:System.Xaml.XamlType" /> oder <see cref="T:System.Xaml.XamlMember" />, bewirken auch keine Nebeneffekte von Such Vorgängen. Alle Daten, die zum Treffen einer Schema Bestimmung benötigt werden, sollten über die Erstellung und die Einstellungen der <see cref="T:System.AppDomain" />verfügbar sein. Beachten Sie, dass sich keine Such-APIs auf explizit bestandenen Diensten stützen. Ihre Eingabe basiert nur auf Zeichen folgen Eingaben.  
  
Die <see cref="T:System.Xaml.XamlSchemaContext" /> Basisklasse und <see cref="T:System.Xaml.XamlType" /> und <see cref="T:System.Xaml.XamlMember" /> sind in ihren Basis Implementierungen Thread sicher. Wenn Sie von <see cref="T:System.Xaml.XamlSchemaContext" /> ableiten oder XAML-Typsystem Klassen, z. b. <see cref="T:System.Xaml.XamlType" /> und <see cref="T:System.Xaml.XamlMember" />, ableiten, können Sie auswählen, ob sich Ihre Klassen als Thread sicher Verhalten.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; referenceAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; referenceAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (referenceAssemblies As IEnumerable(Of Assembly))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ referenceAssemblies);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : seq&lt;System.Reflection.Assembly&gt; -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext referenceAssemblies" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="referenceAssemblies" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;" />
      </Parameters>
      <Docs>
        <param name="referenceAssemblies">Ein aufzählbarer Satz von Assemblyinformationselementen. Jedes Assemblyinformationselement wird durch einen <see cref="T:System.Reflection.Assembly" />-Wert angegeben.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlSchemaContext" />-Klasse auf der Grundlage eines Satzes von Verweisassemblys.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Xaml.XamlSchemaContextSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xaml.XamlSchemaContextSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Xaml.XamlSchemaContextSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (settings As XamlSchemaContextSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Xaml::XamlSchemaContextSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : System.Xaml.XamlSchemaContextSettings -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext settings" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="settings" Type="System.Xaml.XamlSchemaContextSettings" />
      </Parameters>
      <Docs>
        <param name="settings">Das Einstellungsobjekt für das Erstellen der <see cref="T:System.Xaml.XamlSchemaContext" />-Klasse.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlSchemaContext" />-Klasse auf der Grundlage eines Einstellungsobjekts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Einstellungs Objekt speichert Informationen zu Text Konvertern und Markup Erweiterungs Besonderheiten für den Schema Kontext. Weitere Informationen finden Sie unter <xref:System.Xaml.XamlSchemaContextSettings>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlSchemaContext (System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; referenceAssemblies, System.Xaml.XamlSchemaContextSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; referenceAssemblies, class System.Xaml.XamlSchemaContextSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.#ctor(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Xaml.XamlSchemaContextSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (referenceAssemblies As IEnumerable(Of Assembly), settings As XamlSchemaContextSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlSchemaContext(System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ referenceAssemblies, System::Xaml::XamlSchemaContextSettings ^ settings);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlSchemaContext : seq&lt;System.Reflection.Assembly&gt; * System.Xaml.XamlSchemaContextSettings -&gt; System.Xaml.XamlSchemaContext" Usage="new System.Xaml.XamlSchemaContext (referenceAssemblies, settings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="referenceAssemblies" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;" />
        <Parameter Name="settings" Type="System.Xaml.XamlSchemaContextSettings" />
      </Parameters>
      <Docs>
        <param name="referenceAssemblies">Ein aufzählbarer Satz von Assemblyinformationen. Jedes Assemblyinformationselement wird durch einen <see cref="T:System.Reflection.Assembly" />-Wert angegeben.</param>
        <param name="settings">Das Einstellungsobjekt für das Erstellen der <see cref="T:System.Xaml.XamlSchemaContext" />-Klasse.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlSchemaContext" />-Klasse auf Grundlage eines Satzes von Verweisassemblys und eines Einstellungsobjekts.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~XamlSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!XamlSchemaContext ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="xamlSchemaContext.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt eine nicht standardmäßige <see langword="Finalize" />-Implementierung bereit, in der <see langword="Dispose" /> nicht aufgerufen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 XAML-Schema Kontexte sollten nicht von automatischen Garbage Collection oder manuellen Vorgängen verworfen werden. Obwohl XAML-Schema Kontexte nicht über nicht verwaltete Ressourcen verfügen, können <xref:System.Windows.Markup.XamlDeferLoadAttribute> Eigenschaften weiterhin aktiv sein, und das Freigeben eines XAML-Schema Kontexts kann den zugehörigen Verzögerungs Ladevorgang beeinträchtigen.  
  
 <xref:System.AppDomain.AssemblyLoad> Ereignishandler, die intern als schwache Verweise verknüpft sind, werden durch diese Implementierung bereinigt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifyAssemblyNamesInClrNamespaces">
      <MemberSignature Language="C#" Value="public bool FullyQualifyAssemblyNamesInClrNamespaces { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FullyQualifyAssemblyNamesInClrNamespaces As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FullyQualifyAssemblyNamesInClrNamespaces { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifyAssemblyNamesInClrNamespaces : bool" Usage="System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein XAML-Schema und der Kontext vollqualifizierte Assemblynamen in den von der Such-API zurückgegebenen Werten verwenden.</summary>
        <value><see langword="true" />, wenn ein XAML-Schema und der Kontext vollqualifizierte Assemblynamen in den von den Such-APIs zurückgegebenen Werten verwenden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den <xref:System.Xaml.XamlSchemaContextSettings.FullyQualifyAssemblyNamesInClrNamespaces%2A?displayProperty=nameWithType> Wert zurück, der in den Einstellungen für die <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Xaml.XamlSchemaContextSettings%29>-Konstruktorsignatur festgelegt wird. Wenn andere Signaturen für die Erstellung verwendet wurden oder <xref:System.Xaml.XamlSchemaContextSettings.FullyQualifyAssemblyNamesInClrNamespaces%2A?displayProperty=nameWithType> nicht explizit auf `true`festgelegt ist, wird der Wert dieser Eigenschaft `false`.  
  
 Der Wert dieser Eigenschaft wirkt sich auf die Zeichen folgen aus, die von <xref:System.Xaml.XamlSchemaContext.GetAllXamlNamespaces%2A>zurückgegeben werden. Wenn <xref:System.Xaml.XamlSchemaContext.FullyQualifyAssemblyNamesInClrNamespaces%2A> `true`ist, meldet der Assemblyteil der Zeichenfolge die Entsprechung von <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetAllXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetAllXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetAllXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllXamlNamespaces () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetAllXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetAllXamlNamespaces : unit -&gt; seq&lt;string&gt;&#xA;override this.GetAllXamlNamespaces : unit -&gt; seq&lt;string&gt;" Usage="xamlSchemaContext.GetAllXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sucht die in dieser <see cref="T:System.Xaml.XamlSchemaContext" />-Klasse enthaltenen Assemblys und gibt einen Satz von Namespaces zurück.</summary>
        <returns>Ein aufzählbarer Satz von Namespacebezeichnern. Diese Bezeichner werden als Zeichenfolgen bereitgestellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode werden nur die Verweisassemblys durchsucht, wenn Sie über die Konstruktions-oder Eigenschafts Einstellung über Wenn keine Assemblys als Verweisassemblys erstellt werden, überprüft die Logik dieser Methode alle geladenen Assemblys, in denen diese <xref:System.Xaml.XamlSchemaContext> aktiv ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllXamlTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt; GetAllXamlTypes (string xamlNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlType&gt; GetAllXamlTypes(string xamlNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetAllXamlTypes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetAllXamlTypes (xamlNamespace As String) As ICollection(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::ICollection&lt;System::Xaml::XamlType ^&gt; ^ GetAllXamlTypes(System::String ^ xamlNamespace);" />
      <MemberSignature Language="F#" Value="abstract member GetAllXamlTypes : string -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;&#xA;override this.GetAllXamlTypes : string -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;" Usage="xamlSchemaContext.GetAllXamlTypes xamlNamespace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Der XAML-Namespace, für den Typen zurückgegeben werden sollen.</param>
        <summary>Sucht die in dieser <see cref="T:System.Xaml.XamlSchemaContext" />-Klasse enthaltenen Assemblys und gibt einen Satz von Typen aus dem angegebenen XAML-Namespace zurück.</summary>
        <returns>Ein aufzählbarer Satz von XAML-Typen. Jeder XAML-Typ im Satz wird durch ein <see cref="T:System.Xaml.XamlType" />-Objekt dargestellt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreferredPrefix">
      <MemberSignature Language="C#" Value="public virtual string GetPreferredPrefix (string xmlns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetPreferredPrefix(string xmlns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetPreferredPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredPrefix (xmlns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetPreferredPrefix(System::String ^ xmlns);" />
      <MemberSignature Language="F#" Value="abstract member GetPreferredPrefix : string -&gt; string&#xA;override this.GetPreferredPrefix : string -&gt; string" Usage="xamlSchemaContext.GetPreferredPrefix xmlns" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlns">Der XAML-Namespace, für den das bevorzugte Präfix abgerufen werden soll.</param>
        <summary>Ruft beim Zuordnen des angegebenen XAML-Namespaces eine Zeichenfolge ab, die als bevorzugtes Präfix für Consumer angegeben wird.</summary>
        <returns>Eine Zeichenfolge, die von Consumern beim Zuordnen des angegebenen XAML-Namespaces zur Markupverwendung verwendet werden sollte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der unmittelbarste Consumer der Informationen ist in der Regel ein XAML-Writer. Andere indirekte Consumer enthalten Entwurfs Tools.  
  
 Als Teil der XAML-Bindung für die Common Language Runtime (CLR) können Sie diese Informationen angeben, indem Sie <xref:System.Windows.Markup.XmlnsPrefixAttribute> auf Assemblyebene anwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="xmlns" /> ist NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueConverter&lt;TConverterBase&gt;">
      <MemberSignature Language="C#" Value="protected internal System.Xaml.Schema.XamlValueConverter&lt;TConverterBase&gt; GetValueConverter&lt;TConverterBase&gt; (Type converterType, System.Xaml.XamlType targetType) where TConverterBase : class;" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Xaml.Schema.XamlValueConverter`1&lt;!!TConverterBase&gt; GetValueConverter&lt;class TConverterBase&gt;(class System.Type converterType, class System.Xaml.XamlType targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetValueConverter``1(System.Type,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetValueConverter(Of TConverterBase As Class) (converterType As Type, targetType As XamlType) As XamlValueConverter(Of TConverterBase)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA;generic &lt;typename TConverterBase&gt;&#xA; where TConverterBase : class System::Xaml::Schema::XamlValueConverter&lt;TConverterBase&gt; ^ GetValueConverter(Type ^ converterType, System::Xaml::XamlType ^ targetType);" />
      <MemberSignature Language="F#" Value="member this.GetValueConverter : Type * System.Xaml.XamlType -&gt; System.Xaml.Schema.XamlValueConverter&lt;'ConverterBase (requires 'ConverterBase : null)&gt; (requires 'ConverterBase : null)" Usage="xamlSchemaContext.GetValueConverter (converterType, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;TConverterBase&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TConverterBase">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="converterType" Type="System.Type" />
        <Parameter Name="targetType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <typeparam name="TConverterBase">Die bestimmte Konverterbasisklasse.</typeparam>
        <param name="converterType">Die Konverterimplementierung.</param>
        <param name="targetType">Der gewünschte Zieltyp für den Konverter.</param>
        <summary>Gibt einen Wertkonverter zurück, der eine Konvertierung in den angeforderten <paramref name="targetType" /> vornehmen kann.</summary>
        <returns>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> mit einer Einschränkung, die der auf den Methodenaufruf angewendeten Einschränkung entspricht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlDirective">
      <MemberSignature Language="C#" Value="public virtual System.Xaml.XamlDirective GetXamlDirective (string xamlNamespace, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xaml.XamlDirective GetXamlDirective(string xamlNamespace, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlDirective(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlDirective (xamlNamespace As String, name As String) As XamlDirective" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xaml::XamlDirective ^ GetXamlDirective(System::String ^ xamlNamespace, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlDirective : string * string -&gt; System.Xaml.XamlDirective&#xA;override this.GetXamlDirective : string * string -&gt; System.Xaml.XamlDirective" Usage="xamlSchemaContext.GetXamlDirective (xamlNamespace, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlDirective</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Der XAML-Namespace, der die benannte Direktive enthält.</param>
        <param name="name">Der Name der abzurufenden Direktive.</param>
        <summary>Gibt einen <see cref="T:System.Xaml.XamlDirective" />-Wert zurück, der eine Direktive darstellt (entweder für die XAML-Sprache oder für eine bestimmte Implementierung).</summary>
        <returns>Ein <see cref="T:System.Xaml.XamlDirective" />-Objekt, das die angeforderte Direktive darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie diese Methode, wenn Sie eine abgeleitete Klasse aus <xref:System.Xaml.XamlDirective> als Teil eines XAML-Typsystem Erweiterungs Szenarios erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlNamespace" /> oder <paramref name="name" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetXamlType">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein <see cref="T:System.Xaml.XamlType" />-Objekt zurück, das auf einem CLR-Typbezeichner oder XAML-Typbezeichner basiert.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="public virtual System.Xaml.XamlType GetXamlType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xaml.XamlType GetXamlType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlType (type As Type) As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xaml::XamlType ^ GetXamlType(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlType : Type -&gt; System.Xaml.XamlType&#xA;override this.GetXamlType : Type -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, für den ein <see cref="T:System.Xaml.XamlType" />-Objekt abgerufen werden soll.</param>
        <summary>Gibt ein <see cref="T:System.Xaml.XamlType" />-Objekt zurück, das auf einem CLR-Typbezeichner basiert.</summary>
        <returns>Das <see cref="T:System.Xaml.XamlType" />-Objekt, das dem <paramref name="type" /> der Eingabe entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung geht davon aus, dass Sie die CLR für das Unterstützungs-Typsystem verwenden. Wenn Sie das CLR-Typsystem nicht verwenden, verwenden Sie <xref:System.Xaml.XamlSchemaContext.GetXamlType%28System.Xaml.Schema.XamlTypeName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType GetXamlType (System.Xaml.Schema.XamlTypeName xamlTypeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlType GetXamlType(class System.Xaml.Schema.XamlTypeName xamlTypeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.Xaml.Schema.XamlTypeName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXamlType (xamlTypeName As XamlTypeName) As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlType ^ GetXamlType(System::Xaml::Schema::XamlTypeName ^ xamlTypeName);" />
      <MemberSignature Language="F#" Value="member this.GetXamlType : System.Xaml.Schema.XamlTypeName -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType xamlTypeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlTypeName" Type="System.Xaml.Schema.XamlTypeName" />
      </Parameters>
      <Docs>
        <param name="xamlTypeName">Der XAML-Typname, für den ein <see cref="T:System.Xaml.XamlType" />-Objekt abgerufen werden soll.</param>
        <summary>Gibt ein <see cref="T:System.Xaml.XamlType" />-Objekt zurück, das auf einem XAML-Systemtypnamen basiert.</summary>
        <returns>Das <see cref="T:System.Xaml.XamlType" />-Objekt, das dem <paramref name="xamlTypeName" /> der Eingabe entspricht.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Eine Komonenten von <paramref name="xamlTypeName" /> (<see cref="P:System.Xaml.Schema.XamlTypeName.Name" /> oder <see cref="P:System.Xaml.Schema.XamlTypeName.Namespace" />) lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlTypeName" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Xaml.Schema.XamlTypeName" />
      </Docs>
    </Member>
    <Member MemberName="GetXamlType">
      <MemberSignature Language="C#" Value="protected internal virtual System.Xaml.XamlType GetXamlType (string xamlNamespace, string name, params System.Xaml.XamlType[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xaml.XamlType GetXamlType(string xamlNamespace, string name, class System.Xaml.XamlType[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.GetXamlType(System.String,System.String,System.Xaml.XamlType[])" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetXamlType (xamlNamespace As String, name As String, ParamArray typeArguments As XamlType()) As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Xaml::XamlType ^ GetXamlType(System::String ^ xamlNamespace, System::String ^ name, ... cli::array &lt;System::Xaml::XamlType ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member GetXamlType : string * string * System.Xaml.XamlType[] -&gt; System.Xaml.XamlType&#xA;override this.GetXamlType : string * string * System.Xaml.XamlType[] -&gt; System.Xaml.XamlType" Usage="xamlSchemaContext.GetXamlType (xamlNamespace, name, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Xaml.XamlType[]">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Der XAML-Namespace, der den gewünschten Typ enthält.</param>
        <param name="name">Der Zeichenfolgenname des gewünschten Typs.</param>
        <param name="typeArguments">Die Initialisierungstypargumente für einen generischen Typ.</param>
        <summary>Gibt einen <see cref="T:System.Xaml.XamlType" /> zurück, der auf einem XAML-Namespace und einer Zeichenfolge für den Typnamen basiert. Diese Signatur kann die Typargumente für Fälle angeben, bei denen der gewünschte Typ ein generischer Typ ist.</summary>
        <returns>Das <see cref="T:System.Xaml.XamlType" />-Objekt, das den Eingabekriterien entspricht.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAssemblyResolve">
      <MemberSignature Language="C#" Value="protected internal virtual System.Reflection.Assembly OnAssemblyResolve (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Reflection.Assembly OnAssemblyResolve(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.OnAssemblyResolve(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function OnAssemblyResolve (assemblyName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Reflection::Assembly ^ OnAssemblyResolve(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="abstract member OnAssemblyResolve : string -&gt; System.Reflection.Assembly&#xA;override this.OnAssemblyResolve : string -&gt; System.Reflection.Assembly" Usage="xamlSchemaContext.OnAssemblyResolve assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Namen zu ladenden Assembly.</param>
        <summary>Wird aufgerufen, wenn für Vorgänge mithilfe des Schemakontexts eine Assembly aufgelöst wird, die für die Auflösung des darin enthaltenen XAML-Namespaces erforderlich ist.</summary>
        <returns>Die aufgelöste Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das zugrunde liegende Verfahren für die Assemblyauflösung, bei dem es sich um eine interne API handelt, verfügt über integrierte Toleranzen für verschiedene Zeichen folgen Formen eines Assemblynamens, die auf dem <xref:System.Reflection.AssemblyName> Konstruktions Verhalten basieren.  
  
 Der Zweck dieser API besteht darin, die Lösung für die erste Gelegenheit für bekannte Assemblys zu aktivieren, z. b. für Verweisassemblys anstelle eines globalen Assemblycaches. Wenn die Liste der Verweisassemblys aufgefüllt ist, kann die Standard Implementierung auf die bekannten Verweisassemblys zugreifen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceAssemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt; ReferenceAssemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Reflection.Assembly&gt; ReferenceAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.ReferenceAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReferenceAssemblies As IList(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Reflection::Assembly ^&gt; ^ ReferenceAssemblies { System::Collections::Generic::IList&lt;System::Reflection::Assembly ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReferenceAssemblies : System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt;" Usage="System.Xaml.XamlSchemaContext.ReferenceAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen aufzählbaren Satz von Verweisassemblys für den XAML-Schemakontext ab.</summary>
        <value>Ein aufzählbarer Satz von Verweisassemblys für den Schemakontext. Jedes Assemblyinformationselement wird durch einen <see cref="T:System.Reflection.Assembly" />-Wert angegeben.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportMarkupExtensionsWithDuplicateArity">
      <MemberSignature Language="C#" Value="public bool SupportMarkupExtensionsWithDuplicateArity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportMarkupExtensionsWithDuplicateArity" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportMarkupExtensionsWithDuplicateArity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportMarkupExtensionsWithDuplicateArity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportMarkupExtensionsWithDuplicateArity : bool" Usage="System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein XAML-Schema und der Kontext Markuperweiterungen unterstützen, in denen zwei Konstruktoren mit der gleichen Stelligkeit (Anzahl von Eingabeparametern) enthalten sind.</summary>
        <value><see langword="true" />, wenn der Schemakontext Markuperweiterungen mit doppelter Stelligkeit zulässt, andernfalls <see langword="false" />. Der Standardwert lautet <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt den <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A?displayProperty=nameWithType> Wert zurück, der in den Einstellungen für die <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Xaml.XamlSchemaContextSettings%29>-Konstruktorsignatur festgelegt wird. Wenn andere Signaturen für die Erstellung verwendet werden oder <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A?displayProperty=nameWithType> nicht explizit auf `true`festgelegt ist, wird der Wert dieser Eigenschaft `false`.  
  
 Doppelte Stelligkeit von Markup Erweiterungen wird nicht ausdrücklich durch die XAML-Spezifikation [MS-XAML], Abschnitt 6.6.7.2 adressiert. Dies liegt daran, dass die Bildung des XAML-Informations Elements für eine Markup Erweiterung unabhängig von der doppelten Stelligkeit identisch ist, die möglicherweise in der Implementierung der Markup Erweiterung vorhanden ist. Nur der tatsächliche Aufruf der Markup Erweiterung und der zugehörigen `ProvideValue` machen Probleme, die mit doppelter Stelligkeit verknüpft sind. Das Verhalten für die Behandlung doppelter Stelligkeit ist daher nicht definiert und wird für jeden implementiert, der XAML-Schema Kontext und seine XAML-Writer-Integration implementiert. Der standardmäßige XAML-Schema Kontext, der für .NET Framework XAML-Dienst Vorgänge implementiert ist, unterstützt keine doppelte Stelligkeit. verschiedene .NET Framework XAML-Dienste-APIs lösen Ausnahmen aus, wenn die Markup Erweiterungs Verwendung mit der zugrunde liegenden doppelten Stelligkeit verarbeitet wird.  
  
 Weitere Informationen zum Definieren von Markup Erweiterungen finden Sie unter [Übersicht über Markup Erweiterungen für XAML](~/docs/framework/xaml-services/markup-extensions-for-xaml-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetCompatibleXamlNamespace">
      <MemberSignature Language="C#" Value="public virtual bool TryGetCompatibleXamlNamespace (string xamlNamespace, out string compatibleNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetCompatibleXamlNamespace(string xamlNamespace, [out] string&amp; compatibleNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlSchemaContext.TryGetCompatibleXamlNamespace(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetCompatibleXamlNamespace (xamlNamespace As String, ByRef compatibleNamespace As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetCompatibleXamlNamespace(System::String ^ xamlNamespace, [Runtime::InteropServices::Out] System::String ^ % compatibleNamespace);" />
      <MemberSignature Language="F#" Value="abstract member TryGetCompatibleXamlNamespace : string * string -&gt; bool&#xA;override this.TryGetCompatibleXamlNamespace : string * string -&gt; bool" Usage="xamlSchemaContext.TryGetCompatibleXamlNamespace (xamlNamespace, compatibleNamespace)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlNamespace" Type="System.String" />
        <Parameter Name="compatibleNamespace" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="xamlNamespace">Die <see langword="xmlns" />-Zeichenfolge für den XAML-Namespace, der auf ein kompatibles Ergebnis überprüft werden soll.</param>
        <param name="compatibleNamespace">Wenn diese Methode beendet wird, die <see langword="xmlns" />-Zeichenfolge für eine kompatible XAML-Namespaceanforderung. Diese kann mit <paramref name="xamlNamespace" /> identisch sein, wenn die Methode <see langword="false" /> zurückgibt.</param>
        <summary>Gibt den Erfolg oder den Fehler der Anforderung eines kompatiblen XAML-Namespaces zurück. Bei einer erfolgreichen Anforderung wird dieser XAML-Namespace als Out-Parameter gemeldet.</summary>
        <returns><see langword="true" />, wenn <paramref name="compatibleNamespace" /> ein verwendbares Ergebnis enthält, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Intern verwendet diese Methode die folgende Such Reihenfolge:  
  
1.  Ein intern implementiertes Kompatibilitäts Wörterbuch, das möglicherweise durch eine frühere Suche aufgefüllt wurde.  
  
2.  Die <xref:System.Windows.Markup.XmlnsCompatibleWithAttribute> Parameter Auswertung.  
  
 Wenn kein anderer kompatibler Namespace erkannt wird und diese Methode `false`zurückgibt, kann die `compatibleNamespace` Parameter Ausgabe denselben Wert wie die `xamlNamespace` Eingabe aufweisen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="xamlNamespace" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
  </Members>
</Type>
