<Type Name="XamlType" FullName="System.Xaml.XamlType">
  <Metadata><Meta Name="ms.openlocfilehash" Value="43476f8ee5a67f0bae9986ad2bfaf1b0c741a44c" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86692083" /></Metadata><TypeSignature Language="C#" Value="public class XamlType : IEquatable&lt;System.Xaml.XamlType&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlType extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlType&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlType" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlType&#xA;Implements IEquatable(Of XamlType)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlType : IEquatable&lt;System::Xaml::XamlType ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlType = class&#xA;    interface IEquatable&lt;XamlType&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlType&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Meldet Informationen zu XAML-Typen als Teil des gesamten XAML-Systems, das in .NET Framework-XAML-Diensten implementiert wird.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Viele APIs in der- <xref:System.Xaml.XamlType> Klasse stellen Informationen zu XAML-Typen bereit, bei denen das Konzept, das Sie melden, mit bestimmten Abschnitten der XAML-Spezifikation [MS-XAML] vergleichbar ist.  
  
 <xref:System.Xaml.XamlType> wird in der .NET Framework XAML-Dienste-API ausführlich zum Melden von Informationen über einen XAML-Typ verwendet. <xref:System.Xaml.XamlType> gibt Aufschluss über die Informationen, die Sie möglicherweise über einen XAML-Typ wissen müssen, um mit einer-Instanz zu arbeiten oder um von einem XAML-knotenstream aus auf seine Member zuzugreifen, oder eine ähnliche XAML-Darstellung. Die Berichterstellung ähnelt der <xref:System.Type> Art und Weise, wie der im CLR-Typsystem zusammen mit Reflektionsklassen, wie z <xref:System.Reflection.MemberInfo> . b., Informationen zu einem CLR-Typ und seiner Verwendung bereitstellt.  
  
 Um das XAML-Typsystem zu erweitern, können Sie von ableiten <xref:System.Xaml.XamlType> . Um dies effektiv zu tun, müssen Sie möglicherweise auch einen implementieren <xref:System.Xaml.Schema.XamlTypeInvoker> . <xref:System.Xaml.Schema.XamlTypeInvoker>Ermöglicht dem generalisierten XAML-Typsystem das Arbeiten mit der typsystemunterstützung, die Sie als Teil des Aufruf Verhaltens angeben. Das spezifische benutzerdefinierte-Klasse <xref:System.Xaml.Schema.XamlTypeInvoker> bietet eine Möglichkeit, die Abhängigkeiten von dem CLR-Typsystem zu reduzieren, die vom Standardverhalten verwendet werden <xref:System.Xaml.XamlType> .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlType" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Das zugrunde liegende <see cref="T:System.Type" />-Objekt der CLR für den zu erstellenden XAML-Typ.</param>
        <param name="schemaContext">XAML-Schemakontext für XAML-Reader oder XAML-Writer.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlType" />-Klasse auf Grundlage der zugrunde liegenden CLR-Typinformationen.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Ein oder mehrere <paramref name="underlyingType" /> oder <paramref name="schemaContext" /> sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XamlType (string typeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string typeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (typeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XamlType(System::String ^ typeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (typeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des zu erstellenden Typs.</param>
        <param name="typeArguments">Die Typargumente für einen <see cref="T:System.Xaml.XamlType" />, der einen generischen Typ darstellt. Kann <see langword="null" /> sein (dies ist häufig der Fall). Damit wird angegeben, dass der dargestellte Typ kein generischer Typ ist.</param>
        <param name="schemaContext">XAML-Schemakontext für XAML-Reader und XAML-Writer.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlType" />-Klasse auf Grundlage eines Zeichenfolgennamens für den Typ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist ein geschützter Konstruktor. Es sind keine aktuellen öffentlichen abgeleiteten Klassen vorhanden, die diesen speziellen Pfad zur Erstellung verwenden. Als Consumer der vorhandenen <xref:System.Xaml.XamlType> müssen Sie die anderen Konstruktorsignaturen ( <xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%2CSystem.Xaml.Schema.XamlTypeInvoker%29> , <xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%29> oder <xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29> ) verwenden, um ein-Objekt zu initialisieren <xref:System.Xaml.XamlType> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ein oder mehrere <paramref name="typeName" /> oder <paramref name="schemaContext" /> sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlTypeInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlTypeInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlTypeInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext, invoker As XamlTypeInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlTypeInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlTypeInvoker -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlTypeInvoker" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Der zugrunde liegende Typ für den zu erstellenden XAML-Typ.</param>
        <param name="schemaContext">Der XML-Schemakontext für den XAML-Reader.</param>
        <param name="invoker">Die <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />-Implementierung, die die Reflektionslaufzeitaufrufe der <see cref="T:System.Xaml.XamlType" />-Klasse verarbeitet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlType" />-Klasse auf Grundlage der zugrunde liegenden Typinformationen und einer <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />-Implementierung.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Ein oder mehrere <paramref name="underlyingType" /> oder <paramref name="schemaContext" /> sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (string unknownTypeNamespace, string unknownTypeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string unknownTypeNamespace, string unknownTypeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (unknownTypeNamespace As String, unknownTypeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(System::String ^ unknownTypeNamespace, System::String ^ unknownTypeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (unknownTypeNamespace, unknownTypeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="unknownTypeNamespace" Type="System.String" />
        <Parameter Name="unknownTypeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="unknownTypeNamespace">Der XAML-Namespace für den Typ (als Zeichenfolge).</param>
        <param name="unknownTypeName">Der Name des Typs im angegebenen <paramref name="unknownTypeNamespace" />-XAML-Namespace.</param>
        <param name="typeArguments">Die Typargumente für einen <see cref="T:System.Xaml.XamlType" />, der einen generischen Typ darstellt. Kann <see langword="null" /> sein (dies ist häufig der Fall). Damit wird angegeben, dass der dargestellte Typ kein generischer Typ ist.</param>
        <param name="schemaContext">XAML-Schemakontext für XAML-Reader oder XAML-Writer.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Xaml.XamlType" />-Klasse auf Grundlage des XAML-Namespaces und eines Zeichenfolgennamens für den Typ. Dieser Konstruktor dient ausschließlich der Analyse und der XAML-Knoten-Aufzeichnung von Typverwendungen, von denen bekannt ist, dass sie keine Unterstützung im unterstützenden Typsystem und XAML-Schemakontext besitzen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diesen Konstruktor nur für "unbekannte" Typen, bei denen ein XAML-Typ, der einem zugrunde liegenden Typsystem zugeordnet ist, nicht verfügbar ist. Dieser Konstruktor erzeugt möglicherweise kein Ergebnis, wenn <xref:System.Xaml.XamlType.IsUnknown%2A?displayProperty=nameWithType> ist `true` . Stattdessen meldet die Standard reflektorlogik den zugrunde liegenden Typ als <xref:System.Xaml.XamlLanguage.Object%2A?displayProperty=nameWithType> . Dieses Verhalten kann sich jedoch aufgrund der <xref:System.Xaml.XamlType.LookupIsUnknown%2A> außer Kraft Setzung ändern.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ein oder mehrere <paramref name="unknownTypeNamespace" />, <paramref name="unknownTypeName" /> oder <paramref name="schemaContext" /> sind <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedContentTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; AllowedContentTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; AllowedContentTypes" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.AllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowedContentTypes As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ AllowedContentTypes { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowedContentTypes : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.AllowedContentTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine schreibgeschützte Auflistung der Typen ab, die als <see cref="P:System.Xaml.XamlType.ContentProperty" />-Wert für dieses <see cref="T:System.Xaml.XamlType" />-Objekt verwendbar sind.</summary>
        <value>Eine schreibgeschützte Auflistung möglicher Inhaltstypen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typen, die einem bestimmten Inhaltstyp zugewiesen werden können (z. b. einem Basistyp, bei dem es sich um einen zulässigen Inhaltstyp handelt), werden nicht als mehrere Typen für verwendet <xref:System.Xaml.XamlType.AllowedContentTypes%2A> .  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupAllowedContentTypes%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ BaseType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xaml.XamlType" />-Objekt für den unmittelbaren Basistyp dieses XAML-Typs ab. Die Ermittlung dieses Werts basiert auf dem zugrunde liegenden Typ des <see cref="T:System.Xaml.XamlType" />-Objekts und des Schemakontexts.</summary>
        <value>Das <see cref="T:System.Xaml.XamlType" />-Objekt für den unmittelbaren Basistyp dieses XAML-Typs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupBaseType%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupBaseType%2A> diesen Typ. Standardmäßig <xref:System.Xaml.XamlType.BaseType%2A> gibt eine interne Konstante zurück, die eine darstellt, <xref:System.Object> wenn gleich <xref:System.Xaml.XamlType.UnderlyingType%2A> ist `null` .  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung hat die Möglichkeit, die gemeldeten Typinformationen zu einem XAML-Typ zu ändern, um die gemeldeten Typinformationen zu einem XAML-Typ so zu ändern, dass Sie nicht mehr erwartungsgemäß mit den typsysteminformationen des zugrunde liegenden CLR-Typs ausgerichtet werden. Verwenden Sie für sicherheitskritische Überprüfungen von Zuweisungs Vorgängen und Zugriff stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAssignTo">
      <MemberSignature Language="C#" Value="public virtual bool CanAssignTo (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanAssignTo(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.CanAssignTo(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanAssignTo (xamlType As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanAssignTo(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="abstract member CanAssignTo : System.Xaml.XamlType -&gt; bool&#xA;override this.CanAssignTo : System.Xaml.XamlType -&gt; bool" Usage="xamlType.CanAssignTo xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">Der Typ, der anhand des aktuellen <see cref="T:System.Xaml.XamlType" /> überprüft werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine Instanz der <see cref="T:System.Xaml.XamlType" />-Klasse die angegebene <see cref="T:System.Xaml.XamlType" />-Klasse in der Liste zuweisbarer Typen enthält.</summary>
        <returns><see langword="true" />, wenn <paramref name="xamlType" /> in der Liste der zuweisbaren Typen enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl der zustellbare Typ nicht über alle Funktionen des Verweis Typs verfügt, kann er für die Zuweisung verwendet werden. Beispielsweise können Sie mit der-Zuweisung Typübereinstimmungen für die Werte einer-Eigenschaft vornehmen. Das Konzept der zustellbaren Typen in XAML ähnelt dem Konzept der Umwandlung im CLR-Typsystem. Beispielsweise verfügt jeder Typ unter einem CLR-Typsystem über einen <xref:System.Object> in der Liste der zustellbaren Typen.  
  
 Wenn eine der beiden- <xref:System.Xaml.XamlType> Instanzen, die für den Vergleich verwendet werden <xref:System.Xaml.XamlType.IsUnknown%2A> , gleich ist `true` , hat diese Methode einen besonderen unbekannten Modus, der zurückgibt, `true` Wenn die beiden- <xref:System.Xaml.XamlType> Instanzen äquivalent sind.  
  
 Die Standard Implementierung verwendet die CLR <xref:System.Type> von <xref:System.Xaml.XamlType.UnderlyingType%2A> für dieses <xref:System.Xaml.XamlType> und die Eingabe <xref:System.Xaml.XamlType> und ruft auf <xref:System.Type.IsAssignableFrom%2A> . Überschreiben Sie diese Methode, wenn Sie eine andere Bestimmung von zustellbaren Typen wünschen.  
  
 Durch das Übergeben von NULL `xamlType` wird keine Ausnahme ausgelöst, und es wird immer zurückgegeben `false` .  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.CanAssignTo%2A> ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung hat das Potenzial (für böswillige Zwecke oder anderweitig), um die Zustell barkeit eines XAML-Typs so zu ändern, dass er nicht mehr erwartungsgemäß mit dem Typumwandlungs Verhalten seines zugrunde liegenden CLR-Typs ausgerichtet wird. Verwenden Sie für sicherheitskritische Überprüfungen von Zuweisungs Vorgängen und Zugriff stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="public bool ConstructionRequiresArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ConstructionRequiresArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructionRequiresArguments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ConstructionRequiresArguments { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ConstructionRequiresArguments : bool" Usage="System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt Argumente (generische Einschränkungen für <see langword="x:TypeArguments" />, Initialisierungstext oder andere XAML-Techniken) aufweisen muss, um eine gültige Instanz des Typs zu erstellen.</summary>
        <value><see langword="true" />, wenn die Erstellung einer Instanz einen Argumentwert erfordert, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember ContentProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlMember ContentProperty" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentProperty As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlMember ^ ContentProperty { System::Xaml::XamlMember ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentProperty : System.Xaml.XamlMember" Usage="System.Xaml.XamlType.ContentProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Xaml.XamlMember" />-Informationen für die Inhaltseigenschaft dieses <see cref="T:System.Xaml.XamlType" />-Objekts ab.</summary>
        <value><see cref="T:System.Xaml.XamlMember" />-Informationen für die Inhaltseigenschaft dieses <see cref="T:System.Xaml.XamlType" />-Objekts. Kann <see langword="null" /> sein, wenn keine Inhaltseigenschaft vorhanden ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie die Bindung oder das unterstützen des CLR-Typsystems verwenden, kann die XAML-Inhalts Eigenschaft für einen Typ durch Anwenden <xref:System.Windows.Markup.ContentPropertyAttribute> auf die Typdefinition angegeben werden.  
  
 Diese Eigenschaft richtet sich nach dem `[content property]` Informationselement in der [MS-XAML]-Spezifikation.  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupContentProperty%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupContentProperty%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentWrappers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; ContentWrappers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; ContentWrappers" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentWrappers As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ ContentWrappers { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentWrappers : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.ContentWrappers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Typen ab, mit denen Inhalt für eine Inhaltseigenschaft umschlossen wird, wenn es sich nicht um eine strenge Typübereinstimmung handelt, z. B. Zeichenfolgen in einer stark typisierten <see langword="Collection&lt;T&gt;" />.</summary>
        <value>Eine schreibgeschützte Auflistung möglicher Inhaltswrappertypen, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine Wrapper vorhanden sind, die das lockern der Typübereinstimmung berücksichtigen, ist diese Eigenschaft `null` .  
  
 Typen, die als <xref:System.Xaml.XamlType.CanAssignTo%2A> für einen bestimmten Inhaltstyp auswerten, werden für Zwecke von nicht als mehrere Typen betrachtet <xref:System.Xaml.XamlType.ContentWrappers%2A> .  
  
 In der CLR-Bindung für <xref:System.Xaml> und <xref:System.Xaml.XamlType> kann der XAML-Content-Wrapper-Typ für einen Typ als angegeben werden <xref:System.Windows.Markup.ContentWrapperAttribute> .  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupContentWrappers%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupContentWrappers%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlType.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt ab, das für diesen Typ das Konvertierungsverhalten für verzögertes Laden darstellt.</summary>
        <value>Der <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> mit <see cref="T:System.Xaml.XamlDeferringLoader" />-Einschränkung, der für diesen Typ das Verhalten für verzögertes Laden darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das XAML-Vorlagen Verhalten in WPF ist ein Beispiel für verzögertes Laden Verhalten.  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, ob das aktuelle Objekt einem anderen Objekt entspricht.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlType.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das mit diesem Objekt verglichen werden soll.</param>
        <summary>Gibt an, ob das aktuelle Objekt einem anderen Objekt entspricht.</summary>
        <returns><see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="obj" />-Parameter ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlType other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlType other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlType ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlType -&gt; bool" Usage="xamlType.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="other">Ein Objekt, das mit diesem Objekt verglichen werden soll.</param>
        <summary>Gibt an, ob das aktuelle Objekt gleich einem anderen Objekt des gleichen Typs ist.</summary>
        <returns><see langword="true" />, wenn das aktuelle Objekt gleich dem <paramref name="other" />-Parameter ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasedProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="member this.GetAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Die Direktive, für die der mit einem Alias versehene Member gesucht werden soll.</param>
        <summary>Gibt den XAML-Member zurück, der durch die <see cref="T:System.Xaml.XamlType" />-Klasse mit einem Alias für die XAML-Direktive versehen ist.</summary>
        <returns>Der mit einem Alias versehene Member, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Methode außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllAttachableMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllAttachableMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllAttachableMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Auflistung zurück, die alle anfügbaren Eigenschaften enthält, die von dieser <see cref="T:System.Xaml.XamlType" />-Klasse verfügbar gemacht werden.</summary>
        <returns>Eine Auflistung, die null oder mehr <see cref="T:System.Xaml.XamlMember" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede <xref:System.Xaml.XamlMember> in der zurückgegebenen Auflistung sollte Werte enthalten, die das Konzept unterstützen, dass <xref:System.Xaml.XamlMember> ein anfügbares Element ist. Beispielsweise sollten Member `true` für <xref:System.Xaml.XamlMember.IsAttachable%2A> , einen-Typ für <xref:System.Xaml.XamlMember.TargetType%2A> usw. zurückgeben.  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Methode außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Auflistung zurück, die alle Member enthält, die von dieser <see cref="T:System.Xaml.XamlType" />-Klasse verfügbar gemacht wurden.</summary>
        <returns>Eine Auflistung, die null oder mehr <see cref="T:System.Xaml.XamlMember" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufe dieser Methode können außer Kraft setzungen <xref:System.Xaml.XamlType.LookupAllMembers%2A> für <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttachableMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden, anfügbaren Members in der Form <c>ownerTypeName.MemberName</c>.</param>
        <summary>Gibt einen <see cref="T:System.Xaml.XamlMember" /> zurück, der einen bestimmten benannten Member von diesem <see cref="T:System.Xaml.XamlType" /> darstellt, der anfügbar ist.</summary>
        <returns>Ein <see cref="T:System.Xaml.XamlMember" />-Objekt für den angeforderten anfügbaren Member; andernfalls <see langword="null" />, wenn kein anfügbarer Member dieses Namens existiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufe dieser Methode können außer Kraft setzungen <xref:System.Xaml.XamlType.LookupAttachableMember%2A> für <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung hat die Möglichkeit, die gemeldeten Member eines XAML-Typs zu ändern, um die gemeldeten Member eines XAML-Typs so zu ändern, dass Sie nicht mehr erwartungsgemäß mit den <xref:System.ComponentModel.TypeDescriptor> `Get*` Informationen über den zugrunde liegenden CLR-Typ ausgerichtet werden. Verwenden Sie für alle sicherheitskritischen Überprüfungen der Element Berichterstattung stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlType.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für dieses Objekt zurück.</summary>
        <returns>Ein ganzzahliger Hashcode.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden Members (als Zeichenfolge).</param>
        <summary>Gibt einen <see cref="T:System.Xaml.XamlMember" /> für einen bestimmten benannten Member aus diesem <see cref="T:System.Xaml.XamlType" /> zurück.</summary>
        <returns>Die <see cref="T:System.Xaml.XamlMember" />-Informationen für den Member, wenn ein derartiger Member gefunden wurde, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es wird erwartet, dass der Wert für nicht `name` qualifiziert ist. Typqualifizierte Namen, die angeben, dass ein angefügtes Mitglied stattdessen an gesendet werden soll <xref:System.Xaml.XamlType.GetAttachableMember%2A> . Elementnamen mit Präfix dürfen nicht verwendet werden. ein Präfix ist situationsbedingt zu einer Verwendung, und das XAML-Typsystem kennt den Kontext einer solchen Verwendung und wie das Präfix zugeordnet wird.  
  
 Aufrufe dieser Methode können außer Kraft setzungen <xref:System.Xaml.XamlType.LookupMember%2A> für <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung hat die Möglichkeit, die gemeldeten Member eines XAML-Typs zu ändern, um die gemeldeten Member eines XAML-Typs so zu ändern, dass Sie nicht mehr erwartungsgemäß mit den <xref:System.ComponentModel.TypeDescriptor> `Get*` Informationen über den zugrunde liegenden CLR-Typ ausgerichtet werden. Verwenden Sie für alle sicherheitskritischen Überprüfungen der Element Berichterstattung stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionalParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; GetPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; GetPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ GetPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="member this.GetPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.GetPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Die Anzahl (Stelligkeit) des bestimmten Syntax- oder Konstruktormodus, zu dem Sie Informationen anzeigen möchten.</param>
        <summary>Für Markuperweiterungstypen werden die Typen der Positionsparameter zurückgegeben, die bei einer bestimmten Verwendung der Markuperweiterung für diesen <see cref="T:System.Xaml.XamlType" /> unterstützt werden.</summary>
        <returns>Eine Liste von <see cref="T:System.Xaml.XamlType" />-Werten, wobei jeder <see cref="T:System.Xaml.XamlType" /> der Typ für diese Position in der Syntax ist. Beim Angeben von Markupeingaben für die Markuperweiterung müssen die Typen in der gleichen Reihenfolge angegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese API ist nur relevant, wenn Sie <xref:System.Xaml.XamlType> eine Markup Erweiterung ( <xref:System.Xaml.XamlType.IsMarkupExtension%2A> ist `true` ) darstellt.  
  
 Die Eingabe `parameterCount` ist nicht für die Anforderung des Typs eines bestimmten Positions Parameters vorgesehen. Es dient zum Angeben der Stelligkeit einer Markup Erweiterungs Verwendung. Die Verwendung von Markup Erweiterungen weist oft mehrere "Signaturen" auf und verwendet eine andere parameterität (Anzahl) von Positions Parametern, um unterscheiden zu können. Sie können jedoch einen Schema Kontext so konfigurieren, dass doppelte Typen zugelassen werden und Typen der Positions Parameter für die Differenzierung verwendet werden. Weitere Informationen finden Sie unter <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Für eine bestimmte Stelligkeit (Anzahl) können die Parameter Positionen und-Typen variieren. Um den positionellen Typ der Markup Erweiterungs Verwendung einer bestimmten Arität abzurufen, müssen Sie zuerst <xref:System.Xaml.XamlType.GetPositionalParameters%2A> die Anzahl der Stelligkeit angeben. Anschließend wird das Element an dieser Position aus der zurückgegebenen Auflistung zurückgegeben.  
  
 Aufrufe dieser Methode können außer Kraft setzungen <xref:System.Xaml.XamlType.LookupPositionalParameters%2A> für <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlType.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste von Zeichenfolgenbezeichnern für XAML-Namespaces zurück, in denen der Typ enthalten ist.</summary>
        <returns>Eine Liste von Zeichenfolgenwerten, in der jede Zeichenfolge der URI-Bezeichner für einen XAML-Namespace ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typische XAML-Namespace Bezeichner sind Zeichen folgen in der URI-Form.  
  
 Die Standard Implementierung überprüft Folgendes in der angegebenen Reihenfolge: der XAML-Namespace, der in der Konstruktion bereitgestellt wird ( <xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29> nur Signatur), und die Namespaces, die im Schema Kontext verfügbar sind. Wenn dies der Wert ist `null` , wird eine neue Liste generiert, die eine einzelne leere Zeichenfolge enthält. Sie können diese Methode überschreiben, um die Such Methodik zu ändern.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlTypeInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlTypeInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlTypeInvoker ^ Invoker { System::Xaml::Schema::XamlTypeInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlTypeInvoker" Usage="System.Xaml.XamlType.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />-Implementierung ab, die diesem <see cref="T:System.Xaml.XamlType" />-Objekt zugeordnet ist.</summary>
        <value>Die <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />-Implementierung, die diesem <see cref="T:System.Xaml.XamlType" />-Objekt zugeordnet ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , <xref:System.Xaml.XamlType.Invoker%2A> kann <xref:System.Xaml.XamlType.LookupInvoker%2A> der Aufruf von entweder oder eine bestimmte außer Kraft setzung dieser Methode aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupInvoker%2A> diesen Typ.  
  
 Wenn eine <xref:System.Xaml.XamlType.LookupInvoker%2A> außer Kraft Setzung zurückgibt `null` , oder wenn die Standard Implementierung zurückgibt, weil nicht für diesen Wert zurückgegeben `null` <xref:System.Xaml.XamlType.UnderlyingType%2A> <xref:System.Xaml.XamlType> wurde, wird <xref:System.Xaml.XamlType.Invoker%2A> zurückgegeben <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlType.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen Umgebungstyp gemäß XAML-Definition darstellt.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Xaml.XamlType" />-Objekt einen Umgebungstyp darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupIsAmbient%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupIsAmbient%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Xaml.XamlType.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt ein Array darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt ein Array darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupCollectionKind%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupCollectionKind%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollection">
      <MemberSignature Language="C#" Value="public bool IsCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollection : bool" Usage="System.Xaml.XamlType.IsCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt eine Auflistung darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt eine Auflistung darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupCollectionKind%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupCollectionKind%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructible">
      <MemberSignature Language="C#" Value="public bool IsConstructible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructible" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsConstructible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructible : bool" Usage="System.Xaml.XamlType.IsConstructible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen erstellbaren Typ gemäß XAML-Definition darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen erstellbaren Typ darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft richtet sich nach dem `[is default constructible]` Informationselement in der [MS-XAML]-Spezifikation.  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupIsConstructible%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupIsConstructible%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      </Docs>
    </Member>
    <Member MemberName="IsDictionary">
      <MemberSignature Language="C#" Value="public bool IsDictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDictionary" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsDictionary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDictionary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDictionary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDictionary : bool" Usage="System.Xaml.XamlType.IsDictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt ein Wörterbuch gemäß XAML-Definition darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt ein Wörterbuch darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft richtet sich nach dem `[is dictionary]` Informationselement in der [MS-XAML]-Spezifikation.  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupCollectionKind%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupCollectionKind%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGeneric">
      <MemberSignature Language="C#" Value="public bool IsGeneric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGeneric" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsGeneric" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGeneric As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGeneric { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGeneric : bool" Usage="System.Xaml.XamlType.IsGeneric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen generischen Typ darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen generischen Typ darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist eine Hilfseigenschaft, die auf einen NULL-Wert von prüft <xref:System.Xaml.XamlType.TypeArguments%2A> . Es gibt keine bestimmte `Lookup` Methode, die mit verknüpft ist <xref:System.Xaml.XamlType.IsGeneric%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarkupExtension">
      <MemberSignature Language="C#" Value="public bool IsMarkupExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarkupExtension" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarkupExtension As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarkupExtension { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarkupExtension : bool" Usage="System.Xaml.XamlType.IsMarkupExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt eine Markuperweiterung darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt eine Markuperweiterung darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In XAML-Spezifikations Begriffen muss dieser Typ zugeordnet werden, damit `x:MarkupExtension` für zurückgegeben werden kann `true` <xref:System.Xaml.XamlType.IsMarkupExtension%2A> .  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameScope">
      <MemberSignature Language="C#" Value="public bool IsNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameScope { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameScope : bool" Usage="System.Xaml.XamlType.IsNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen XAML-Namescope gemäß XAML-Definition darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen XAML-Namescope darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein XAML-Namescope erzwingt die namens Eindeutigkeit der Eigenschaft oder Eigenschaften, die für verwendet werden `x:Name`  /  `[name property]` . Wenn den Wert <xref:System.Xaml.XamlType.IsNameScope%2A> `true` hat, sollte ein Mechanismus zum Erzwingen der Eindeutigkeit vorhanden sein, der aus der Perspektive dieses Typs ausgewertet werden muss, der einen XAML-Namescope besitzt. Der XAML-Namescope erweitert dann den Inhalt des Typs, bis ein anderer XAML-Namescope-Typ gefunden wird.  
  
 Diese Eigenschaft richtet sich nach dem `[is name scope]` Informationselement in der [MS-XAML]-Spezifikation.  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupIsNameScope%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlType.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt mit einer gültigen <see langword="xamlName" />-Zeichenfolge als <see cref="P:System.Xaml.XamlType.Name" />-Eigenschaft initialisiert wird.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt mit einer gültigen <see langword="xamlName" />-Zeichenfolge initialisiert wird, andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public bool IsNullable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNullable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNullable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool" Usage="System.Xaml.XamlType.IsNullable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen Nullable-Typ gemäß XAML-Definition darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen Nullable-Typ darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft richtet sich nach dem `[is nullable]` Informationselement in der [MS-XAML]-Spezifikation.  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupIsNullable%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Xaml.XamlType.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen öffentlichen Typ im relevanten Typsystem darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen öffentlichen Typ darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupIsPublic%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung hat die Möglichkeit, die gemeldeten Zugriffs Informationen zu einem XAML-Typ zu ändern, um die gemeldeten Zugriffs Informationen zu einem XAML-Typ so zu ändern, dass Sie nicht mehr erwartungsgemäß mit dem Typsystem und den Zugriffs Informationen des zugrunde liegenden CLR-Typs ausgerichtet werden. Verwenden Sie für sicherheitskritische Überprüfungen von Zuweisungs Vorgängen und Zugriff stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlType.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen Typ darstellt, der nicht im zugrunde liegenden Typsystem aufgelöst werden kann.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen nicht auflösbaren Typ darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupIsUnknown%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen.  
  
 Bei einem Auslastungs Pfad, der <xref:System.Xaml.XamlObjectWriter> <xref:System.Xaml.XamlType> enthält, kann ein, der über für verfügt, `true` <xref:System.Xaml.XamlType.IsUnknown%2A> nicht in ein Objekt Diagramm geschrieben werden. Unter den Standard Implementierungen in löst der-Befehl <xref:System.Xaml> <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A?displayProperty=nameWithType> eine <xref:System.Xaml.XamlObjectWriterException> aus, wenn die relevanten <xref:System.Xaml.XamlType> Berichte `true` für <xref:System.Xaml.XamlType.IsUnknown%2A> . Sie sollten nur dann übergeben, <xref:System.Xaml.XamlType> <xref:System.Xaml.XamlType.IsUnknown%2A> `true` Wenn Sie darauf vorbereitet sind, die Ausnahmen von zu behandeln <xref:System.Xaml.XamlObjectWriter> , oder Sie haben andere Möglichkeiten, das <xref:System.Xaml.XamlObjectWriter> Verhalten oder den XAML-knotenstream vor dem Schreiben des Objekt Diagramms anzupassen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUsableDuringInitialization">
      <MemberSignature Language="C#" Value="public bool IsUsableDuringInitialization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUsableDuringInitialization" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUsableDuringInitialization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUsableDuringInitialization { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUsableDuringInitialization : bool" Usage="System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt während der XAML-Initialisierung von oben nach unten erstellt wird.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt während der XAML-Initialisierung von oben nach unten erstellt wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Top-Down ist eine Metapher, die das XAML-Prozessor Verhalten beim Erstellen des Objekt Diagramms anweist. Wenn ein Typ von oben nach unten erstellt wird, wird er instanziiert, an das übergeordnete Element angefügt und seine Eigenschaften festgelegt. Bei der Top-Down-Konstruktion wird vermieden, dass von der Eigenschaft geänderte Handler mehrmals aufgerufen werden. Eine solche Behandlung sorgt für das Objekt Diagramm und beseitigt daher die Aufrufe mehrerer Handler und bietet eine Leistungsoptimierung für den Start des Objekt Diagramms.  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
        <altmember cref="P:System.Windows.FrameworkElement.IsInitialized" />
      </Docs>
    </Member>
    <Member MemberName="IsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="public bool IsWhitespaceSignificantCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWhitespaceSignificantCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWhitespaceSignificantCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWhitespaceSignificantCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWhitespaceSignificantCollection : bool" Usage="System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt eine leerraumsignifikante Auflistung gemäß der XML-Definition darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt eine leerraumsignifikante Auflistung darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsXData">
      <MemberSignature Language="C#" Value="public bool IsXData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsXData" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsXData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsXData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsXData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsXData : bool" Usage="System.Xaml.XamlType.IsXData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt XML-<see langword="XDATA" /> gemäß XAML-Definition darstellt.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt <see langword="XDATA" /> darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft richtet sich nach dem `[is xdata]` Informationselement in der [MS-XAML]-Spezifikation.  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupIsXData%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupIsXData%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType ItemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType ItemType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ ItemType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Typinformationen für die <see langword="Items" />-Eigenschaft dieses <see cref="T:System.Xaml.XamlType" />-Objekts enthält.</summary>
        <value>Ein <see cref="T:System.Xaml.XamlType" />-Objekt für den Typ der Elemente in der Auflistung, andernfalls <see langword="null" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt keine Auflistung darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist nur relevant, wenn dies <xref:System.Xaml.XamlType> eine Auflistung darstellt ( <xref:System.Xaml.XamlType.IsCollection%2A> ist `true` ). Die- `Items` Eigenschaft ist eine beliebige Eigenschaft, die Elemente in diesem Typ von Sammlung oder Array enthält.  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupItemType%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupItemType%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType KeyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType KeyType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.KeyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ KeyType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.KeyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Typinformationen für die Schlüsseleigenschaft von diesem <see cref="T:System.Xaml.XamlType" />-Objekt enthält, wenn das <see cref="T:System.Xaml.XamlType" />-Objekt ein Wörterbuch darstellt.</summary>
        <value>Ein <see cref="T:System.Xaml.XamlType" />-Objekt für den Typ des Schlüssels für die Wörterbuchverwendung, andernfalls <see langword="null" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt kein Wörterbuch darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist nur relevant, wenn Sie <xref:System.Xaml.XamlType> ein Wörterbuch ( <xref:System.Xaml.XamlType.IsDictionary%2A> ist) darstellt `true` .  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupKeyType%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupKeyType%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAliasedProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="abstract member LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember&#xA;override this.LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Die Direktive, für die der mit einem Alias versehene Member gesucht werden soll.</param>
        <summary>Gibt den XAML-Member zurück, der durch die <see cref="T:System.Xaml.XamlType" />-Klasse mit einem Alias für die XAML-Direktive versehen ist.</summary>
        <returns>Der mit einem Alias versehene Member, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn ein Aufrufer einen Wert aus abruft <xref:System.Xaml.XamlType.GetAliasedProperty%2A> .  
  
 Die Standard Implementierung kann Ergebnisse für die folgenden XAML-Direktiven zurückgeben: `Key` ; `Name` ; `Uid` ; und `xml:lang` . Die Werte für diese hängen von der zugrunde liegenden Reflektion ab und geben möglicherweise trotzdem zurück, `null` Wenn keine Alias Eigenschaft gefunden wird.  
  
 Überschreiben Sie diese Methode, wenn Sie nicht auf die interne Standard-CLR-Reflektion Vertrauen und Metadaten oder andere Techniken zum Melden der XAML-typsysteminformationen oder der Schema Informationen eines Typs verwenden.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xaml.XamlDirective" />
        <altmember cref="T:System.Xaml.XamlLanguage" />
      </Docs>
    </Member>
    <Member MemberName="LookupAllAttachableMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllAttachableMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen aufzählbaren Satz zurück, der alle anfügbaren, von diesem <see cref="T:System.Xaml.XamlType" /> verfügbar gemachten Eigenschaften enthält.</summary>
        <returns>Ein aufzählbarer Satz, der 0 (null) oder mehr <see cref="T:System.Xaml.XamlMember" />-Werte enthält, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn ein Aufrufer einen Wert aus abruft <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A> .  
  
 Obwohl <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A> eine generische Auflistung zurückgibt, `Lookup` gibt diese Methode einen generischen Aufzähl baren Satz zurück.  
  
 Die Standard Implementierung verwendet die interne CLR-Reflektion. Wenn <xref:System.Xaml.XamlType.UnderlyingType%2A> `null` den Wert hat, kann die Standard Implementierung verwenden <xref:System.Xaml.XamlType.BaseType%2A> , wenn Sie verfügbar ist. Dieses Verhalten ruft <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> rekursiv auf, um einen gültigen Basistyp zu finden, und gibt zurück, `null` Wenn kein gültiger Basistyp vorhanden ist.  
  
 Überschreiben Sie diese Methode, wenn Sie nicht auf die interne Standard-CLR-Reflektion Vertrauen und Metadaten oder andere Techniken zum Melden von XAML-typsysteminformationen oder Schema Informationen eines Typs verwenden. Eine NULL-Rückgabe sollte für Fälle reserviert werden, in denen Informationen aufgrund fehlender Typsystem-oder reflektionserunterstützung nicht bestimmt werden können. Wenn ein Typ gültig ist und Reflektion oder andere Techniken verfügbar sind, ein Typ aber keine anfügbaren Member hat, sollten Sie stattdessen eine leere Menge zurückgeben <xref:System.Collections.Generic.IEnumerable%601> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen aufzählbaren Satz zurück, der alle Member enthält, die von diesem <see cref="T:System.Xaml.XamlType" /> verfügbar gemacht werden.</summary>
        <returns>Ein aufzählbarer Satz, der 0 (null) oder mehr <see cref="T:System.Xaml.XamlMember" />-Werte enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn ein Aufrufer einen Wert aus abruft <xref:System.Xaml.XamlType.GetAllMembers%2A> .  
  
 Obwohl <xref:System.Xaml.XamlType.GetAllMembers%2A> eine generische Auflistung zurückgibt, `Lookup` gibt diese Methode einen generischen Aufzähl baren Satz zurück.  
  
 Die Standard Implementierung verwendet die interne CLR-Reflektion. In Fällen, in denen <xref:System.Xaml.XamlType.UnderlyingType%2A> ist `null` , kann die Standard Implementierung verwenden <xref:System.Xaml.XamlType.BaseType%2A> , sofern Sie verfügbar ist. Dieses Verhalten ruft <xref:System.Xaml.XamlType.LookupAllMembers%2A> rekursiv auf, um einen gültigen Basistyp zu finden, und gibt zurück, `null` Wenn kein gültiger Basistyp vorhanden ist.  
  
 Überschreiben Sie diese Methode, wenn Sie nicht auf die interne Standard-CLR-Reflektion Vertrauen und Metadaten oder andere Techniken zum Melden von XAML-typsysteminformationen oder Schema Informationen eines Typs verwenden. Eine NULL-Rückgabe sollte für Fälle reserviert werden, in denen Informationen aufgrund fehlender Typsystem-oder reflektionserunterstützung nicht bestimmt werden können. Wenn ein Typ gültig ist, sind Reflektion oder andere Techniken verfügbar. Wenn ein Typ nicht über Member verfügt, sollten Sie stattdessen eine leere Menge zurückgeben <xref:System.Collections.Generic.IEnumerable%601> .  
  
 Rückgabewerte für <xref:System.Xaml.XamlType.LookupAllMembers%2A> und <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> sollten sich gegenseitig ausschließen. Wenn eine unterstützende Typsystem Eigenschaft eine standardmäßige instanzverwendung sowie eine anfügbare Verwendung unterstützen kann, sollte dieser Member als zwei unterschiedliche Werte gemeldet werden <xref:System.Xaml.XamlMember> , wobei ein Wert in der anfügbaren Liste und ein anderer in der Liste der Standardmember angezeigt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllowedContentTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupAllowedContentTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupAllowedContentTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllowedContentTypes () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupAllowedContentTypes();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupAllowedContentTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Liste der Typen zurück, die als <see cref="P:System.Xaml.XamlType.ContentProperty" />-Wert für dieses <see cref="T:System.Xaml.XamlType" />-Objekt verwendbar sind.</summary>
        <returns>Eine Liste möglicher Inhaltstypen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn ein Aufrufer einen Wert aus abruft <xref:System.Xaml.XamlType.AllowedContentTypes%2A> .  
  
 Typen, die als <xref:System.Xaml.XamlType.CanAssignTo%2A> für einen bestimmten Inhaltstyp auswerten, werden für Zwecke von nicht als mehrere Typen betrachtet <xref:System.Xaml.XamlType.AllowedContentTypes%2A> .  
  
 Die Standard Implementierung kann andere Eigenschaften von <xref:System.Xaml.XamlType> ( <xref:System.Xaml.XamlType.ContentWrappers%2A> , <xref:System.Xaml.XamlType.ContentProperty%2A> oder) verwenden <xref:System.Xaml.XamlType.ItemType%2A> , um ein Ergebnis zu erhalten. Die außer Kraft setzungen `Lookup` für die vorherige Eigenschaften Liste können auch in dieser Bestimmung aufgerufen werden.  
  
 Überschreiben Sie diese Methode, wenn Sie nicht auf die interne Standard-CLR-Reflektion Vertrauen und Metadaten oder andere Techniken zum Melden von XAML-typsysteminformationen oder Schema Informationen eines Typs verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAttachableMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member LookupAttachableMember : string -&gt; System.Xaml.XamlMember&#xA;override this.LookupAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden, anfügbaren Members in der Form <c>ownerTypeName.MemberName</c>.</param>
        <summary>Gibt einen <see cref="T:System.Xaml.XamlMember" /> für einen bestimmten benannten anfügbaren Member aus diesem <see cref="T:System.Xaml.XamlType" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Xaml.XamlMember" />-Objekt für den angeforderten anfügbaren Member; andernfalls <see langword="null" />, wenn kein anfügbarer Member dieses Namens existiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn ein Aufrufer einen Wert aus abruft <xref:System.Xaml.XamlType.GetAttachableMember%2A> .  
  
 Die Standard Implementierung verwendet die interne CLR-Reflektion. Wenn <xref:System.Xaml.XamlType.UnderlyingType%2A> `null` den Wert hat, kann die Standard Implementierung verwenden <xref:System.Xaml.XamlType.BaseType%2A> , wenn Sie verfügbar ist. Dieses Verhalten ruft <xref:System.Xaml.XamlType.LookupAttachableMember%2A> rekursiv auf, um einen gültigen Basistyp zu finden, und gibt zurück, `null` Wenn kein gültiger Basistyp vorhanden ist.  
  
 Überschreiben Sie diese Methode, wenn Sie nicht auf die interne Standard-CLR-Reflektion Vertrauen und Metadaten oder andere Techniken zum Melden von XAML-typsysteminformationen oder Schema Informationen eines Typs verwenden.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung hat die Möglichkeit, die gemeldeten Member eines XAML-Typs zu ändern, um die gemeldeten Member eines XAML-Typs so zu ändern, dass Sie nicht mehr erwartungsgemäß mit den <xref:System.ComponentModel.TypeDescriptor> `Get*` Informationen über den zugrunde liegenden CLR-Typ ausgerichtet werden. Verwenden Sie für alle sicherheitskritischen Überprüfungen der Element Berichterstattung stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupBaseType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupBaseType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupBaseType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupBaseType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupBaseType();" />
      <MemberSignature Language="F#" Value="abstract member LookupBaseType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupBaseType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupBaseType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das <see cref="T:System.Xaml.XamlType" />-Objekt für den unmittelbaren Basistyp dieses XAML-Typs zurück. Die Ermittlung dieses Werts basiert auf dem zugrunde liegenden Typ des <see cref="T:System.Xaml.XamlType" />-Objekts und des Schemakontexts.</summary>
        <returns>Das <see cref="T:System.Xaml.XamlType" />-Objekt für den unmittelbaren Basistyp dieses XAML-Typs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn ein Aufrufer einen Wert aus abruft <xref:System.Xaml.XamlType.BaseType%2A> .  
  
 Die Standard Implementierung gibt möglicherweise eine interne Konstante zurück, die den darstellt, <xref:System.Object> wenn gleich <xref:System.Xaml.XamlType.UnderlyingType%2A> ist `null` .  
  
 Überschreiben Sie diese Methode, wenn Sie nicht auf die interne Standard-CLR-Reflektion Vertrauen und Metadaten oder andere Techniken zum Melden von XAML-typsysteminformationen oder Schema Informationen eines Typs verwenden.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung hat die Möglichkeit, die gemeldeten Typinformationen zu einem XAML-Typ zu ändern, um die gemeldeten Typinformationen zu einem XAML-Typ so zu ändern, dass Sie nicht mehr erwartungsgemäß mit den typsysteminformationen des zugrunde liegenden CLR-Typs ausgerichtet werden. Verwenden Sie für sicherheitskritische Überprüfungen von Zuweisungs Vorgängen und Zugriff stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCollectionKind">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlCollectionKind LookupCollectionKind ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Xaml.Schema.XamlCollectionKind LookupCollectionKind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCollectionKind" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCollectionKind () As XamlCollectionKind" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlCollectionKind LookupCollectionKind();" />
      <MemberSignature Language="F#" Value="abstract member LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind&#xA;override this.LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind" Usage="xamlType.LookupCollectionKind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlCollectionKind</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert der <see cref="T:System.Xaml.Schema.XamlCollectionKind" />-Enumeration zurück, durch den deklariert wird, welcher bestimmte Auflistungstyp von diesem <see cref="T:System.Xaml.XamlType" />-Objekt verwendet wird.</summary>
        <returns>Ein Wert der <see cref="T:System.Xaml.Schema.XamlCollectionKind" />-Enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von einer internen privaten Methode aufgerufen (es ist keine öffentliche `CollectionKind` oder `GetCollectionKind` API vorhanden <xref:System.Xaml.XamlType> ).  
  
 Die Standard Implementierung verwendet die interne CLR-Reflektion. In Fällen, in denen <xref:System.Xaml.XamlType.UnderlyingType%2A> ist `null` , kann die Standard Implementierung verwenden <xref:System.Xaml.XamlType.BaseType%2A> , sofern Sie verfügbar ist. Dieses Verhalten ruft indirekt <xref:System.Xaml.XamlType.LookupCollectionKind%2A> rekursiv auf, um einen gültigen Basistyp zu finden. es wird zurückgegeben, <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> Wenn kein gültiger Basistyp vorhanden ist. Im Allgemeinen versucht die Standard Implementierung, die `Add` Methode des zugrunde liegenden Typs durch Reflektion zu finden. Wenn Sie gefunden wird, <xref:System.Reflection.MethodInfo> sind die der- `Add` Methode ausreichend Informationen, um zu bestimmen, welcher <xref:System.Xaml.Schema.XamlCollectionKind> Wert zurückgegeben werden soll. Andernfalls wird <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>zurückgegeben.  
  
 Überschreiben Sie diese Methode, wenn Sie nicht auf die interne Standard-CLR-Reflektion Vertrauen und Metadaten oder andere Techniken zum Melden von XAML-typsysteminformationen oder Schema Informationen eines Typs verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="protected virtual bool LookupConstructionRequiresArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupConstructionRequiresArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupConstructionRequiresArguments () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupConstructionRequiresArguments();" />
      <MemberSignature Language="F#" Value="abstract member LookupConstructionRequiresArguments : unit -&gt; bool&#xA;override this.LookupConstructionRequiresArguments : unit -&gt; bool" Usage="xamlType.LookupConstructionRequiresArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt Argumente (generische Einschränkungen für <see langword="x:TypeArguments" />, Initialisierungstext oder andere XAML-Techniken) aufweisen muss, um eine gültige Instanz des Typs zu erstellen.</summary>
        <returns><see langword="true" />, wenn die Erstellung einer Instanz einen Argumentwert erfordert, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn ein Aufrufer einen Wert aus abruft <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A> .  
  
 Die Standard Implementierung gibt `false` für Typen zurück, die im CLR-Typsystem als Werttypen angesehen werden. Für andere als Werttypen wird die CLR-Reflektion <xref:System.Reflection.ConstructorInfo> verwendet, um zu bestimmen, ob ein Parameter loser Konstruktor vorhanden ist.  
  
 Überschreiben Sie diese Methode, wenn Sie nicht auf die interne Standard-CLR-Reflektion Vertrauen und Metadaten oder andere Techniken zum Melden von XAML-typsysteminformationen oder Schema Informationen eines Typs verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupContentProperty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupContentProperty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentProperty () As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupContentProperty();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentProperty : unit -&gt; System.Xaml.XamlMember&#xA;override this.LookupContentProperty : unit -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupContentProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt <see cref="T:System.Xaml.XamlMember" />-Informationen für die Inhaltseigenschaft dieses <see cref="T:System.Xaml.XamlType" />-Objekts zurück.</summary>
        <returns><see cref="T:System.Xaml.XamlMember" />-Informationen für die Inhaltseigenschaft dieses <see cref="T:System.Xaml.XamlType" />-Objekts. Kann <see langword="null" /> sein.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn ein Aufrufer einen Wert aus abruft <xref:System.Xaml.XamlType.ContentProperty%2A> .  
  
 Die Standard Implementierung überprüft für <xref:System.Windows.Markup.ContentPropertyAttribute> die Typdefinition. Sie kann auch das-Attribut überprüfen, <xref:System.Xaml.XamlType.BaseType%2A> Wenn kein Attribut für den unmittelbaren zugrunde liegenden Typ gefunden wird. Wenn diese Überprüfungen keinen Inhaltstyp ermitteln, gibt die Standard Implementierung zurück `null` .  
  
 Überschreiben Sie diese Methode, wenn Sie nicht auf die interne Standard-CLR-Reflektion Vertrauen und Metadaten oder andere Techniken zum Melden von XAML-typsysteminformationen oder Schema Informationen eines Typs verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentWrappers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupContentWrappers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupContentWrappers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentWrappers () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupContentWrappers();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupContentWrappers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Liste von <see cref="T:System.Xaml.XamlType" />-Werten ab, die die Inhaltswrapper für dieses <see cref="T:System.Xaml.XamlType" />-Objekt darstellen.</summary>
        <returns>Eine Liste von <see cref="T:System.Xaml.XamlType" />-Werten, die die Inhaltswrapper für dieses <see cref="T:System.Xaml.XamlType" />-Objekt darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Inhalts Wrapper ist eine Klasse, die den inhaltsammlungstyp darstellt, wenn die in dieser Auflistung verwendeten Typen nicht an das Typsystem zusammenhängend sind. Es wird davon ausgegangen, dass die Typen der Sammel Elemente für den Inhalts Wrapper in gewisser Weise über <xref:System.Object> oder mit einem neutralen Objekt Äquivalent eingeschränkt werden. Diese Einschränkung wird jedoch nur durch das Design oder den Zweck der Eigenschaften erzwungen, die diesen Typ verwenden, nicht vom Typsystem. Für einen Typ können mehrere Inhalts Wrapper vorhanden sein.  
  
 Eine Beispiel Klasse und ein Szenario aus der WPF-XAML-Implementierung finden Sie unter <xref:System.Windows.Documents.InlineCollection> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlType.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt bei der Implementierung in einer abgeleiteten Klasse eine <see cref="T:System.Reflection.ICustomAttributeProvider" />-Implementierung zurück.</summary>
        <returns>Eine <see cref="T:System.Reflection.ICustomAttributeProvider" />-Implementierung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überschreiben Sie diese Methode, um die interne Reflektion mit einer alternativen Methode zum Abrufen von CLR-Attributwerten bereitzustellen. Wenn keine außer Kraft Setzung vorhanden ist, verwendet der interne Reflektor typische CLR-reflektionslogik.  
  
 Die Standardimplementierung gibt `null` zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlType.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt zurück, das für verzögertes Laden von in XAML deklarierten Objekten verwendet wird.</summary>
        <returns>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, der eine <see cref="T:System.Xaml.XamlDeferringLoader" />-Einschränkung für den generischen Typ besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn ein Aufrufer einen Wert aus abruft <xref:System.Xaml.XamlType.DeferringLoader%2A> . Überschreiben Sie diese Methode, wenn Sie <xref:System.Xaml.XamlType.DeferringLoader%2A> einen anderen Wert zurückgeben möchten, als durch die interne Standard Reflektion aktiviert ist, und stellen Sie auch benutzerdefinierte <xref:System.Xaml.Schema.XamlTypeInvoker> Informationen bereit.  
  
 Die Standard Implementierung gibt ein-Objekt auf Grundlage des Lesevorgangs zurück <xref:System.Windows.Markup.XamlDeferLoadAttribute> . Sie kann auch das-Attribut überprüfen, <xref:System.Xaml.XamlType.BaseType%2A> Wenn kein Attribut für den unmittelbaren zugrunde liegenden Typ gefunden wird. Wenn ein Wert nicht verfügbar ist, gibt diese Methode zurück `null` .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlTypeInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlTypeInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlTypeInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker" Usage="xamlType.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> zurück, der diesem <see cref="T:System.Xaml.XamlType" /> zugeordnet ist.</summary>
        <returns>Die <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />-Informationen für diesen <see cref="T:System.Xaml.XamlType" />, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.Invoker%2A> .  
  
 Die Standard Implementierung erfordert nicht, dass eine mit einem <xref:System.Xaml.XamlType> der Konstruktoren erstellt wird, die einen anfänglichen übergeben <xref:System.Xaml.Schema.XamlTypeInvoker> . Allerdings muss ein- <xref:System.Xaml.XamlType.UnderlyingType%2A> Wert für das vorhanden sein <xref:System.Xaml.XamlType> ; andernfalls gibt die Standard Implementierung zurück `null` .  
  
 Überschreiben Sie diese Methode, wenn Sie auch eine abgeleitete Klasse von erstellen <xref:System.Xaml.Schema.XamlTypeInvoker> und die abgeleitete Klasse zurückgeben möchten. Wenn Sie zurückgeben `null` , <xref:System.Xaml.XamlType.Invoker%2A> kehrt zu <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType> Aufrufern zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlType.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieser <see cref="T:System.Xaml.XamlType" /> einen Umgebungstyp gemäß XAML-Definition darstellt.</summary>
        <returns><see langword="true" />, wenn das <see cref="T:System.Xaml.XamlType" />-Objekt einen Umgebungstyp darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.IsAmbient%2A> .  
  
 Die Standard Implementierung verwendet die CLR-Reflektion für <xref:System.Xaml.XamlType.UnderlyingType%2A> und kann die Basis Typen überprüfen. Diese Implementierung überprüft das <xref:System.Windows.Markup.AmbientAttribute> , das auf die Definition des entsprechenden Typs auf Klassenebene angewendet wird, und gibt `true` in diesem Fall zurück. Alle anderen Fälle geben zurück `false` .  
  
 Überschreiben Sie diese Methode, wenn Sie <xref:System.Xaml.XamlType.IsAmbient%2A> einen anderen Wert zurückgeben möchten, als durch die standardmäßige interne Reflektion aktiviert ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsConstructible">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsConstructible ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsConstructible() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsConstructible" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsConstructible () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsConstructible();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsConstructible : unit -&gt; bool&#xA;override this.LookupIsConstructible : unit -&gt; bool" Usage="xamlType.LookupIsConstructible " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieser <see cref="T:System.Xaml.XamlType" /> einen erstellbaren Typ gemäß XAML-Definition darstellt.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen erstellbaren Typ darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.IsConstructible%2A> .  
  
 Die Standard Implementierung verwendet die CLR-Reflektion für den <xref:System.Xaml.XamlType.UnderlyingType%2A> . Der Typ muss "konkret", "Non-netsted" und "Closed" sein. Die Standard Implementierung überprüft, ob der Typ ein Werttyp und die Rückgabe von ist <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A> . Bei einem NULL-Wert <xref:System.Xaml.XamlType.UnderlyingType%2A> gibt diese Methode zurück `true` .  
  
 Überschreiben Sie diese Methode, wenn Sie <xref:System.Xaml.XamlType.IsConstructible%2A> einen anderen Wert zurückgeben möchten, als durch die standardmäßige interne Reflektion aktiviert ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsMarkupExtension">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsMarkupExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsMarkupExtension() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsMarkupExtension () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsMarkupExtension();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsMarkupExtension : unit -&gt; bool&#xA;override this.LookupIsMarkupExtension : unit -&gt; bool" Usage="xamlType.LookupIsMarkupExtension " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt eine Markuperweiterung darstellt.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt eine Markuperweiterung darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.IsMarkupExtension%2A> .  
  
 Die Standard Implementierung besteht nur aus folgendem:  
  
 `return CanAssignTo(XamlLanguage.MarkupExtension);`  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.IsMarkupExtension%2A> andere Logik verwenden möchten.  
  
 In XAML-Spezifikations Begriffen muss dieser Typ zugeordnet werden, damit `x:MarkupExtension` für zurückgegeben werden kann `true` <xref:System.Xaml.XamlType.IsMarkupExtension%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsNameScope">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNameScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNameScope" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNameScope () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNameScope();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNameScope : unit -&gt; bool&#xA;override this.LookupIsNameScope : unit -&gt; bool" Usage="xamlType.LookupIsNameScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieser <see cref="T:System.Xaml.XamlType" /> einen XAML-Namescope gemäß XAML-Definition darstellt.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen XAML-Namescope darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.IsNameScope%2A> .  
  
 Die Standard Implementierung führt einen <xref:System.Xaml.XamlType.CanAssignTo%2A> Rückruf indirekt gegen den-Typ aus <xref:System.Windows.Markup.INameScope> . <xref:System.Windows.Markup.INameScope> ist eine Schnittstelle, die im WindowsBase.dll der Assembly definiert ist. Diese Vorgehensweise für die XAML-Namescope-Identifikation wird sowohl von WPF als auch von Windows Workflow Foundation-Implementierungen von XAML verwendet.  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.IsNameScope%2A> andere Logik verwenden möchten.  
  
 Ein XAML-Namescope erzwingt die namens Eindeutigkeit der Eigenschaft oder Eigenschaften, die für verwendet werden `x:Name`  /  `[name property]` . Wenn den Wert <xref:System.Xaml.XamlType.IsNameScope%2A> `true` hat, sollte ein Mechanismus zum Erzwingen der Eindeutigkeit vorhanden sein, der aus der Perspektive dieses Typs ausgewertet werden muss, der einen XAML-Namescope besitzt. Der XAML-Namespace wird dann auf den Inhalt des Typs ausgedehnt, bis ein anderer durch XAML-Namescope ermittelter Typ gefunden wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsNullable">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNullable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNullable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNullable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNullable () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNullable();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNullable : unit -&gt; bool&#xA;override this.LookupIsNullable : unit -&gt; bool" Usage="xamlType.LookupIsNullable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieser <see cref="T:System.Xaml.XamlType" /> einen Nullable-Typ gemäß XAML-Definition darstellt.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen Nullable-Typ darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.IsNullable%2A> .  
  
 Die Standard Implementierung trifft basierend auf dem CLR-Kern Bibliotheks Konzept NULL-Werte, das überprüft wird <xref:System.Xaml.XamlType.UnderlyingType%2A> . Bei einem NULL-Wert <xref:System.Xaml.XamlType.UnderlyingType%2A> wird zurückgegeben `true` .  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.IsNullable%2A> andere Logik verwenden möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsPublic : unit -&gt; bool&#xA;override this.LookupIsPublic : unit -&gt; bool" Usage="xamlType.LookupIsPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen öffentlichen Typ im relevanten Typsystem darstellt.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen öffentlichen Typ darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.IsPublic%2A> .  
  
 Die Standard Implementierung verwendet die CLR-Reflektion für einen nicht-NULL-Wert <xref:System.Xaml.XamlType.UnderlyingType%2A> . Bei einem NULL-Wert <xref:System.Xaml.XamlType.UnderlyingType%2A> wird zurückgegeben `true` .  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.IsPublic%2A> andere Logik verwenden möchten.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung hat die Möglichkeit, die gemeldeten Zugriffs Informationen zu einem XAML-Typ zu ändern, um die gemeldeten Zugriffs Informationen zu einem XAML-Typ so zu ändern, dass Sie nicht mehr erwartungsgemäß mit dem Typsystem oder den Zugriffs Informationen des zugrunde liegenden CLR-Typs ausgerichtet werden. Verwenden Sie für sicherheitskritische Überprüfungen von Zuweisungs Vorgängen und Zugriff stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlType.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen Typ darstellt, der nicht im zugrunde liegenden Typsystem aufgelöst werden kann.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen nicht auflösbaren Typ darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.IsUnknown%2A> .  
  
 Die Standard Implementierung kann CLR-Reflektion verwenden. Bei einem NULL-Wert <xref:System.Xaml.XamlType.UnderlyingType%2A> wird zurückgegeben `true` .  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.IsUnknown%2A> andere Logik verwenden möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWhitespaceSignificantCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWhitespaceSignificantCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWhitespaceSignificantCollection () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWhitespaceSignificantCollection();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWhitespaceSignificantCollection : unit -&gt; bool&#xA;override this.LookupIsWhitespaceSignificantCollection : unit -&gt; bool" Usage="xamlType.LookupIsWhitespaceSignificantCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt eine leerraumsignifikante Auflistung gemäß der XML-Definition darstellt.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt eine leerraumsignifikante Auflistung darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A> .  
  
 Die Standard Implementierung gibt einen Wert zurück, der auf dem Lesevorgang basiert <xref:System.Windows.Markup.WhitespaceSignificantCollectionAttribute> . Es kann auch das- <xref:System.Xaml.XamlType.BaseType%2A> Attribut für das-Attribut überprüfen, wenn für den unmittelbaren zugrunde liegenden Typ kein Attribut gefunden wird. Wenn kein Wert verfügbar ist, wird zurückgegeben `false` .  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A> andere Logik verwenden möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsXData">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsXData ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsXData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsXData" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsXData () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsXData();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsXData : unit -&gt; bool&#xA;override this.LookupIsXData : unit -&gt; bool" Usage="xamlType.LookupIsXData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt XML-<see langword="XDATA" /> gemäß XAML-Definition darstellt.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt <see langword="XDATA" /> darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.IsXData%2A> .  
  
 Die Standard Implementierung führt einen <xref:System.Xaml.XamlType.CanAssignTo%2A> Rückruf indirekt gegen den-Typ aus <xref:System.Xml.Serialization.IXmlSerializable> .  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.IsXData%2A> andere Logik verwenden möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupItemType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupItemType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupItemType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupItemType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupItemType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupItemType();" />
      <MemberSignature Language="F#" Value="abstract member LookupItemType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupItemType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupItemType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der die Typinformationen für die <see langword="Items" />-Eigenschaft dieses <see cref="T:System.Xaml.XamlType" />-Objekts enthält.</summary>
        <returns>Ein <see cref="T:System.Xaml.XamlType" />-Objekt für den Typ der Elemente in der Auflistung, andernfalls <see langword="null" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt keine Auflistung darstellt</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.ItemType%2A> .  
  
 Die Standard Implementierung kann CLR-reflektionskonzepte verwenden, wie z. b. das Überprüfen auf eine `Add` Methode durch und die Verwendung von, das überprüfen und <xref:System.Reflection.MethodInfo> <xref:System.Reflection.ParameterInfo> <xref:System.Xaml.XamlType.IsArray%2A> prüfen <xref:System.Xaml.XamlType.BaseType%2A> der gleichen Logik.  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.ItemType%2A> andere Logik verwenden möchten. Fälle, in denen <xref:System.Xaml.XamlType.LookupCollectionKind%2A> <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> Return zurückgeben soll `null` .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupKeyType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupKeyType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupKeyType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupKeyType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupKeyType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupKeyType();" />
      <MemberSignature Language="F#" Value="abstract member LookupKeyType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupKeyType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupKeyType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der die Typinformationen für die Schlüsseleigenschaft von diesem <see cref="T:System.Xaml.XamlType" />-Objekt enthält, wenn das <see cref="T:System.Xaml.XamlType" />-Objekt ein Wörterbuch darstellt.</summary>
        <returns>Ein <see cref="T:System.Xaml.XamlType" />-Objekt für den Typ des Schlüssels für die Wörterbuchverwendung oder <see langword="null" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt kein Wörterbuch darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.KeyType%2A> .  
  
 Die Standard Implementierung kann CLR-reflektionskonzepte verwenden, wie z. b. das Überprüfen auf eine `Add` Methode durch <xref:System.Reflection.MethodInfo> und die Verwendung von, <xref:System.Reflection.ParameterInfo> und das Überprüfen <xref:System.Xaml.XamlType.BaseType%2A> und ausprobieren der gleichen Logik.  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.KeyType%2A> andere Logik verwenden möchten. Fälle, in denen <xref:System.Xaml.XamlType.LookupCollectionKind%2A> nicht zurückgibt, <xref:System.Xaml.Schema.XamlCollectionKind.Dictionary?displayProperty=nameWithType> sollte zurückgeben `null` .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupMarkupExtensionReturnType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupMarkupExtensionReturnType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionReturnType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupMarkupExtensionReturnType();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupMarkupExtensionReturnType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der die Typinformationen für das zurückgegebene <see langword="ProvideValue" />-Objekt dieses <see cref="T:System.Xaml.XamlType" />-Objekts enthält, wenn es eine Markuperweiterung darstellt.</summary>
        <returns>Ein <see cref="T:System.Xaml.XamlType" />-Objekt für den Rückgabetyp für die Verwendung der Markuperweiterung, andernfalls <see langword="null" />, wenn dieser <see cref="T:System.Xaml.XamlType" /> keine Markuperweiterung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A> .  
  
 Die Standard Implementierung gibt einen <xref:System.Xaml.XamlType> auf der Grundlage des Lesevorgangs zurück <xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> . Sie kann auch das-Attribut überprüfen, <xref:System.Xaml.XamlType.BaseType%2A> Wenn kein Attribut für den unmittelbaren zugrunde liegenden Typ gefunden wird. Wenn kein Wert verfügbar ist, wird zurückgegeben `null` .  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A> andere Logik verwenden möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupMember (string name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupMember(string name, bool skipReadOnlyCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMember(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMember (name As String, skipReadOnlyCheck As Boolean) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupMember(System::String ^ name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="F#" Value="abstract member LookupMember : string * bool -&gt; System.Xaml.XamlMember&#xA;override this.LookupMember : string * bool -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupMember (name, skipReadOnlyCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="skipReadOnlyCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Der Name des abzurufenden Members (als Zeichenfolge).</param>
        <param name="skipReadOnlyCheck"><see langword="true" />, um einen Member zurückzugeben, auch wenn dieser Member den Wert <see langword="true" /> für <see cref="P:System.Xaml.XamlMember.IsReadOnly" /> aufweist. <see langword="false" />, wenn kein <see cref="P:System.Xaml.XamlMember.IsReadOnly" />-Member zurückgegeben werden soll. Der Standardwert ist <see langword="false" />.</param>
        <summary>Gibt den <see cref="T:System.Xaml.XamlMember" /> für einen bestimmten benannten Member aus diesem <see cref="T:System.Xaml.XamlType" /> zurück.</summary>
        <returns>Die <see cref="T:System.Xaml.XamlMember" />-Informationen für den Member, wenn ein Member gefunden wurde, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.GetMember%2A> .  
  
 Die Standard Implementierung gibt einen <xref:System.Xaml.XamlType> auf der Grundlage interner CLR-Reflektion und Auswertung für den Schema Kontext zurück.  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.GetMember%2A> andere Logik verwenden möchten.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> ist virtuell und kann daher überschrieben werden. Die außer Kraft Setzung hat die Möglichkeit, die gemeldeten Member eines XAML-Typs zu ändern, um die gemeldeten Member eines XAML-Typs so zu ändern, dass Sie nicht mehr erwartungsgemäß mit den <xref:System.ComponentModel.TypeDescriptor> `Get*` Informationen über den zugrunde liegenden CLR-Typ ausgerichtet werden. Verwenden Sie für alle sicherheitskritischen Überprüfungen der Element Berichterstattung stattdessen den zugrunde liegenden CLR-Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupPositionalParameters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="abstract member LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Die Anzahl (Stelligkeit) des bestimmten Syntax- oder Konstruktormodus, zu dem Sie Informationen anzeigen möchten.</param>
        <summary>Für Markuperweiterungstypen werden die Typen der Positionsparameter zurückgegeben, die bei einer bestimmten Verwendung der Markuperweiterung für diesen <see cref="T:System.Xaml.XamlType" /> unterstützt werden.</summary>
        <returns>Eine Liste von <see cref="T:System.Xaml.XamlType" />-Werten, wobei jedes derartige <see cref="T:System.Xaml.XamlType" />-Objekt der Typ für diese Position in der Syntax ist. Beim Angeben von Markupeingaben für die Markuperweiterung müssen diese Typen in der gleichen Reihenfolge angegeben werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.GetPositionalParameters%2A> .  
  
 Die Standard Implementierung verwendet interne Reflektionsinformationen, die auf der Suche nach Konstruktoren und der Überprüfung der Stelligkeit Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.GetPositionalParameters%2A> andere Logik verwenden möchten.  
  
 Diese API ist nur relevant, wenn Sie <xref:System.Xaml.XamlType> eine Markup Erweiterung ( <xref:System.Xaml.XamlType.IsMarkupExtension%2A> ist `true` ) darstellt.  
  
 Die Eingabe `parameterCount` ist nicht für die Anforderung des Typs eines bestimmten Positions Parameters vorgesehen. Es dient zum Angeben der Stelligkeit einer Markup Erweiterungs Verwendung. Die Verwendung von Markup Erweiterungen weist oft mehrere Signaturen auf und verwendet eine andere parameterität (Anzahl) von Positions Parametern, um unterscheiden zu können. Sie können jedoch einen Schema Kontext so konfigurieren, dass doppelte Typen zugelassen werden und Typen der Positions Parameter für die Differenzierung verwendet werden. Weitere Informationen finden Sie unter <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Für eine bestimmte Anzahl von Stelligkeit können die Parameter Positionen und-Typen variieren. Um den positionellen Typ der Markup Erweiterungs Verwendung einer bestimmten Arität zu erhalten, wird zuerst <xref:System.Xaml.XamlType.GetPositionalParameters%2A> mit der stellilarzahl aufgerufen. Anschließend wird das Element an dieser Position aus der zurückgegebenen Auflistung zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetMarkupExtensionHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetMarkupExtensionHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetMarkupExtensionHandler () As EventHandler(Of XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^&gt; ^ LookupSetMarkupExtensionHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;&#xA;override this.LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;" Usage="xamlType.LookupSetMarkupExtensionHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Handlerrückruf zurück, der für set-Vorgänge von Markuperweiterungen verwendet werden soll.</summary>
        <returns>Ein Handlerrückruf, der für set-Vorgänge von Markuperweiterungen verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt einen Wert zurück, der auf dem Lesevorgang basiert <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute> . Sie kann auch das-Attribut überprüfen, <xref:System.Xaml.XamlType.BaseType%2A> Wenn kein Attribut für den unmittelbaren zugrunde liegenden Typ gefunden wird. Wenn ein Wert nicht verfügbar ist, wird zurückgegeben `null` .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetTypeConverterHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetTypeConverterHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetTypeConverterHandler () As EventHandler(Of XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetTypeConverterEventArgs ^&gt; ^ LookupSetTypeConverterHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;&#xA;override this.LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;" Usage="xamlType.LookupSetTypeConverterHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Handler zurück, der in Fällen von Typkonverterfestlegung verwendet werden soll.</summary>
        <returns>Ein Handler, der in Fällen von Typkonverterfestlegung verwendet werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standard Implementierung gibt einen Wert zurück, der auf dem Lesevorgang basiert <xref:System.Windows.Markup.XamlSetTypeConverterAttribute> . Sie kann auch das-Attribut überprüfen, <xref:System.Xaml.XamlType.BaseType%2A> Wenn kein Attribut für den unmittelbaren zugrunde liegenden Typ gefunden wird. Wenn ein Wert nicht verfügbar ist, wird zurückgegeben `null` .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="protected virtual bool LookupTrimSurroundingWhitespace ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupTrimSurroundingWhitespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTrimSurroundingWhitespace () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupTrimSurroundingWhitespace();" />
      <MemberSignature Language="F#" Value="abstract member LookupTrimSurroundingWhitespace : unit -&gt; bool&#xA;override this.LookupTrimSurroundingWhitespace : unit -&gt; bool" Usage="xamlType.LookupTrimSurroundingWhitespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt mit einem Modus serialisiert werden soll, in dem umgebender Leerraum abgeschnitten wird.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt mit einem Modus serialisiert werden soll, in dem umgebender Leerraum abgeschnitten wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.TrimSurroundingWhitespace%2A> .  
  
 Die Standard Implementierung gibt einen Wert zurück, der auf dem Lesevorgang basiert <xref:System.Windows.Markup.TrimSurroundingWhitespaceAttribute> . Sie kann auch das-Attribut überprüfen, <xref:System.Xaml.XamlType.BaseType%2A> Wenn kein Attribut für den unmittelbaren zugrunde liegenden Typ gefunden wird. Wenn ein Wert nicht verfügbar ist, wird zurückgegeben `false` .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlType.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit einer <see cref="T:System.ComponentModel.TypeConverter" />-Einschränkung zurück, das das Typkonvertierungsverhalten für Werte dieses <see cref="T:System.Xaml.XamlType" />-Objekts darstellt.</summary>
        <returns>Gibt ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit <see cref="T:System.ComponentModel.TypeConverter" />-Einschränkung zurück, das das Typkonvertierungsverhalten für Werte dieses <see cref="T:System.Xaml.XamlType" />-Objekts darstellt, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.TypeConverter%2A> .  
  
 Die Standard Implementierung gibt einen Wert zurück, der auf dem Lesevorgang basiert <xref:System.ComponentModel.TypeConverterAttribute> . Die Standard Implementierung kann auch das-Attribut überprüfen, <xref:System.Xaml.XamlType.BaseType%2A> Wenn für den unmittelbaren zugrunde liegenden Typ kein Attribut gefunden wird. Außerdem ist eine spezielle Logik für die Standard Konvertierung von Enumerationen, allgemeinen Werttypen und Generika enthalten. Wenn ein Wert nicht verfügbar ist, wird zurückgegeben `null` .  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.TypeConverter%2A> andere Logik verwenden möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingType">
      <MemberSignature Language="C#" Value="protected virtual Type LookupUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type LookupUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ LookupUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingType : unit -&gt; Type&#xA;override this.LookupUnderlyingType : unit -&gt; Type" Usage="xamlType.LookupUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das <see cref="T:System.Type" />-Objekt der CLR zurück, das diesem <see cref="T:System.Xaml.XamlType" />-Objekt unterliegt.</summary>
        <returns>Das <see cref="T:System.Type" />-Objekt der CLR, das diesem <see cref="T:System.Xaml.XamlType" />-Objekt unterliegt, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.UnderlyingType%2A> .  
  
 Die Standard Implementierung gibt ein internes Feld zurück. Dieses Feld wird im Allgemeinen während der Erstellung initialisiert, und sein Wert basiert darauf, welcher Konstruktor aufgerufen wurde und welche Informationen Sie angegeben haben.  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.UnderlyingType%2A> andere Logik verwenden möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUsableDuringInitialization">
      <MemberSignature Language="C#" Value="protected virtual bool LookupUsableDuringInitialization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupUsableDuringInitialization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUsableDuringInitialization () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupUsableDuringInitialization();" />
      <MemberSignature Language="F#" Value="abstract member LookupUsableDuringInitialization : unit -&gt; bool&#xA;override this.LookupUsableDuringInitialization : unit -&gt; bool" Usage="xamlType.LookupUsableDuringInitialization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt während der XAML-Initialisierung von oben nach unten erstellt wird.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt während der XAML-Initialisierung von oben nach unten erstellt wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Top-Down ist eine Metapher, die das XAML-Prozessor Verhalten beim Erstellen des Objekt Diagramms anweist. Wenn ein Typ von oben nach unten erstellt wird, wird er instanziiert, an das übergeordnete Element angefügt und seine Eigenschaften festgelegt. Bei der Top-Down-Konstruktion wird vermieden, dass von der Eigenschaft geänderte Handler mehrmals aufgerufen werden. Eine solche Behandlung sorgt für das Objekt Diagramm und beseitigt daher die Aufrufe mehrerer Handler und bietet eine Leistungsoptimierung für den Start des Objekt Diagramms.  
  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A> .  
  
 Die Standard Implementierung gibt einen Wert zurück, der auf dem Lesevorgang basiert <xref:System.Windows.Markup.UsableDuringInitializationAttribute> . Sie kann auch das-Attribut überprüfen, <xref:System.Xaml.XamlType.BaseType%2A> Wenn kein Attribut für den unmittelbaren zugrunde liegenden Typ gefunden wird. Wenn ein Wert nicht verfügbar ist, wird zurückgegeben `false` .  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A> andere Logik verwenden möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlType.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit einer <see cref="T:System.Windows.Markup.ValueSerializer" />-Einschränkung zurück, das das Wertserialisierungsverhalten für Werte dieses <see cref="T:System.Xaml.XamlType" />-Objekts darstellt.</summary>
        <returns>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit der <see cref="T:System.Windows.Markup.ValueSerializer" />-Einschränkung, das das Wertserialisierungsverhalten für Werte dieses <see cref="T:System.Xaml.XamlType" />-Objekts darstellt, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann durch Aufrufe von aufgerufen werden <xref:System.Xaml.XamlType.ValueSerializer%2A> .  
  
 Die Standard Implementierung gibt einen Wert zurück, der auf dem Lesevorgang basiert <xref:System.Windows.Markup.ValueSerializerAttribute> . Sie kann auch das-Attribut überprüfen, <xref:System.Xaml.XamlType.BaseType%2A> Wenn kein Attribut für den unmittelbaren zugrunde liegenden Typ gefunden wird. Außerdem ist eine spezielle Logik für die Standardserialisierung von Enumerationen, allgemeinen Werttypen oder Generika enthalten. Wenn ein Wert nicht verfügbar ist, wird zurückgegeben `null` .  
  
 Überschreiben Sie diese Methode, wenn Sie eine <xref:System.Xaml.XamlType.ValueSerializer%2A> andere Logik verwenden möchten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType MarkupExtensionReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType MarkupExtensionReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionReturnType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ MarkupExtensionReturnType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionReturnType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Typinformationen für das zurückgegebene <see langword="ProvideValue" />-Objekt dieses <see cref="T:System.Xaml.XamlType" />-Objekts enthält, wenn es eine Markuperweiterung darstellt.</summary>
        <value>Ein <see cref="T:System.Xaml.XamlType" />-Objekt für den Rückgabetyp für die Verwendung der Markuperweiterung, andernfalls <see langword="null" />, wenn dieser <see cref="T:System.Xaml.XamlType" /> keine Markuperweiterung darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist nur relevant, wenn dies <xref:System.Xaml.XamlType> eine Markup Erweiterung darstellt ( `x:MarkupExtension` in der Liste der zustellbaren Typen).  
  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlType.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Zeichenfolgennamen des Typs ab, den dieses <see cref="T:System.Xaml.XamlType" />-Objekt darstellt.</summary>
        <value>Der Zeichenfolgenname dieses XAML-Typs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft in der Regel den mit dem Schema erstellten Namen (pro <xref:System.Xaml.XamlType.%23ctor%2A> Signatur) oder den Namen der ab <xref:System.Type> , wenn Sie mit dem entsprechenden Konstruktor des CLR-Typsystems erstellt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Equality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="xamlType1 = xamlType2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1"><see cref="T:System.Xaml.XamlType" /> oder <see langword="null" />.</param>
        <param name="xamlType2"><see cref="T:System.Xaml.XamlType" /> oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.Xaml.XamlType" />-Objekte denselben Wert haben.</summary>
        <returns><see langword="true" />, wenn <paramref name="xamlType1" /> und <paramref name="xamlType2" /> denselben Wert haben, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Inequality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="System.Xaml.XamlType.op_Inequality (xamlType1, xamlType2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1"><see cref="T:System.Xaml.XamlType" /> oder <see langword="null" />.</param>
        <param name="xamlType2"><see cref="T:System.Xaml.XamlType" /> oder <see langword="null" />.</param>
        <summary>Bestimmt, ob zwei angegebene <see cref="T:System.Xaml.XamlType" />-Objekte verschiedene Werte haben.</summary>
        <returns><see langword="true" />, wenn der Wert von <paramref name="xamlType1" /> vom Wert von <paramref name="xamlType2" /> verschieden ist; andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den einzelnen XAML-Namespace ab, der der primäre XAML-Namespace für diesen <see cref="T:System.Xaml.XamlType" /> ist.</summary>
        <value>Der Bezeichner für den primären XAML-Namespace für diesen XAML-Typ als Zeichenfolge.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung bietet denselben Wert wie das Aufrufen <xref:System.Xaml.XamlType.GetXamlNamespaces%2A> von und das Abrufen der ersten Wert Zeichenfolge aus der zurückgegebenen Aufzähl Bare-Menge.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlType.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das aktive <see cref="T:System.Xaml.XamlSchemaContext" />-Objekt zum Verarbeiten dieses <see cref="T:System.Xaml.XamlType" />-Objekt ab.</summary>
        <value>Das aktive <see cref="T:System.Xaml.XamlSchemaContext" />-Objekt zum Verarbeiten dieses <see cref="T:System.Xaml.XamlType" />-Objekts.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlSchemaContext> ist ein erforderlicher Parameter Eintrag beim Erstellen einer <xref:System.Xaml.XamlType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine Zeichenfolgendarstellung für diese <see cref="T:System.Xaml.XamlType" /> zurück.</summary>
        <returns>Eine Zeichenfolgendarstellung für diese <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Xaml.XamlType> Implementierung von <xref:System.Object.ToString%2A> gibt die- <xref:System.Xaml.XamlType.Name%2A> Eigenschaft von zurück <xref:System.Xaml.XamlType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="public bool TrimSurroundingWhitespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimSurroundingWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TrimSurroundingWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimSurroundingWhitespace { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.TrimSurroundingWhitespace : bool" Usage="System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses <see cref="T:System.Xaml.XamlType" />-Objekt Leerraumbehandlungsverhalten für die Serialisierung aufweist, bei dem umgebender Leerraum in seinem Inhalt abgeschnitten wird.</summary>
        <value><see langword="true" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt einen Typ darstellt, der Leerraumeinschränkung verwendet, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; TypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; TypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArguments As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ TypeArguments { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeArguments : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.TypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Liste von Typargumenten für Fälle ab, in denen dieses <see cref="T:System.Xaml.XamlType" />-Objekt ein generisches Objekt darstellt.</summary>
        <value>Eine Liste von Typargumenttypen, andernfalls <see langword="null" />, wenn dieses <see cref="T:System.Xaml.XamlType" />-Objekt kein generisches Objekt darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt bestimmte Szenarien für einen, <xref:System.Xaml.XamlType> bei dem der Aufruf des- <xref:System.Xaml.XamlType.TypeArguments%2A> Parameters eine Liste zurückgibt, in der die Typen noch geöffnet sind. In diesem Fall verfügt mindestens einer der zurückgegebenen <xref:System.Xaml.XamlType> Werte über Platzhalter Werte für <xref:System.Xaml.XamlType.Name%2A?displayProperty=nameWithType> , z `T` . b., um darzustellen, dass der generische weiterhin geöffnet ist. Dieses Szenario kann eintreten, wenn Sie einen <xref:System.Xaml.XamlType> von einem-Befehl <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A> anstelle von einer XAML-Reader-Implementierung erhalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlType.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit der <see cref="T:System.ComponentModel.TypeConverter" />-Einschränkung ab, das das Typkonvertierungsverhalten für Werte dieses <see cref="T:System.Xaml.XamlType" />-Objekts darstellt.</summary>
        <value>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit der <see cref="T:System.ComponentModel.TypeConverter" />-Einschränkung, das das Typkonvertierungsverhalten für Werte dieses <see cref="T:System.Xaml.XamlType" />-Objekts darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupTypeConverter%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupTypeConverter%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingType">
      <MemberSignature Language="C#" Value="public Type UnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.UnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ UnderlyingType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingType : Type" Usage="System.Xaml.XamlType.UnderlyingType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Type" />-Objekt der CLR ab, die diesem <see cref="T:System.Xaml.XamlType" />-Objekt unterliegt.</summary>
        <value>Der CLR-<see cref="T:System.Type" />, der diesem <see cref="T:System.Xaml.XamlType" /> zugrunde liegt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlType.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit <see cref="T:System.Windows.Markup.ValueSerializer" />-Einschränkung ab, das das Wertserialisierungsverhalten für Werte dieses <see cref="T:System.Xaml.XamlType" />-Objekts darstellt.</summary>
        <value>Ein <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />-Objekt mit der <see cref="T:System.Windows.Markup.ValueSerializer" />-Einschränkung, das das Wertserialisierungsverhalten für Werte dieses <see cref="T:System.Xaml.XamlType" />-Objekts darstellt, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie nicht die standardmäßige interne CLR-reflektionstechnik für ein verwenden <xref:System.Xaml.XamlType> , können Aufrufe dieser Eigenschaft außer Kraft setzungen für <xref:System.Xaml.XamlType.LookupValueSerializer%2A> <xref:System.Xaml.XamlType> abgeleitete Klassen aufrufen. Weitere Informationen zu Rückgabe Werten und anderem Verhalten finden Sie in der Dokumentation zu für <xref:System.Xaml.XamlType.LookupValueSerializer%2A> diesen Typ.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
