<Type Name="GraphicsPath" FullName="System.Drawing.Drawing2D.GraphicsPath">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b9479e3322c6cbf909de37dc8a02478f9f628a32" /><Meta Name="ms.sourcegitcommit" Value="367e1eae0725e6da7136cd073aaa856ded5d5c29" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/13/2019" /><Meta Name="ms.locfileid" Value="75019474" /></Metadata><TypeSignature Language="C#" Value="public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit GraphicsPath extends System.MarshalByRefObject implements class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Drawing.Drawing2D.GraphicsPath" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class GraphicsPath&#xA;Inherits MarshalByRefObject&#xA;Implements ICloneable, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class GraphicsPath sealed : MarshalByRefObject, ICloneable, IDisposable" />
  <TypeSignature Language="F#" Value="type GraphicsPath = class&#xA;    inherit MarshalByRefObject&#xA;    interface ICloneable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Drawing</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Drawing.Common</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.1</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Reihe verbundener Linien und Kurven dar. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anwendungen verwenden Pfade, um Kontur Formen zu zeichnen, das Innere von Formen auszufüllen und Clippingbereiche zu erstellen. Die Grafik-Engine behält die Koordinaten der geometrischen Formen in einem Pfad im Raum der Welt Koordinate bei.  
  
 Ein Pfad kann aus einer beliebigen Anzahl von Abbildungen (unter Pfaden) bestehen. Jede Abbildung besteht entweder aus einer Sequenz von verbundenen Linien und Kurven oder einer geometrischen Form primitiv. Der Ausgangspunkt einer Abbildung ist der erste Punkt in der Sequenz der verbundenen Linien und Kurven. Der Endpunkt ist der letzte Punkt in der Sequenz. Die Anfangs-und Endpunkte einer geometrischen Form primitiven werden durch die primitive Spezifikation definiert.  
  
 Eine Abbildung, die aus einer Sequenz von verbundenen Linien und Kurven besteht (deren Anfangs-und Endpunkte ggf. Coincident sein können), ist eine offene Abbildung, es sei denn, Sie wird explizit geschlossen. Eine Abbildung kann explizit geschlossen werden, mithilfe der <xref:System.Drawing.Drawing2D.GraphicsPath.CloseFigure%2A>-Methode, die die aktuelle Figur schließt, indem eine Linie vom Endpunkt mit dem Ausgangspunkt verbunden wird. Eine Abbildung, die aus einer geometrischen Form primitiv besteht, ist eine geschlossene Abbildung.  
  
 Zum Zwecke des Füllens und cliings (z. b. Wenn ein Pfad mit <xref:System.Drawing.Graphics.FillPath%2A>gerendert wird), werden alle geöffneten Abbildungen geschlossen, indem eine Zeile aus dem ersten Punkt der Abbildung zum letzten Punkt hinzugefügt wird.  
  
 Eine neue Abbildung wird implizit gestartet, wenn ein Pfad erstellt wird oder wenn eine Abbildung geschlossen wird. Eine neue Figur wird explizit erstellt, wenn die <xref:System.Drawing.Drawing2D.GraphicsPath.StartFigure%2A>-Methode aufgerufen wird.  
  
 Wenn ein geometrisches Shape-primitiv einem Pfad hinzugefügt wird, wird eine Abbildung mit der geometrischen Form hinzugefügt, und es wird auch implizit eine neue Figur gestartet. Folglich gibt es immer eine aktuelle Figur in einem Pfad. Wenn einem Pfad Linien und Kurven hinzugefügt werden, wird nach Bedarf eine implizite Linie hinzugefügt, um den Endpunkt der aktuellen Abbildung mit dem Ausgangspunkt der neuen Linien und Kurven zu verbinden und so eine Sequenz von verbundenen Linien und Kurven zu bilden.  
  
 Eine Abbildung hat eine Richtung, in der beschrieben wird, wie Linien-und Kurven Segmente zwischen dem Anfangspunkt und dem Endpunkt verfolgt werden. Die Richtung wird in der Reihenfolge definiert, in der Linien und Kurven zu einer Abbildung hinzugefügt werden, oder wird durch die geometrische Form primitiv definiert. Die Richtung wird bei der Ermittlung der Pfad innere für Clipping und Fill verwendet.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/f16ec921-56cf-46d1-9741-d7316ad06b23">Erstellen und Zeichnen von Pfaden</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />-Klasse mit einer <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration von <see langword="Alternate" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />-Klasse mit dem <see cref="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" />-Wert <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.Drawing2D.FillMode -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath fillMode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="fillMode">Die <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, die bestimmt, wie das Innere dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> ausgefüllt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />-Klasse mit der angegebenen <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As Point(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.Point[] * byte[] -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Ein Array von <see cref="T:System.Drawing.Point" />-Strukturen, das die Koordinaten der Punkte definiert, aus denen dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> besteht.</param>
        <param name="types">Ein Array von <see cref="T:System.Drawing.Drawing2D.PathPointType" />-Enumerationselementen, das den Typ für jeden entsprechenden Punkt im <paramref name="pts" />-Array angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />-Klasse mit dem angegebenen <see cref="T:System.Drawing.Drawing2D.PathPointType" />-Array und dem angegebenen <see cref="T:System.Drawing.Point" />-Array.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (pts As PointF(), types As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.PointF[] * byte[] -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="pts">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, das die Koordinaten der Punkte definiert, aus denen dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> besteht.</param>
        <param name="types">Ein Array von <see cref="T:System.Drawing.Drawing2D.PathPointType" />-Enumerationselementen, das den Typ für jeden entsprechenden Punkt im <paramref name="pts" />-Array angibt.</param>
        <summary>Initialisiert eine neue Instanz des <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />-Arrays mit dem angegebenen <see cref="T:System.Drawing.Drawing2D.PathPointType" />-Array und dem angegebenen <see cref="T:System.Drawing.PointF" />-Array.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.Point[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.Point[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.Point[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::Point&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.Point[] * byte[] * System.Drawing.Drawing2D.FillMode -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types, fillMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.Point[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Ein Array von <see cref="T:System.Drawing.Point" />-Strukturen, das die Koordinaten der Punkte definiert, aus denen dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> besteht.</param>
        <param name="types">Ein Array von <see cref="T:System.Drawing.Drawing2D.PathPointType" />-Enumerationselementen, das den Typ für jeden entsprechenden Punkt im <paramref name="pts" />-Array angibt.</param>
        <param name="fillMode">Eine <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, die angibt, wie das Innere der Formen in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> gefüllt wird.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />-Klasse mit dem angegebenen <see cref="T:System.Drawing.Drawing2D.PathPointType" />-Array, dem angegebenen <see cref="T:System.Drawing.Point" />-Array und dem angegebenen <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumerationselement.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public GraphicsPath (System.Drawing.PointF[] pts, byte[] types, System.Drawing.Drawing2D.FillMode fillMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Drawing.PointF[] pts, unsigned int8[] types, valuetype System.Drawing.Drawing2D.FillMode fillMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.#ctor(System.Drawing.PointF[],System.Byte[],System.Drawing.Drawing2D.FillMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; GraphicsPath(cli::array &lt;System::Drawing::PointF&gt; ^ pts, cli::array &lt;System::Byte&gt; ^ types, System::Drawing::Drawing2D::FillMode fillMode);" />
      <MemberSignature Language="F#" Value="new System.Drawing.Drawing2D.GraphicsPath : System.Drawing.PointF[] * byte[] * System.Drawing.Drawing2D.FillMode -&gt; System.Drawing.Drawing2D.GraphicsPath" Usage="new System.Drawing.Drawing2D.GraphicsPath (pts, types, fillMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="pts" Type="System.Drawing.PointF[]" />
        <Parameter Name="types" Type="System.Byte[]" />
        <Parameter Name="fillMode" Type="System.Drawing.Drawing2D.FillMode" />
      </Parameters>
      <Docs>
        <param name="pts">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, das die Koordinaten der Punkte definiert, aus denen dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> besteht.</param>
        <param name="types">Ein Array von <see cref="T:System.Drawing.Drawing2D.PathPointType" />-Enumerationselementen, das den Typ für jeden entsprechenden Punkt im <paramref name="pts" />-Array angibt.</param>
        <param name="fillMode">Eine <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, die angibt, wie das Innere der Formen in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> gefüllt wird.</param>
        <summary>Initialisiert eine neue Instanz des <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />-Arrays mit dem angegebenen <see cref="T:System.Drawing.Drawing2D.PathPointType" />-Array, dem angegebenen <see cref="T:System.Drawing.PointF" />-Array und dem angegebenen <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumerationselement.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddArc">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt einen Ellipsenbogen an die aktuelle Figur an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphicsPath.AddArc (rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.Rectangle" />, das die rechteckigen Grenzen der Ellipse darstellt, aus der der Bogen entnommen wird.</param>
        <param name="startAngle">Der Startwinkel des Bogens in Grad, von der x-Achse im Uhrzeigersinn gemessen.</param>
        <param name="sweepAngle">Der Winkel zwischen <paramref name="startAngle" /> und dem Ende des Bogens.</param>
        <summary>Fügt einen Ellipsenbogen an die aktuelle Figur an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn in der Abbildung vorherige Zeilen oder Kurven vorhanden sind, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments mit dem Anfang des Bogens zu verbinden.  
  
 Der Bogen wird entlang des durch das angegebene Rechteck begrenzten Umfangs der Ellipse verfolgt. Der Anfangspunkt des Bogens wird durch die Messung im Uhrzeigersinn von der x-Achse der Ellipse (im 0-Grad-Winkel) um die Anzahl der Grad im Start Winkel bestimmt. Der Endpunkt befindet sich auf ähnliche Weise, indem er im Uhrzeigersinn zwischen dem Anfangspunkt und der Anzahl der Grad im Mittelpunktswinkel gemessen wird. Wenn der Mittelpunktswinkel größer als 360 Grad oder kleiner als-360 Grad ist, wird der Bogen um genau 360 Grad bzw.-360 Grad gezogen.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Rechteck, von dem der Bogen definiert wird.  
  
-   Erstellt einen Pfad, `myPath`.  
  
-   Definiert einen Ellipsen Bogen mit 180 Grad, der zwischen 0 und 180 Grad zieht und ihn an einen Pfad anfügt.  
  
-   Zeichnet den Pfad zum Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#1)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#1)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (System.Drawing.RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(valuetype System.Drawing.RectangleF rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Drawing.RectangleF,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (rect As RectangleF, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(System::Drawing::RectangleF rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : System.Drawing.RectangleF * single * single -&gt; unit" Usage="graphicsPath.AddArc (rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.RectangleF" />, das die rechteckigen Grenzen der Ellipse darstellt, aus der der Bogen entnommen wird.</param>
        <param name="startAngle">Der Startwinkel des Bogens in Grad, von der x-Achse im Uhrzeigersinn gemessen.</param>
        <param name="sweepAngle">Der Winkel zwischen <paramref name="startAngle" /> und dem Ende des Bogens.</param>
        <summary>Fügt einen Ellipsenbogen an die aktuelle Figur an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn in der Abbildung vorherige Zeilen oder Kurven vorhanden sind, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments mit dem Anfang des Bogens zu verbinden.  
  
 Der Bogen wird entlang des durch das angegebene Rechteck begrenzten Umfangs der Ellipse verfolgt. Der Anfangspunkt des Bogens wird durch die Messung im Uhrzeigersinn von der x-Achse der Ellipse (im 0-Grad-Winkel) um die Anzahl der Grad im Start Winkel bestimmt. Der Endpunkt befindet sich auf ähnliche Weise, indem er im Uhrzeigersinn zwischen dem Anfangspunkt und der Anzahl der Grad im Mittelpunktswinkel gemessen wird. Wenn der Mittelpunktswinkel größer als 360 Grad oder kleiner als-360 Grad ist, wird der Bogen um genau 360 Grad bzw.-360 Grad gezogen.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : int * int * int * int * single * single -&gt; unit" Usage="graphicsPath.AddArc (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der linken oberen Ecke des rechteckigen Bereichs, der die Ellipse definiert, aus der der zu zeichnende Bogen stammt.</param>
        <param name="y">Die y-Koordinate der linken oberen Ecke des rechteckigen Bereichs, der die Ellipse definiert, aus der der zu zeichnende Bogen stammt.</param>
        <param name="width">Die Breite des rechteckigen Bereichs, der die Ellipse definiert, aus der der zu zeichnende Bogen stammt.</param>
        <param name="height">Die Höhe des rechteckigen Bereichs, der die Ellipse definiert, aus der der zu zeichnende Bogen stammt.</param>
        <param name="startAngle">Der Startwinkel des Bogens in Grad, von der x-Achse im Uhrzeigersinn gemessen.</param>
        <param name="sweepAngle">Der Winkel zwischen <paramref name="startAngle" /> und dem Ende des Bogens.</param>
        <summary>Fügt einen Ellipsenbogen an die aktuelle Figur an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn in der Abbildung vorherige Zeilen oder Kurven vorhanden sind, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments mit dem Anfang des Bogens zu verbinden.  
  
 Der Bogen wird entlang des durch das angegebene Rechteck begrenzten Umfangs der Ellipse verfolgt. Der Anfangspunkt des Bogens wird durch die Messung im Uhrzeigersinn von der x-Achse der Ellipse (im 0-Grad-Winkel) um die Anzahl der Grad im Start Winkel bestimmt. Der Endpunkt befindet sich auf ähnliche Weise, indem er im Uhrzeigersinn zwischen dem Anfangspunkt und der Anzahl der Grad im Mittelpunktswinkel gemessen wird. Wenn der Mittelpunktswinkel größer als 360 Grad oder kleiner als-360 Grad ist, wird der Bogen um genau 360 Grad bzw.-360 Grad gezogen.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddArc">
      <MemberSignature Language="C#" Value="public void AddArc (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddArc(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddArc(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddArc (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddArc : single * single * single * single * single * single -&gt; unit" Usage="graphicsPath.AddArc (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der linken oberen Ecke des rechteckigen Bereichs, der die Ellipse definiert, aus der der zu zeichnende Bogen stammt.</param>
        <param name="y">Die y-Koordinate der linken oberen Ecke des rechteckigen Bereichs, der die Ellipse definiert, aus der der zu zeichnende Bogen stammt.</param>
        <param name="width">Die Breite des rechteckigen Bereichs, der die Ellipse definiert, aus der der zu zeichnende Bogen stammt.</param>
        <param name="height">Die Höhe des rechteckigen Bereichs, der die Ellipse definiert, aus der der zu zeichnende Bogen stammt.</param>
        <param name="startAngle">Der Startwinkel des Bogens in Grad, von der x-Achse im Uhrzeigersinn gemessen.</param>
        <param name="sweepAngle">Der Winkel zwischen <paramref name="startAngle" /> und dem Ende des Bogens.</param>
        <summary>Fügt einen Ellipsenbogen an die aktuelle Figur an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn in der Abbildung vorherige Zeilen oder Kurven vorhanden sind, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments mit dem Anfang des Bogens zu verbinden.  
  
 Der Bogen wird entlang des durch das angegebene Rechteck begrenzten Umfangs der Ellipse verfolgt. Der Anfangspunkt des Bogens wird durch die Messung im Uhrzeigersinn von der x-Achse der Ellipse (im 0-Grad-Winkel) um die Anzahl der Grad im Start Winkel bestimmt. Der Endpunkt befindet sich auf ähnliche Weise, indem er im Uhrzeigersinn zwischen dem Anfangspunkt und der Anzahl der Grad im Mittelpunktswinkel gemessen wird. Wenn der Mittelpunktswinkel größer als 360 Grad oder kleiner als-360 Grad ist, wird der Bogen um genau 360 Grad bzw.-360 Grad gezogen.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddArc%28System.Drawing.Rectangle%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBezier">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der aktuellen Figur eine kubische Bézierkurve hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.Point pt1, System.Drawing.Point pt2, System.Drawing.Point pt3, System.Drawing.Point pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2, valuetype System.Drawing.Point pt3, valuetype System.Drawing.Point pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.Point,System.Drawing.Point,System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As Point, pt2 As Point, pt3 As Point, pt4 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::Point pt1, System::Drawing::Point pt2, System::Drawing::Point pt3, System::Drawing::Point pt4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : System.Drawing.Point * System.Drawing.Point * System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphicsPath.AddBezier (pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
        <Parameter Name="pt3" Type="System.Drawing.Point" />
        <Parameter Name="pt4" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">Ein den Anfangspunkt der Kurve darstellender <see cref="T:System.Drawing.Point" />.</param>
        <param name="pt2">Ein <see cref="T:System.Drawing.Point" />, der den ersten Kontrollpunkt der Kurve darstellt.</param>
        <param name="pt3">Ein <see cref="T:System.Drawing.Point" />, der den zweiten Kontrollpunkt der Kurve darstellt.</param>
        <param name="pt4">Ein den Endpunkt der Kurve darstellender <see cref="T:System.Drawing.Point" />.</param>
        <summary>Fügt der aktuellen Figur eine kubische Bézierkurve hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die kubische Kurve wird vom ersten Punkt bis zum vierten Punkt erstellt, indem der zweite und dritte Punkt als Kontrollpunkte verwendet werden.  
  
 Wenn in der Abbildung ein vorheriges Linien-oder Kurven Segment vorhanden ist, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments mit dem Ausgangspunkt der kubischen Kurve zu verbinden.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (System.Drawing.PointF pt1, System.Drawing.PointF pt2, System.Drawing.PointF pt3, System.Drawing.PointF pt4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2, valuetype System.Drawing.PointF pt3, valuetype System.Drawing.PointF pt4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (pt1 As PointF, pt2 As PointF, pt3 As PointF, pt4 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(System::Drawing::PointF pt1, System::Drawing::PointF pt2, System::Drawing::PointF pt3, System::Drawing::PointF pt4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphicsPath.AddBezier (pt1, pt2, pt3, pt4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
        <Parameter Name="pt3" Type="System.Drawing.PointF" />
        <Parameter Name="pt4" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">Ein den Anfangspunkt der Kurve darstellender <see cref="T:System.Drawing.PointF" />.</param>
        <param name="pt2">Ein <see cref="T:System.Drawing.PointF" />, der den ersten Kontrollpunkt der Kurve darstellt.</param>
        <param name="pt3">Ein <see cref="T:System.Drawing.PointF" />, der den zweiten Kontrollpunkt der Kurve darstellt.</param>
        <param name="pt4">Ein den Endpunkt der Kurve darstellender <see cref="T:System.Drawing.PointF" />.</param>
        <summary>Fügt der aktuellen Figur eine kubische Bézierkurve hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die kubische Kurve wird vom ersten Punkt bis zum vierten Punkt erstellt, indem der zweite und dritte Punkt als Kontrollpunkte verwendet werden.  
  
 Wenn in der Abbildung ein vorheriges Linien-oder Kurven Segment vorhanden ist, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments mit dem Ausgangspunkt der kubischen Kurve zu verbinden.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(int32 x1, int32 y1, int32 x2, int32 y2, int32 x3, int32 y3, int32 x4, int32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, x3 As Integer, y3 As Integer, x4 As Integer, y4 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : int * int * int * int * int * int * int * int -&gt; unit" Usage="graphicsPath.AddBezier (x1, y1, x2, y2, x3, y3, x4, y4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
        <Parameter Name="x3" Type="System.Int32" />
        <Parameter Name="y3" Type="System.Int32" />
        <Parameter Name="x4" Type="System.Int32" />
        <Parameter Name="y4" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Die x-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="y1">Die y-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="x2">Die x-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="y2">Die y-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="x3">Die x-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="y3">Die y-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="x4">Die x-Koordinate des Endpunkts der Kurve.</param>
        <param name="y4">Die y-Koordinate des Endpunkts der Kurve.</param>
        <summary>Fügt der aktuellen Figur eine kubische Bézierkurve hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die kubische Kurve wird vom ersten Punkt bis zum vierten Punkt erstellt, indem der zweite und dritte Punkt als Kontrollpunkte verwendet werden.  
  
 Wenn in der Abbildung ein vorheriges Linien-oder Kurven Segment vorhanden ist, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments mit dem Ausgangspunkt der kubischen Kurve zu verbinden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad.  
  
-   Fügt eine kubische Bézier-Kurve, die durch die Punkte (50, 50), (70, 0), (100, 120) und (150, 50) definiert ist, in den Pfad ein.  
  
-   Schließt die Kurve.  
  
-   Zeichnet den Pfad zum Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#2)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#2)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBezier">
      <MemberSignature Language="C#" Value="public void AddBezier (float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBezier(float32 x1, float32 y1, float32 x2, float32 y2, float32 x3, float32 y3, float32 x4, float32 y4) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBezier(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBezier (x1 As Single, y1 As Single, x2 As Single, y2 As Single, x3 As Single, y3 As Single, x4 As Single, y4 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);" />
      <MemberSignature Language="F#" Value="member this.AddBezier : single * single * single * single * single * single * single * single -&gt; unit" Usage="graphicsPath.AddBezier (x1, y1, x2, y2, x3, y3, x4, y4)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
        <Parameter Name="x3" Type="System.Single" />
        <Parameter Name="y3" Type="System.Single" />
        <Parameter Name="x4" Type="System.Single" />
        <Parameter Name="y4" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Die x-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="y1">Die y-Koordinate des Anfangspunkts der Kurve.</param>
        <param name="x2">Die x-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="y2">Die y-Koordinate des ersten Kontrollpunkts der Kurve.</param>
        <param name="x3">Die x-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="y3">Die y-Koordinate des zweiten Kontrollpunkts der Kurve.</param>
        <param name="x4">Die x-Koordinate des Endpunkts der Kurve.</param>
        <param name="y4">Die y-Koordinate des Endpunkts der Kurve.</param>
        <summary>Fügt der aktuellen Figur eine kubische Bézierkurve hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die kubische Kurve wird vom ersten Punkt bis zum vierten Punkt erstellt, indem der zweite und dritte Punkt als Kontrollpunkte verwendet werden.  
  
 Wenn in der Abbildung ein vorheriges Linien-oder Kurven Segment vorhanden ist, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments mit dem Ausgangspunkt der kubischen Kurve zu verbinden.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddBezier%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBeziers">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der aktuellen Figur eine Abfolge verbundener kubischer Bézierkurven hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (params System.Drawing.Point[] points);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (ParamArray points As Point())" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(... cli::array &lt;System::Drawing::Point&gt; ^ points);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="member this.AddBeziers : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddBeziers points" />
      <MemberSignature Language="C#" Value="public void AddBeziers (System.Drawing.Point[] points);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (points As Point())" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(cli::array &lt;System::Drawing::Point&gt; ^ points);" FrameworkAlternate="netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" />-Strukturen, das die Punkte für die Definition der Kurven darstellt.</param>
        <summary>Fügt der aktuellen Figur eine Abfolge verbundener kubischer Bézierkurven hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `points`-Parameter gibt ein Array von Endpunkten und Steuerungs Punkten der verbundenen Kurven an. Die erste Kurve wird vom ersten Punkt bis zum vierten Punkt im `points` Array erstellt, indem der zweite und dritte Punkt als Kontrollpunkte verwendet werden. Zusätzlich zum Endpunkt der vorherigen Kurve benötigt jede nachfolgende Kurve in der Sequenz genau drei weitere Punkte: die nächsten zwei Punkte in der Sequenz sind Steuerungs Punkte, und der dritte ist der Endpunkt für die hinzugefügte Kurve.  
  
 Wenn in der Abbildung vorherige Zeilen oder Kurven vorhanden sind, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments mit dem Ausgangspunkt der ersten kubischen Kurve in der Sequenz zu verbinden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Array von sieben Punkten (die zwei verbundene Bézier-Kurven darstellen).  
  
-   Erstellt einen Pfad und fügt dem Pfad die Reihe der Bézier-Kurven Punkte hinzu.  
  
-   Zeichnet den Pfad zum Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#3)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#3)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBeziers">
      <MemberSignature Language="C#" Value="public void AddBeziers (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeziers(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddBeziers(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeziers (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeziers(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddBeziers : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddBeziers points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, das die Punkte für die Definition der Kurven darstellt.</param>
        <summary>Fügt der aktuellen Figur eine Abfolge verbundener kubischer Bézierkurven hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `points`-Parameter gibt ein Array von Endpunkten und Steuerungs Punkten der verbundenen Kurven an. Die erste Kurve wird vom ersten Punkt bis zum vierten Punkt im `points` Array erstellt, indem der zweite und dritte Punkt als Kontrollpunkte verwendet werden. Zusätzlich zum Endpunkt der vorherigen Kurve benötigt jede nachfolgende Kurve in der Sequenz genau drei weitere Punkte: die nächsten zwei Punkte in der Sequenz sind Steuerungs Punkte, und der dritte ist der Endpunkt für die hinzugefügte Kurve.  
  
 Wenn in der Abbildung vorherige Zeilen oder Kurven vorhanden sind, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments mit dem Ausgangspunkt der ersten kubischen Kurve in der Sequenz zu verbinden.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter:  
  
 <xref:System.Drawing.Drawing2D.GraphicsPath.AddBeziers%28System.Drawing.Point%5B%5D%29>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddClosedCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt diesem Pfad eine geschlossene Kurve hinzu. Es wird eine Cardinal-Splinekurve verwendet, weil die Kurve durch jeden der Punkte im Array verläuft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddClosedCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" />-Strukturen, das die Punkte für die Definition der Kurve darstellt.</param>
        <summary>Fügt diesem Pfad eine geschlossene Kurve hinzu. Es wird eine Cardinal-Splinekurve verwendet, weil die Kurve durch jeden der Punkte im Array verläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss die ursprünglichen Punkte aufbewahren, wenn Sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerungs Punkte konvertiert. Daher gibt es keinen Mechanismus zum Zurückgeben der ursprünglichen Punkte. Wenn der erste Punkt und der letzte Punkt im `points` Array nicht denselben Punkt haben, wird die Kurve geschlossen, indem diese beiden Punkte verbunden werden. Der Spannungswert kann für diese Methode nicht festgelegt werden, und der Standardwert ist 0,5.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddClosedCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, das die Punkte für die Definition der Kurve darstellt.</param>
        <summary>Fügt diesem Pfad eine geschlossene Kurve hinzu. Es wird eine Cardinal-Splinekurve verwendet, weil die Kurve durch jeden der Punkte im Array verläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss die ursprünglichen Punkte aufbewahren, wenn Sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerungs Punkte konvertiert. Daher gibt es keinen Mechanismus zum Zurückgeben der ursprünglichen Punkte. Wenn der erste Punkt und der letzte Punkt im `points` Array nicht denselben Punkt haben, wird die Kurve geschlossen, indem diese beiden Punkte verbunden werden. Der Spannungswert kann für diese Methode nicht festgelegt werden, und der Standardwert ist 0,5.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.Point[] * single -&gt; unit" Usage="graphicsPath.AddClosedCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" />-Strukturen, das die Punkte für die Definition der Kurve darstellt.</param>
        <param name="tension">Ein Wert zwischen 0 (null) und 1, der die Kurvenkrümmung zwischen den einzelnen Punkten angibt. 0  (null) stellt die kleinste Kurve (stärkste Krümmung) und 1 die am sanftesten gekrümmte Kurve dar.</param>
        <summary>Fügt diesem Pfad eine geschlossene Kurve hinzu. Es wird eine Cardinal-Splinekurve verwendet, weil die Kurve durch jeden der Punkte im Array verläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss die ursprünglichen Punkte aufbewahren, wenn Sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerungs Punkte konvertiert. Daher gibt es keinen Mechanismus zum Zurückgeben der ursprünglichen Punkte. Wenn der erste Punkt und der letzte Punkt im `points` Array nicht denselben Punkt haben, wird die Kurve geschlossen, indem diese beiden Punkte verbunden werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Array von sechs Punkten (die einen kardinalspline darstellen).  
  
-   Erstellt einen Pfad und fügt die geschlossenen kardinalsplinienkurven dem Pfad hinzu (geschlossen vom Endpunkt zum Startpunkt).  
  
-   Zeichnet den Pfad zum Bildschirm.  
  
 Beachten Sie, dass eine Spannung von 0,5 verwendet wird.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#4)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#4)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddClosedCurve">
      <MemberSignature Language="C#" Value="public void AddClosedCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddClosedCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddClosedCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddClosedCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddClosedCurve : System.Drawing.PointF[] * single -&gt; unit" Usage="graphicsPath.AddClosedCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, das die Punkte für die Definition der Kurve darstellt.</param>
        <param name="tension">Ein Wert zwischen 0 (null) und 1, der die Kurvenkrümmung zwischen den einzelnen Punkten angibt. 0  (null) stellt die kleinste Kurve (stärkste Krümmung) und 1 die am sanftesten gekrümmte Kurve dar.</param>
        <summary>Fügt diesem Pfad eine geschlossene Kurve hinzu. Es wird eine Cardinal-Splinekurve verwendet, weil die Kurve durch jeden der Punkte im Array verläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss die ursprünglichen Punkte aufbewahren, wenn Sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerungs Punkte konvertiert. Daher gibt es keinen Mechanismus zum Zurückgeben der ursprünglichen Punkte. Wenn der erste Punkt und der letzte Punkt im `points` Array nicht denselben Punkt haben, wird die Kurve geschlossen, indem diese beiden Punkte verbunden werden.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCurve">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt der aktuellen Figur eine Splinekurve hinzu. Es wird eine Cardinal-Splinekurve verwendet, weil die Kurve durch jeden der Punkte im Array verläuft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" />-Strukturen, das die Punkte für die Definition der Kurve darstellt.</param>
        <summary>Fügt der aktuellen Figur eine Splinekurve hinzu. Es wird eine Cardinal-Splinekurve verwendet, weil die Kurve durch jeden der Punkte im Array verläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss die ursprünglichen Punkte aufbewahren, wenn Sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerungs Punkte konvertiert. Daher gibt es keinen Mechanismus zum Zurückgeben der ursprünglichen Punkte.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddCurve points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, das die Punkte für die Definition der Kurve darstellt.</param>
        <summary>Fügt der aktuellen Figur eine Splinekurve hinzu. Es wird eine Cardinal-Splinekurve verwendet, weil die Kurve durch jeden der Punkte im Array verläuft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss die ursprünglichen Punkte aufbewahren, wenn Sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerungs Punkte konvertiert. Daher gibt es keinen Mechanismus zum Zurückgeben der ursprünglichen Punkte.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.Point[] * single -&gt; unit" Usage="graphicsPath.AddCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" />-Strukturen, das die Punkte für die Definition der Kurve darstellt.</param>
        <param name="tension">Ein Wert, der die Kurvenkrümmung zwischen Kontrollpunkten angibt. Werte, die größer als 1 sind, führen zu unvorhersehbaren Ergebnissen.</param>
        <summary>Fügt der aktuellen Figur eine Splinekurve hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss die ursprünglichen Punkte aufbewahren, wenn Sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerungs Punkte konvertiert. Daher gibt es keinen Mechanismus zum Zurückgeben der ursprünglichen Punkte.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddClosedCurve%28System.Drawing.Point%5B%5D%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.PointF[] * single -&gt; unit" Usage="graphicsPath.AddCurve (points, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, das die Punkte für die Definition der Kurve darstellt.</param>
        <param name="tension">Ein Wert, der die Kurvenkrümmung zwischen Kontrollpunkten angibt. Werte, die größer als 1 sind, führen zu unvorhersehbaren Ergebnissen.</param>
        <summary>Fügt der aktuellen Figur eine Splinekurve hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss die ursprünglichen Punkte aufbewahren, wenn Sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerungs Punkte konvertiert. Daher gibt es keinen Mechanismus zum Zurückgeben der ursprünglichen Punkte.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.Point[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.Point[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.Point[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As Point(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::Point&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.Point[] * int * int * single -&gt; unit" Usage="graphicsPath.AddCurve (points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" />-Strukturen, das die Punkte für die Definition der Kurve darstellt.</param>
        <param name="offset">Der Index des Elements im <paramref name="points" />-Array, das als erster Punkt der Kurve verwendet wird.</param>
        <param name="numberOfSegments">Ein Wert, der die Kurvenkrümmung zwischen Kontrollpunkten angibt. Werte, die größer als 1 sind, führen zu unvorhersehbaren Ergebnissen.</param>
        <param name="tension">Ein Wert, der die Kurvenkrümmung zwischen Kontrollpunkten angibt. Werte, die größer als 1 sind, führen zu unvorhersehbaren Ergebnissen.</param>
        <summary>Fügt der aktuellen Figur eine Splinekurve hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss die ursprünglichen Punkte aufbewahren, wenn Sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerungs Punkte konvertiert. Daher gibt es keinen Mechanismus zum Zurückgeben der ursprünglichen Punkte.  
  
 Die Kurve beginnt an dem Punkt im Array, der durch den `offset`-Parameter angegeben wird, und schließt die Anzahl der Punkte (Segmente) ein, die von `numberOfSegments`angegeben werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Array aus vier Punkten (die einen kardinalspline darstellen).  
  
-   Erstellt einen Pfad und verwendet das Array von Punkten, fügt die Kurve dem Pfad hinzu.  
  
-   Zeichnet den Pfad auf dem Bildschirm.  
  
 Beachten Sie, dass das Array vier Punkte enthält, es sind jedoch nur drei Segmente vorhanden. Dies ist die Zahl, die im dritten Argument des Aufrufes <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%2A>angegeben ist.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#5)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#5)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCurve">
      <MemberSignature Language="C#" Value="public void AddCurve (System.Drawing.PointF[] points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCurve(valuetype System.Drawing.PointF[] points, int32 offset, int32 numberOfSegments, float32 tension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddCurve(System.Drawing.PointF[],System.Int32,System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCurve (points As PointF(), offset As Integer, numberOfSegments As Integer, tension As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCurve(cli::array &lt;System::Drawing::PointF&gt; ^ points, int offset, int numberOfSegments, float tension);" />
      <MemberSignature Language="F#" Value="member this.AddCurve : System.Drawing.PointF[] * int * int * single -&gt; unit" Usage="graphicsPath.AddCurve (points, offset, numberOfSegments, tension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numberOfSegments" Type="System.Int32" />
        <Parameter Name="tension" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, das die Punkte für die Definition der Kurve darstellt.</param>
        <param name="offset">Der Index des Elements im <paramref name="points" />-Array, das als erster Punkt der Kurve verwendet wird.</param>
        <param name="numberOfSegments">Die zum Zeichnen der Kurve verwendete Anzahl von Segmenten. Ein Segment kann als Linie aufgefasst werden, die zwei Punkte verbindet.</param>
        <param name="tension">Ein Wert, der die Kurvenkrümmung zwischen Kontrollpunkten angibt. Werte, die größer als 1 sind, führen zu unvorhersehbaren Ergebnissen.</param>
        <summary>Fügt der aktuellen Figur eine Splinekurve hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss die ursprünglichen Punkte aufbewahren, wenn Sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerungs Punkte konvertiert. Daher gibt es keinen Mechanismus zum Zurückgeben der ursprünglichen Punkte.  
  
 Die Kurve beginnt an dem Punkt im Array, der durch `offset`angegeben wird, und schließt die Anzahl der Punkte (Segmente) ein, die von `numberOfSegments`angegeben werden.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddCurve%28System.Drawing.Point%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddEllipse">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt dem aktuellen Pfad eine Ellipse hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : System.Drawing.Rectangle -&gt; unit" Usage="graphicsPath.AddEllipse rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.Rectangle" />, das das die Ellipse definierende umschließende Rechteck darstellt.</param>
        <summary>Fügt dem aktuellen Pfad eine Ellipse hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
 Erstellt ein umgebenden Rechteck, das eine Ellipse definiert.  
  
 Erstellt einen Pfad und fügt die Ellipse dem Pfad hinzu.  
  
 Zeichnet den Pfad zum Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#6)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : System.Drawing.RectangleF -&gt; unit" Usage="graphicsPath.AddEllipse rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.RectangleF" />, das das die Ellipse definierende umschließende Rechteck darstellt.</param>
        <summary>Fügt dem aktuellen Pfad eine Ellipse hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : int * int * int * int -&gt; unit" Usage="graphicsPath.AddEllipse (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Die Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Die Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Fügt dem aktuellen Pfad eine Ellipse hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEllipse">
      <MemberSignature Language="C#" Value="public void AddEllipse (float x, float y, float width, float height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEllipse(float32 x, float32 y, float32 width, float32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddEllipse(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEllipse (x As Single, y As Single, width As Single, height As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEllipse(float x, float y, float width, float height);" />
      <MemberSignature Language="F#" Value="member this.AddEllipse : single * single * single * single -&gt; unit" Usage="graphicsPath.AddEllipse (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="width">Die Breite des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <param name="height">Die Höhe des umschließenden Rechtecks, das die Ellipse definiert.</param>
        <summary>Fügt dem aktuellen Pfad eine Ellipse hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddEllipse%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLine">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt ein Liniensegment an diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.Point pt1, System.Drawing.Point pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.Point pt1, valuetype System.Drawing.Point pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.Point,System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As Point, pt2 As Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::Point pt1, System::Drawing::Point pt2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : System.Drawing.Point * System.Drawing.Point -&gt; unit" Usage="graphicsPath.AddLine (pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.Point" />
        <Parameter Name="pt2" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt1">Ein den Anfangspunkt der Linie darstellender <see cref="T:System.Drawing.Point" />.</param>
        <param name="pt2">Ein den Endpunkt der Linie darstellender <see cref="T:System.Drawing.Point" />.</param>
        <summary>Fügt ein Liniensegment an diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt das von den angegebenen Punkten definierte Liniensegment am Ende dieses <xref:System.Drawing.Drawing2D.GraphicsPath>hinzu. Wenn im <xref:System.Drawing.Drawing2D.GraphicsPath>vorherige Linien oder Kurven vorhanden sind, wird ein Liniensegment gezeichnet, um den letzten Punkt im Pfad mit dem ersten Punkt im neuen Zeilen Segment zu verbinden.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (System.Drawing.PointF pt1, System.Drawing.PointF pt2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(valuetype System.Drawing.PointF pt1, valuetype System.Drawing.PointF pt2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Drawing.PointF,System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (pt1 As PointF, pt2 As PointF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(System::Drawing::PointF pt1, System::Drawing::PointF pt2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : System.Drawing.PointF * System.Drawing.PointF -&gt; unit" Usage="graphicsPath.AddLine (pt1, pt2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt1" Type="System.Drawing.PointF" />
        <Parameter Name="pt2" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="pt1">Ein den Anfangspunkt der Linie darstellender <see cref="T:System.Drawing.PointF" />.</param>
        <param name="pt2">Ein den Endpunkt der Linie darstellender <see cref="T:System.Drawing.PointF" />.</param>
        <summary>Fügt ein Liniensegment an diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt das von den angegebenen Punkten definierte Liniensegment am Ende dieses <xref:System.Drawing.Drawing2D.GraphicsPath>hinzu. Wenn im <xref:System.Drawing.Drawing2D.GraphicsPath>vorherige Linien oder Kurven vorhanden sind, wird ein Liniensegment gezeichnet, um den letzten Punkt im Pfad mit dem ersten Punkt im neuen Zeilen Segment zu verbinden.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(int32 x1, int32 y1, int32 x2, int32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(int x1, int y1, int x2, int y2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : int * int * int * int -&gt; unit" Usage="graphicsPath.AddLine (x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Int32" />
        <Parameter Name="y1" Type="System.Int32" />
        <Parameter Name="x2" Type="System.Int32" />
        <Parameter Name="y2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x1">Die x-Koordinate des Anfangspunkts der Linie.</param>
        <param name="y1">Die y-Koordinate des Anfangspunkts der Linie.</param>
        <param name="x2">Die x-Koordinate des Endpunkts der Linie.</param>
        <param name="y2">Die y-Koordinate des Endpunkts der Linie.</param>
        <summary>Fügt ein Liniensegment an die aktuelle Figur an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt das Liniensegment, das durch die angegebenen Punkte definiert ist, am Ende der aktuellen Abbildung hinzu. Wenn im <xref:System.Drawing.Drawing2D.GraphicsPath>vorherige Linien oder Kurven vorhanden sind, wird ein Liniensegment gezeichnet, um den letzten Punkt im Pfad mit dem ersten Punkt im neuen Zeilen Segment zu verbinden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code erstellt einen Pfad, fügt drei Zeilen hinzu, die ein Dreieck bilden, und zeichnet dann den Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#7)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#7)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLine">
      <MemberSignature Language="C#" Value="public void AddLine (float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLine(float32 x1, float32 y1, float32 x2, float32 y2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLine(System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLine (x1 As Single, y1 As Single, x2 As Single, y2 As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLine(float x1, float y1, float x2, float y2);" />
      <MemberSignature Language="F#" Value="member this.AddLine : single * single * single * single -&gt; unit" Usage="graphicsPath.AddLine (x1, y1, x2, y2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x1" Type="System.Single" />
        <Parameter Name="y1" Type="System.Single" />
        <Parameter Name="x2" Type="System.Single" />
        <Parameter Name="y2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x1">Die x-Koordinate des Anfangspunkts der Linie.</param>
        <param name="y1">Die y-Koordinate des Anfangspunkts der Linie.</param>
        <param name="x2">Die x-Koordinate des Endpunkts der Linie.</param>
        <param name="y2">Die y-Koordinate des Endpunkts der Linie.</param>
        <summary>Fügt ein Liniensegment an diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode fügt das von den angegebenen Punkten definierte Liniensegment am Ende dieses <xref:System.Drawing.Drawing2D.GraphicsPath>hinzu. Wenn im <xref:System.Drawing.Drawing2D.GraphicsPath>vorherige Linien oder Kurven vorhanden sind, wird ein Liniensegment gezeichnet, um den letzten Punkt im Pfad mit dem ersten Punkt im neuen Zeilen Segment zu verbinden.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddLine%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddLines">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt eine Abfolge verbundener Liniensegmente an das Ende dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddLines : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddLines points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" />-Strukturen, das die Punkte für die Definition der hinzuzufügenden Liniensegmente darstellt.</param>
        <summary>Fügt eine Abfolge verbundener Liniensegmente an das Ende dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn in der Abbildung vorherige Zeilen oder Kurven vorhanden sind, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments als Ausgangspunkt der Linie zu verbinden. Der `points`-Parameter gibt ein Array von Endpunkten an. In den ersten beiden Zeilen wird die erste Zeile angegeben. Jeder zusätzliche Punkt gibt den Endpunkt eines Linien Segments an, dessen Anfangspunkt der Endpunkt der vorherigen Zeile ist.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Array aus vier Punkten, die ein Dreieck beschreiben.  
  
-   Erstellt einen Pfad und fügt das Array von Zeilen hinzu.  
  
-   Zeichnet den Pfad zum Bildschirm.  
  
 Beachten Sie, dass jede Zeile nach dem ersten Punkt den vorherigen Punkt als Ausgangspunkt und den neuen Punkt als Endpunkt verwendet.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#8)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#8)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLines">
      <MemberSignature Language="C#" Value="public void AddLines (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddLines(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddLines(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddLines (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddLines(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddLines : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddLines points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, das die Punkte für die Definition der hinzuzufügenden Liniensegmente darstellt.</param>
        <summary>Fügt eine Abfolge verbundener Liniensegmente an das Ende dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn in der Abbildung vorherige Zeilen oder Kurven vorhanden sind, wird eine Zeile hinzugefügt, um den Endpunkt des vorherigen Segments als Ausgangspunkt der Linie zu verbinden. Der `points`-Parameter gibt ein Array von Endpunkten an. In den ersten beiden Zeilen wird die erste Zeile angegeben. Jeder zusätzliche Punkt gibt den Endpunkt eines Linien Segments an, dessen Anfangspunkt der Endpunkt der vorherigen Zeile ist.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddLines%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPath">
      <MemberSignature Language="C#" Value="public void AddPath (System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPath(class System.Drawing.Drawing2D.GraphicsPath addingPath, bool connect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPath(System.Drawing.Drawing2D.GraphicsPath,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPath (addingPath As GraphicsPath, connect As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPath(System::Drawing::Drawing2D::GraphicsPath ^ addingPath, bool connect);" />
      <MemberSignature Language="F#" Value="member this.AddPath : System.Drawing.Drawing2D.GraphicsPath * bool -&gt; unit" Usage="graphicsPath.AddPath (addingPath, connect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addingPath" Type="System.Drawing.Drawing2D.GraphicsPath" />
        <Parameter Name="connect" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="addingPath">Das hinzuzufügende <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</param>
        <param name="connect">Ein boolescher Wert, der angibt, ob die erste Figur im hinzugefügten Pfad Teil der letzten Figur in diesem Pfad ist. Der Wert <see langword="true" /> gibt an, dass die erste Figur im hinzugefügten Pfad Teil der letzten Figur in diesem Pfad ist, sofern möglich. Der Wert <see langword="false" /> gibt an, dass die erste Figur im hinzugefügten Pfad von der letzten Figur in diesem Pfad getrennt ist.</param>
        <summary>Fügt den angegebenen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> an diesen Pfad an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt zwei Pfade mit einem rechtsseitigen Dreieck und einem auf der anderen Seite basierenden Dreieck.  
  
-   Fügt dem ersten den zweiten Pfad hinzu.  
  
-   Zeichnet den resultierenden Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#9)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#9)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPie">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt diesem Pfad den Umriss einer Kreisform hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (System.Drawing.Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(valuetype System.Drawing.Rectangle rect, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Drawing.Rectangle,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (rect As Rectangle, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(System::Drawing::Rectangle rect, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddPie : System.Drawing.Rectangle * single * single -&gt; unit" Usage="graphicsPath.AddPie (rect, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.Rectangle" />, das das umschließende Rechteck darstellt, das die Ellipse definiert, aus der der Kreis gezeichnet wird.</param>
        <param name="startAngle">Der Startwinkel des Kreisausschnitts in Grad, von der x-Achse aus im Uhrzeigersinn gemessen.</param>
        <param name="sweepAngle">Der Winkel in Grad zwischen <paramref name="startAngle" /> und dem Ende des Kreisausschnitts, ausgehend von <paramref name="startAngle" /> im Uhrzeigersinn gemessen.</param>
        <summary>Fügt diesem Pfad den Umriss einer Kreisform hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kreis Form wird durch eine partielle Gliederung einer Ellipse und die beiden radialen Linien definiert, die die Endpunkte der partiellen Gliederung überschneiden. Die partielle Kontur beginnt bei `startAngle` (im Uhrzeigersinn von der x-Achse gemessen) und endet bei `startAngle` + `sweepAngle`.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(int32 x, int32 y, int32 width, int32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Integer, y As Integer, width As Integer, height As Integer, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddPie : int * int * int * int * single * single -&gt; unit" Usage="graphicsPath.AddPie (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreis gezeichnet wird.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreis gezeichnet wird.</param>
        <param name="width">Die Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreis gezeichnet wird.</param>
        <param name="height">Die Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreis gezeichnet wird.</param>
        <param name="startAngle">Der Startwinkel des Kreisausschnitts in Grad, von der x-Achse aus im Uhrzeigersinn gemessen.</param>
        <param name="sweepAngle">Der Winkel in Grad zwischen <paramref name="startAngle" /> und dem Ende des Kreisausschnitts, ausgehend von <paramref name="startAngle" /> im Uhrzeigersinn gemessen.</param>
        <summary>Fügt diesem Pfad den Umriss einer Kreisform hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kreis Form wird durch eine partielle Gliederung einer Ellipse und die beiden radialen Linien definiert, die die Endpunkte der partiellen Gliederung überschneiden. Die partielle Kontur beginnt bei `startAngle` (im Uhrzeigersinn von der x-Achse gemessen) und endet bei `startAngle` + `sweepAngle`.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code erstellt einen Grafik Pfad, fügt die Kreisform hinzu und zeichnet dann den Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#10)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#10)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPie">
      <MemberSignature Language="C#" Value="public void AddPie (float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPie(float32 x, float32 y, float32 width, float32 height, float32 startAngle, float32 sweepAngle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPie(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPie (x As Single, y As Single, width As Single, height As Single, startAngle As Single, sweepAngle As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle);" />
      <MemberSignature Language="F#" Value="member this.AddPie : single * single * single * single * single * single -&gt; unit" Usage="graphicsPath.AddPie (x, y, width, height, startAngle, sweepAngle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="width" Type="System.Single" />
        <Parameter Name="height" Type="System.Single" />
        <Parameter Name="startAngle" Type="System.Single" />
        <Parameter Name="sweepAngle" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreis gezeichnet wird.</param>
        <param name="y">Die y-Koordinate der oberen linken Ecke des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreis gezeichnet wird.</param>
        <param name="width">Die Breite des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreis gezeichnet wird.</param>
        <param name="height">Die Höhe des umschließenden Rechtecks, das die Ellipse definiert, aus der der Kreis gezeichnet wird.</param>
        <param name="startAngle">Der Startwinkel des Kreisausschnitts in Grad, von der x-Achse aus im Uhrzeigersinn gemessen.</param>
        <param name="sweepAngle">Der Winkel in Grad zwischen <paramref name="startAngle" /> und dem Ende des Kreisausschnitts, ausgehend von <paramref name="startAngle" /> im Uhrzeigersinn gemessen.</param>
        <summary>Fügt diesem Pfad den Umriss einer Kreisform hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Kreis Form wird durch eine partielle Gliederung einer Ellipse und die beiden radialen Linien definiert, die die Endpunkte der partiellen Gliederung überschneiden. Die partielle Kontur beginnt bei `startAngle` (im Uhrzeigersinn von der x-Achse gemessen) und endet bei `startAngle` + `sweepAngle`.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddPie%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Single%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddPolygon">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt diesem Pfad ein Vieleck hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As Point())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddPolygon : System.Drawing.Point[] -&gt; unit" Usage="graphicsPath.AddPolygon points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.Point[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.Point" />-Strukturen, das das hinzuzufügende Vieleck definiert.</param>
        <summary>Fügt diesem Pfad ein Vieleck hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Punkte im `points` Arrays geben die Scheitel Punkte eines Polygons an. Wenn der erste Punkt im Array nicht mit dem letzten Punkt identisch ist, werden diese beiden Punkte verbunden, um das Polygon zu schließen.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt ein Array von Punkten, das ein Polygon definiert.  
  
-   Erstellt einen Pfad und fügt das Polygon dem Pfad hinzu.  
  
-   Zeichnet den Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#11)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#11)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPolygon">
      <MemberSignature Language="C#" Value="public void AddPolygon (System.Drawing.PointF[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPolygon(valuetype System.Drawing.PointF[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddPolygon(System.Drawing.PointF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPolygon (points As PointF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPolygon(cli::array &lt;System::Drawing::PointF&gt; ^ points);" />
      <MemberSignature Language="F#" Value="member this.AddPolygon : System.Drawing.PointF[] -&gt; unit" Usage="graphicsPath.AddPolygon points" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="points" Type="System.Drawing.PointF[]" />
      </Parameters>
      <Docs>
        <param name="points">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, das das hinzuzufügende Vieleck definiert.</param>
        <summary>Fügt diesem Pfad ein Vieleck hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Punkte im `points` Arrays geben die Scheitel Punkte eines Polygons an. Wenn der erste Punkt im Array nicht mit dem letzten Punkt identisch ist, werden diese beiden Punkte verbunden, um das Polygon zu schließen.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddPolygon%28System.Drawing.Point%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangle">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt diesem Pfad ein Rechteck hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.Rectangle rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.Rectangle rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::Rectangle rect);" />
      <MemberSignature Language="F#" Value="member this.AddRectangle : System.Drawing.Rectangle -&gt; unit" Usage="graphicsPath.AddRectangle rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.Rectangle" />, das das hinzuzufügende Rechteck darstellt.</param>
        <summary>Fügt diesem Pfad ein Rechteck hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad.  
  
-   Erstellt ein Rechteck und fügt das Rechteck dem Pfad hinzu.  
  
-   Zeichnet den Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#12)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#12)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangle">
      <MemberSignature Language="C#" Value="public void AddRectangle (System.Drawing.RectangleF rect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangle(valuetype System.Drawing.RectangleF rect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangle(System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangle (rect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangle(System::Drawing::RectangleF rect);" />
      <MemberSignature Language="F#" Value="member this.AddRectangle : System.Drawing.RectangleF -&gt; unit" Usage="graphicsPath.AddRectangle rect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="rect">Ein <see cref="T:System.Drawing.RectangleF" />, das das hinzuzufügende Rechteck darstellt.</param>
        <summary>Fügt diesem Pfad ein Rechteck hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangle%28System.Drawing.Rectangle%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRectangles">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt diesem Pfad ein Reihe von Rechtecken hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.Rectangle[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.Rectangle[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.Rectangle[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As Rectangle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::Rectangle&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.AddRectangles : System.Drawing.Rectangle[] -&gt; unit" Usage="graphicsPath.AddRectangles rects" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.Rectangle[]" />
      </Parameters>
      <Docs>
        <param name="rects">Ein Array von <see cref="T:System.Drawing.Rectangle" />-Strukturen, das die hinzuzufügenden Rechtecke darstellt.</param>
        <summary>Fügt diesem Pfad ein Reihe von Rechtecken hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad.  
  
-   Erstellt ein Array von Rechtecke und fügt dem Pfad die Rechtecke hinzu.  
  
-   Zeichnet den Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#13)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#13)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRectangles">
      <MemberSignature Language="C#" Value="public void AddRectangles (System.Drawing.RectangleF[] rects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRectangles(valuetype System.Drawing.RectangleF[] rects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddRectangles(System.Drawing.RectangleF[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRectangles (rects As RectangleF())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRectangles(cli::array &lt;System::Drawing::RectangleF&gt; ^ rects);" />
      <MemberSignature Language="F#" Value="member this.AddRectangles : System.Drawing.RectangleF[] -&gt; unit" Usage="graphicsPath.AddRectangles rects" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rects" Type="System.Drawing.RectangleF[]" />
      </Parameters>
      <Docs>
        <param name="rects">Ein Array von <see cref="T:System.Drawing.RectangleF" />-Strukturen, das die hinzuzufügenden Rechtecke darstellt.</param>
        <summary>Fügt diesem Pfad ein Reihe von Rechtecken hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddRectangles%28System.Drawing.Rectangle%5B%5D%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddString">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt diesem Pfad eine Textzeichenfolge hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Point origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Point origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Point,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As Point, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Point origin, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.Point * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, origin, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.Point" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Das hinzuzufügende <see cref="T:System.String" />.</param>
        <param name="family">Eine <see cref="T:System.Drawing.FontFamily" />, die den Namen der Schriftart darstellt, in der der Test gezeichnet wird.</param>
        <param name="style">Eine <see cref="T:System.Drawing.FontStyle" />-Enumeration, die Textformatierungsinformationen (fett, kursiv usw.) darstellt. Diese muss in eine ganze Zahl umgewandelt werden (siehe den Beispielcode weiter unten in diesem Abschnitt).</param>
        <param name="emSize">Die Höhe des Geviertkästchens, das das Zeichen umschließt.</param>
        <param name="origin">Ein den Anfangspunkt des Texts darstellender <see cref="T:System.Drawing.Point" />.</param>
        <param name="format">Ein <see cref="T:System.Drawing.StringFormat" />, das Textformatierungsinformationen angibt, z. B. Zeilenabstand und Ausrichtung.</param>
        <summary>Fügt diesem Pfad eine Textzeichenfolge hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad.  
  
-   Richtet Zeichen folgen-und Schriftart Argumente ein.  
  
-   Fügt die Zeichenfolge dem Pfad hinzu.  
  
-   Zeichnet die Zeichenfolge auf dem Bildschirm.  
  
 Es gibt zwei wichtige Punkte, auf die verwiesen werden muss. Beachten Sie zunächst, dass das `fontStyle`-Argument in eine ganze Zahl umgewandelt wird. Die <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%2A>-Methode erfordert dies, damit zwei oder mehr <xref:System.Drawing.FontStyle> Member kombiniert werden können, um den gewünschten Schriftart Stil zu erstellen (in diesem Fall <xref:System.Drawing.FontStyle.Italic> und <xref:System.Drawing.FontStyle.Underline>). Beachten Sie, dass die <xref:System.Drawing.Graphics.FillPath%2A>-Methode anstelle der <xref:System.Drawing.Graphics.DrawPath%2A>-Methode verwendet wird. Wenn <xref:System.Drawing.Graphics.FillPath%2A> verwendet wird, wird der voll Text gerendert. wenn <xref:System.Drawing.Graphics.DrawPath%2A> verwendet wird, ist der Text ein Gliederungs Stil.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#14)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#14)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.PointF origin, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.PointF origin, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.PointF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, origin As PointF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::PointF origin, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.PointF * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, origin, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="origin" Type="System.Drawing.PointF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Das hinzuzufügende <see cref="T:System.String" />.</param>
        <param name="family">Eine <see cref="T:System.Drawing.FontFamily" />, die den Namen der Schriftart darstellt, in der der Test gezeichnet wird.</param>
        <param name="style">Eine <see cref="T:System.Drawing.FontStyle" />-Enumeration, die Textformatierungsinformationen (fett, kursiv usw.) darstellt. Diese muss in eine ganze Zahl umgewandelt werden (siehe den Beispielcode weiter unten in diesem Abschnitt).</param>
        <param name="emSize">Die Höhe des Geviertkästchens, das das Zeichen umschließt.</param>
        <param name="origin">Ein den Anfangspunkt des Texts darstellender <see cref="T:System.Drawing.PointF" />.</param>
        <param name="format">Ein <see cref="T:System.Drawing.StringFormat" />, das Textformatierungsinformationen angibt, z. B. Zeilenabstand und Ausrichtung.</param>
        <summary>Fügt diesem Pfad eine Textzeichenfolge hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.Rectangle layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.Rectangle layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.Rectangle,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As Rectangle, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::Rectangle layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.Rectangle * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, layoutRect, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.Rectangle" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Das hinzuzufügende <see cref="T:System.String" />.</param>
        <param name="family">Eine <see cref="T:System.Drawing.FontFamily" />, die den Namen der Schriftart darstellt, in der der Test gezeichnet wird.</param>
        <param name="style">Eine <see cref="T:System.Drawing.FontStyle" />-Enumeration, die Textformatierungsinformationen (fett, kursiv usw.) darstellt. Diese muss in eine ganze Zahl umgewandelt werden (siehe den Beispielcode weiter unten in diesem Abschnitt).</param>
        <param name="emSize">Die Höhe des Geviertkästchens, das das Zeichen umschließt.</param>
        <param name="layoutRect">Ein <see cref="T:System.Drawing.Rectangle" />, das das den Text umschließende Rechteck darstellt.</param>
        <param name="format">Ein <see cref="T:System.Drawing.StringFormat" />, das Textformatierungsinformationen angibt, z. B. Zeilenabstand und Ausrichtung.</param>
        <summary>Fügt diesem Pfad eine Textzeichenfolge hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddString">
      <MemberSignature Language="C#" Value="public void AddString (string s, System.Drawing.FontFamily family, int style, float emSize, System.Drawing.RectangleF layoutRect, System.Drawing.StringFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddString(string s, class System.Drawing.FontFamily family, int32 style, float32 emSize, valuetype System.Drawing.RectangleF layoutRect, class System.Drawing.StringFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.AddString(System.String,System.Drawing.FontFamily,System.Int32,System.Single,System.Drawing.RectangleF,System.Drawing.StringFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddString (s As String, family As FontFamily, style As Integer, emSize As Single, layoutRect As RectangleF, format As StringFormat)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddString(System::String ^ s, System::Drawing::FontFamily ^ family, int style, float emSize, System::Drawing::RectangleF layoutRect, System::Drawing::StringFormat ^ format);" />
      <MemberSignature Language="F#" Value="member this.AddString : string * System.Drawing.FontFamily * int * single * System.Drawing.RectangleF * System.Drawing.StringFormat -&gt; unit" Usage="graphicsPath.AddString (s, family, style, emSize, layoutRect, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="family" Type="System.Drawing.FontFamily" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="emSize" Type="System.Single" />
        <Parameter Name="layoutRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="format" Type="System.Drawing.StringFormat" />
      </Parameters>
      <Docs>
        <param name="s">Das hinzuzufügende <see cref="T:System.String" />.</param>
        <param name="family">Eine <see cref="T:System.Drawing.FontFamily" />, die den Namen der Schriftart darstellt, in der der Test gezeichnet wird.</param>
        <param name="style">Eine <see cref="T:System.Drawing.FontStyle" />-Enumeration, die Textformatierungsinformationen (fett, kursiv usw.) darstellt. Diese muss in eine ganze Zahl umgewandelt werden (siehe den Beispielcode weiter unten in diesem Abschnitt).</param>
        <param name="emSize">Die Höhe des Geviertkästchens, das das Zeichen umschließt.</param>
        <param name="layoutRect">Ein <see cref="T:System.Drawing.RectangleF" />, das das den Text umschließende Rechteck darstellt.</param>
        <param name="format">Ein <see cref="T:System.Drawing.StringFormat" />, das Textformatierungsinformationen angibt, z. B. Zeilenabstand und Ausrichtung.</param>
        <summary>Fügt diesem Pfad eine Textzeichenfolge hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.AddString%28System.String%2CSystem.Drawing.FontFamily%2CSystem.Int32%2CSystem.Single%2CSystem.Drawing.Point%2CSystem.Drawing.StringFormat%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearMarkers">
      <MemberSignature Language="C#" Value="public void ClearMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.ClearMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearMarkers();" />
      <MemberSignature Language="F#" Value="member this.ClearMarkers : unit -&gt; unit" Usage="graphicsPath.ClearMarkers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Marker aus diesem Pfad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Drawing.Drawing2D.GraphicsPath.SetMarkers%2A>-Methode, um einen Marker an der aktuellen Position in einer <xref:System.Drawing.Drawing2D.GraphicsPath>zu erstellen. Verwenden Sie die <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A>-Methode, um die vorhandenen Marker in einem Pfad zu durchlaufen.  
  
 Marker werden zum Trennen von Gruppen von unter Pfaden verwendet. Zwischen zwei Markern kann mindestens ein unter Pfad enthalten sein.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad.  
  
-   Fügt dem Pfad mehrere-Objekte hinzu.  
  
-   Fügt dem Pfad Marker hinzu.  
  
-   Löscht alle Marker aus dem Pfad.  
  
-   Zeichnet den Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#15)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#15)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="graphicsPath.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine genaue Kopie von diesem Pfad.</summary>
        <returns>Das von dieser Methode erstellte <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />, umgewandelt in ein Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad.  
  
-   Fügt dem Pfad mehrere Abbildungen hinzu.  
  
-   Zeichnet den Pfad auf dem Bildschirm.  
  
-   Klont eine Kopie dieses Pfads.  
  
-   Zeichnet den neuen Pfad auf dem Bildschirm.  
  
 Beachten Sie, dass der Rückruf der <xref:System.Drawing.Drawing2D.GraphicsPath.Clone%2A>-Methode als <xref:System.Drawing.Drawing2D.GraphicsPath>umgewandelt werden muss.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#16)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#16)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseAllFigures">
      <MemberSignature Language="C#" Value="public void CloseAllFigures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseAllFigures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseAllFigures" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseAllFigures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseAllFigures();" />
      <MemberSignature Language="F#" Value="member this.CloseAllFigures : unit -&gt; unit" Usage="graphicsPath.CloseAllFigures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt alle geöffneten Figuren in diesem Pfad und beginnt eine neue Figur. Jede geöffnete Figur wird geschlossen, indem ihr End- und Anfangspunkt durch eine Linie verbunden werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad.  
  
-   Fügt dem Pfad mehrere offene Abbildungen hinzu.  
  
-   Schließt alle Abbildungen im Pfad.  
  
-   Zeichnet den Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#17)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#17)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseFigure">
      <MemberSignature Language="C#" Value="public void CloseFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.CloseFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub CloseFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseFigure();" />
      <MemberSignature Language="F#" Value="member this.CloseFigure : unit -&gt; unit" Usage="graphicsPath.CloseFigure " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die aktuelle Figur und beginnt eine neue. Wenn die aktuelle Figur eine Abfolge verbundener Linien und Kurven enthält, schließt die Methode die Schleife, indem End- und Anfangspunkt durch eine Linie verbunden werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code erstellt ein Dreieck, indem er einen neuen Pfad erstellt, eine Abbildung startet, der Abbildung zwei verschachtelte Linien hinzufügt und dann die Figur zum bilden eines Dreiecks schließt. Der Pfad wird dann auf dem Bildschirm gezeichnet.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#18)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#18)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="graphicsPath.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Aufrufen von <xref:System.Drawing.Drawing2D.GraphicsPath.Dispose%2A> können die von diesem <xref:System.Drawing.Drawing2D.GraphicsPath> verwendeten Ressourcen für andere Zwecke neu zugeordnet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FillMode">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.FillMode FillMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Drawing2D.FillMode FillMode" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.FillMode" />
      <MemberSignature Language="VB.NET" Value="Public Property FillMode As FillMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::FillMode FillMode { System::Drawing::Drawing2D::FillMode get(); void set(System::Drawing::Drawing2D::FillMode value); };" />
      <MemberSignature Language="F#" Value="member this.FillMode : System.Drawing.Drawing2D.FillMode with get, set" Usage="System.Drawing.Drawing2D.GraphicsPath.FillMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.FillMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration ab, die bestimmt, wie das Innere der Formen in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> gefüllt wird, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Drawing.Drawing2D.FillMode" />-Enumeration, die angibt, wie das Innere der Formen in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> gefüllt wird.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~GraphicsPath ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!GraphicsPath ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="graphicsPath.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einem Objekt Gelegenheit zu dem Versuch, Ressourcen freizugeben und andere Bereinigungen durchzuführen, bevor es von der Garbage Collection freigegeben wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flatten">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert jede Kurve in diesem Pfad in eine Abfolge verbundener Liniensegmente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flatten ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten();" />
      <MemberSignature Language="F#" Value="member this.Flatten : unit -&gt; unit" Usage="graphicsPath.Flatten " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert jede Kurve in diesem Pfad in eine Abfolge verbundener Liniensegmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Flatten : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Flatten matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">Eine <see cref="T:System.Drawing.Drawing2D.Matrix" />, mit der dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> vor dem Abflachen transformiert wird.</param>
        <summary>Wendet die angegebene Transformation an und konvertiert dann jede Kurve in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> in eine Abfolge verbundener Liniensegmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Flatten%28System.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flatten">
      <MemberSignature Language="C#" Value="public void Flatten (System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flatten(class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Flatten(System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flatten(System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberSignature Language="F#" Value="member this.Flatten : System.Drawing.Drawing2D.Matrix * single -&gt; unit" Usage="graphicsPath.Flatten (matrix, flatness)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="matrix">Eine <see cref="T:System.Drawing.Drawing2D.Matrix" />, mit der dieser <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> vor dem Abflachen transformiert wird.</param>
        <param name="flatness">Gibt die höchstzulässige Abweichung zwischen der Kurve und ihrer abgeflachten Näherungskurve an. Der Standardwert ist 0,25. Wenn der Abflachungswert verringert wird, erhöht sich die Anzahl der Liniensegmente in der Näherungskurve.</param>
        <summary>Konvertiert jede Kurve in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> in eine Abfolge verbundener Liniensegmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Grafik Pfad und eine Übersetzungs Matrix.  
  
-   Fügt dem Pfad eine Kurve mit vier Punkten hinzu.  
  
-   Zeichnet den Pfad (Kurve) mithilfe eines schwarzen Stifts auf dem Bildschirm.  
  
-   Verschiebt die Kurve um 10 Pixel nach unten und vereinfacht Sie.  
  
-   Zeichnet die Kurve mithilfe eines roten Stifts auf dem Bildschirm.  
  
 Beachten Sie, dass die rote Kurve vereinfachte Linien zum Verbinden der Punkte aufweist.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#19)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#19)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#19](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein Rechteck zurück, das diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> umschließt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBounds () As RectangleF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds();" />
      <MemberSignature Language="F#" Value="member this.GetBounds : unit -&gt; System.Drawing.RectangleF" Usage="graphicsPath.GetBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Rechteck zurück, das diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> umschließt.</summary>
        <returns>Ein <see cref="T:System.Drawing.RectangleF" />, das ein diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> umschließendes Rechteck darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Größe des zurückgegebenen umschließenden Rechtecks wird durch den Typ der endtrennzeichen, die Stift Breite und die Anzahl der Stift Trennzeichen beeinflusst und somit eine "lose Anpassung" in den begrenzten Pfad erzeugt. Die ungefähre Formel ist: das anfängliche umgebende Rechteck wird durch die Stift Breite aufgebläht, und dieses Ergebnis wird mit dem Trennzeichen multipliziert, zuzüglich eines zusätzlichen Rahmens, um ENDCAPS zuzulassen.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Grafik Pfad.  
  
-   Fügt eine Ellipse (Kreis) hinzu und zeichnet Sie auf dem Bildschirm.  
  
-   Ruft das umschließende Rechteck für den Kreis mit einem aufgerufenen <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds%2A> ab und zeichnet das Rechteck auf den Bildschirm.  
  
-   Erstellt einen zweiten Grafik Pfad.  
  
-   Fügt einen Kreis hinzu und erweitert den Pfad zu einer Breite von 10.  
  
-   Zeichnet den Pfad auf dem Bildschirm.  
  
-   Ruft das umschließende Rechteck für den zweiten Kreis ab.  
  
-   Zeichnet das umgebende Rechteck auf dem Bildschirm.  
  
-   Zeigt die Rechteck Größe in einem Dialogfeld an.  
  
 Beachten Sie, dass das umschließende Rechteck auf der rechten Seite größer ist (um die zusätzliche Breite der Linie zu berücksichtigen).  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#20)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#20)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#20](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.GetBounds : System.Drawing.Drawing2D.Matrix -&gt; System.Drawing.RectangleF" Usage="graphicsPath.GetBounds matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">Die <see cref="T:System.Drawing.Drawing2D.Matrix" />, die eine Transformation angibt, die vor dem Berechnen des Rechtecks auf diesen Pfad angewendet werden soll. Dieser Pfad wird nur vorübergehend transformiert. Die Transformation wird lediglich während der Berechnung des umschließenden Rechtecks verwendet.</param>
        <summary>Gibt ein Rechteck zurück, das diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> umschließt, wenn dieser Pfad durch die angegebene <see cref="T:System.Drawing.Drawing2D.Matrix" /> transformiert wird.</summary>
        <returns>Ein <see cref="T:System.Drawing.RectangleF" />, das ein diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> umschließendes Rechteck darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Größe des zurückgegebenen umschließenden Rechtecks wird durch den Typ der endtrennzeichen, die Stift Breite und die Anzahl der Stift Trennzeichen beeinflusst und somit eine "lose Anpassung" in den begrenzten Pfad erzeugt. Die ungefähre Formel ist: das anfängliche umgebende Rechteck wird durch die Stift Breite aufgebläht, und dieses Ergebnis wird mit dem Trennzeichen multipliziert, zuzüglich eines zusätzlichen Rahmens, um ENDCAPS zuzulassen.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.RectangleF GetBounds (System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.RectangleF GetBounds(class System.Drawing.Drawing2D.Matrix matrix, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetBounds(System.Drawing.Drawing2D.Matrix,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::RectangleF GetBounds(System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.GetBounds : System.Drawing.Drawing2D.Matrix * System.Drawing.Pen -&gt; System.Drawing.RectangleF" Usage="graphicsPath.GetBounds (matrix, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.RectangleF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="matrix">Die <see cref="T:System.Drawing.Drawing2D.Matrix" />, die eine Transformation angibt, die vor dem Berechnen des Rechtecks auf diesen Pfad angewendet werden soll. Dieser Pfad wird nur vorübergehend transformiert. Die Transformation wird lediglich während der Berechnung des umschließenden Rechtecks verwendet.</param>
        <param name="pen">Der <see cref="T:System.Drawing.Pen" />, mit dem der <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> gezeichnet werden soll.</param>
        <summary>Gibt ein Rechteck zurück, das diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> umschließt, wenn der aktuelle Pfad durch die angegebene <see cref="T:System.Drawing.Drawing2D.Matrix" /> transformiert und mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wird.</summary>
        <returns>Ein <see cref="T:System.Drawing.RectangleF" />, das ein diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> umschließendes Rechteck darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Größe des zurückgegebenen umschließenden Rechtecks wird durch den Typ der endtrennzeichen, die Stift Breite und die Anzahl der Stift Trennzeichen beeinflusst und somit eine "lose Anpassung" in den begrenzten Pfad erzeugt. Die ungefähre Formel ist: das anfängliche umgebende Rechteck wird durch die Stift Breite aufgebläht, und dieses Ergebnis wird mit dem Trennzeichen multipliziert, zuzüglich eines zusätzlichen Rahmens, um ENDCAPS zuzulassen.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.GetBounds>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastPoint">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF GetLastPoint ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.PointF GetLastPoint() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.GetLastPoint" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastPoint () As PointF" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::PointF GetLastPoint();" />
      <MemberSignature Language="F#" Value="member this.GetLastPoint : unit -&gt; System.Drawing.PointF" Usage="graphicsPath.GetLastPoint " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den letzten Punkt im <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />-Array dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> ab.</summary>
        <returns>Eine <see cref="T:System.Drawing.PointF" />-Struktur, die den letzten Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code erstellt einen Pfad, fügt dem Pfad eine Zeile hinzu und ruft dann den letzten Punkt im Pfad ab.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#21)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#21)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsOutlineVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zeigt an, ob sich der angegebene Punkt auf bzw. unter dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point point, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.Point * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (point, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">Ein <see cref="T:System.Drawing.Point" />, der die zu überprüfende Position angibt.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <summary>Zeigt an, ob sich der angegebene Punkt auf bzw. unter dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn sich der angegebene Punkt auf dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode testet, ob die Gliederung eines gegebenen Pfades an der angegebenen Stelle sichtbar gerendert wird.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF point, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF point, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF point, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.PointF * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (point, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="point">Ein <see cref="T:System.Drawing.PointF" />, der die zu überprüfende Position angibt.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <summary>Zeigt an, ob sich der angegebene Punkt auf bzw. unter dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn sich der angegebene Punkt auf dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode testet, ob die Gliederung eines gegebenen Pfades an der angegebenen Stelle sichtbar gerendert wird.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.Point pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.Point pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.Point,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::Point pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.Point * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (pt, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.Point" />, der die zu überprüfende Position angibt.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <param name="graphics">Das auf Sichtbarkeit zu überprüfende <see cref="T:System.Drawing.Graphics" />-Objekt.</param>
        <summary>Zeigt an, ob sich der angegebene Punkt auf bzw. unter dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er unter Verwendung des angegebenen <see cref="T:System.Drawing.Pen" />-Objekts mit dem angegebenen <see cref="T:System.Drawing.Graphics" /> gezeichnet wurde.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn sich der angegebene Punkt auf dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode testet, ob die Gliederung eines gegebenen Pfades an der angegebenen Stelle sichtbar gerendert wird. Die Koordinaten des zu testenden Punkts werden in globalen Koordinaten angegeben. Die Transformationsmatrix von `graphics` wird vorübergehend vor dem Testen der Sichtbarkeit angewendet.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (System.Drawing.PointF pt, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Drawing.PointF,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(System::Drawing::PointF pt, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : System.Drawing.PointF * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (pt, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.PointF" />, der die zu überprüfende Position angibt.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <param name="graphics">Das auf Sichtbarkeit zu überprüfende <see cref="T:System.Drawing.Graphics" />-Objekt.</param>
        <summary>Zeigt an, ob sich der angegebene Punkt auf bzw. unter dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er unter Verwendung des angegebenen <see cref="T:System.Drawing.Pen" />-Objekts mit dem angegebenen <see cref="T:System.Drawing.Graphics" /> gezeichnet wurde.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn sich der angegebene Punkt auf bzw. unter dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode testet, ob die Gliederung eines gegebenen Pfades an der angegebenen Stelle sichtbar gerendert wird. Die Koordinaten des zu testenden Punkts werden in globalen Koordinaten angegeben. Die Transformationsmatrix von `graphics` wird vorübergehend vor dem Testen der Sichtbarkeit angewendet.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : int * int * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <summary>Zeigt an, ob sich der angegebene Punkt auf bzw. unter dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn sich der angegebene Punkt auf dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode testet, ob die Gliederung eines gegebenen Pfades an der angegebenen Stelle sichtbar gerendert wird.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : single * single * System.Drawing.Pen -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <summary>Zeigt an, ob sich der angegebene Punkt auf bzw. unter dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn sich der angegebene Punkt auf dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode testet, ob die Gliederung eines gegebenen Pfades an der angegebenen Stelle sichtbar gerendert wird.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (int x, int y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(int32 x, int32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Int32,System.Int32,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(int x, int y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : int * int * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <param name="graphics">Das auf Sichtbarkeit zu überprüfende <see cref="T:System.Drawing.Graphics" />-Objekt.</param>
        <summary>Zeigt an, ob sich der angegebene Punkt auf bzw. unter dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er unter Verwendung des angegebenen <see cref="T:System.Drawing.Pen" />-Objekts mit dem angegebenen <see cref="T:System.Drawing.Graphics" /> gezeichnet wurde.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn sich der angegebene Punkt auf dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode testet, ob die Gliederung eines gegebenen Pfades an der angegebenen Stelle sichtbar gerendert wird. Die Koordinaten des zu testenden Punkts werden in globalen Koordinaten angegeben. Die Transformationsmatrix von `graphics` wird vorübergehend vor dem Testen der Sichtbarkeit angewendet.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad.  
  
-   Fügt dem Pfad ein Rechteck hinzu.  
  
-   Erstellt einen breiten Stift und erweitert den Pfad mit diesem Stift (um das Beispiel klarer zu machen).  
  
-   Testet einen Punkt (100, 50), um festzustellen, ob dieser innerhalb von (unter) einem der Kanten des Rechtecks liegt, indem <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%2A>aufgerufen wird.  
  
 Das Ergebnis wird im Meldungs Feld angezeigt (in diesem Fall true). Das heißt, dass der Rand an diesem Punkt gerendert wird.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#22)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#22)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutlineVisible">
      <MemberSignature Language="C#" Value="public bool IsOutlineVisible (float x, float y, System.Drawing.Pen pen, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsOutlineVisible(float32 x, float32 y, class System.Drawing.Pen pen, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible(System.Single,System.Single,System.Drawing.Pen,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsOutlineVisible(float x, float y, System::Drawing::Pen ^ pen, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsOutlineVisible : single * single * System.Drawing.Pen * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsOutlineVisible (x, y, pen, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="pen">Der zu überprüfende <see cref="T:System.Drawing.Pen" />.</param>
        <param name="graphics">Das auf Sichtbarkeit zu überprüfende <see cref="T:System.Drawing.Graphics" />-Objekt.</param>
        <summary>Zeigt an, ob sich der angegebene Punkt auf bzw. unter dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er unter Verwendung des angegebenen <see cref="T:System.Drawing.Pen" />-Objekts mit dem angegebenen <see cref="T:System.Drawing.Graphics" /> gezeichnet wurde.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn sich der angegebene Punkt auf bzw. unter dem Umriss dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> befindet, wenn er mit dem angegebenen <see cref="T:System.Drawing.Pen" /> gezeichnet wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode testet, ob die Gliederung eines gegebenen Pfades an der angegebenen Stelle sichtbar gerendert wird. Die Koordinaten des zu testenden Punkts werden in globalen Koordinaten angegeben. Die Transformationsmatrix des `graphics`-Parameters wird vorübergehend vor dem Testen der Sichtbarkeit angewendet.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsOutlineVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Pen%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsVisible">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt an, dass der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point -&gt; bool" Usage="graphicsPath.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">Ein <see cref="T:System.Drawing.Point" />, der den zu überprüfenden Punkt darstellt.</param>
        <summary>Gibt an, dass der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (point As PointF) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF point);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF -&gt; bool" Usage="graphicsPath.IsVisible point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.PointF" />
      </Parameters>
      <Docs>
        <param name="point">Ein <see cref="T:System.Drawing.PointF" />, der den zu überprüfenden Punkt darstellt.</param>
        <summary>Gibt an, dass der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.Point pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.Point pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.Point,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::Point pt, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.Point * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (pt, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.Point" />, der den zu überprüfenden Punkt darstellt.</param>
        <param name="graphics">Das auf Sichtbarkeit zu überprüfende <see cref="T:System.Drawing.Graphics" />-Objekt.</param>
        <summary>Gibt an, dass der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Koordinaten des zu testenden Punkts werden in globalen Koordinaten angegeben. Die Transformationsmatrix des `graphics`-Parameters wird vorübergehend vor dem Testen der Sichtbarkeit angewendet.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter `GraphicsPath.IsVisible Method (Int32, Int32, Graphics)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (System.Drawing.PointF pt, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(valuetype System.Drawing.PointF pt, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Drawing.PointF,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(System::Drawing::PointF pt, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : System.Drawing.PointF * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (pt, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.PointF" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="pt">Ein <see cref="T:System.Drawing.PointF" />, der den zu überprüfenden Punkt darstellt.</param>
        <param name="graphics">Das auf Sichtbarkeit zu überprüfende <see cref="T:System.Drawing.Graphics" />-Objekt.</param>
        <summary>Gibt an, dass der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn der angegebene Punkt darin enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Koordinaten des zu testenden Punkts werden in globalen Koordinaten angegeben. Die Transformationsmatrix des `graphics`-Parameters wird vorübergehend vor dem Testen der Sichtbarkeit angewendet.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Integer, y As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int -&gt; bool" Usage="graphicsPath.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <summary>Gibt an, dass der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsVisible (x As Single, y As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single -&gt; bool" Usage="graphicsPath.IsVisible (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <summary>Gibt an, dass der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (int x, int y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(int32 x, int32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Int32,System.Int32,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(int x, int y, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : int * int * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (x, y, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="graphics">Das auf Sichtbarkeit zu überprüfende <see cref="T:System.Drawing.Graphics" />-Objekt.</param>
        <summary>Gibt an, dass der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist und dass dabei das angegebene <see cref="T:System.Drawing.Graphics" />-Objekt verwendet wird.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Koordinaten des zu testenden Punkts werden in globalen Koordinaten angegeben. Die Transformationsmatrix von `graphics` wird vorübergehend vor dem Testen der Sichtbarkeit angewendet.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad und fügt dem Pfad eine Ellipse hinzu.  
  
-   Testet, ob der angegebene Punkt im Pfad enthalten ist.  
  
-   Zeigt das Ergebnis in einem Dialogfeld an.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#23)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#23)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#23](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible (float x, float y, System.Drawing.Graphics graphics);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsVisible(float32 x, float32 y, class System.Drawing.Graphics graphics) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.IsVisible(System.Single,System.Single,System.Drawing.Graphics)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsVisible(float x, float y, System::Drawing::Graphics ^ graphics);" />
      <MemberSignature Language="F#" Value="member this.IsVisible : single * single * System.Drawing.Graphics -&gt; bool" Usage="graphicsPath.IsVisible (x, y, graphics)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="graphics" Type="System.Drawing.Graphics" />
      </Parameters>
      <Docs>
        <param name="x">Die x-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="y">Die y-Koordinate des Punktes, der überprüft werden soll.</param>
        <param name="graphics">Das auf Sichtbarkeit zu überprüfende <see cref="T:System.Drawing.Graphics" />-Objekt.</param>
        <summary>Gibt an, ob der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> im sichtbaren Clipbereich des angegebenen <see cref="T:System.Drawing.Graphics" />-Objekts enthalten ist.</summary>
        <returns>Diese Methode gibt <see langword="true" /> zurück, wenn der angegebene Punkt in diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> enthalten ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Koordinaten des zu testenden Punkts werden in globalen Koordinaten angegeben. Die Transformationsmatrix des `graphics`-Parameters wird vorübergehend vor dem Testen der Sichtbarkeit angewendet.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.IsVisible%28System.Int32%2CSystem.Int32%2CSystem.Drawing.Graphics%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PathData">
      <MemberSignature Language="C#" Value="public System.Drawing.Drawing2D.PathData PathData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Drawing2D.PathData PathData" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathData As PathData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Drawing2D::PathData ^ PathData { System::Drawing::Drawing2D::PathData ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathData : System.Drawing.Drawing2D.PathData" Usage="System.Drawing.Drawing2D.GraphicsPath.PathData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Drawing2D.PathData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Drawing.Drawing2D.PathData" />-Objekt ab, das Arrays von Punkten (<paramref name="points" />) und Typen (<paramref name="types" />) für diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> kapselt.</summary>
        <value>Ein <see cref="T:System.Drawing.Drawing2D.PathData" />-Objekt, das Arrays sowohl für die Punkte als auch für die Typen dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> kapselt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathPoints">
      <MemberSignature Language="C#" Value="public System.Drawing.PointF[] PathPoints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.PointF[] PathPoints" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathPoints As PointF()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Drawing::PointF&gt; ^ PathPoints { cli::array &lt;System::Drawing::PointF&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathPoints : System.Drawing.PointF[]" Usage="System.Drawing.Drawing2D.GraphicsPath.PathPoints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.PointF[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Punkte im Pfad ab.</summary>
        <value>Ein Array von <see cref="T:System.Drawing.PointF" />-Objekten, die den Pfad darstellen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathTypes">
      <MemberSignature Language="C#" Value="public byte[] PathTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] PathTypes" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathTypes As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ PathTypes { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathTypes : byte[]" Usage="System.Drawing.Drawing2D.GraphicsPath.PathTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Typen der entsprechenden Punkte im <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />-Array ab.</summary>
        <value>Ein Bytearray, das die Typen der entsprechenden Punkte im Pfad angibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Bytearray, das von der <xref:System.Drawing.Drawing2D.GraphicsPath.PathTypes%2A>-Eigenschaft zurückgegeben wird, gibt die Punkt Typen und Flags für die Datenpunkte in einem Pfad an. Für jeden Punkt geben Bits 0 bis 2 den Typ eines Punkts an, und Bits 3 bis 7 enthalten einen Satz von Flags, die die Attribute eines Punkts angeben. In der folgenden Tabelle sind mögliche Werte und deren Bedeutungen aufgeführt.  
  
|Wert|Bedeutung|  
|-----------|-------------|  
|0|Gibt an, dass der Punkt der Anfang einer Abbildung ist.|  
|1|Gibt an, dass der Punkt einer der beiden Endpunkte einer Zeile ist.|  
|3|Gibt an, dass der Punkt ein Endpunkt oder Steuerungspunkt einer kubischen Bézier-Spline ist.|  
|0x7|Maskiert alle Bits außer den drei nieder wertigen Bits, die den Punkttyp angeben.|  
|0x20|Gibt an, dass der Punkt ein Marker ist.|  
|0x80|Gibt an, dass der Punkt der letzte Punkt in einem geschlossenen unter Pfad (Abbildung) ist.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointCount">
      <MemberSignature Language="C#" Value="public int PointCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PointCount" />
      <MemberSignature Language="DocId" Value="P:System.Drawing.Drawing2D.GraphicsPath.PointCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PointCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PointCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PointCount : int" Usage="System.Drawing.Drawing2D.GraphicsPath.PointCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Elemente in <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> oder im <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />-Array ab.</summary>
        <value>Eine ganze Zahl, die die Anzahl der Elemente in <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" /> oder im <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />-Array angibt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; unit" Usage="graphicsPath.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Leert das <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />-Array und das <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathTypes" />-Array und legt <see cref="T:System.Drawing.Drawing2D.FillMode" /> auf <see cref="F:System.Drawing.Drawing2D.FillMode.Alternate" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad.  
  
-   Fügt eine Reihe von primitiven hinzu.  
  
-   Zeichnet das Punkt Array des Pfades auf den Bildschirm.  
  
-   Setzt den Pfad auf einen leeren Zustand zurück.  
  
-   Ruft das Points-Array (sofern vorhanden) erneut ab.  
  
-   Zeichnet das Array auf dem Bildschirm.  
  
 Beachten Sie, dass nach dem Reset-Befehl kein Array gefunden wird.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#24)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#24)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="graphicsPath.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kehrt die Reihenfolge der Punkte im <see cref="P:System.Drawing.Drawing2D.GraphicsPath.PathPoints" />-Array dieses <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> um.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad und fügt dem Pfad mehrere primitive hinzu.  
  
-   Zeichnet das Punkt Array des Pfades auf den Bildschirm.  
  
-   Zeichnet das Array der umgekehrten Punkte auf dem Bildschirm.  
  
 Beachten Sie, dass die zweite Liste der Punkte in umgekehrter Reihenfolge vom ersten ist.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#25)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#25)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#25)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMarkers">
      <MemberSignature Language="C#" Value="public void SetMarkers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetMarkers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.SetMarkers" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetMarkers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetMarkers();" />
      <MemberSignature Language="F#" Value="member this.SetMarkers : unit -&gt; unit" Usage="graphicsPath.SetMarkers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt einen Marker für diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt einen Marker auf dem Pfad, der zum Trennen von Abschnitten des Pfads verwendet werden kann. Anschließend können Sie die <xref:System.Drawing.Drawing2D.GraphicsPathIterator.NextMarker%2A>-Methoden verwenden, um die Marker im Pfad zu durchlaufen.  
  
 Marker werden zum Trennen von Gruppen von unter Pfaden verwendet. Ein oder mehrere unter Pfade können zwischen zwei Markern im Pfad enthalten sein.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code erstellt einen Pfad und fügt dem Pfad mehrere primitive durch Marker getrennt hinzu und zeichnet den Pfad auf dem Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#26)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#26)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartFigure">
      <MemberSignature Language="C#" Value="public void StartFigure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartFigure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.StartFigure" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartFigure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartFigure();" />
      <MemberSignature Language="F#" Value="member this.StartFigure : unit -&gt; unit" Usage="graphicsPath.StartFigure " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Startet eine neue Figur, ohne die aktuelle zu schließen. Alle nachfolgenden Punkte, die dem Pfad hinzugefügt werden, werden dieser neuen Figur hinzugefügt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Benutzer muss die ursprünglichen Punkte aufbewahren, wenn Sie benötigt werden. Die ursprünglichen Punkte werden intern in kubische Bézier-Steuerungs Punkte konvertiert. Daher gibt es keinen Mechanismus zum Zurückgeben der ursprünglichen Punkte.  
  
 Diese Methode startet einen neuen Unterpfad im Pfad. Mithilfe von unter Pfaden können Sie einen Pfad in Abschnitte aufteilen und die <xref:System.Drawing.Drawing2D.GraphicsPathIterator> Klasse zum Durchlaufen der unter Pfade verwenden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad.  
  
-   Addiert zwei Sätze von Abbildungen. Der erste Satz von Abbildungen kombiniert vier primitive in zwei Abbildungen. Der zweite Satz von Abbildungen kombiniert die gleichen vier primitiven (mit der Ausnahme, dass Sie auf der y-Achse versetzt werden) in drei Abbildungen.  
  
-   Zeichnet alle Abbildungen auf dem Bildschirm.  
  
 Beachten Sie den Unterschied in der Darstellung zwischen den zwei Sätzen von Abbildungen.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#27)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#27)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#27](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transform">
      <MemberSignature Language="C#" Value="public void Transform (System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transform(class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Transform(System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transform(System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Transform : System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Transform matrix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="matrix">Eine <see cref="T:System.Drawing.Drawing2D.Matrix" />, die die zuzuweisende Transformation darstellt.</param>
        <summary>Weist diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> eine Transformationsmatrix zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der Transformation können die <xref:System.Drawing.Drawing2D.GraphicsPath>skaliert, übersetzt, gedreht oder verzerrt werden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad und fügt dem Pfad eine Ellipse hinzu.  
  
-   Zeichnet den Pfad zum Bildschirm.  
  
-   Erstellt eine Transformationsmatrix zum Übersetzen der Pfad-100-Einheiten in die Richtung der x-Achse.  
  
-   Zeichnet den transformierten Pfad auf dem Bildschirm.  
  
 Beachten Sie, dass die ursprüngliche Ellipse in schwarz gezeichnet wird und die transformierte Ellipse rot gezeichnet wird.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#28)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#28)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#28](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Warp">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weist diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> eine durch ein Rechteck und ein Parallelogramm definierte Verzerrungstransformation zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Warp (destPoints As PointF(), srcRect As RectangleF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
      </Parameters>
      <Docs>
        <param name="destPoints">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, in das das durch <paramref name="srcRect" /> definierte Rechteck transformiert wird. Das Array kann entweder drei oder vier Elemente enthalten. Wenn das Array drei Elemente enthält, ergibt sich die untere rechte Ecke des Parallelogramms aus den ersten drei Punkten.</param>
        <param name="srcRect">Ein <see cref="T:System.Drawing.RectangleF" />, das das Rechteck darstellt, das in das durch <paramref name="destPoints" /> definierte Parallelogramm transformiert wird.</param>
        <summary>Weist diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> eine durch ein Rechteck und ein Parallelogramm definierte Verzerrungstransformation zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect, matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="destPoints">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, in das das durch <paramref name="srcRect" /> definierte Rechteck transformiert wird. Das Array kann entweder drei oder vier Elemente enthalten. Wenn das Array drei Elemente enthält, ergibt sich die untere rechte Ecke des Parallelogramms aus den ersten drei Punkten.</param>
        <param name="srcRect">Ein <see cref="T:System.Drawing.RectangleF" />, das das Rechteck darstellt, das in das durch <paramref name="destPoints" /> definierte Parallelogramm transformiert wird.</param>
        <param name="matrix">Eine <see cref="T:System.Drawing.Drawing2D.Matrix" />, die eine dem Pfad zuzuweisende geometrische Transformation angibt.</param>
        <summary>Weist diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> eine durch ein Rechteck und ein Parallelogramm definierte Verzerrungstransformation zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.Drawing2D.Matrix * System.Drawing.Drawing2D.WarpMode -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect, matrix, warpMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
      </Parameters>
      <Docs>
        <param name="destPoints">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, das ein Parallelogramm definiert, in das das durch <paramref name="srcRect" /> definierte Rechteck transformiert wird. Das Array kann entweder drei oder vier Elemente enthalten. Wenn das Array drei Elemente enthält, ergibt sich die untere rechte Ecke des Parallelogramms aus den ersten drei Punkten.</param>
        <param name="srcRect">Ein <see cref="T:System.Drawing.RectangleF" />, das das Rechteck darstellt, das in das durch <paramref name="destPoints" /> definierte Parallelogramm transformiert wird.</param>
        <param name="matrix">Eine <see cref="T:System.Drawing.Drawing2D.Matrix" />, die eine dem Pfad zuzuweisende geometrische Transformation angibt.</param>
        <param name="warpMode">Eine <see cref="T:System.Drawing.Drawing2D.WarpMode" />-Enumeration, die angibt, ob bei dieser Verzerrung der perspektivische oder der bilineare Modus verwendet wird.</param>
        <summary>Weist diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> eine durch ein Rechteck und ein Parallelogramm definierte Verzerrungstransformation zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Warp%28System.Drawing.PointF%5B%5D%2CSystem.Drawing.RectangleF%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Drawing.Drawing2D.WarpMode%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Warp">
      <MemberSignature Language="C#" Value="public void Warp (System.Drawing.PointF[] destPoints, System.Drawing.RectangleF srcRect, System.Drawing.Drawing2D.Matrix matrix, System.Drawing.Drawing2D.WarpMode warpMode, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Warp(valuetype System.Drawing.PointF[] destPoints, valuetype System.Drawing.RectangleF srcRect, class System.Drawing.Drawing2D.Matrix matrix, valuetype System.Drawing.Drawing2D.WarpMode warpMode, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Warp(System.Drawing.PointF[],System.Drawing.RectangleF,System.Drawing.Drawing2D.Matrix,System.Drawing.Drawing2D.WarpMode,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Warp(cli::array &lt;System::Drawing::PointF&gt; ^ destPoints, System::Drawing::RectangleF srcRect, System::Drawing::Drawing2D::Matrix ^ matrix, System::Drawing::Drawing2D::WarpMode warpMode, float flatness);" />
      <MemberSignature Language="F#" Value="member this.Warp : System.Drawing.PointF[] * System.Drawing.RectangleF * System.Drawing.Drawing2D.Matrix * System.Drawing.Drawing2D.WarpMode * single -&gt; unit" Usage="graphicsPath.Warp (destPoints, srcRect, matrix, warpMode, flatness)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destPoints" Type="System.Drawing.PointF[]" />
        <Parameter Name="srcRect" Type="System.Drawing.RectangleF" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="warpMode" Type="System.Drawing.Drawing2D.WarpMode" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="destPoints">Ein Array von <see cref="T:System.Drawing.PointF" />-Strukturen, die ein Parallelogramm definieren, in das das durch <paramref name="srcRect" /> definierte Rechteck transformiert wird. Das Array kann entweder drei oder vier Elemente enthalten. Wenn das Array drei Elemente enthält, ergibt sich die untere rechte Ecke des Parallelogramms aus den ersten drei Punkten.</param>
        <param name="srcRect">Ein <see cref="T:System.Drawing.RectangleF" />, das das Rechteck darstellt, das in das durch <paramref name="destPoints" /> definierte Parallelogramm transformiert wird.</param>
        <param name="matrix">Eine <see cref="T:System.Drawing.Drawing2D.Matrix" />, die eine dem Pfad zuzuweisende geometrische Transformation angibt.</param>
        <param name="warpMode">Eine <see cref="T:System.Drawing.Drawing2D.WarpMode" />-Enumeration, die angibt, ob bei dieser Verzerrung der perspektivische oder der bilineare Modus verwendet wird.</param>
        <param name="flatness">Ein Wert von 0 bis 1, der angibt, wie flach der resultierende Pfad ist. Weitere Informationen finden Sie unter <see cref="M:System.Drawing.Drawing2D.GraphicsPath.Flatten" />-Methoden.</param>
        <summary>Weist diesem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> eine durch ein Rechteck und ein Parallelogramm definierte Verzerrungstransformation zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad und fügt dem Pfad ein Rechteck hinzu.  
  
-   Zeichnet dieses Rechteck in schwarz auf den Bildschirm.  
  
-   Verzerrt den Pfad mit einer perspektivischen Schleife.  
  
-   Zeichnet das aufwärzte Rechteck (Pfad) auf den roten Bildschirm.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#29)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#29)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#29](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#29)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Widen">
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ersetzt diesen Pfad durch Kurven, die den Bereich einschließen, der beim Zeichnen des Pfads mithilfe des angegebenen Stifts ausgefüllt wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen);" />
      <MemberSignature Language="F#" Value="member this.Widen : System.Drawing.Pen -&gt; unit" Usage="graphicsPath.Widen pen" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
      </Parameters>
      <Docs>
        <param name="pen">Ein <see cref="T:System.Drawing.Pen" />, der die Breite zwischen dem ursprünglichen Umriss des Pfads und dem neuen, durch diese Methode erstellten Umriss angibt.</param>
        <summary>Fügt dem Pfad einen weiteren Umriss hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Gliederung um die ursprünglichen Zeilen in diesem <xref:System.Drawing.Drawing2D.GraphicsPath>, wobei der Abstand zwischen den vorhandenen Zeilen und der neuen Gliederung gleich der Breite des <xref:System.Drawing.Pen> ist, der im <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>aufgerufen wird. Wenn Sie den Leerraum zwischen den Zeilen ausfüllen möchten, müssen Sie die <xref:System.Drawing.Graphics.FillPath%2A> anstelle des <xref:System.Drawing.Graphics.DrawPath%2A>verwenden.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix);" />
      <MemberSignature Language="F#" Value="member this.Widen : System.Drawing.Pen * System.Drawing.Drawing2D.Matrix -&gt; unit" Usage="graphicsPath.Widen (pen, matrix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
      </Parameters>
      <Docs>
        <param name="pen">Ein <see cref="T:System.Drawing.Pen" />, der die Breite zwischen dem ursprünglichen Umriss des Pfads und dem neuen, durch diese Methode erstellten Umriss angibt.</param>
        <param name="matrix">Eine <see cref="T:System.Drawing.Drawing2D.Matrix" />, die eine Transformation angibt, die dem Pfad vor dem Verbreitern zugewiesen werden soll.</param>
        <summary>Fügt dem <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> einen weiteren Umriss hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Gliederung um die ursprünglichen Zeilen in diesem <xref:System.Drawing.Drawing2D.GraphicsPath>, wobei der Abstand zwischen den vorhandenen Zeilen und der neuen Gliederung gleich der Breite des <xref:System.Drawing.Pen> ist, der im <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>aufgerufen wird. Wenn Sie den Leerraum zwischen den Zeilen ausfüllen möchten, müssen Sie die <xref:System.Drawing.Graphics.FillPath%2A> anstelle des <xref:System.Drawing.Graphics.DrawPath%2A>verwenden.  
  
   
  
## Examples  
 Ein Beispiel finden Sie unter <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%28System.Drawing.Pen%2CSystem.Drawing.Drawing2D.Matrix%2CSystem.Single%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Widen">
      <MemberSignature Language="C#" Value="public void Widen (System.Drawing.Pen pen, System.Drawing.Drawing2D.Matrix matrix, float flatness);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Widen(class System.Drawing.Pen pen, class System.Drawing.Drawing2D.Matrix matrix, float32 flatness) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Drawing.Drawing2D.GraphicsPath.Widen(System.Drawing.Pen,System.Drawing.Drawing2D.Matrix,System.Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Widen(System::Drawing::Pen ^ pen, System::Drawing::Drawing2D::Matrix ^ matrix, float flatness);" />
      <MemberSignature Language="F#" Value="member this.Widen : System.Drawing.Pen * System.Drawing.Drawing2D.Matrix * single -&gt; unit" Usage="graphicsPath.Widen (pen, matrix, flatness)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Drawing</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Drawing.Common</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.1</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pen" Type="System.Drawing.Pen" />
        <Parameter Name="matrix" Type="System.Drawing.Drawing2D.Matrix" />
        <Parameter Name="flatness" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="pen">Ein <see cref="T:System.Drawing.Pen" />, der die Breite zwischen dem ursprünglichen Umriss des Pfads und dem neuen, durch diese Methode erstellten Umriss angibt.</param>
        <param name="matrix">Eine <see cref="T:System.Drawing.Drawing2D.Matrix" />, die eine Transformation angibt, die dem Pfad vor dem Verbreitern zugewiesen werden soll.</param>
        <param name="flatness">Ein Wert, der die Abflachung von Kurven angibt.</param>
        <summary>Ersetzt diesen <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> durch Kurven, die den Bereich einschließen, der beim Zeichnen des Pfads mithilfe des angegebenen Stifts ausgefüllt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt eine Gliederung um die ursprünglichen Zeilen in diesem <xref:System.Drawing.Drawing2D.GraphicsPath>, wobei der Abstand zwischen den vorhandenen Zeilen und der neuen Gliederung gleich der Breite des <xref:System.Drawing.Pen> ist, der im <xref:System.Drawing.Drawing2D.GraphicsPath.Widen%2A>aufgerufen wird. Wenn Sie den Leerraum zwischen den Zeilen ausfüllen möchten, müssen Sie die <xref:System.Drawing.Graphics.FillPath%2A> anstelle des <xref:System.Drawing.Graphics.DrawPath%2A>verwenden.  
  
   
  
## Examples  
 Das folgende Codebeispiel ist für die Verwendung mit Windows Forms konzipiert und erfordert <xref:System.Windows.Forms.PaintEventArgs>`e`, ein <xref:System.Windows.Forms.Form.OnPaint%2A> Ereignis Objekt. Der Code führt die folgenden Aktionen aus:  
  
-   Erstellt einen Pfad und fügt dem Pfad zwei Ellipsen hinzu.  
  
-   Zeichnet den Pfad in schwarz.  
  
-   Erweitert den Pfad.  
  
-   Zeichnet den Pfad in rot.  
  
 Beachten Sie, dass das zweite Rendering <xref:System.Drawing.Graphics.FillPath%2A> anstelle von <xref:System.Drawing.Graphics.DrawPath%2A>verwendet, und daher wird in der gerenderten Abbildung der Umriss ausgefüllt.  
  
 [!code-cpp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CPP/form1.cpp#30)]
 [!code-csharp[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/CS/form1.cs#30)]
 [!code-vb[System.Drawing.Drawing2D.ClassicGraphicsPathExamples#30](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.Drawing2D.ClassicGraphicsPathExamples/VB/form1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
