<Type Name="Rfc3161TimestampToken" FullName="System.Security.Cryptography.Pkcs.Rfc3161TimestampToken">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f903416d018e753fddc34d7b0fd7b79ce1daed93" /><Meta Name="ms.sourcegitcommit" Value="f9576bf8c61e3d46834aeeff50f858359f2a99ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/09/2020" /><Meta Name="ms.locfileid" Value="77102207" /></Metadata><TypeSignature Language="C#" Value="public sealed class Rfc3161TimestampToken" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Rfc3161TimestampToken extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Rfc3161TimestampToken" />
  <TypeSignature Language="C++ CLI" Value="public ref class Rfc3161TimestampToken sealed" />
  <TypeSignature Language="F#" Value="type Rfc3161TimestampToken = class" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.1</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Diese Klasse stellt ein Zeitstempeltoken aus IETF RFC 3161 dar.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsSignedCms">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Pkcs.SignedCms AsSignedCms ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.Pkcs.SignedCms AsSignedCms() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.AsSignedCms" />
      <MemberSignature Language="VB.NET" Value="Public Function AsSignedCms () As SignedCms" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::Pkcs::SignedCms ^ AsSignedCms();" />
      <MemberSignature Language="F#" Value="member this.AsSignedCms : unit -&gt; System.Security.Cryptography.Pkcs.SignedCms" Usage="rfc3161TimestampToken.AsSignedCms " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.SignedCms</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Diese Methode ruft die Darstellung der Signed Cryptographic Message Syntax (CMS) des RFC3161-Zeitstempeltokens ab.</summary>
        <returns>Eine <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" />-Darstellung des <see cref="T:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Bei aufeinander folgenden Aufrufen dieser Methode wird das gleiche Objekt zurückgegeben.

Die <xref:System.Security.Cryptography.Pkcs.SignedCms>-Klasse ist änderbar, Änderungen an diesem Objekt werden jedoch nicht im <xref:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken> Objekt widergespiegelt, das es erzeugt hat.

Der Wert aus dem Aufruf von <xref:System.Security.Cryptography.Pkcs.SignedCms.Encode?displayProperty=nameWithType> kann erneut als <xref:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken> über einen anderen Aufruf von <xref:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.TryDecode(System.ReadOnlyMemory{System.Byte},System.Security.Cryptography.Pkcs.Rfc3161TimestampToken@,System.Int32@)?displayProperty=nameWithType>interpretiert werden.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TokenInfo">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo TokenInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo TokenInfo" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.TokenInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TokenInfo As Rfc3161TimestampTokenInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Pkcs::Rfc3161TimestampTokenInfo ^ TokenInfo { System::Security::Cryptography::Pkcs::Rfc3161TimestampTokenInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TokenInfo : System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.TokenInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Diese Eigenschaft ruft die Details dieses Zeitstempeltokens als <see cref="T:System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo" /> ab.</summary>
        <value>Die Details dieses Zeitstempel Tokens als <see cref="T:System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDecode">
      <MemberSignature Language="C#" Value="public static bool TryDecode (ReadOnlyMemory&lt;byte&gt; encodedBytes, out System.Security.Cryptography.Pkcs.Rfc3161TimestampToken token, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryDecode(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; encodedBytes, [out] class System.Security.Cryptography.Pkcs.Rfc3161TimestampToken&amp; token, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.TryDecode(System.ReadOnlyMemory{System.Byte},System.Security.Cryptography.Pkcs.Rfc3161TimestampToken@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryDecode (encodedBytes As ReadOnlyMemory(Of Byte), ByRef token As Rfc3161TimestampToken, ByRef bytesConsumed As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryDecode(ReadOnlyMemory&lt;System::Byte&gt; encodedBytes, [Runtime::InteropServices::Out] System::Security::Cryptography::Pkcs::Rfc3161TimestampToken ^ % token, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member TryDecode : ReadOnlyMemory&lt;byte&gt; * Rfc3161TimestampToken * int -&gt; bool" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.TryDecode (encodedBytes, token, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encodedBytes" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="token" Type="System.Security.Cryptography.Pkcs.Rfc3161TimestampToken" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="encodedBytes">Dies ist der Puffer, der ein DER-codiertes Zeitstempeltoken enthält.</param>
        <param name="token">Mit dieser Methode wird das erfolgreich decodierte Zeitstempeltoken zurückgegeben, falls die Decodierung erfolgreich war, oder <see langword="null" />, wenn die Decodierung fehlgeschlagen ist. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Mit dieser Methode wird die Anzahl der Bytes zurückgegeben, die aus <paramref name="encodedBytes" /> gelesen wurden. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <summary>Diese Methode versucht, den Inhalt von <paramref name="encodedBytes" /> als DER-codiertes Zeitstempeltoken zu interpretieren.</summary>
        <returns><see langword="true" />, wenn <paramref name="encodedBytes" /> erfolgreich als Zeitstempeltoken interpretiert wurde. Andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifySignatureForData">
      <MemberSignature Language="C#" Value="public bool VerifySignatureForData (ReadOnlySpan&lt;byte&gt; data, out System.Security.Cryptography.X509Certificates.X509Certificate2 signerCertificate, System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraCandidates = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifySignatureForData(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, [out] class System.Security.Cryptography.X509Certificates.X509Certificate2&amp; signerCertificate, class System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraCandidates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForData(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifySignatureForData (data As ReadOnlySpan(Of Byte), ByRef signerCertificate As X509Certificate2, Optional extraCandidates As X509Certificate2Collection = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.VerifySignatureForData : ReadOnlySpan&lt;byte&gt; * X509Certificate2 * System.Security.Cryptography.X509Certificates.X509Certificate2Collection -&gt; bool" Usage="rfc3161TimestampToken.VerifySignatureForData (data, signerCertificate, extraCandidates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="signerCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate2" RefType="out" />
        <Parameter Name="extraCandidates" Type="System.Security.Cryptography.X509Certificates.X509Certificate2Collection" />
      </Parameters>
      <Docs>
        <param name="data">Dies sind die Daten, die anhand des Zeitstempeltokens überprüft werden sollen.</param>
        <param name="signerCertificate">Mit dieser Methode wird das Zertifikat von der TSA (Time Stamping Authority) zurückgegeben, die dieses Token signiert hat, oder <see langword="null" />, wenn ein Signaturzertifikat nicht bestimmt werden kann. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="extraCandidates">Dies ist eine optionale Auflistung von Zertifikaten, die zusätzlich zu den Zertifikaten, die in das Token eingeschlossen werden können, als TSA-Zertifikate (Time Stamping Authority) berücksichtigt werden.</param>
        <summary>Mit dieser Methode wird überprüft, ob das aktuelle Token ein gültiges Zeitstempeltoken für die bereitgestellten Daten ist.</summary>
        <returns><see langword="true" /> wird ausgegeben, wenn das TSA-Zertifikat (Time Stamping Authority) gefunden wurde, der öffentliche Schlüssel des Zertifikats die Tokensignatur überprüft und das Token dem Hash für die bereitgestellten Daten entspricht. Andernfalls wird <see langword="false" /> ausgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Diese Methode erfordert, dass das Zeitstempel-Autoritäts Zertifikat (1.3.6.1.5.5.7.3.8) über den erforderlichen Wert für die erweiterte Schlüssel Verwendung () verfügt, den eingebetteten esscertid-oder ESSCertID2-Bezeichner des Tokens entspricht und einen Gültigkeitsbereich hat, der den Zeitstempel des Tokens umfasst. der Wert und verfügt über einen öffentlichen Schlüssel, der die Signatur des Tokens erfolgreich überprüft.

Nachdem Sie das geeignete TSA-Zertifikat bestimmt haben, berechnet diese Methode den Digest der `data` mithilfe des im Token eingebetteten algorithmusbezeichners.
Wenn dieser Digest mit dem eingebetteten Digest des Tokens übereinstimmt, wird das Zertifikat über das `signerCertificate` gemeldet, und die Methode gibt `true`zurück.

Wenn der Digest nicht entspricht oder das TSA-Zertifikat nicht bestimmt werden konnte, meldet die Methode `signerCertificate` als `null` und gibt `false`zurück.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForHash(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForHash(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.Oid,System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
      </Docs>
    </Member>
    <Member MemberName="VerifySignatureForHash">
      <MemberSignature Language="C#" Value="public bool VerifySignatureForHash (ReadOnlySpan&lt;byte&gt; hash, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, out System.Security.Cryptography.X509Certificates.X509Certificate2 signerCertificate, System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraCandidates = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifySignatureForHash(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; hash, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, [out] class System.Security.Cryptography.X509Certificates.X509Certificate2&amp; signerCertificate, class System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraCandidates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForHash(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifySignatureForHash (hash As ReadOnlySpan(Of Byte), hashAlgorithm As HashAlgorithmName, ByRef signerCertificate As X509Certificate2, Optional extraCandidates As X509Certificate2Collection = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.VerifySignatureForHash : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * X509Certificate2 * System.Security.Cryptography.X509Certificates.X509Certificate2Collection -&gt; bool" Usage="rfc3161TimestampToken.VerifySignatureForHash (hash, hashAlgorithm, signerCertificate, extraCandidates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="signerCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate2" RefType="out" />
        <Parameter Name="extraCandidates" Type="System.Security.Cryptography.X509Certificates.X509Certificate2Collection" />
      </Parameters>
      <Docs>
        <param name="hash">Dies ist das Kryptografiehash, das anhand dieses Zeitstempeltokens überprüft werden soll.</param>
        <param name="hashAlgorithm">Dies ist der Algorithmus, der <paramref name="hash" /> erstellt hat.</param>
        <param name="signerCertificate">Mit dieser Methode wird das Zertifikat von der TSA (Time Stamping Authority) zurückgegeben, die dieses Token signiert hat, oder <see langword="null" />, wenn ein Signaturzertifikat nicht bestimmt werden kann. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="extraCandidates">Dies ist eine optionale Auflistung von Zertifikaten, die zusätzlich zu den Zertifikaten, die in das Token eingeschlossen werden können, als TSA-Zertifikate (Time Stamping Authority) berücksichtigt werden.</param>
        <summary>Mit dieser Methode wird überprüft, ob das aktuelle Token ein gültiges Zeitstempeltoken für das bereitgestellte Datenhash und den Algorithmusbezeichner ist.</summary>
        <returns><see langword="true" /> wird ausgegeben, wenn das TSA-Zertifikat (Time Stamping Authority) gefunden wurde, der öffentliche Schlüssel des Zertifikats die Tokensignatur überprüft und das Token dem Hash für das bereitgestellte Datenhash und dem Algorithmus entspricht. Andernfalls wird <see langword="false" /> ausgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Diese Methode erfordert, dass das Zeitstempel-Autoritäts Zertifikat (1.3.6.1.5.5.7.3.8) über den erforderlichen Wert für die erweiterte Schlüssel Verwendung () verfügt, den eingebetteten esscertid-oder ESSCertID2-Bezeichner des Tokens entspricht und einen Gültigkeitsbereich hat, der den Zeitstempel des Tokens umfasst. der Wert und verfügt über einen öffentlichen Schlüssel, der die Signatur des Tokens erfolgreich überprüft.

Nachdem Sie das geeignete TSA-Zertifikat bestimmt haben, vergleicht diese Methode den bereitgestellten Digest-und Algorithmusbezeichner mit den entsprechenden Werten aus dem Token.
Wenn sowohl der Digest als auch der Algorithmus mit den Werten des Tokens identisch sind, wird das Zertifikat über das `signerCertificate` gemeldet, und die Methode gibt `true`zurück.

Wenn der Digest nicht stimmt, der Algorithmus nicht entspricht oder das TSA-Zertifikat nicht bestimmt werden konnte, meldet die Methode `signerCertificate` als `null` und gibt `false`zurück.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForData(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForHash(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.Oid,System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
      </Docs>
    </Member>
    <Member MemberName="VerifySignatureForHash">
      <MemberSignature Language="C#" Value="public bool VerifySignatureForHash (ReadOnlySpan&lt;byte&gt; hash, System.Security.Cryptography.Oid hashAlgorithmId, out System.Security.Cryptography.X509Certificates.X509Certificate2 signerCertificate, System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraCandidates = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifySignatureForHash(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; hash, class System.Security.Cryptography.Oid hashAlgorithmId, [out] class System.Security.Cryptography.X509Certificates.X509Certificate2&amp; signerCertificate, class System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraCandidates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForHash(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.Oid,System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifySignatureForHash (hash As ReadOnlySpan(Of Byte), hashAlgorithmId As Oid, ByRef signerCertificate As X509Certificate2, Optional extraCandidates As X509Certificate2Collection = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.VerifySignatureForHash : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.Oid * X509Certificate2 * System.Security.Cryptography.X509Certificates.X509Certificate2Collection -&gt; bool" Usage="rfc3161TimestampToken.VerifySignatureForHash (hash, hashAlgorithmId, signerCertificate, extraCandidates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="hashAlgorithmId" Type="System.Security.Cryptography.Oid" />
        <Parameter Name="signerCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate2" RefType="out" />
        <Parameter Name="extraCandidates" Type="System.Security.Cryptography.X509Certificates.X509Certificate2Collection" />
      </Parameters>
      <Docs>
        <param name="hash">Dies ist das Kryptografiehash, das anhand dieses Zeitstempeltokens überprüft werden soll.</param>
        <param name="hashAlgorithm">Dies ist die Darstellung des Objektbezeichners des Algorithmus, der <paramref name="hash" /> erstellt hat.</param>
        <param name="signerCertificate">Mit dieser Methode wird das Zertifikat von der TSA (Time Stamping Authority) zurückgegeben, die dieses Token signiert hat, oder <see langword="null" />, wenn ein Signaturzertifikat nicht bestimmt werden kann. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="extraCandidates">Dies ist eine optionale Auflistung von Zertifikaten, die zusätzlich zu den Zertifikaten, die in das Token eingeschlossen werden können, als TSA-Zertifikate (Time Stamping Authority) berücksichtigt werden.</param>
        <summary>Mit dieser Methode wird überprüft, ob das aktuelle Token ein gültiges Zeitstempeltoken für das bereitgestellte Datenhash und den Algorithmusbezeichner ist.</summary>
        <returns><see langword="true" /> wird ausgegeben, wenn das TSA-Zertifikat (Time Stamping Authority) gefunden wurde, der öffentliche Schlüssel des Zertifikats die Tokensignatur überprüft und das Token dem Hash für das bereitgestellte Datenhash und dem Algorithmus entspricht. Andernfalls wird <see langword="false" /> ausgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Methode erfordert, dass das TSA-Zertifikat über den erforderlichen erweiterten Schlüssel Verwendungs Wert (1.3.6.1.5.5.7.3.8) verfügt, mit dem eingebetteten esscertid-oder ESSCertID2-Bezeichner des Tokens übereinstimmt, über einen Gültigkeitsbereich verfügt, der den Zeitstempel-Wert des Tokens umfasst und über einen öffentlichen Schlüssel verfügt. , die die Signatur des Tokens erfolgreich überprüft.

Nachdem Sie das geeignete TSA-Zertifikat bestimmt haben, vergleicht diese Methode den bereitgestellten Digest-und Algorithmusbezeichner mit den entsprechenden Werten aus dem Token.
Wenn sowohl der Digest als auch der Algorithmus mit den Werten des Tokens identisch sind, wird das Zertifikat über das `signerCertificate` gemeldet, und die Methode gibt `true`zurück.

Wenn der Digest nicht stimmt, der Algorithmus nicht entspricht oder das TSA-Zertifikat nicht bestimmt werden konnte, meldet die Methode `signerCertificate` als `null` und gibt `false`zurück.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForData(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForHash(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
      </Docs>
    </Member>
    <Member MemberName="VerifySignatureForSignerInfo">
      <MemberSignature Language="C#" Value="public bool VerifySignatureForSignerInfo (System.Security.Cryptography.Pkcs.SignerInfo signerInfo, out System.Security.Cryptography.X509Certificates.X509Certificate2 signerCertificate, System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraCandidates = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifySignatureForSignerInfo(class System.Security.Cryptography.Pkcs.SignerInfo signerInfo, [out] class System.Security.Cryptography.X509Certificates.X509Certificate2&amp; signerCertificate, class System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraCandidates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForSignerInfo(System.Security.Cryptography.Pkcs.SignerInfo,System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
      <MemberSignature Language="F#" Value="member this.VerifySignatureForSignerInfo : System.Security.Cryptography.Pkcs.SignerInfo * X509Certificate2 * System.Security.Cryptography.X509Certificates.X509Certificate2Collection -&gt; bool" Usage="rfc3161TimestampToken.VerifySignatureForSignerInfo (signerInfo, signerCertificate, extraCandidates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signerInfo" Type="System.Security.Cryptography.Pkcs.SignerInfo" />
        <Parameter Name="signerCertificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate2" RefType="out" />
        <Parameter Name="extraCandidates" Type="System.Security.Cryptography.X509Certificates.X509Certificate2Collection" />
      </Parameters>
      <Docs>
        <param name="signerInfo">Dies sind Informationen zum CMS-Signaturgeber, der überprüft werden soll und für den der Zeitstempel erstellt wurde.</param>
        <param name="signerCertificate">Mit dieser Methode wird das Zertifikat von der TSA (Time Stamping Authority) zurückgegeben, die dieses Token signiert hat, oder <see langword="null" />, wenn ein Signaturzertifikat nicht bestimmt werden kann. Dieser Parameter wird nicht initialisiert behandelt.</param>
        <param name="extraCandidates">Dies ist eine optionale Auflistung von Zertifikaten, die zusätzlich zu den Zertifikaten, die in das Token eingeschlossen werden können, als TSA-Zertifikate (Time Stamping Authority) berücksichtigt werden.</param>
        <summary>Mit dieser Methode wird überprüft, ob das aktuelle Token ein gültiges Zeitstempeltoken für die <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" />-Klasse ist.</summary>
        <returns><see langword="true" /> wird ausgegeben, wenn das TSA-Zertifikat (Time Stamping Authority) gefunden wurde, der öffentliche Schlüssel des Zertifikats die Tokensignatur überprüft und das Token der Signatur für <paramref name="signerInfo" /> entspricht. Andernfalls wird <see langword="false" /> ausgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
Diese Methode überprüft, ob das Zeitstempel Token für eine CMS (Cryptographic Message Syntax)-<xref:System.Security.Cryptography.Pkcs.SignerInfo>gemäß IETF RFC 3161 Anhang a (Signatur-Zeitstempel Attribut mit CMS) gültig ist.

Diese Methode erfordert, dass das TSA-Zertifikat über den erforderlichen erweiterten Schlüssel Verwendungs Wert (1.3.6.1.5.5.7.3.8) verfügt, mit dem eingebetteten esscertid-oder ESSCertID2-Bezeichner des Tokens übereinstimmt, über einen Gültigkeitsbereich verfügt, der den Zeitstempel-Wert des Tokens umfasst und über einen öffentlichen Schlüssel verfügt. , die die Signatur des Tokens erfolgreich überprüft.

Nachdem Sie das geeignete TSA-Zertifikat bestimmt haben, bestimmt diese Methode, ob der Signatur Wert aus dem bereitgestellten `signerInfo` mit dem Digest-und Algorithmusbezeichner aus dem Token übereinstimmt.
Wenn die `signerInfo` Signatur mit dem Digest-und Algorithmusbezeichner des Tokens übereinstimmt, wird das Zertifikat über die `signerCertificate` gemeldet, und die Methode gibt `true`zurück.

Wenn die `signerInfo` Signatur nicht stimmt oder das TSA-Zertifikat nicht ermittelt werden konnte, meldet die Methode `signerCertificate` als `null` und gibt `false`zurück.

Diese Methode übernimmt nicht die <xref:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes> der zu berücksichtigenden `signerInfo`, und es wird nicht ermittelt, ob die `signerInfo` Signatur für die Daten geeignet ist, die von den Signaturen signiert wurden.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="signerInfo" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForData(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken.VerifySignatureForHash(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.Oid,System.Security.Cryptography.X509Certificates.X509Certificate2@,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
      </Docs>
    </Member>
  </Members>
</Type>
