<Type Name="Rfc3161TimestampRequest" FullName="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="989df94de40e5fc7d7fecefb404233c20e8ae8ac" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82407086" /></Metadata><TypeSignature Language="C#" Value="public sealed class Rfc3161TimestampRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Rfc3161TimestampRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Rfc3161TimestampRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class Rfc3161TimestampRequest sealed" />
  <TypeSignature Language="F#" Value="type Rfc3161TimestampRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.1</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt eine Zeitstempelanforderung aus IETF RFC 3161 dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
Diese Klasse ermöglicht die Erstellung und Überprüfung von `TimeStampReq` Werten gemäß der Definition durch IETF RFC 3161: Internet X. 509 Public Key Infrastructure Zeitstempel Protokoll (TSP).
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateFromData">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromData (ReadOnlySpan&lt;byte&gt; data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.Oid requestedPolicyId = default, ReadOnlyMemory&lt;byte&gt;? nonce = default, bool requestSignerCertificates = false, System.Security.Cryptography.X509Certificates.X509ExtensionCollection extensions = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromData(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, class System.Security.Cryptography.Oid requestedPolicyId, valuetype System.Nullable`1&lt;valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&gt; nonce, bool requestSignerCertificates, class System.Security.Cryptography.X509Certificates.X509ExtensionCollection extensions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromData(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.Boolean,System.Security.Cryptography.X509Certificates.X509ExtensionCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromData (data As ReadOnlySpan(Of Byte), hashAlgorithm As HashAlgorithmName, Optional requestedPolicyId As Oid = null, Optional nonce As Nullable(Of ReadOnlyMemory(Of Byte)) = null, Optional requestSignerCertificates As Boolean = false, Optional extensions As X509ExtensionCollection = null) As Rfc3161TimestampRequest" />
      <MemberSignature Language="F#" Value="static member CreateFromData : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.Oid * Nullable&lt;ReadOnlyMemory&lt;byte&gt;&gt; * bool * System.Security.Cryptography.X509Certificates.X509ExtensionCollection -&gt; System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromData (data, hashAlgorithm, requestedPolicyId, nonce, requestSignerCertificates, extensions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="requestedPolicyId" Type="System.Security.Cryptography.Oid" />
        <Parameter Name="nonce" Type="System.Nullable&lt;System.ReadOnlyMemory&lt;System.Byte&gt;&gt;" />
        <Parameter Name="requestSignerCertificates" Type="System.Boolean" />
        <Parameter Name="extensions" Type="System.Security.Cryptography.X509Certificates.X509ExtensionCollection" />
      </Parameters>
      <Docs>
        <param name="data">Die mit dem Zeitstempel zu versehenden Daten, für die von dieser Methode ein Hashwert berechnet wird.</param>
        <param name="hashAlgorithm">Der mit dieser Zeitstempelanforderung zu verwendende Hashalgorithmus.</param>
        <param name="requestedPolicyId">Der Objektbezeichner (OID) für eine Zeitstempelrichtlinie, die den Timestamp Authority (TSA) verwenden soll, oder <see langword="null" />, um keine Einstellung auszudrücken.</param>
        <param name="nonce">Eine optionale Nonce (einmal verwendete Zahl) zur eindeutigen Identifizierung dieser Anforderung, um sie mit der Antwort zu koppeln. Der Wert wird als vorzeichenlose Big-Endian-Ganzzahl interpretiert und kann auf das Codierungsformat normiert werden.</param>
        <param name="requestSignerCertificates"><see langword="true" />, um anzugeben, dass die Timestamp Authority (TSA) das Signaturzertifikat in das ausgestellte Zeitstempeltoken aufnehmen muss, ansonsten <see langword="false" />.</param>
        <param name="extensions">Eine optionale Auflistung von Erweiterungen, die in die Anforderung aufgenommen werden sollen.</param>
        <summary>Erstellt eine Zeitstempelanforderung, indem für die angegebenen Daten mit einem angegebenen Algorithmus ein Hashwert berechnet wird.</summary>
        <returns>Eine <see cref="T:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest" />, die die ausgewählten Werte darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Kryptografietimestamps werden immer auf eine Kombination aus dem Hashwert der Daten und dem Algorithmusbezeichner für den Hash Algorithmus angewendet, der zum Hash der Daten verwendet wird.
Diese Methode stellt eine bequeme Alternative zum <xref:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromHash(System.ReadOnlyMemory{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.Boolean,System.Security.Cryptography.X509Certificates.X509ExtensionCollection)> dar, wenn nicht bereits ein Hashwert für die Daten vorhanden ist.

Der Nonce-Wert in dieser Methode wird als unsigned Big-Endian-Ganzzahl behandelt.
Diese Methode normalisiert die Eingabe zu einer ber-Ganzzahl-Codierung, bevor der Nonce-Wert zugewiesen wird.
Der normalisierte Wert wird von der <xref:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.GetNonce>-Methode zurückgegeben.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="hashAlgorithm" /> ist kein bekannter Hashalgorithmus.</exception>
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromHash(System.ReadOnlyMemory{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.Boolean,System.Security.Cryptography.X509Certificates.X509ExtensionCollection)" />
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromSignerInfo(System.Security.Cryptography.Pkcs.SignerInfo,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.Boolean,System.Security.Cryptography.X509Certificates.X509ExtensionCollection)" />
      </Docs>
    </Member>
    <Member MemberName="CreateFromHash">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromHash (ReadOnlyMemory&lt;byte&gt; hash, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.Oid requestedPolicyId = default, ReadOnlyMemory&lt;byte&gt;? nonce = default, bool requestSignerCertificates = false, System.Security.Cryptography.X509Certificates.X509ExtensionCollection extensions = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromHash(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; hash, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, class System.Security.Cryptography.Oid requestedPolicyId, valuetype System.Nullable`1&lt;valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&gt; nonce, bool requestSignerCertificates, class System.Security.Cryptography.X509Certificates.X509ExtensionCollection extensions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromHash(System.ReadOnlyMemory{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.Boolean,System.Security.Cryptography.X509Certificates.X509ExtensionCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromHash (hash As ReadOnlyMemory(Of Byte), hashAlgorithm As HashAlgorithmName, Optional requestedPolicyId As Oid = null, Optional nonce As Nullable(Of ReadOnlyMemory(Of Byte)) = null, Optional requestSignerCertificates As Boolean = false, Optional extensions As X509ExtensionCollection = null) As Rfc3161TimestampRequest" />
      <MemberSignature Language="F#" Value="static member CreateFromHash : ReadOnlyMemory&lt;byte&gt; * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.Oid * Nullable&lt;ReadOnlyMemory&lt;byte&gt;&gt; * bool * System.Security.Cryptography.X509Certificates.X509ExtensionCollection -&gt; System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromHash (hash, hashAlgorithm, requestedPolicyId, nonce, requestSignerCertificates, extensions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="requestedPolicyId" Type="System.Security.Cryptography.Oid" />
        <Parameter Name="nonce" Type="System.Nullable&lt;System.ReadOnlyMemory&lt;System.Byte&gt;&gt;" />
        <Parameter Name="requestSignerCertificates" Type="System.Boolean" />
        <Parameter Name="extensions" Type="System.Security.Cryptography.X509Certificates.X509ExtensionCollection" />
      </Parameters>
      <Docs>
        <param name="hash">Der mit einem Zeitstempel zu versehene vorab berechnete Hashwert.</param>
        <param name="hashAlgorithm">Der zum Erzeugen von <paramref name="hash" /> verwendete Hashalgorithmus.</param>
        <param name="requestedPolicyId">Der Objektbezeichner (OID) für die Zeitstempelrichtlinie, die die Timestamp Authority (TSA) verwenden soll, oder <see langword="null" />, um keine Einstellung auszudrücken.</param>
        <param name="nonce">Ein optionaler Wert, der verwendet wird, um eine Anforderung einer Antwort eindeutig zuzuordnen, oder <see langword="null" />, damit keine Nonce in die Anforderung aufgenommen wird.</param>
        <param name="requestSignerCertificates"><see langword="true" />, um anzugeben, dass die Timestamp Authority (TSA) das Signaturzertifikat in das ausgestellte Zeitstempeltoken aufnehmen muss, ansonsten <see langword="false" />.</param>
        <param name="extensions">Eine optionale Auflistung von Erweiterungen, die in die Anforderung aufgenommen werden sollen.</param>
        <summary>Erstellen Sie eine Zeitstempelanforderung mit einem vorab berechneten Hashwert und dem Namen des Hashalgorithmus.</summary>
        <returns>Eine <see cref="T:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest" />, die die ausgewählten Werte darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Diese Methode verwendet den `hashAlgorithm`-Parameter, um den Objekt Bezeichner (OID) zu bestimmen, der in die Zeitstempel-Anforderung aufgenommen werden soll.
Wenn Sie eine Anforderung für einen Zeitstempel basierend auf einem Hash Algorithmus, der von dieser Methode nicht unterstützt wird, aufbauen, verwenden Sie die <xref:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromHash(System.ReadOnlyMemory{System.Byte},System.Security.Cryptography.Oid,System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.Boolean,System.Security.Cryptography.X509Certificates.X509ExtensionCollection)> Überladung.

Der Nonce-Wert in dieser Methode wird als unsigned Big-Endian-Ganzzahl behandelt.
Diese Methode normalisiert die Eingabe zu einer ber-Ganzzahl-Codierung, bevor der Nonce-Wert zugewiesen wird.
Der normalisierte Wert wird von der <xref:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.GetNonce>-Methode zurückgegeben.

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="hashAlgorithm" /> ist kein bekannter Hashalgorithmus.</exception>
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromData(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.Boolean,System.Security.Cryptography.X509Certificates.X509ExtensionCollection)" />
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromHash(System.ReadOnlyMemory{System.Byte},System.Security.Cryptography.Oid,System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.Boolean,System.Security.Cryptography.X509Certificates.X509ExtensionCollection)" />
      </Docs>
    </Member>
    <Member MemberName="CreateFromHash">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromHash (ReadOnlyMemory&lt;byte&gt; hash, System.Security.Cryptography.Oid hashAlgorithmId, System.Security.Cryptography.Oid requestedPolicyId = default, ReadOnlyMemory&lt;byte&gt;? nonce = default, bool requestSignerCertificates = false, System.Security.Cryptography.X509Certificates.X509ExtensionCollection extensions = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromHash(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; hash, class System.Security.Cryptography.Oid hashAlgorithmId, class System.Security.Cryptography.Oid requestedPolicyId, valuetype System.Nullable`1&lt;valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&gt; nonce, bool requestSignerCertificates, class System.Security.Cryptography.X509Certificates.X509ExtensionCollection extensions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromHash(System.ReadOnlyMemory{System.Byte},System.Security.Cryptography.Oid,System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.Boolean,System.Security.Cryptography.X509Certificates.X509ExtensionCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromHash (hash As ReadOnlyMemory(Of Byte), hashAlgorithmId As Oid, Optional requestedPolicyId As Oid = null, Optional nonce As Nullable(Of ReadOnlyMemory(Of Byte)) = null, Optional requestSignerCertificates As Boolean = false, Optional extensions As X509ExtensionCollection = null) As Rfc3161TimestampRequest" />
      <MemberSignature Language="F#" Value="static member CreateFromHash : ReadOnlyMemory&lt;byte&gt; * System.Security.Cryptography.Oid * System.Security.Cryptography.Oid * Nullable&lt;ReadOnlyMemory&lt;byte&gt;&gt; * bool * System.Security.Cryptography.X509Certificates.X509ExtensionCollection -&gt; System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromHash (hash, hashAlgorithmId, requestedPolicyId, nonce, requestSignerCertificates, extensions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="hashAlgorithmId" Type="System.Security.Cryptography.Oid" />
        <Parameter Name="requestedPolicyId" Type="System.Security.Cryptography.Oid" />
        <Parameter Name="nonce" Type="System.Nullable&lt;System.ReadOnlyMemory&lt;System.Byte&gt;&gt;" />
        <Parameter Name="requestSignerCertificates" Type="System.Boolean" />
        <Parameter Name="extensions" Type="System.Security.Cryptography.X509Certificates.X509ExtensionCollection" />
      </Parameters>
      <Docs>
        <param name="hash">Der mit einem Zeitstempel zu versehene vorab berechnete Hashwert.</param>
        <param name="hashAlgorithmId">Der Objektbezeichner (OID) für den Hashalgorithmus, der <paramref name="hash" /> erzeugt hat.</param>
        <param name="requestedPolicyId">Der Objektbezeichner (OID) für eine Zeitstempelrichtlinie, die den Timestamp Authority (TSA) verwenden soll, oder <see langword="null" />, um keine Einstellung auszudrücken.</param>
        <param name="nonce">Eine optionale Nonce (einmal verwendete Zahl) zur eindeutigen Identifizierung dieser Anforderung, um sie mit der Antwort zu koppeln. Der Wert wird als vorzeichenlose Big-Endian-Ganzzahl interpretiert und kann auf das Codierungsformat normiert werden.</param>
        <param name="requestSignerCertificates"><see langword="true" />, um anzugeben, dass die Timestamp Authority (TSA) das Signaturzertifikat in das ausgestellte Zeitstempeltoken aufnehmen muss, ansonsten <see langword="false" />.</param>
        <param name="extensions">Eine optionale Auflistung von Erweiterungen, die in die Anforderung aufgenommen werden sollen.</param>
        <summary>Erstellen Sie eine Zeitstempelanforderung mit einem vorab berechneten Hashwert und dem Objektbezeichner für den Hashalgorithmus.</summary>
        <returns>Eine <see cref="T:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest" />, die die ausgewählten Werte darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Der Nonce-Wert in dieser Methode wird als unsigned Big-Endian-Ganzzahl behandelt.
Diese Methode normalisiert die Eingabe zu einer ber-Ganzzahl-Codierung, bevor der Nonce-Wert zugewiesen wird.
Der normalisierte Wert wird von der <xref:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.GetNonce>-Methode zurückgegeben.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hashAlgorithmId" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="hashAlgorithmId" />.<see cref="P:System.Security.Cryptography.Oid.Value" /> ist keine gültige OID.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromSignerInfo">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromSignerInfo (System.Security.Cryptography.Pkcs.SignerInfo signerInfo, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.Oid requestedPolicyId = default, ReadOnlyMemory&lt;byte&gt;? nonce = default, bool requestSignerCertificates = false, System.Security.Cryptography.X509Certificates.X509ExtensionCollection extensions = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest CreateFromSignerInfo(class System.Security.Cryptography.Pkcs.SignerInfo signerInfo, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, class System.Security.Cryptography.Oid requestedPolicyId, valuetype System.Nullable`1&lt;valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&gt; nonce, bool requestSignerCertificates, class System.Security.Cryptography.X509Certificates.X509ExtensionCollection extensions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromSignerInfo(System.Security.Cryptography.Pkcs.SignerInfo,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.Boolean,System.Security.Cryptography.X509Certificates.X509ExtensionCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromSignerInfo (signerInfo As SignerInfo, hashAlgorithm As HashAlgorithmName, Optional requestedPolicyId As Oid = null, Optional nonce As Nullable(Of ReadOnlyMemory(Of Byte)) = null, Optional requestSignerCertificates As Boolean = false, Optional extensions As X509ExtensionCollection = null) As Rfc3161TimestampRequest" />
      <MemberSignature Language="F#" Value="static member CreateFromSignerInfo : System.Security.Cryptography.Pkcs.SignerInfo * System.Security.Cryptography.HashAlgorithmName * System.Security.Cryptography.Oid * Nullable&lt;ReadOnlyMemory&lt;byte&gt;&gt; * bool * System.Security.Cryptography.X509Certificates.X509ExtensionCollection -&gt; System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromSignerInfo (signerInfo, hashAlgorithm, requestedPolicyId, nonce, requestSignerCertificates, extensions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signerInfo" Type="System.Security.Cryptography.Pkcs.SignerInfo" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="requestedPolicyId" Type="System.Security.Cryptography.Oid" />
        <Parameter Name="nonce" Type="System.Nullable&lt;System.ReadOnlyMemory&lt;System.Byte&gt;&gt;" />
        <Parameter Name="requestSignerCertificates" Type="System.Boolean" />
        <Parameter Name="extensions" Type="System.Security.Cryptography.X509Certificates.X509ExtensionCollection" />
      </Parameters>
      <Docs>
        <param name="signerInfo">Die Informationen des CMS-Signierers, für den eine Zeitstempelanforderung erstellt werden soll.</param>
        <param name="hashAlgorithm">Der mit dieser Zeitstempelanforderung zu verwendende Hashalgorithmus.</param>
        <param name="requestedPolicyId">Der Objektbezeichner (OID) für die Zeitstempelrichtlinie, die die Timestamp Authority (TSA) verwenden soll, oder <see langword="null" />, um keine Einstellung auszudrücken.</param>
        <param name="nonce">Eine optionale Nonce (einmal verwendete Zahl) zur eindeutigen Identifizierung dieser Anforderung, um sie mit der Antwort zu koppeln. Der Wert wird als vorzeichenlose Big-Endian-Ganzzahl interpretiert und kann auf das Codierungsformat normiert werden.</param>
        <param name="requestSignerCertificates"><see langword="true" />, um anzugeben, dass die Timestamp Authority (TSA) das Signaturzertifikat in das ausgestellte Zeitstempeltoken aufnehmen muss, ansonsten <see langword="false" />.</param>
        <param name="extensions">Eine optionale Auflistung von Erweiterungen, die in die Anforderung aufgenommen werden sollen.</param>
        <summary>Erstellt eine Zeitstempelanforderung, indem für die Signatur des angegebenen Signierers mit einem angegebenen Algorithmus ein Hashwert berechnet wird.</summary>
        <returns>Eine <see cref="T:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest" />, die die ausgewählten Werte darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Dieser Konstruktor erstellt einen Zeitstempel für den Signatur Wert eines <xref:System.Security.Cryptography.Pkcs.SignerInfo> Werts gemäß der Empfehlung von IETF RFC 3161 Anhang a (Signatur-Zeitstempel Attribut mithilfe von CMS).

Der Nonce-Wert in dieser Methode wird als unsigned Big-Endian-Ganzzahl behandelt.
Diese Methode normalisiert die Eingabe zu einer ber-Ganzzahl-Codierung, bevor der Nonce-Wert zugewiesen wird.
Der normalisierte Wert wird von der <xref:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.GetNonce>-Methode zurückgegeben.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="signerInfo" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> ist <see langword="null" /> oder <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="hashAlgorithm" /> ist kein bekannter Hashalgorithmus.</exception>
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.CreateFromData(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.Boolean,System.Security.Cryptography.X509Certificates.X509ExtensionCollection)" />
      </Docs>
    </Member>
    <Member MemberName="Encode">
      <MemberSignature Language="C#" Value="public byte[] Encode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Encode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.Encode" />
      <MemberSignature Language="VB.NET" Value="Public Function Encode () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Encode();" />
      <MemberSignature Language="F#" Value="member this.Encode : unit -&gt; byte[]" Usage="rfc3161TimestampRequest.Encode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Codiert die Zeitstempelanforderung und gibt sie als Bytearray zurück.</summary>
        <returns>Ein Bytearray, das die DER-codierte Zeitstempelanforderung enthält.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.TryDecode(System.ReadOnlyMemory{System.Byte},System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest@,System.Int32@)" />
        <altmember cref="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.TryEncode(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="GetExtensions">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509ExtensionCollection GetExtensions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509ExtensionCollection GetExtensions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.GetExtensions" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExtensions () As X509ExtensionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509ExtensionCollection ^ GetExtensions();" />
      <MemberSignature Language="F#" Value="member this.GetExtensions : unit -&gt; System.Security.Cryptography.X509Certificates.X509ExtensionCollection" Usage="rfc3161TimestampRequest.GetExtensions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ExtensionCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Auflistung mit einer Kopie der in dieser Anforderung vorhandenen Erweiterungen ab.</summary>
        <returns>Eine Auflistung mit einer Kopie der in dieser Anforderung vorhandenen Erweiterungen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Die Auflistung, die von dieser Methode zurückgegeben wird, stellt eine Momentaufnahme der Daten dar.
Keine Änderung der Auflistung oder einer Instanz innerhalb der Auflistung führt zu einer Änderung in dieser Instanz.

Diese Methode gibt eine leere Auflistung zurück, wenn Sie über keine Erweiterungen verfügt.
Um die Objekt Erstellung in diesem gängigen Szenario zu vermeiden, lesen Sie <xref:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.HasExtensions>.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageHash">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; GetMessageHash ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; GetMessageHash() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.GetMessageHash" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageHash () As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyMemory&lt;System::Byte&gt; GetMessageHash();" />
      <MemberSignature Language="F#" Value="member this.GetMessageHash : unit -&gt; ReadOnlyMemory&lt;byte&gt;" Usage="rfc3161TimestampRequest.GetMessageHash " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Datenhash für diese Zeitstempelanforderung ab.</summary>
        <returns>Der Datenhash für diese Zeitstempelanforderung als schreibgeschützter Arbeitsspeicherwert.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNonce">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt;? GetNonce ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&gt; GetNonce() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.GetNonce" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNonce () As Nullable(Of ReadOnlyMemory(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;ReadOnlyMemory&lt;System::Byte&gt;&gt; GetNonce();" />
      <MemberSignature Language="F#" Value="member this.GetNonce : unit -&gt; Nullable&lt;ReadOnlyMemory&lt;byte&gt;&gt;" Usage="rfc3161TimestampRequest.GetNonce " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.ReadOnlyMemory&lt;System.Byte&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Nonce für diese Zeitstempelanforderung ab.</summary>
        <returns>Die Nonce für diese Zeitstempelanforderung als schreibgeschützter Arbeitsspeicherwert, wenn eine vorhanden war. Andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasExtensions">
      <MemberSignature Language="C#" Value="public bool HasExtensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExtensions" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.HasExtensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExtensions As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExtensions { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExtensions : bool" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.HasExtensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zeigt an, ob die Anforderung eine Erweiterung besitzt oder nicht.</summary>
        <value><see langword="true" />, wenn die Anforderung über Erweiterungen verfügt. Andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithmId">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Oid HashAlgorithmId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Oid HashAlgorithmId" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.HashAlgorithmId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HashAlgorithmId As Oid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Oid ^ HashAlgorithmId { System::Security::Cryptography::Oid ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithmId : System.Security.Cryptography.Oid" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.HashAlgorithmId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Oid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Objektbezeichner (OID) für den der Anforderung zugeordneten Hashalgorithmus ab.</summary>
        <value>Der Objekt Bezeichner (OID) für den Hash Algorithmus, der der Anforderung zugeordnet ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessResponse">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Pkcs.Rfc3161TimestampToken ProcessResponse (ReadOnlyMemory&lt;byte&gt; responseBytes, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.Pkcs.Rfc3161TimestampToken ProcessResponse(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; responseBytes, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.ProcessResponse(System.ReadOnlyMemory{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ProcessResponse (responseBytes As ReadOnlyMemory(Of Byte), ByRef bytesConsumed As Integer) As Rfc3161TimestampToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::Pkcs::Rfc3161TimestampToken ^ ProcessResponse(ReadOnlyMemory&lt;System::Byte&gt; responseBytes, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="member this.ProcessResponse : ReadOnlyMemory&lt;byte&gt; * int -&gt; System.Security.Cryptography.Pkcs.Rfc3161TimestampToken" Usage="rfc3161TimestampRequest.ProcessResponse (responseBytes, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.Rfc3161TimestampToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="responseBytes" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="responseBytes">Die DER-codierte Zeitstempelantwort.</param>
        <param name="bytesConsumed">Mit dieser Methode wird die Anzahl der Bytes zurückgegeben, die aus <paramref name="responseBytes" /> gelesen wurden. Dieser Parameter wird als nicht initialisiert behandelt.</param>
        <summary>Kombiniert eine codierte Zeitstempelantwort mit dieser Anforderung, um eine <see cref="T:System.Security.Cryptography.Pkcs.Rfc3161TimestampToken" /> zu erzeugen.</summary>
        <returns>Das Zeitstempeltoken aus der Antwort, das dieser Anforderung entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Diese Methode interpretiert den Anfang `responseBytes` als IETF RFC 3161-`TimeStampResp`.
Wenn die Antwort nicht decodiert werden kann, lautet der Antwortstatus nicht `granted` oder `grantedWithMods`, das ausgegebene Zeitstempel Token kann nicht erfolgreich decodiert werden, oder das Zeitstempel-Token entspricht dieser Anforderung nicht gemäß den Akzeptanz Kriterien von IETF RFC 3161 (vor allem Abschnitte 2.4.1 und 2.4.2), dann wird ein <xref:System.Security.Cryptography.CryptographicException> ausgelöst.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestedPolicyId">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Oid RequestedPolicyId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Oid RequestedPolicyId" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.RequestedPolicyId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestedPolicyId As Oid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Oid ^ RequestedPolicyId { System::Security::Cryptography::Oid ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestedPolicyId : System.Security.Cryptography.Oid" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.RequestedPolicyId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Oid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Richtlinien-ID für die Anforderung ab oder <see langword="null" />, wenn keine Richtlinien-ID angefordert wurde.</summary>
        <value>Die Richtlinien-ID für die Anforderung oder <see langword="null" />, wenn keine Richtlinien-ID angefordert wurde.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestSignerCertificate">
      <MemberSignature Language="C#" Value="public bool RequestSignerCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RequestSignerCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.RequestSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestSignerCertificate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RequestSignerCertificate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestSignerCertificate : bool" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.RequestSignerCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der anzeigt, ob die Anforderung angegeben hat, dass das Zeitstempel-Autoritätszertifikat in der Antwort vorhanden sein muss.</summary>
        <value><see langword="true" />, wenn die Antwort das Zeitstempel Zertifizierungsstellen-Zertifikat enthalten muss. Andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDecode">
      <MemberSignature Language="C#" Value="public static bool TryDecode (ReadOnlyMemory&lt;byte&gt; encodedBytes, out System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest request, out int bytesConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryDecode(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; encodedBytes, [out] class System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest&amp; request, [out] int32&amp; bytesConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.TryDecode(System.ReadOnlyMemory{System.Byte},System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryDecode (encodedBytes As ReadOnlyMemory(Of Byte), ByRef request As Rfc3161TimestampRequest, ByRef bytesConsumed As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryDecode(ReadOnlyMemory&lt;System::Byte&gt; encodedBytes, [Runtime::InteropServices::Out] System::Security::Cryptography::Pkcs::Rfc3161TimestampRequest ^ % request, [Runtime::InteropServices::Out] int % bytesConsumed);" />
      <MemberSignature Language="F#" Value="static member TryDecode : ReadOnlyMemory&lt;byte&gt; * Rfc3161TimestampRequest * int -&gt; bool" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.TryDecode (encodedBytes, request, bytesConsumed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encodedBytes" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="request" Type="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest" RefType="out" />
        <Parameter Name="bytesConsumed" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="encodedBytes">Der Puffer, der eine DER-codierte Zeitstempelanforderung enthält.</param>
        <param name="request">Mit dieser Methode wird die erfolgreich decodierte Zeitstempelanforderung zurückgegeben, falls die Decodierung erfolgreich war, oder <see langword="null" />, wenn die Decodierung fehlgeschlagen ist. Dieser Parameter wird als nicht initialisiert behandelt.</param>
        <param name="bytesConsumed">Mit dieser Methode wird die Anzahl der Bytes zurückgegeben, die aus <paramref name="encodedBytes" /> gelesen wurden. Dieser Parameter wird als nicht initialisiert behandelt.</param>
        <summary>Versucht, den Inhalt von <paramref name="encodedBytes" /> als DER-codierten Zeitstempelanforderung zu interpretieren.</summary>
        <returns><see langword="true" />, wenn <paramref name="encodedBytes" /> erfolgreich als Zeitstempelanforderung interpretiert wurde. Andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEncode">
      <MemberSignature Language="C#" Value="public bool TryEncode (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncode(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.TryEncode(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEncode (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncode(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncode : Span&lt;byte&gt; * int -&gt; bool" Usage="rfc3161TimestampRequest.TryEncode (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">Der Puffer, der die codierte Anforderung empfangen soll.</param>
        <param name="bytesWritten">Nach Ausführung dieser Methode die Gesamtzahl der in <paramref name="destination" /> geschriebenen Bytes. Dieser Parameter wird als nicht initialisiert behandelt.</param>
        <summary>Versucht, die Instanz als <c>TimeStampReq</c> aus IETF RFC 3161 zu codieren, wobei die Bytes in den bereitgestellten Puffer geschrieben werden.</summary>
        <returns><see langword="true" />, wenn <paramref name="destination" /> zum Empfangen der codierten Anforderung lang genug ist. Andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public int Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Version" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Version { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : int" Usage="System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Versionsnummer des Datenformats für diese Anforderung ab.</summary>
        <value>Die Versionsnummer des Datenformats für diese Anforderung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
