<Type Name="ResourceManager" FullName="System.Resources.ResourceManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1f4576691fe95ae036b83eb8f7fd45935ddefe96" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58729896" /></Metadata><TypeSignature Language="C#" Value="public class ResourceManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ResourceManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceManager" />
  <TypeSignature Language="F#" Value="type ResourceManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-1.0;netstandard-1.1;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
      <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Ressourcen-Manager dar, der einfachen Zugriff auf kulturabhängige Ressourcen zur Laufzeit ermöglicht.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 Die <xref:System.Resources.ResourceManager> Klasse entnimmt Ressourcen eine binäre RESOURCES-Datei, die in einer Assembly eingebettet ist oder eigenständige RESOURCES-Datei. Wenn eine app lokalisiert wurde und lokalisierte Ressourcen bereitgestellt worden [Satellitenassemblys](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md), es kulturabhängige Ressourcen sucht, bietet Sie Ressourcenfallback aus, wenn eine lokalisierte Ressource ist nicht vorhanden, und Resource unterstützt die Serialisierung.  
  
 Weitere Informationen zum Erstellen und Verwalten von Ressourcen in desktop-apps und [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -apps finden Sie unter den folgenden Abschnitten:  
  
-   [Desktop-Apps](#desktop)  
  
    -   [Erstellen von Ressourcen](#creating_resources)  
  
    -   [Instanziieren eines ResourceManager-Objekts](#instantiating)  
  
    -   [ResourceManager und kulturspezifische Ressourcen](#CultureSpecific)  
  
    -   [Abrufen von Ressourcen](#retrieving)  
  
    -   [Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen](#exception)  
  
    -   [Ressourcenversionsverwaltung](#versioning)  
  
    -   [\<Satelliteassemblies > Knoten "Datei"](#config)  
  
-   [Windows Store-Apps](#ws)  
  
<a name="desktop"></a>   
## <a name="desktop-apps"></a>Desktop-Apps  
 Für desktop-apps die <xref:System.Resources.ResourceManager> Klasse ruft Ressourcen aus binäre Ressourcendateien (.resources). In der Regel einen Sprachcompiler oder [Assembly Linker (AL.exe)](~/docs/framework/tools/al-exe-assembly-linker.md) diese Ressourcendateien in einer Assembly eingebettet werden können. Sie können auch eine <xref:System.Resources.ResourceManager> Objekt, das Abrufen von Ressourcen direkt aus einer RESOURCES-Datei, die nicht in einer Assembly, durch den Aufruf eingebettet ist der <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> Methode.  
  
> [!CAUTION]
>  Mit eigenständigen Ressourcendateien in einer ASP.NET-Anwendung unterbricht die XCOPY-Bereitstellung, da die Ressourcen gesperrt bleiben, bis sie explizit, indem freigegeben werden die <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> Methode. Wenn Sie Ressourcen mit ASP.NET-Anwendungen bereitstellen möchten, sollten Sie die RESOURCES-Dateien in Satellitenassemblys kompilieren.  
  
 In einer app-basierten Ressource enthält eine RESOURCES-Datei die Ressourcen der Standardkultur, deren Ressourcen verwendet werden, wenn keine kulturspezifischen Ressourcen gefunden werden können. Z. B. wenn Standardkultur einer app Englisch (En) ist, werden die Sprachressourcen für Englisch verwendet, wenn lokalisierte Ressourcen für eine bestimmte Kultur, z. B. Englisch (USA) (En-US) oder Französisch (Frankreich) (fr-FR) gefunden werden können. Klicken Sie in der Regel die Ressourcen der Standardkultur in die Haupt-app-Assembly eingebettet werden, und Ressourcen für andere lokalisierten Kulturen werden in Satellitenassemblys eingebettet. Satellitenassemblys werden nur Ressourcen enthalten. Sie haben den gleichen stammdateinamen wie die Haupt-Assembly und der Erweiterung. resources.dll. Für apps, deren Assemblys nicht im globalen Assemblycache registriert sind, werden Satellitenassemblys in eine app-Unterverzeichnis gespeichert, dessen Name der Assembly Kultur entspricht.  
  
<a name="creating_resources"></a>   
### <a name="creating-resources"></a>Erstellen von Ressourcen  
 Wenn Sie eine Ressource-basierte Anwendung entwickeln, speichern Sie Informationen zu Ressourcen in Textdateien (Dateien, die eine Erweiterung ".txt" oder ".restext") oder XML-Dateien (Dateien, die Erweiterung ".resx"). Kompilieren Sie dann den Text oder XML-Dateien mit der [Resource File Generator (Resgen.exe)](~/docs/framework/tools/resgen-exe-resource-file-generator.md) eine binäre RESOURCES-Datei erstellen. Anschließend können Sie die resultierende RESOURCES-Datei in eine ausführbare Datei oder einbetten, wie z. B. mithilfe einer Compileroption `/resources` für die C#- und Visual Basic-Compiler, oder Sie es in eine Satellitenassembly mit einbetten können die. Wenn Sie eine RESX-Datei in Visual Studio-Projekts einschließen, wird Visual Studio kümmert sich um die Kompilierung und Einbetten von standardmäßigen und lokalisierte Ressourcen automatisch als Teil des Buildprozesses.  
  
 Im Idealfall, erstellen Sie Ressourcen für jede Sprache Ihre app unterstützt, oder zumindest für eine sinnvolle Teilmenge der einzelnen Sprachen. Die binäre RESOURCES-Dateinamen folgen der Namenskonvention *Basename*. *CultureName*Resources, wobei *Basename* ist der Name der app oder den Namen einer Klasse, je nach der gewünschten Detailebene. Die <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType> Eigenschaft wird verwendet, um zu bestimmen, *CultureName*. Eine Ressource für die Standardkultur der app heißen *Basename*Resources.  
  
 Nehmen wir beispielsweise an, dass eine Assembly in einer Ressourcendatei verfügt über mehrere Ressourcen, die den Basisnamen MyResources verfügt. Diese Ressourcendateien müssen die Namen z. B. MyResources.ja-JP.resources für die Kultur Japan (Japanisch) MyResources.de.resources für die deutschen Kultur MyResources.zh-CHS.resources für die Kultur für vereinfachtes Chinesisch, und MyResources.fr-BE.resources für die Kultur Französisch (Belgien). Die Ressourcendatei sollten MyResources.resources benannt werden. Die kulturspezifischen Ressourcendateien werden häufig in Satellitenassemblys für jede Kultur gepackt. Die Ressourcendatei sollte in die Hauptassembly der Anwendung eingebettet werden.  
  
 Beachten Sie, dass, mit der Ressourcen, die als privat markiert werden, aber Sie sollten immer kennzeichnen als öffentlich, sodass sie von anderen Assemblys zugegriffen werden kann. (Da eine Satellitenassembly keinen Code enthält, sind Ressourcen, die als privat markiert sind für Ihre app auf beliebige Weise nicht verfügbar.)  
  
 Weitere Informationen zum Erstellen, Packen und Bereitstellen von Ressourcen, finden Sie in den Artikeln [Erstellen von Ressourcendateien](~/docs/framework/resources/creating-resource-files-for-desktop-apps.md), [Erstellen von Satellitenassemblys](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md), und [Verpacken und Bereitstellen von Ressourcen](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
<a name="instantiating"></a>   
### <a name="instantiating-a-resourcemanager-object"></a>Instanziieren eines ResourceManager-Objekts  
 Instanziieren Sie ein <xref:System.Resources.ResourceManager> -Objekt, das Ressourcen aus einer eingebetteten .resources-Datei durch Aufrufen einer der zugehörigen Klasse Konstruktorüberladungen abruft. Diese eng miteinander verbindet eine <xref:System.Resources.ResourceManager> Objekt mit einer bestimmten RESOURCES-Datei und alle zugehörigen lokalisierte RESOURCES-Dateien in Satellitenassemblys.  
  
 Die beiden am häufigsten aufgerufenen Konstruktoren sind:  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> Sucht nach Ressourcen basierend auf zwei Arten von Informationen, die Sie angeben: Name der Basisname der RESOURCES-Datei und die Assembly, in dem die Standard-RESOURCES-Datei befindet. Der Basisname enthält den Namen und das Stammelement der RESOURCES-Datei, ohne die Kultur oder die Erweiterung. Beachten Sie, dass die RESOURCES-Dateien, die über die Befehlszeile, in der Regel kompiliert werden ein Namespacename nicht beinhalten, während führen Sie die RESOURCES-Dateien, die in der Visual Studio-Umgebung erstellt werden. Angenommen, eine Ressourcendatei MyCompany.StringResources.resources heißt und die <xref:System.Resources.ResourceManager> Konstruktor wird aufgerufen, eine statische Methode mit dem Namen `Example.Main`, instanziiert der folgende Code eine <xref:System.Resources.ResourceManager> -Objekt, das Ressourcen aus abrufen kann die. Ressourcendatei:  
  
     [!code-csharp[Conceptual.Resources.Retrieving#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#1)]
     [!code-vb[Conceptual.Resources.Retrieving#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#1)]  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> Sucht nach Ressourcen in Satellitenassemblys, die basierend auf Informationen von einem Typobjekt. Den vollqualifizierten Typnamen entspricht den Basisnamen der RESOURCES-Datei ohne Dateierweiterung. In desktop-apps, die mit dem Visual Studio-Ressourcen-Designer erstellt wurden, erstellt Visual Studio eine Wrapperklasse, dessen vollqualifizierter Name den Stammnamen der RESOURCES-Datei übereinstimmt. Z. B. eine Ressourcendatei MyCompany.StringResources.resources lautet und es ist eine Wrapperklasse, die mit dem Namen `MyCompany.StringResources`, instanziiert der folgende Code eine <xref:System.Resources.ResourceManager> -Objekt, das Ressourcen aus der RESOURCES-Datei abgerufen werden kann:  
  
     [!code-csharp[Conceptual.Resources.Retrieving#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#2)]
     [!code-vb[Conceptual.Resources.Retrieving#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#2)]  
  
 Wenn die entsprechenden Ressourcen nicht gefunden wird, erstellt der Konstruktoraufruf eine gültige <xref:System.Resources.ResourceManager> Objekt. Der Versuch, eine Ressource abrufen, löst jedoch eine <xref:System.Resources.MissingManifestResourceException> Ausnahme. Informationen zum Umgang mit der Ausnahme, finden Sie unter den [Behandlung von MissingManifestResourceException- und MissingSatelliteAssembly Ausnahmen](#exception) weiter unten in diesem Artikel.  
  
 Das folgende Beispiel zeigt, wie Sie instanziieren ein <xref:System.Resources.ResourceManager> Objekt. Es enthält den Quellcode für eine ausführbare Datei namens ShowTime.exe. Es enthält auch die folgende Textdatei, die mit dem Namen Strings.txt, die eine einzelne Zeichenfolgenressource enthält `TimeHeader`:  
  
```  
TimeHeader=The current time is  
```  
  
 Sie können eine Batchdatei verwenden, um die Ressourcendatei zu generieren und diese in die ausführbare Datei einzubetten. Hier wird die Batchdatei eine ausführbare Datei, die mithilfe von c#-Compiler generiert:  
  
```  
  
resgen strings.txt  
csc ShowTime.cs /resource:strings.resources  
  
```  
  
 Für Visual Basic-Compiler können Sie die folgende Batchdatei verwenden:  
  
```  
  
resgen strings.txt  
vbc ShowTime.vb /resource:strings.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showtime.cs#1)]
 [!code-vb[System.Resources.ResourceManager.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showtime.vb#1)]  
  
<a name="CultureSpecific"></a>   
### <a name="resourcemanager-and-culture-specific-resources"></a>ResourceManager und kulturspezifische Ressourcen  
 Eine lokalisierte app benötigt Ressourcen, die bereitgestellt werden, wie im folgenden Artikel beschrieben [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md). Wenn die Assemblys ordnungsgemäß konfiguriert sind, der Ressourcen-Manager bestimmt des aktuellen Threads abgerufen werden, welche Ressourcen anhand <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft. (Diese Eigenschaft gibt auch UI-Kultur des aktuellen Threads zurück.) Beispielsweise ist die Kompilierung mit einer app standardmäßig den Sprachressourcen für Englisch und Französisch und Russisch Sprachressourcen in zwei Satellitenassemblys,, in der Hauptassembly und <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft auf "fr-FR" festgelegt ist, der Ressourcen-Manager Ruft ab, der Französisch Ressourcen zu.  
  
 Sie können festlegen, die <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> Eigenschaft explizit oder implizit. Bestimmt, die Möglichkeit, legen Sie fest, wie die <xref:System.Resources.ResourceManager> Objekt ruft Ressourcen auf Grundlage der Kultur ab:  
  
-   Wenn Sie explizit festlegen, die <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft, um eine bestimmte Kultur, immer der Ressourcen-Manager Ruft die Ressourcen für die jeweilige Kultur, unabhängig von der Sprache des Benutzers Browsers oder Betriebssystems ab. Erwägen Sie eine app, die mit Englisch kompiliert wird und drei Satellitenassemblys, die Ressourcen für Englisch (Vereinigte Staaten), Französisch (Frankreich) und Russisch (Russische Föderation) enthalten. Wenn die <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> -Eigenschaftensatz auf "fr-FR", die <xref:System.Resources.ResourceManager> Objekt ruft immer die Französisch (Frankreich)-Ressourcen ab, selbst wenn der Benutzer Betriebssystem Systemsprache nicht Französisch. Stellen Sie sicher, dass dies das gewünschte Verhalten ist, bevor Sie die Eigenschaft explizit festlegen.  
  
     In ASP.NET-Anwendungen müssen Sie festlegen der <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft explizit, da es unwahrscheinlich ist, dass die Einstellung auf dem Server eingehende Clientanforderungen übereinstimmt. Eine ASP.NET-App kann festlegen, die <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> -Eigenschaft explizit auf den Browser des Benutzers, Sprache akzeptieren.  
  
     Explizites Festlegen der <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft definiert, die aktuelle Benutzeroberflächenkultur für diesen Thread. Es wirkt sich nicht auf die aktuelle Benutzeroberflächenkultur des anderen Threads in einer app aus.  
  
-   Sie können die Benutzeroberflächenkultur aller Threads in einer app-Domäne festlegen, durch Zuweisen einer <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur, an die statische darstellt <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft.  
  
-   Wenn Sie die aktuelle Kultur nicht explizit festlegen, und Sie eine Standardkultur für die aktuelle app-Domäne, nicht definieren die <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft wird implizit von der Windows festgelegt `GetUserDefaultUILanguage` Funktion. Diese Funktion wird durch das Multilingual User Interface (MUI) bereitgestellt, die dem Benutzer ermöglicht, als Standardsprache festgelegt. Wenn die Sprache der Benutzeroberfläche nicht vom Benutzer festgelegt ist, wird standardmäßig die Sprachen-System installiert, die die Sprache der Ressourcen des Betriebssystems ist.  
  
 Im folgenden einfachen "Hello World"-Beispiel wird die aktuelle Benutzeroberflächenkultur explizit an. Es enthält Ressourcen für die drei Kulturen: Englisch (USA) oder En-US, Französisch (Frankreich) oder "fr-FR", und Russisch (Russische Föderation) oder ru-RU. Die En-US-Ressourcen sind in eine Textdatei namens Greetings.txt enthalten:  
  
```  
HelloString=Hello world!  
```  
  
 Die "fr-FR" Ressourcen befinden sich in einer Textdatei mit dem Namen Greetings.fr-FR.txt:  
  
```  
HelloString=Salut tout le monde!  
```  
  
 Die ru-RU-Ressourcen befinden sich in einer Textdatei mit dem Namen Greetings.ru-RU.txt:  
  
```  
HelloString=Всем привет!  
```  
  
 Hier ist der Quellcode für das Beispiel (Example.vb für Visual Basic-Version) oder "example.cs" für die C#-Version:  
  
 [!code-csharp[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.currentculture/cs/example.cs#1)]
 [!code-vb[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.currentculture/vb/example.vb#1)]  
  
 Um dieses Beispiel zu kompilieren, erstellen Sie eine Batchdatei (. bat), die enthält die folgenden Befehle aus, und führen Sie es an der Eingabeaufforderung ein. Wenn Sie c# verwenden, geben Sie `csc` anstelle von `vbc` und `Example.cs` anstelle von `Example.vb`.  
  
```  
resgen Greetings.txt   
vbc Example.vb /resource:Greetings.resources  
  
resgen Greetings.fr-FR.txt  
Md fr-FR  
al /embed:Greetings.fr-FR.resources /culture:fr-FR /out:fr-FR\Example.resources.dll  
  
resgen Greetings.ru-RU.txt  
Md ru-RU  
al /embed:Greetings.ru-RU.resources /culture:ru-RU /out:ru-RU\Example.resources.dll  
```  
  
<a name="retrieving"></a>   
### <a name="retrieving-resources"></a>Abrufen von Ressourcen  
 Rufen Sie die <xref:System.Resources.ResourceManager.GetObject%28System.String%29> und <xref:System.Resources.ResourceManager.GetString%28System.String%29> Methoden, um eine bestimmte Ressource zugreifen darf. Sie können auch aufrufen, die <xref:System.Resources.ResourceManager.GetStream%28System.String%29> Methode zum Abrufen von nicht-Zeichenfolgenressourcen als Bytearray. Standardmäßig zurück diese Methoden in einer app, die die lokalisierte Ressourcen, hat die Ressource für die Kultur, die durch die aktuelle Benutzeroberflächenkultur des Threads, der der Aufruf bestimmt. Finden Sie im vorherigen Abschnitt [ResourceManager und kulturspezifische Ressourcen](#CultureSpecific), Weitere Informationen dazu, wie die aktuelle Benutzeroberflächenkultur eines Threads definiert wird. Wenn der Ressourcen-Manager die Ressource für UI-Kultur des aktuellen Threads nicht gefunden, verwendet es einen Ressourcenfallback-Prozess, um die angegebene Ressource abzurufen. Wenn der Ressourcen-Manager nicht lokalisierten Ressourcen finden kann, verwendet er die Ressourcen der Standardkultur. Weitere Informationen zum Ressourcen-fallback-Regeln finden Sie im Abschnitt "Ressourcenfallback-Prozess" des Artikels [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md).  
  
> [!NOTE]
>  Wenn die RESOURCES-Datei im angegebenen der <xref:System.Resources.ResourceManager> Klassenkonstruktor kann nicht gefunden werden kann, löst des Versuch, eine Ressource abrufen eine <xref:System.Resources.MissingManifestResourceException> oder <xref:System.Resources.MissingSatelliteAssemblyException> Ausnahme. Informationen zum Umgang mit der Ausnahme, finden Sie unter den [Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen](#exception) weiter unten in diesem Thema.  
  
 Im folgenden Beispiel wird die <xref:System.Resources.ResourceManager.GetString%2A> Methode zum Abrufen von kulturspezifischen Ressourcen. Es besteht aus Ressourcen, die von TXT-Dateien für den Englisch (En), Französisch (Frankreich) (fr-FR) und Russisch (Russische Föderation) (ru-RU) kompiliert Kulturen. Im Beispiel wird die aktuelle Kultur und die aktuelle UI-Kultur Englisch (Vereinigte Staaten), Französisch (Frankreich), Russisch (Russische Föderation) und Schwedisch (Schweden) geändert. Es ruft dann die <xref:System.Resources.ResourceManager.GetString%2A> Methode, um die lokalisierte Zeichenfolge abzurufen, die zusammen mit den aktuellen Tag und Monat angezeigt. Beachten Sie, dass die Ausgabe die entsprechende lokalisierte Zeichenfolge zeigt, es sei denn, die aktuelle Benutzeroberflächenkultur Schwedisch (Schweden). Da die Ressourcen der Schwedischen Sprache nicht verfügbar sind, verwendet die app stattdessen die Ressourcen der Standardkultur-Englisch.  
  
 Das Beispiel erfordert die textbasierte Ressourcendateien, die in der folgenden Tabelle aufgeführt. Jede hat eine einzelne Zeichenfolgenressource mit dem Namen `DateStart`.  
  
|culture|Dateiname|Ressourcenname|Ressourcenwert|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|Heute ist|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|СЕГОДНЯ|  
  
 Hier ist der Quellcode für das Beispiel (ShowDate.vb für Visual Basic-Version) oder ShowDate.cs für die C#-Version des Codes.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 Um dieses Beispiel zu kompilieren, erstellen Sie eine Batchdatei, die enthält die folgenden Befehle aus, und führen Sie es von der Befehlszeile aus. Wenn Sie c# verwenden, geben Sie `csc` anstelle von `vbc` und `showdate.cs` anstelle von `showdate.vb`.  
  
```  
  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
  
```  
  
 Es gibt zwei Möglichkeiten, um die Ressourcen einer bestimmten Kultur als die aktuelle Benutzeroberflächenkultur abzurufen:  
  
-   Rufen Sie die <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>, <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>, oder <xref:System.Resources.ResourceManager.GetStream%28System.String%2CSystem.Globalization.CultureInfo%29> Methode, um eine Ressource für eine bestimmte Kultur abrufen. Wenn Sie eine lokalisierte Ressource nicht gefunden werden kann, verwendet der Ressourcen-Manager den Ressourcenfallback-Prozess zu einer geeigneten Ressource.  
  
-   Rufen Sie die <xref:System.Resources.ResourceManager.GetResourceSet%2A> Methode zum Abrufen einer <xref:System.Resources.ResourceSet> -Objekt, das die Ressourcen für eine bestimmte Kultur darstellt. Im Aufruf Methode können Sie bestimmen, ob der Ressourcen-Manager für übergeordneten Kulturen Tests, wenn keine lokalisierte Ressourcen gefunden werden kann, oder gibt an, ob sie einfach auf die Ressourcen der Standardkultur zurückgegriffen. Anschließend können Sie die <xref:System.Resources.ResourceSet> Methoden Zugriff auf die Ressourcen (für die jeweilige Kultur lokalisierte) anhand des Namens oder die Ressourcen in der Gruppe aufgelistet werden.  
  
<a name="exception"></a>   
### <a name="handling-missingmanifestresourceexception-and-missingsatelliteassemblyexception-exceptions"></a>Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen  
 Wenn Sie versuchen, eine bestimmte Ressource abzurufen, aber der Ressourcen-Manager wurde nicht gefunden, dass die Ressource und entweder keine Standardkultur definiert wurde oder die Ressourcen der Standardkultur nicht gefunden werden kann, löst des Ressourcen-Managers eine <xref:System.Resources.MissingManifestResourceException> Ausnahme wenn es davon ausgeht, die Ressourcen in der Hauptassembly oder <xref:System.Resources.MissingSatelliteAssemblyException> , wenn er davon ausgeht, die Ressourcen in eine Satellitenassembly. Beachten Sie, dass die Ausnahme ausgelöst wird, wenn Sie eine Ressourcenabrufmethode, z. B. Aufrufen <xref:System.Resources.ResourceManager.GetString%2A> oder <xref:System.Resources.ResourceManager.GetObject%2A>, und nicht beim Instanziieren einer <xref:System.Resources.ResourceManager> Objekt.  
  
 Die Ausnahme wird in der Regel in den folgenden Situationen ausgelöst:  
  
-   Die entsprechende Ressource Datei- oder Satelliten-Assembly ist nicht vorhanden. Wenn der RM erwartet, der app-Standardressourcen dass, die in der Haupt-app-Assembly eingebettet werden, sind sie nicht vorhanden. Wenn die <xref:System.Resources.NeutralResourcesLanguageAttribute> -Attribut gibt an, dass es sich bei der app-Standardressourcen in einer Satellitenassembly befinden sich, dass die Assembly nicht gefunden werden kann. Beim Kompilieren Ihrer app stellen Sie sicher, dass Ressourcen in die Hauptassembly eingebettet sind oder die erforderlichen Satellitenassembly generiert wird und entsprechend benannt ist. Der Name sollte das Formular dauern *AppName*. "Resources.dll"-Datei enthält, und es in ein Verzeichnis namens nach der die Kultur, deren darin enthaltenen Ressourcen gefunden werden.  
  
-   Ihre app keine Standardinstanz oder eine neutrale Kultur definiert. Hinzufügen der <xref:System.Resources.NeutralResourcesLanguageAttribute> -Attribut in einer Quellcodedatei oder in der Projektdatei von Informationen (AssemblyInfo.vb-Datei für eine Visual Basic-app) oder die Datei "AssemblyInfo.cs" für eine c#-app-Datei.  
  
-   Die `baseName` Parameter in der <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> Konstruktor gibt nicht den Namen des eine RESOURCES-Datei an. Der Name muss den vollqualifizierten Namespace der Ressourcendatei, aber nicht die Dateinamenerweiterung enthalten. In der Regel Ressourcendateien, die in Visual Studio erstellt werden, umfassen Namespacenamen, Ressourcendateien, die erstellt und kompiliert werden, an der Eingabeaufforderung jedoch nicht. Sie können die Namen der eingebettete RESOURCES-Dateien durch Kompilieren und Ausführen von das folgende Dienstprogramm bestimmen. Dies ist eine Konsolen-app, die den Namen einer Hauptassembly oder Satellitenassembly als Befehlszeilenparameter akzeptiert. Zeigt die Zeichenfolgen, die als bereitgestellt werden, müssen die `baseName` Parameter, damit der Ressourcen-Manager die Ressource ordnungsgemäß identifizieren kann.  
  
     [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
     [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 Wenn Sie die aktuelle Kultur der Anwendung explizit ändern, sollten Sie auch bedenken, dass der Ressourcen-Manager Ruft ab, ein Ressourcensatz, der anhand des Werts von der <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> -Eigenschaft, und nicht die <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> Eigenschaft. In der Regel, wenn Sie einen Wert ändern, sollten Sie auch den anderen ändern.  
  
<a name="versioning"></a>   
### <a name="resource-versioning"></a>Ressourcenversionsverwaltung  
 Da die Haupt-Assembly, die der app-Standardressourcen enthält von der app-Satellitenassemblys ist, können Sie eine neue Version der Hauptassembly freigeben, ohne erneute Bereitstellung der Satellitenassemblys. Sie verwenden die <xref:System.Resources.SatelliteContractVersionAttribute> Attribut, um die vorhandenen Satellitenassemblys verwenden, und weisen des Ressourcen-Managers nicht, dass diese mit einer neuen Version der Hauptassembly, erneut bereitgestellt  
  
 Weitere Informationen zu Unterstützung der Versionskontrolle bei Satellitenassemblys, finden Sie im Artikel [Abrufen von Ressourcen](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md).  
  
<a name="config"></a>   
### <a name="satelliteassemblies-configuration-file-node"></a>\<Satelliteassemblies > Knoten "Datei"  
 Für ausführbare Dateien, die bereitgestellt und von einer Website (HREF .exe-Dateien), führen Sie die <xref:System.Resources.ResourceManager> Objekt kann eine Überprüfung auf Satellitenassemblys über das Web, wodurch die Leistung Ihrer Anwendung beeinträchtigt werden kann. Um das Leistungsproblem zu vermeiden, können Sie einschränken, diese Überprüfung auf Satellitenassemblys, die Sie mit der app bereitgestellt haben. Zu diesem Zweck erstellen Sie eine `<satelliteassemblies>` Knoten in Ihrer app-Konfigurationsdatei, um anzugeben, dass Sie einen bestimmten Satz von Kulturen, für Ihre app, und bereitgestellt haben die <xref:System.Resources.ResourceManager> Objekt sollten nicht versuchen, nach einer Kultur gesucht werden soll, die in diesem Knoten nicht aufgeführt ist.  
  
> [!NOTE]
>  Die bevorzugte Alternative zum Erstellen einer `<satelliteassemblies>` Knoten ist die Verwendung der [ClickOnce-Bereitstellungsmanifest](https://msdn.microsoft.com/library/8457e615-e3b6-4990-8dcf-11bc590e4e9b) Feature.  
  
 Erstellen Sie einen Abschnitt in Ihrer app-Konfigurationsdatei etwa wie folgt:  
  
```  
<?xml version ="1.0"?>  
<configuration>  
    <satelliteassemblies>  
        <assembly name="MainAssemblyName, Version=versionNumber, Culture=neutral, PublicKeyToken=null|yourPublicKeyToken">  
            <culture>cultureName1</culture>  
            <culture>cultureName2</culture>  
            <culture>cultureName3</culture>  
        </assembly>  
    </satelliteassemblies>  
</configuration>  
```  
  
 Bearbeiten Sie diese Konfigurationsinformationen wie folgt:  
  
-   Geben Sie eine oder mehrere `<assembly>` Knoten für jede Hauptassembly, die Sie bereitstellen, wobei jeder Knoten einen vollqualifizierten Assemblynamen angibt. Geben Sie den Namen der Hauptassembly anstelle von *MainAssemblyName*, und geben Sie die `Version`, `PublicKeyToken`, und `Culture` Attributwerte entsprechen, die auf Ihre Hauptassembly.  
  
     Für die `Version` Attribut verwenden, geben Sie die Versionsnummer der Assembly. Beispielsweise kann die erste Version der Assembly Versionsnummer 1.0.0.0 sein.  
  
     Für die `PublicKeyToken` -Attributs festzulegen, geben Sie das Schlüsselwort `null` , wenn Sie Ihre Assembly mit einem starken Namen noch nicht registriert, oder geben Sie das öffentliche Schlüsseltoken aus, wenn Sie die Assembly signiert ist.  
  
     Für die `Culture` -Attributs festzulegen, geben Sie das Schlüsselwort `neutral` zum Festlegen der Hauptassembly und dazu führen, dass die <xref:System.Resources.ResourceManager> Klasse, um nur die Kulturen, die in aufgeführten sucht die `<culture>` Knoten.  
  
     Weitere Informationen zu den vollqualifizierten Assemblynamen verwenden zu müssen, finden Sie im Artikel [Assemblynamen](~/docs/framework/app-domains/assembly-names.md). Weitere Informationen zu Assemblys mit starkem Namen finden Sie im Artikel [erstellen und Assemblys mit starkem Namen](~/docs/framework/app-domains/create-and-use-strong-named-assemblies.md).  
  
-   Geben Sie eine oder mehrere `<culture>` Knoten mit einem bestimmten Kulturnamen wie z. B. "fr-FR", oder eine neutrale Kultur-ein, z. B. "fr".  
  
 Wenn Ressourcen, für jede Assembly, die nicht aufgeführt benötigt werden, unter der `<satelliteassemblies>` Knoten die <xref:System.Resources.ResourceManager> Prüfpunkte für die Kulturen, die mit standardmäßigen Überprüfungsregeln Klasse.  
  
<a name="ws"></a>   
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]-Apps  
  
> [!IMPORTANT]
>  Obwohl die <xref:System.Resources.ResourceManager> Klasse wird von unterstützt [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps sollten nicht die Verwendung. Verwenden Sie diese Klasse nur beim Entwickeln von [!INCLUDE[net_portable](~/includes/net-portable-md.md)] Projekte, die mit verwendet werden können [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps. Zum Abrufen von Ressourcen aus [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps verwenden die [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) stattdessen.  
  
 Für [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -apps, die <xref:System.Resources.ResourceManager> Klasse ruft Ressourcen aus dem Paket ressourcenindexdateien (PRI). Eine einzelne PRI-Datei (die Anwendung Paket PRI-Datei) enthält die Ressourcen für die Standardkultur und alle Kulturen lokalisiert. Sie verwenden das MakePRI-Hilfsprogramm, um eine PRI-Datei aus einem oder mehreren Ressourcendateien zu erstellen, die im XML-Ressource (.resw) Format vorliegen. Für Ressourcen, die in Visual Studio-Projekt enthalten sind, wird Visual Studio erstellen und Packen die PRI-Datei automatisch. Anschließend können Sie die .NET Framework <xref:System.Resources.ResourceManager> Klasse, um die app oder Bibliothek zugreifen.  
  
 Instanziieren Sie ein <xref:System.Resources.ResourceManager> Objekt für eine [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] app auf die gleiche Weise, die Sie für eine desktop-app ausführen.  
  
 Anschließend können Sie die Ressourcen für eine bestimmte Kultur zugreifen, durch Übergeben des Namens der Ressource, die abgerufen werden die <xref:System.Resources.ResourceManager.GetString%28System.String%29> Methode. Standardmäßig gibt diese Methode die Ressource für die Kultur, die bestimmt, indem die aktuelle Benutzeroberflächenkultur des Threads, der der Aufruf ausgeführt wird. Sie können auch die Ressourcen für eine bestimmte Kultur abrufen, indem der Name der Ressource übergeben und ein <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, deren Ressourcen abgerufen werden die <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> Methode. Wenn die Ressource für die aktuelle Benutzeroberflächenkultur oder die angegebene Kultur nicht gefunden werden kann, verwendet der Ressourcen-Manager eine alternative Benutzeroberfläche Sprachenliste nach einer geeigneten Ressource.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie mit einer expliziten Kultur und die aktuelle Benutzeroberflächenkultur implizite um Zeichenfolgenressourcen aus einer Hauptassembly und eine Satellitenassembly zu erhalten. Weitere Informationen finden Sie im Abschnitt "Speicherorte für die Satellitenassembly, die nicht im globalen Assemblycache installiert sind" die [Erstellen von Satellitenassemblys](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) Thema.  
  
 Um dieses Beispiel auszuführen:  
  
1.  Erstellen Sie in das app-Verzeichnis eine Datei namens rmc.txt, die die folgenden Ressourcenzeichenfolgen enthält:  
  
    ```  
  
    day=Friday  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
2.  Verwenden der [Resource File Generator](~/docs/framework/tools/resgen-exe-resource-file-generator.md) rmc.resources Ressourcendatei wie folgt aus der Eingabedatei rmc.txt generiert:  
  
    ```  
    resgen rmc.txt  
    ```  
  
3.  Erstellen Sie ein Unterverzeichnis des app-Verzeichnis, und nennen Sie es "es-MX". Dies ist der Name der Kultur der Satellitenassembly, die Sie in den folgenden drei Schritten erstellen.  
  
4.  Erstellen Sie eine Datei namens rmc.es-MX.txt, in dem Verzeichnis es-MX, das die folgenden Ressourcenzeichenfolgen enthält:  
  
    ```  
  
    day=Viernes  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
5.  Verwenden der [Resource File Generator](~/docs/framework/tools/resgen-exe-resource-file-generator.md) rmc.es-MX.resources Ressourcendatei wie folgt aus der Eingabedatei rmc.es-MX.txt generiert:  
  
    ```  
    resgen rmc.es-MX.txt  
    ```  
  
6.  Wird davon ausgegangen Sie, dass der Dateiname für dieses Beispiel rmc.vb oder rmc.cs ist. Kopieren Sie den folgenden Quellcode in eine Datei aus. Klicken Sie dann kompiliert, und die Haupt-Assembly-Ressourcendatei, rmc.resources, in die ausführbare Assembly einbetten. Wenn Sie Visual Basic-Compiler verwenden, ist die Syntax auf:  
  
    ```  
    vbc rmc.vb /resource:rmc.resources  
    ```  
  
     Die entsprechende Syntax für den C#-Compiler lautet:  
  
    ```  
    csc /resource:rmc.resources rmc.cs  
    ```  
  
7.  Verwenden der [Assemblylinker](~/docs/framework/tools/al-exe-assembly-linker.md) eine Satellitenassembly zu erstellen. Wenn der Basisname der app Rmc ist, muss der Name der Satellitenassembly rmc.resources.dll sein. Die Satellitenassembly sollte im es-MX-Verzeichnis erstellt werden. Wenn es-MX im aktuellen Verzeichnis ist, verwenden Sie folgenden Befehl aus:  
  
    ```  
    al /embed:rmc.es-MX.resources /c:es-MX /out:rmc.resources.dll   
    ```  
  
8.  Führen Sie rmc.exe zum Abrufen und Anzeigen der eingebetteten Ressource-Zeichenfolgen.  
  
 [!code-csharp[ResourceManager_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ResourceManager_Class/cs/rmc.cs#1)]
 [!code-vb[ResourceManager_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ResourceManager_Class/vb/rmc.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.Globalization.CultureInfo" />
    <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
    <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Ressourcen in Anwendungen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Resources.ResourceManager" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ResourceManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ResourceManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Resources.ResourceManager" />-Klasse mit Standardwerten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist nur nützlich, wenn Sie eine eigene Klasse, die Schreiben von abgeleitet ist die <xref:System.Resources.ResourceManager> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (Type resourceSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type resourceSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resourceSource As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(Type ^ resourceSource);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager resourceSource" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="resourceSource" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="resourceSource">Ein Typ, aus dem der Ressourcen-Manager alle Informationen zum Suchen von RESOURCES-Dateien ableitet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Resources.ResourceManager" />-Klasse, die Ressourcen in Satellitenassemblys auf der Grundlage der Informationen aus dem angegebenen Typobjekt sucht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Desktop-Apps  
 In desktop-apps, die Ressourcen-Manager verwendet die `resourceSource` Parameter, um eine bestimmte Ressource-Datei wie folgt zu laden:  
  
-   Wenn die <xref:System.Resources.NeutralResourcesLanguageAttribute> Attribut wird nicht verwendet, um anzugeben, dass die Ressourcen der Standardkultur befinden sich in einer Satellitenassembly, der Ressourcen-Manager wird davon ausgegangen, dass die Ressourcendatei für die Standardkultur in der gleichen Assembly wie durch die angegebenenTypsgefundenwird`resourceSource` Parameter.  
  
-   Der Ressourcen-Manager wird davon ausgegangen, dass die Ressourcendatei den gleichen Basisnamen wie die vom angegebenen Typ verfügt über die `resourceSource` Parameter.  
  
-   Der Ressourcen-Manager verwendet die standardmäßige <xref:System.Resources.ResourceSet> Klasse, um die Ressourcendatei bearbeiten.  
  
 Beispielsweise sucht einen Typ mit dem Namen Firma.Produkt.Typ wird angegeben, der Ressourcen-Manager eine RESOURCES-Datei mit dem Namen MyCompany.MyProduct.MyType.resources in der Assembly, die MyType definiert.  
  
 In Visual Studio generiert automatisch den Ressourcen-Designer-Code, definiert ein `internal` (in c#) oder `Friend` (in Visual Basic)-Klasse, deren Namen den Basisnamen der RESOURCES-Datei für eine neutrale Kultur entspricht. Dadurch kann zum Instanziieren einer <xref:System.Resources.ResourceManager> Objekt aus, und verknüpfen es mit einem bestimmten Satz von Ressourcen durch ein Typobjekt, dessen Name dem Namen der Ressource entspricht, abrufen, da die Ressourcen als, solange die Klasse für den Compiler sichtbar ist sein müssen, gut. Z. B. wenn eine RESOURCES-Datei kann "Resource1" heißt, die folgende Anweisung instanziiert ein <xref:System.Resources.ResourceManager> Objekt, um die RESOURCES-Datei mit dem Namen kann "Resource1" zu verwalten:  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/ctor1.cs#2)]  
  
 Wenn Sie nicht über Visual Studio nutzen, können Sie eine Klasse ohne Member erstellen, dessen Namespace und Name, der den Standard-RESOURCES-Datei identisch sind. Dies wird im Beispiel veranschaulicht.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]-Apps  
  
> [!IMPORTANT]
>  Obwohl die <xref:System.Resources.ResourceManager> Klasse wird von unterstützt [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps sollten nicht die Verwendung. Verwenden Sie diese Klasse nur beim Entwickeln von [!INCLUDE[net_portable](~/includes/net-portable-md.md)] Projekte, die mit verwendet werden können [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps. Zum Abrufen von Ressourcen aus [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps verwenden die [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) stattdessen.  
  
 In [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps <xref:System.Resources.ResourceManager> verwendet die `resourceSource` Parameter Ableiten von der Assembly, Basisnamen und dem Namespace, in dem die Ressourcenelemente in der app-Paket (paketressourcenindex) Ressourcendatei gefunden werden können. Angenommen, einen Typ, der mit dem Namen Firma.Produkt.Typ, die in definierten `MyAssembly`, der Ressourcen-Manager sucht nach eine Ressource mit dem Namen MyAssembly Bezeichner festgelegt, und sucht nach einem Bereich Firma.Produkt.Typ innerhalb dieses Ressourcensatzes. Der Ressourcen-Manager sucht nach Ressourcenelemente unter den Standardkontext (aktuelle Kultur, aktuelle Einstellung von hohem Kontrast usw.) innerhalb dieses Bereichs.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> Konstruktor zum Instanziieren einer <xref:System.Resources.ResourceManager> Objekt. Es besteht aus Ressourcen, die von TXT-Dateien für den Englisch (En), Französisch (Frankreich) (fr-FR) und Russisch (Russische Föderation) (ru-RU) kompiliert Kulturen. Im Beispiel wird die aktuelle Kultur und die aktuelle UI-Kultur Englisch (Vereinigte Staaten), Französisch (Frankreich), Russisch (Russische Föderation) und Schwedisch (Schweden) geändert. Es ruft dann die <xref:System.Resources.ResourceManager.GetString%28System.String%29> Methode, um die lokalisierte Zeichenfolge abzurufen, der eine Begrüßung angezeigt, die von der Tageszeit abhängt.  
  
 Das Beispiel erfordert drei textbasierten Ressourcendateien, wie in der folgenden Tabelle aufgeführt. Jede Datei enthält Ressourcen, die Zeichenfolgen sind, mit dem Namen `Morning`, `Afternoon`, und `Evening`.  
  
|culture|Dateiname|Ressourcenname|Ressourcenwert|  
|-------------|---------------|-------------------|--------------------|  
|en-US|GreetingResources.txt|`Morning`|Guten Morgen|  
|en-US|GreetingResources.txt|`Afternoon`|Guten Tag|  
|en-US|GreetingResources.txt|`Evening`|Guten Abend|  
|fr-FR|GreetingResources.fr-FR.txt|`Morning`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Afternoon`|Bonjour|  
|fr-FR|GreetingResources.fr-FR.txt|`Evening`|Bonsoir|  
|ru-RU|GreetingResources.ru-RU.txt|`Morning`|ДОБРОЕ УТРО|  
|ru-RU|GreetingResources.ru-RU.txt|`Afternoon`|ДОБРЫЙ ДЕНЬ|  
|ru-RU|GreetingResources.ru-RU.txt|`Evening`|ДОБРЫЙ ВЕЧЕР|  
  
 Sie können die folgende Batchdatei verwenden, Visual Basic-Beispiel zu kompilieren und erstellen eine ausführbare Datei namens Greet.exe. Zum Kompilieren mit c# ändern Sie den Compilernamen aus `vbc` zu `csc` und der Dateierweiterung aus `.vb` zu `.cs`.  
  
```  
  
resgen GreetingResources.txt  
vbc Greet.vb /resource: GreetingResources.resources  
  
md fr-FR  
resgen GreetingResources.fr-FR.txt  
al /out:fr-FR\Greet.resources.dll /culture:fr-FR /embed: GreetingResources.fr-FR.resources   
  
md ru-RU  
resgen GreetingResources.ru-RU.txt  
al /out:ru-RU\Greet.resources.dll /culture:ru-RU /embed: GreetingResources.ru-RU.resources  
  
```  
  
 Hier ist der Quellcode für das Beispiel (ShowDate.vb für Visual Basic-Version) oder ShowDate.cs für die C#-Version des Codes.  
  
 [!code-csharp[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/greet.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/greet.vb#3)]  
  
 Zusätzlich zum Definieren von app-Klasse mit dem Namen `Example`, der Quellcode definiert einer internen Klasse, deren Namen `GreetingResources`, ist identisch mit dem Basisnamen der Ressourcendateien. Dadurch kann erfolgreich instanziiert ein <xref:System.Resources.ResourceManager> -Objekt durch Aufrufen der <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> Konstruktor.  
  
 Beachten Sie, dass die Ausgabe zeigt an, die die entsprechende lokalisierte Zeichenfolge nur, wenn die aktuelle Benutzeroberflächenkultur Schwedisch (Schweden), in diesem Fall ist es verwendet die Sprachressourcen für Englisch. Da die Ressourcen der Schwedischen Sprache nicht verfügbar sind, die app verwendet die Ressourcen der Standardkultur, gemäß der <xref:System.Resources.NeutralResourcesLanguageAttribute> Attribut stattdessen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="resourceSource" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="baseName">Der Stammname der Ressourcendatei ohne Erweiterung, aber einschließlich irgendeines vollqualifizierten Namespacenamens. Der Stammname der Ressourcendatei "MyApplication.MyResource.en-US.resources" lautet beispielsweise "MyApplication.MyResource".</param>
        <param name="assembly">Die Hauptassembly für die Ressourcen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Resources.ResourceManager" />-Klasse zum Suchen von Ressourcen in Dateien mit dem angegebenen Stammnamen in der angegebenen Assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Desktop-Apps  
 In desktop-apps die einzelnen kulturspezifischen Ressourcendateien in Satellitenassemblys enthalten sein soll, und die Standardkultur Ressourcen-Datei sollte in der Hauptassembly enthalten sein. Eine Satellitenassembly wird davon ausgegangen, dass Sie Ressourcen für eine einzelne Kultur angegeben, die im Manifest dieser Assembly enthält, und nach Bedarf geladen wird.  
  
> [!NOTE]
>  Um Ressourcen aus Ressourcendateien direkt statt sie von Assemblys abzurufen, rufen Sie die <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> Methode stattdessen zum Instanziieren einer <xref:System.Resources.ResourceManager> Objekt.  
  
 Wenn durch die Ressourcendatei identifiziert `baseName` wurde nicht gefunden im `assembly`, die Methode instanziiert ein <xref:System.Resources.ResourceManager> -Objekt, aber der Versuch zum Abrufen einer bestimmten Ressource löst eine Ausnahme aus, in der Regel <xref:System.Resources.MissingManifestResourceException>. Informationen zum Diagnostizieren der Ursache der Ausnahme, finden Sie im Abschnitt "Behandeln der MissingManifestResourceException-Ausnahme" der <xref:System.Resources.ResourceManager> Thema-Klasse.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]-Apps  
  
> [!IMPORTANT]
>  Obwohl die <xref:System.Resources.ResourceManager> Klasse wird von unterstützt [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps sollten nicht die Verwendung. Verwenden Sie diese Klasse nur beim Entwickeln von [!INCLUDE[net_portable](~/includes/net-portable-md.md)] Projekte, die mit verwendet werden können [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps. Zum Abrufen von Ressourcen aus [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps verwenden die [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) stattdessen.  
  
 In [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -apps, die Ressourcen-Manager verwendet den einfachen Namen der `assembly` Parametersatz, um eine passende Ressource zu suchen, in der app-Paket (paketressourcenindex) Ressourcendatei. Die `baseName` Parameter wird verwendet, um ein Ressourcenelement innerhalb der Ressourcenmenge zu suchen. Beispielsweise ist der Stammname PortableLibrary1.Resource1.de-DE.resources PortableLibrary1.Resource1.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine einfache nicht-lokalisierter "Hello World"-app zur Veranschaulichung der <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> Konstruktor. Das folgende Beispiel zeigt den Inhalt einer Textdatei mit dem Namen ExampleResources.txt. Wenn die app kompiliert wird, wird die Ressource in der Haupt-app-Assembly eingebettet.  
  
```  
Greeting=Hello  
```  
  
 Die Textdatei in eine binäre Ressourcendatei konvertiert werden kann, mithilfe der an der Eingabeaufforderung wie folgt:  
  
```  
resgen ExampleResources.txt  
```  
  
 Im folgenden Beispiel wird den ausführbaren Code, der instanziiert ein <xref:System.Resources.ResourceManager> -Objekt, fordert den Benutzer zur Eingabe eines Namens und eine Begrüßung angezeigt.  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/example.cs#1)]
 [!code-vb[System.Resources.ResourceManager.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/example.vb#1)]  
  
 Sie können mit den folgenden Befehl in Visual Basic kompiliert werden:  
  
```  
vbc Example.vb /resource:ExampleResources.resources  
```  
  
 oder mithilfe des folgenden Befehls in c#:  
  
```  
csc Example.cs /resource:ExampleResources.resources  
```  
  
 Beachten Sie, dass im Beispiel wird einen Verweis auf die Assembly, das die Ressourcendatei enthält abgerufen, durch Übergeben eines Typs, die in dieser Assembly definiert die `typeof` -Funktion (in c#) oder die `GetType` funktionieren (in Visual Basic) und Abrufen des Werts der <xref:System.Type.Assembly%2A?displayProperty=nameWithType>Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="baseName" />-Parameter oder der <paramref name="assembly" />-Parameter ist <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Dieser Konstruktor verwendet, die vom System bereitgestellten <see cref="T:System.Resources.ResourceSet" /> Implementierung. Um eine benutzerdefinierte Ressource-Dateiformat verwenden zu können, sollten Sie die Ableitung von der <see cref="T:System.Resources.ResourceSet" /> Klasse außer Kraft, indem die <see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> und <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> Methoden auf und übergeben, die zum Eingeben der <see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" /> Konstruktor. Mithilfe einer benutzerdefinierten <see cref="T:System.Resources.ResourceSet" /> kann nützlich sein, für die Steuerung Ressource Cacherichtlinie oder unterstützen Ihre eigenen Ressourcendateiformat, jedoch ist in der Regel nicht erforderlich.</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly * Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly, usingResourceSet)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="usingResourceSet" Type="System.Type" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="baseName">Der Stammname der Ressourcendatei ohne Erweiterung, aber einschließlich irgendeines vollqualifizierten Namespacenamens. Der Stammname der Ressourcendatei "MyApplication.MyResource.en-US.resources" lautet beispielsweise "MyApplication.MyResource".</param>
        <param name="assembly">Die Hauptassembly für die Ressourcen.</param>
        <param name="usingResourceSet">Der Typ des zu verwendenden benutzerdefinierten <see cref="T:System.Resources.ResourceSet" />. Wenn <see langword="null" />, wird das für die Laufzeit standardmäßig festgelegte <see cref="T:System.Resources.ResourceSet" />-Objekt verwendet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Resources.ResourceManager" />-Klasse, die eine angegebene <see cref="T:System.Resources.ResourceSet" />-Klasse verwendet, um Ressourcen in Dateien mit dem angegebenen Stammnamen in der angegebenen Assembly zu suchen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die einzelnen kulturspezifischen Ressourcendateien in Satellitenassemblys enthalten sein soll, und die Standardkultur Ressourcen-Datei sollte in der Hauptassembly enthalten sein. Eine Satellitenassembly wird davon ausgegangen, dass Sie Ressourcen für eine einzelne Kultur angegeben, die im Manifest dieser Assembly enthält, und nach Bedarf geladen wird.  
  
> [!NOTE]
>  Um Ressourcen aus Ressourcendateien direkt statt sie von Assemblys abzurufen, rufen Sie die <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> Methode stattdessen zum Instanziieren einer <xref:System.Resources.ResourceManager> Objekt.  
  
 Wenn durch die Ressourcendatei identifiziert `baseName` wurde nicht gefunden im `assembly`, die Methode instanziiert ein <xref:System.Resources.ResourceManager> -Objekt, aber der Versuch zum Abrufen einer bestimmten Ressource löst eine Ausnahme aus, in der Regel <xref:System.Resources.MissingManifestResourceException>. Informationen zum Diagnostizieren der Ursache der Ausnahme, finden Sie im Abschnitt "Behandeln der MissingManifestResourceException-Ausnahme" der <xref:System.Resources.ResourceManager> Thema-Klasse.  
  
> [!NOTE]
>  Die `usingResourceSet` Parameter wird verwendet, um Ihre eigenen Ressourcenformat unterstützt und werden häufig `null`. Dies unterscheidet sich von der Konstruktor, akzeptiert eine <xref:System.Type> nur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="usingResourceset" /> ist keine von <see cref="T:System.Resources.ResourceSet" /> abgeleitete Klasse.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="baseName" />-Parameter oder der <paramref name="assembly" />-Parameter ist <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Dieser Konstruktor ermöglicht die Angabe einer <see cref="T:System.Resources.ResourceSet" /> Implementierung. Wenn Sie nicht, dass eine bestimmte möchten <see cref="T:System.Resources.ResourceSet" /> Implementierung würde, aber wie auf eine benutzerdefinierte Ressource-Dateiformat verwenden, sollten Sie die Ableitung von der <see cref="T:System.Resources.ResourceSet" /> Klasse außer Kraft, indem die <see cref="M:System.Resources.ResourceSet.GetDefaultReader" /> und <see cref="M:System.Resources.ResourceSet.GetDefaultWriter" /> Methoden und übergeben, die Geben Sie an diesen Konstruktor.</para></block>
      </Docs>
    </Member>
    <Member MemberName="BaseName">
      <MemberSignature Language="C#" Value="public virtual string BaseName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseName" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.BaseName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseName : string" Usage="System.Resources.ResourceManager.BaseName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Stammnamen der Ressourcendateien ab, die der <see cref="T:System.Resources.ResourceManager" /> nach Ressourcen durchsucht.</summary>
        <value>Der Stammname der Ressourcendateien, die der <see cref="T:System.Resources.ResourceManager" /> nach Ressourcen durchsucht.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Resources.ResourceManager.BaseName%2A> Eigenschaft spiegelt wider, den vollqualifizierten Namespacenamen und der Stammname der Ressourcen einer Ressourcendatei, ohne die Dateinamenerweiterung Kultur oder der Datei. Angenommen, dem Namen der app-Standardressourcendatei `SampleApps.StringResources.resources`, den Wert des der <xref:System.Resources.ResourceManager.BaseName%2A> -Eigenschaft ist "SampleApps.StringResources". Wenn den Namen der app-Standardressourcendatei `SampleApps.StringResources.en-US.resources` und in eine Satellitenassembly, die den Wert der eingebettet ist die <xref:System.Resources.ResourceManager.BaseName%2A> Eigenschaft ist immer noch "SampleApps.StringResources".  
  
> [!IMPORTANT]
>  Die <xref:System.Resources.ResourceManager.BaseName%2A> Eigenschaftswert einer Ressourcendatei, die kompiliert und über die Befehlszeile eingebettet enthält keine Namen für einen Namespace, wenn Sie explizit eine einschließen, wenn die Datei zu kompilieren. Auf der anderen Seite der <xref:System.Resources.ResourceManager.BaseName%2A> Eigenschaftswert einer Ressourcendatei, die kompiliert und in Visual Studio-Umgebung eingebettet sind, in der Regel schließt den Standardnamen für den Namespace.  
  
 Die <xref:System.Resources.ResourceManager.BaseName%2A> Eigenschaftswert ist dasselbe wie die Zeichenfolge, die an die <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> oder <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> Konstruktor beim Instanziieren einer <xref:System.Resources.ResourceManager> Instanz.  
  
   
  
## Examples  
 Sie können die Namen der eingebettete RESOURCES-Dateien durch Kompilieren und Ausführen von das folgende Dienstprogramm bestimmen. Dies ist eine Konsolen-app, die den Namen einer Hauptassembly oder Satellitenassembly als Befehlszeilenparameter akzeptiert. Es zeigt, dass die Zeichenfolgen, die als bereitgestellt werden sollen die `baseName` Parameter der <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> oder <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29> Konstruktor, damit der Ressourcen-Manager die Ressource ordnungsgemäß identifizieren kann.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
 [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseNameField">
      <MemberSignature Language="C#" Value="protected string BaseNameField;" />
      <MemberSignature Language="ILAsm" Value=".field family string BaseNameField" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.BaseNameField" />
      <MemberSignature Language="VB.NET" Value="Protected BaseNameField As String " />
      <MemberSignature Language="C++ CLI" Value="protected: System::String ^ BaseNameField;" />
      <MemberSignature Language="F#" Value="val mutable BaseNameField : string" Usage="System.Resources.ResourceManager.BaseNameField" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den Stammnamen der Ressourcendateien an, die der <see cref="T:System.Resources.ResourceManager" /> nach Ressourcen durchsucht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Resources.ResourceManager.BaseNameField> Feld ist nur nützlich, wenn Sie eine eigene Klasse, die Schreiben von abgeleitet ist die <xref:System.Resources.ResourceManager> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFileBasedResourceManager">
      <MemberSignature Language="C#" Value="public static System.Resources.ResourceManager CreateFileBasedResourceManager (string baseName, string resourceDir, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.CreateFileBasedResourceManager(System.String,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFileBasedResourceManager (baseName As String, resourceDir As String, usingResourceSet As Type) As ResourceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Resources::ResourceManager ^ CreateFileBasedResourceManager(System::String ^ baseName, System::String ^ resourceDir, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="static member CreateFileBasedResourceManager : string * string * Type -&gt; System.Resources.ResourceManager" Usage="System.Resources.ResourceManager.CreateFileBasedResourceManager (baseName, resourceDir, usingResourceSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="resourceDir" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="usingResourceSet" Type="System.Type" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="baseName">Der Stammname der Ressourcen. Der Stammname der Ressourcendatei "MyResource.en-US.resources" lautet beispielsweise "MyResource".</param>
        <param name="resourceDir">Der Name des Verzeichnisses, das nach Ressourcen durchsucht werden soll. <paramref name="resourceDir" /> kann ein absoluter Pfad oder ein relativer Pfad im Anwendungsverzeichnis sein.</param>
        <param name="usingResourceSet">Der Typ des zu verwendenden benutzerdefinierten <see cref="T:System.Resources.ResourceSet" />. Wenn <see langword="null" />, wird das für die Laufzeit standardmäßig festgelegte <see cref="T:System.Resources.ResourceSet" />-Objekt verwendet.</param>
        <summary>Gibt ein <see cref="T:System.Resources.ResourceManager" />-Objekt zurück, der anstelle eines Assemblymanifests ein bestimmtes Verzeichnis nach Ressourcen durchsucht.</summary>
        <returns>Eine neue Instanz eines Ressourcen-Managers, der das angegebene Verzeichnis anstelle eines Assemblymanifests nach Ressourcen durchsucht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt einen Ressourcen-Manager, der Ressourcen aus einer RESOURCES-Datei abruft, die nicht in einer Assembly eingebettet ist. Sie können dies verwenden <xref:System.Resources.ResourceManager> Objekt zum Laden von Ressourcen für eine ASP.NET-Seite oder zum Testen einer <xref:System.Resources.ResourceSet> Implementierung.  Ein Beispiel für die Ressourcen aus einer eigenständigen RESOURCES-Datei abruft, finden Sie unter den [Abrufen von Ressourcen](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md) Artikel.  
  
 Diese Methode ermöglicht die Angabe einer <xref:System.Resources.ResourceSet> Implementierung. Wenn Sie nicht, dass eine bestimmte möchten <xref:System.Resources.ResourceSet> Implementierung, aber in einer benutzerdefinierten Ressource-Dateiformat verwenden möchten sollten Sie die Ableitung von der <xref:System.Resources.ResourceSet> Klasse außer Kraft, indem die <xref:System.Resources.ResourceSet.GetDefaultReader%2A> und <xref:System.Resources.ResourceSet.GetDefaultWriter%2A> Methoden und übergeben, die Geben Sie an diesen Konstruktor.  
  
> [!CAUTION]
>  Mit eigenständigen Ressourcendateien in einer ASP.NET-Anwendung unterbricht die XCOPY-Bereitstellung, da die Ressourcen gesperrt bleiben, bis sie explizit, indem freigegeben werden die <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> Methode. Wenn Sie Ressourcen mit ASP.NET-Anwendungen bereitstellen möchten, kompilieren Sie die RESOURCES-Dateien in Satellitenassemblys.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="baseName" />-Parameter oder der <paramref name="resourceDir" />-Parameter ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FallbackLocation">
      <MemberSignature Language="C#" Value="protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Resources.UltimateResourceFallbackLocation FallbackLocation" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.FallbackLocation" />
      <MemberSignature Language="VB.NET" Value="Protected Property FallbackLocation As UltimateResourceFallbackLocation" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Resources::UltimateResourceFallbackLocation FallbackLocation { System::Resources::UltimateResourceFallbackLocation get(); void set(System::Resources::UltimateResourceFallbackLocation value); };" />
      <MemberSignature Language="F#" Value="member this.FallbackLocation : System.Resources.UltimateResourceFallbackLocation with get, set" Usage="System.Resources.ResourceManager.FallbackLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.UltimateResourceFallbackLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Speicherort für das Abrufen von Standard-Fallbackressourcen ab oder legt diesen fest.</summary>
        <value>Einer der Enumerationswerte, der angibt, wo der Ressourcen-Manager nach Ausweichressourcen suchen kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Resources.ResourceManager.FallbackLocation%2A> Eigenschaft ist nur nützlich, wenn Sie eine eigene Klasse, die Schreiben von abgeleitet ist die <xref:System.Resources.ResourceManager> Klasse.  
  
 Können Sie die <xref:System.Resources.NeutralResourcesLanguageAttribute> Attribut, um dem Ressourcen-Manager darüber zu informieren, wo die Standardkultur für eine app zu finden: in der Hauptassembly (Standard) oder in eine Satellitenassembly.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Resources.UltimateResourceFallbackLocation" />
        <altmember cref="T:System.Resources.NeutralResourcesLanguageAttribute" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="GetNeutralResourcesLanguage">
      <MemberSignature Language="C#" Value="protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Globalization.CultureInfo GetNeutralResourcesLanguage(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetNeutralResourcesLanguage(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetNeutralResourcesLanguage (a As Assembly) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Globalization::CultureInfo ^ GetNeutralResourcesLanguage(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetNeutralResourcesLanguage : System.Reflection.Assembly -&gt; System.Globalization.CultureInfo" Usage="System.Resources.ResourceManager.GetNeutralResourcesLanguage a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="a">Die Assembly, für die kulturspezifische Informationen zurückgegeben werden sollen.</param>
        <summary>Gibt kulturspezifische Informationen für die Standardressourcen der Hauptassembly zurück, indem der Wert des <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" />-Attributs in einer angegebenen Assembly gelesen wird.</summary>
        <returns>Die Kultur des <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" />-Attributs, sofern gefunden, andernfalls die invariante Kultur.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Wert der angegebenen Ressource, die keine Zeichenfolge ist, für die aktuelle Kultur zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string -&gt; obj&#xA;override this.GetObject : string -&gt; obj" Usage="resourceManager.GetObject name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der abzurufenden Ressource.</param>
        <summary>Gibt den Wert der angegebenen Ressource, die keine Zeichenfolge ist, zurück.</summary>
        <returns>Der Wert der Ressource, die für die aktuellen Kultureinstellungen des Aufrufers lokalisiert wurde. Wenn ein entsprechender Ressourcensatz vorhanden ist, jedoch <paramref name="name" /> nicht gefunden werden kann, gibt die Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Resources.ResourceManager.GetObject%2A> Methode wird verwendet, um nicht-Zeichenfolgenressourcen abzurufen. Dazu gehören die Werte, wie z. B. primitive Datentypen gehören <xref:System.Int32> oder <xref:System.Double>, Bitmaps (z. B. eine <xref:System.Drawing.Bitmap?displayProperty=nameWithType> Objekt), oder benutzerdefinierte von serialisierten Objekten. Das zurückgegebene Objekt muss in der Regel umgewandelt (in c#) oder (in Visual Basic) in ein Objekt des entsprechenden Typs konvertiert werden.  
  
 Die zurückgegebene Ressource lokalisiert wird, für die UI-Kultur des aktuellen Threads, die durch definiert wird die <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft. Wenn die Ressource für die jeweilige Kultur nicht lokalisiert ist, verwendet der Ressourcen-Manager fallback-Regeln, um eine entsprechende Ressource zu laden. Wenn kein passender Satz von lokalisierten Ressourcen gefunden wird, die <xref:System.Resources.ResourceManager> greift auf die Standardkultur Ressourcen zurück. Wenn ein Ressourcensatz, der für eine neutrale Kultur nicht gefunden wird, löst die Methode eine <xref:System.Resources.MissingManifestResourceException> Ausnahme oder, wenn der Ressourcensatz in einer Satellitenassembly befinden soll eine <xref:System.Resources.MissingSatelliteAssemblyException> Ausnahme. Falls der Ressourcen-Manager laden, kann eine entsprechende Ressource festgelegt, aber eine Ressource mit dem Namen wurde nicht gefunden `name`, gibt die Methode zurück `null`.  
  
 Die <xref:System.Resources.ResourceManager.IgnoreCase%2A> Eigenschaft bestimmt, ob der Vergleich `name` mit den Namen der Ressourcen ist Groß-/Kleinschreibung (Standard) oder Groß-/Kleinschreibung beachtet.  
  
> [!CAUTION]
>  Diese Methode kann Ausnahmen mehr als die aufgelisteten auslösen. Ein Grund, dies ist, wenn eine Methode, die diese Methode ruft eine Ausnahme auslöst.  Z. B. eine <xref:System.IO.FileLoadException> Ausnahme ausgelöst werden kann, wenn ein Fehler ausgelöst wurde, bereitstellen oder eine Satellitenassembly zu installieren, oder ein <xref:System.Runtime.Serialization.SerializationException> Ausnahme ausgelöst werden kann, wenn Sie ein benutzerdefinierten Typ eine benutzerdefinierte-Ausnahme auslöst, wenn der Typ deserialisiert wird.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Aufrufen der <xref:System.Resources.ResourceManager.GetObject%2A> -Methode mehrere Male mit dem gleichen `name` Parameter hängen nicht von der Methode, die ein Verweis auf das gleiche Objekt mit jedem Aufruf zurückgegeben wird. Grund hierfür ist die <xref:System.Resources.ResourceManager.GetObject%2A> Methode kann einen Verweis auf ein vorhandenes Ressourcenobjekt in einem Cache zurückgeben oder können die Ressource neu laden und einen Verweis auf ein neues Ressourcenobjekt zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Resources.ResourceManager.GetObject%28System.String%29> -Methode verwendet, um ein benutzerdefiniertes Objekt zu deserialisieren. Das Beispiel enthält eine Quellcodedatei mit dem Namen UIElements.cs (UIElements.vb, wenn Sie Visual Basic verwenden), definiert die folgende Struktur mit dem Namen `PersonTable`. Diese Struktur soll von einer allgemeinen Tabellen-Anzeigeroutine verwendet werden, die den lokalisierten Namen der Tabellenspalten anzeigt. Beachten Sie, dass die `PersonTable` -Struktur ist mit dem <xref:System.SerializableAttribute> -Attribut gekennzeichnet ist.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example.cs#6)]
 [!code-vb[Conceptual.Resources.Retrieving#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#6)]  
  
 Der folgende Code aus einer Datei mit dem Namen CreateResources.cs (CreateResources.vb für Visual Basic) erstellt eine XML-Ressourcendatei mit dem Namen UIResources.resx, die einen Tabellentitel und ein `PersonTable` -Objekt speichert, das Informationen für eine App enthält, die für die englische Sprache lokalisiert ist.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example1.cs#7)]
 [!code-vb[Conceptual.Resources.Retrieving#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#7)]  
  
 Der folgende Code in eine Quellcodedatei mit dem Namen GetObject.cs (GetObject.vb) ruft dann die Ressourcen ab und zeigt sie auf der Konsole an.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example2.cs#8)]
 [!code-vb[Conceptual.Resources.Retrieving#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example2.vb#8)]  
  
 Mit der folgenden Batchdatei können Sie die erforderliche Ressourcendatei und Assemblys erstellen und die App ausführen. Verwenden Sie die Option `/r` , um Resgen.exe einen Verweis auf UIElements.dll bereitzustellen, damit die Anwendung Zugriff auf Informationen über die `PersonTable` -Struktur erhält. Wenn Sie C# verwenden, ersetzen Sie den `vbc` -Compilernamen mit `csc`und ersetzen Sie die `.vb` -Erweiterung mit `.cs`.  
  
```  
  
vbc /t:library UIElements.vb  
vbc CreateResources.vb /r:UIElements.dll  
CreateResources  
  
resgen UIResources.resx  /r:UIElements.dll  
vbc GetObject.vb /r:UIElements.dll /resource:UIResources.resources  
  
GetObject.exe  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Es wurde kein passender Satz von lokalisierten Ressourcen gefunden, und es sind keine Standardkulturressourcen vorhanden. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Die Ressourcen der Standardkultur befinden sich in einer Satellitenassembly, die nicht gefunden werden konnte. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String)" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string * System.Globalization.CultureInfo -&gt; obj&#xA;override this.GetObject : string * System.Globalization.CultureInfo -&gt; obj" Usage="resourceManager.GetObject (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der abzurufenden Ressource.</param>
        <param name="culture">Die Kultur, für die die Ressource lokalisiert wurde. Wenn die Ressource für diese Kultur nicht lokalisiert ist, dann sucht der Ressourcen-Manager unter Verwendung von Fallback-Regeln nach einer geeigneten Ressource.  
  
Wenn dieser Wert <see langword="null" /> ist, wird das <see cref="T:System.Globalization.CultureInfo" />-Objekt durch die <see cref="P:System.Globalization.CultureInfo.CurrentUICulture" />-Eigenschaft abgerufen.</param>
        <summary>Ruft den Wert der angegebenen Ressource ab, die keine Zeichenfolge ist und für die angegebene Kultur lokalisiert wurde.</summary>
        <returns>Der Wert der Ressource, die für die angegebene Kultur lokalisiert wurde. Wenn ein entsprechender Ressourcensatz vorhanden ist, jedoch <paramref name="name" /> nicht gefunden werden kann, gibt die Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> Methode wird verwendet, um nicht-Zeichenfolgenressourcen abzurufen. Dazu gehören die Werte, wie z. B. primitive Datentypen gehören <xref:System.Int32> oder <xref:System.Double>, Bitmaps (z. B. eine <xref:System.Drawing.Bitmap?displayProperty=nameWithType> Objekt), oder benutzerdefinierte von serialisierten Objekten. Das zurückgegebene Objekt muss in der Regel umgewandelt (in c#) oder (in Visual Basic) in ein Objekt des entsprechenden Typs konvertiert werden.  
  
 Die zurückgegebene Ressource lokalisiert wird, für die Kultur, die angegebenen `culture`, oder für die Kultur, die angegeben wird die <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft Wenn `culture` ist `null`. Wenn die Ressource für die jeweilige Kultur nicht lokalisiert ist, verwendet der Ressourcen-Manager fallback-Regeln, um eine entsprechende Ressource zu laden. Wenn kein passender Satz von lokalisierten Ressourcen gefunden wird, greift der Ressourcen-Manager zurück auf die Ressourcen der Standardkultur. Wenn ein Ressourcensatz, der für eine neutrale Kultur nicht gefunden wird, löst die Methode eine <xref:System.Resources.MissingManifestResourceException> Ausnahme oder, wenn der Ressourcensatz in einer Satellitenassembly befinden soll eine <xref:System.Resources.MissingSatelliteAssemblyException> Ausnahme. Falls der Ressourcen-Manager laden, kann eine entsprechende Ressource festgelegt, aber eine Ressource mit dem Namen wurde nicht gefunden `name`, gibt die Methode zurück `null`.  
  
 Die <xref:System.Resources.ResourceManager.IgnoreCase%2A> Eigenschaft bestimmt, ob der Vergleich `name` mit den Namen der Ressourcen ist Groß-/Kleinschreibung (Standard) oder Groß-/Kleinschreibung beachtet.  
  
> [!CAUTION]
>  Diese Methode kann Ausnahmen mehr als die aufgelisteten auslösen. Ein Grund, dies ist, wenn eine Methode, die diese Methode ruft eine Ausnahme auslöst.  Z. B. eine <xref:System.IO.FileLoadException> Ausnahme ausgelöst werden kann, wenn ein Fehler ausgelöst wurde, bereitstellen oder eine Satellitenassembly zu installieren, oder ein <xref:System.Runtime.Serialization.SerializationException> Ausnahme ausgelöst werden kann, wenn Sie ein benutzerdefinierten Typ eine benutzerdefinierte-Ausnahme auslöst, wenn der Typ deserialisiert wird.  
  
## <a name="performance-considerations"></a>Überlegungen zur Leistung  
 Aufrufen der <xref:System.Resources.ResourceManager.GetObject%2A> -Methode mehrere Male mit dem gleichen `name` Parameter hängen nicht von der Methode, die ein Verweis auf das gleiche Objekt mit jedem Aufruf zurückgegeben wird. Grund hierfür ist die <xref:System.Resources.ResourceManager.GetObject%2A> Methode kann einen Verweis auf ein vorhandenes Ressourcenobjekt in einem Cache zurückgeben oder können die Ressource neu laden und einen Verweis auf ein neues Ressourcenobjekt zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> -Methode verwendet, um ein benutzerdefiniertes Objekt zu deserialisieren. Das Beispiel enthält eine Quellcodedatei mit dem Namen NumberInfo.cs (NumberInfo.vb, wenn Sie Visual Basic verwenden), definiert die folgende Struktur mit dem Namen `Numbers`. Diese Struktur soll von einer einfachen Bildungs-app verwendet werden, die nicht englische gesehen Schülern/Studenten auf 10 in englischer Sprache zählen erläutert. Beachten Sie, dass die `Numbers` Klasse markiert ist, mit der <xref:System.SerializableAttribute> Attribut.  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/numberinfo.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/numberinfo.vb#1)]  
  
 Die folgenden Quellcode aus einer Datei benannte CreateResources.cs (CreateResources.vb für Visual Basic) erstellt die XML-Ressourcendateien für Englisch als Standardsprache sowie zu den Sprachen Französisch, Portugiesisch und Russisch.  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/createresources.cs#2)]
 [!code-vb[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/createresources.vb#2)]  
  
 Die Ressourcen werden von der folgenden app genutzt, die die aktuelle Kultur auf Französisch (Frankreich), Portugiesisch (Brasilien) und Russisch (Russische Föderation) festlegt. Ruft die <xref:System.Resources.ResourceManager.GetObject%28System.String%29> -Methode zum Abrufen eine `Numbers` -Objekt, das lokalisierte Zahlen enthält und die <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> -Methode zum Abrufen einer `Numbers` -Objekt, das englische Zahlen enthält. Dann wird ungerade Zahlen, die mit der die aktuelle Benutzeroberflächenkultur und die englische Sprache angezeigt. Die Quellcodedatei heißt ShowNumbers.cs (ShowNumbers.vb).  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/shownumbers.cs#3)]
 [!code-vb[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/shownumbers.vb#3)]  
  
 Sie können die folgende Batchdatei verwenden, erstellen und Ausführen von Visual Basic-Version des Beispiels. Wenn Sie c# verwenden, ersetzen Sie `vbc` mit `csc`, und Ersetzen Sie die `.vb` Erweiterung mit `.cs`.  
  
```  
  
vbc /t:library NumberInfo.vb  
  
vbc CreateResources.vb /r:NumberInfo.dll  
CreateResources  
  
resgen NumberResources.resx /r:NumberInfo.dll  
  
resgen NumberResources.fr.resx /r:Numberinfo.dll  
Md fr  
al /embed:NumberResources.fr.resources /culture:fr /t:lib /out:fr\ShowNumbers.resources.dll  
  
resgen NumberResources.pt.resx  /r:Numberinfo.dll  
Md pt  
al /embed:NumberResources.pt.resources /culture:pt /t:lib /out:pt\ShowNumbers.resources.dll  
  
resgen NumberResources.ru.resx /r:Numberinfo.dll  
Md ru  
al /embed:NumberResources.ru.resources /culture:ru /t:lib /out:ru\ShowNumbers.resources.dll  
  
vbc ShowNumbers.vb /r:NumberInfo.dll /resource:NumberResources.resources  
ShowNumbers.exe  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Es wurde kein passender Satz von Ressourcen gefunden, und es sind keine Standardkulturressourcen vorhanden. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Die Ressourcen der Standardkultur befinden sich in einer Satellitenassembly, die nicht gefunden werden konnte. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <threadsafe>Die <see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" /> Methode ist threadsicher.</threadsafe>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceFileName">
      <MemberSignature Language="C#" Value="protected virtual string GetResourceFileName (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetResourceFileName(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResourceFileName (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetResourceFileName(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceFileName : System.Globalization.CultureInfo -&gt; string&#xA;override this.GetResourceFileName : System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetResourceFileName culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Das Kulturobjekt, für das ein Ressourcendateiname erstellt wird.</param>
        <summary>Generiert den Ressourcendateinamen für das angegebene <see cref="T:System.Globalization.CultureInfo" />-Objekt.</summary>
        <returns>Der Name, der für eine Ressourcendatei des angegebenen <see cref="T:System.Globalization.CultureInfo" />-Objekts verwendet werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Resources.ResourceManager.GetResourceFileName%2A> Methode ist nur nützlich, wenn Sie eine eigene Klasse, die Schreiben von abgeleitet ist die <xref:System.Resources.ResourceManager> Klasse.  
  
 Diese Methode verwendet die <xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType> Eigenschaft als Teil des Dateinamens für alle Kulturen als der invarianten Kultur. Diese Methode sucht nicht in ein Assemblymanifest oder Touch des Datenträgers und wird nur verwendet, um einen Dateinamen für die Ressource zu erstellen (geeignet für die Übergabe an die <xref:System.Resources.ResourceReader> Konstruktor) oder ein blobname Manifestressource.  
  
 Eine abgeleitete Klasse kann diese Methode, um nach einer anderen Erweiterung, suchen z. B. überschreiben ". ResX", oder einem anderen Schema für die Benennung von Ressourcendateien. Beachten Sie, dass die Methode zum Anpassen des Namens einer Ressourcendatei in eine Satellitenassembly und nicht für das Anpassen des Namens der Satellitenassembly selbst verwendet werden kann.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">Globalisieren und Lokalisieren von .NET-Anwendungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceSet">
      <MemberSignature Language="C#" Value="public virtual System.Resources.ResourceSet GetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Resources.ResourceSet GetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Resources::ResourceSet ^ GetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.GetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="tryParents" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Die Kultur, deren Ressourcen abgerufen werden sollen.</param>
        <param name="createIfNotExists"><see langword="true" />, um den Ressourcensatz zu laden, falls er noch nicht geladen wurde; andernfalls <see langword="false" />.</param>
        <param name="tryParents"><see langword="true" />, um Ressourcenfallback zu verwenden, um eine entsprechende Ressource zu laden, wenn der Ressourcensatz nicht gefunden werden kann; <see langword="false" />, um den Ressourcenfallback-Prozess zu umgehen.</param>
        <summary>Ruft die Ressource ab, die für eine bestimmte Kultur festgelegt wird.</summary>
        <returns>Die Ressource, die für die angegebene Kultur festgelegt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Ressourcensatz, der zurückgegeben wird, stellt die Ressourcen, die für die angegebene Kultur lokalisiert werden dar. Wenn die Ressourcen nicht für diese Kultur lokalisiert wurden und `tryParents` ist `true`, <xref:System.Resources.ResourceManager.GetResourceSet%2A> ressourcenfallbackregeln verwendet, um eine entsprechende Ressource zu laden. Wenn `tryParents` ist `false` und ein Satz kulturspezifische Ressource wurde nicht gefunden werden, die Methode gibt `null`. Weitere Informationen zu den Ressourcenfallback, finden Sie unter "Der Ressourcenfallback-Prozess" im Abschnitt der [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) Artikel.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Resources.ResourceManager.GetResourceSet%2A> Methode zum Abrufen von kulturspezifischen Ressourcen für die Kultur Französisch (Frankreich). Anschließend werden alle Ressourcen in den Ressourcensatz aufgezählt. Es enthält den Quellcode für eine ausführbare Datei namens ShowNumbers.exe. Darüber hinaus die folgenden zwei Textdatei, die die Namen der Zahlen enthalten. Die erste, NumberResources.txt, enthält die Namen der Zahlen von 1 bis 10 in Englischer Sprache an:  
  
```  
  
one=one  
two=two  
three=three  
four=four  
five=five  
six=six  
seven=seven  
eight=eight  
nine=nine  
ten=ten  
  
```  
  
 Das zweite NumberResources.fr-FR.txt, enthält die Namen der Zahlen von einer bis zu vier in französischer Sprache:  
  
```  
  
one=un  
two=deux  
three=trois  
four=quatre  
  
```  
  
 Eine Batchdatei können Sie die Ressourcendateien zu generieren, die englische Sprache-Ressourcendatei in die ausführbare Datei einbetten und erstellen eine Satellitenassembly für die französische Sprache-Ressourcen. Hier wird die Batchdatei eine ausführbare Datei, die mithilfe von Visual Basic-Compiler generiert:  
  
```  
  
resgen NumberResources.txt  
vbc shownumbers.vb /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
```  
  
 Für den c#-Compiler können Sie die folgende Batchdatei verwenden:  
  
```  
  
resgen NumberResources.txt  
csc shownumbers.cs /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/cs/shownumbers.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/vb/shownumbers.vb#1)]  
  
 Beachten Sie, dass, wenn Sie den Wert des Ändern der `createIfNotExists` Argument `false`, der Methodenaufruf zurückkehrt `null`, da die Ressourcen-Manager die Ressourcen für die französische Sprache noch nicht geladen wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="culture" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException"><paramref name="tryParents" /> ist <see langword="true" />, es wurde kein passender Satz von Ressourcen gefunden, und es sind keine Ressourcen für die Standardkultur vorhanden.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">Globalisieren und Lokalisieren von .NET-Anwendungen</related>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteContractVersion">
      <MemberSignature Language="C#" Value="protected static Version GetSatelliteContractVersion (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Version GetSatelliteContractVersion(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetSatelliteContractVersion(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetSatelliteContractVersion (a As Assembly) As Version" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static Version ^ GetSatelliteContractVersion(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetSatelliteContractVersion : System.Reflection.Assembly -&gt; Version" Usage="System.Resources.ResourceManager.GetSatelliteContractVersion a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="a">Die Assembly, die auf das <see cref="T:System.Resources.SatelliteContractVersionAttribute" />-Attribut überprüft werden soll.</param>
        <summary>Gibt die vom <see cref="T:System.Resources.SatelliteContractVersionAttribute" />-Attribut in der gegebenen Assembly angegebene Version zurück.</summary>
        <returns>Die Satellitenvertragsversion der angegebenen Assembly, oder <see langword="null" />, wenn keine Version gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Versionen von Satellitenassemblys, finden Sie unter den <xref:System.Resources.SatelliteContractVersionAttribute> Referenzthema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die in der Assembly <paramref name="a" /> gefundene <see cref="T:System.Version" /> ist ungültig.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="a" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein nicht verwaltetes Arbeitsspeicher-Datenstromobjekt aus einer angegebenen Ressource zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Der Name einer Ressource.</param>
        <summary>Gibt ein nicht verwaltetes Arbeitsspeicher-Datenstromobjekt aus der angegebenen Ressource zurück.</summary>
        <returns>Ein nicht verwaltetes Arbeitsspeicherstreamobjekt, das eine Ressource darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Resources.ResourceManager.GetStream%2A> Methode erhält den Namen einer Ressource, die als gespeichert ist eine <xref:System.IO.MemoryStream> Objekt, ruft den Wert des der <xref:System.Object> Ressource, und gibt eine <xref:System.IO.UnmanagedMemoryStream> Objekt. Es ist erforderlich, dass diese arbeiten Sie direkt in einen Stream von Bytes, das Sie dann auf ein Objekt konvertieren. Diese Methode eignet sich in erster Linie zur Verbesserung der Leistung: Abrufen einer Ressource als Byte-Stream anstelle eines expliziten Objekts kann die Leistung verbessern.  
  
 Die zurückgegebene Ressource lokalisiert wird, für die UI-Kultur des aktuellen Threads, die durch definiert wird die <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft. Wenn die Ressource für die jeweilige Kultur nicht lokalisiert ist, verwendet der Ressourcen-Manager fallback-Regeln, um eine entsprechende Ressource zu laden. Wenn kein passender Satz von lokalisierten Ressourcen gefunden wird, die <xref:System.Resources.ResourceManager> greift auf die Standardkultur Ressourcen zurück. Wenn ein Ressourcensatz, der für eine neutrale Kultur nicht gefunden wird, löst die Methode eine <xref:System.Resources.MissingManifestResourceException> Ausnahme oder, wenn der Ressourcensatz in einer Satellitenassembly befinden soll eine <xref:System.Resources.MissingSatelliteAssemblyException> Ausnahme. Falls der Ressourcen-Manager laden, kann eine entsprechende Ressource festgelegt, aber eine Ressource mit dem Namen wurde nicht gefunden `name`, gibt die Methode zurück `null`.  
  
 Die <xref:System.Resources.ResourceManager.IgnoreCase%2A> Eigenschaft bestimmt, ob der Vergleich `name` mit den Namen der Ressourcen ist Groß-/Kleinschreibung (Standard) oder Groß-/Kleinschreibung beachtet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Resources.ResourceManager.GetStream%28System.String%29> -Methode verwendet, um eine Bitmap abzurufen, die im Begrüßungsbildschirm-Fenster einer App erscheint. Der folgende Quellcode aus einer Datei mit dem Namen CreateResources.cs (für c#) oder CreateResources.vb (für Visual Basic) generiert eine RESX-Datei mit dem Namen AppResources.resx, die das serialisierte Bild enthält. In diesem Fall wird das Bild aus einer Datei namens SplashScreen.jpg geladen. Sie können den Dateinamen ändern und damit Ihr eigenes Bild laden.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/createresources.cs#4)]
 [!code-vb[Conceptual.Resources.Retrieving#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/createresources.vb#4)]  
  
 Der folgende code aus einer Datei namens GetStream.cs (für c#) oder GetStream.vb (für Visual Basic), dann Ruft die Ressource ab und zeigt das Bild in einem <xref:System.Windows.Forms.PictureBox?displayProperty=nameWithType> Steuerelement.  
  
 [!code-csharp[Conceptual.Resources.Retrieving#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/getstream.cs#5)]
 [!code-vb[Conceptual.Resources.Retrieving#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/getstream.vb#5)]  
  
 Sie können die folgende Batchdatei verwenden, um das C#-Beispiel zu erstellen. Ändern Sie in Visual Basic `csc` in `vbc`und ändern Sie die Erweiterung des Quellcodes von `.cs` in `.vb`. 
  
```  
  
csc CreateResources.cs  
CreateResources  
  
resgen AppResources.resx  
  
csc GetStream.cs /resource:AppResources.resources  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert der angegebenen Ressource ist kein <see cref="T:System.IO.MemoryStream" />-Objekt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Es wurde kein passender Satz von Ressourcen gefunden, und es sind keine Standardressourcen vorhanden. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Die Ressourcen der Standardkultur befinden sich in einer Satellitenassembly, die nicht gefunden werden konnte. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String, culture As CultureInfo) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string * System.Globalization.CultureInfo -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">Der Name einer Ressource.</param>
        <param name="culture">Ein Objekt, das die Kultur für die Ressourcensuche angibt. Wenn <paramref name="culture" /><see langword="null" /> ist, wird die Kultur für den aktuellen Thread verwendet.</param>
        <summary>Gibt mithilfe der angegebenen Kultur ein nicht verwaltetes Arbeitsspeicherstreamobjekt aus der angegebenen Ressource zurück.</summary>
        <returns>Ein nicht verwaltetes Arbeitsspeicherstreamobjekt, das eine Ressource darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Resources.ResourceManager.GetStream%2A> Methode erhält den Namen einer Ressource, die als gespeichert ist eine <xref:System.IO.MemoryStream> Objekt, ruft den Wert des der <xref:System.Object> Ressource, und gibt eine <xref:System.IO.UnmanagedMemoryStream> Objekt. Es ist erforderlich, dass diese arbeiten Sie direkt in einen Stream von Bytes, das Sie dann auf ein Objekt konvertieren. Diese Methode eignet sich in erster Linie zur Verbesserung der Leistung: Abrufen einer Ressource als Byte-Stream anstelle eines expliziten Objekts kann die Leistung verbessern.  
  
 Die zurückgegebene Ressource lokalisiert wird, für die Kultur, die angegebenen `culture`, oder für die Kultur, die angegeben wird die <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft Wenn `culture` ist `null`. Wenn die Ressource für die jeweilige Kultur nicht lokalisiert ist, verwendet der Ressourcen-Manager fallback-Regeln, um eine entsprechende Ressource zu laden. Wenn kein passender Satz von lokalisierten Ressourcen gefunden wird, die <xref:System.Resources.ResourceManager> greift auf die Standardkultur Ressourcen zurück. Wenn ein Ressourcensatz, der für eine neutrale Kultur nicht gefunden wird, löst die Methode eine <xref:System.Resources.MissingManifestResourceException> Ausnahme oder, wenn der Ressourcensatz in einer Satellitenassembly befinden soll eine <xref:System.Resources.MissingSatelliteAssemblyException> Ausnahme. Falls der Ressourcen-Manager laden, kann eine entsprechende Ressource festgelegt, aber eine Ressource mit dem Namen wurde nicht gefunden `name`, gibt die Methode zurück `null`.  
  
 Die <xref:System.Resources.ResourceManager.IgnoreCase%2A> Eigenschaft bestimmt, ob der Vergleich `name` mit den Namen der Ressourcen ist Groß-/Kleinschreibung (Standard) oder Groß-/Kleinschreibung beachtet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Wert der angegebenen Ressource ist kein <see cref="T:System.IO.MemoryStream" />-Objekt.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Es wurde kein passender Satz von Ressourcen gefunden, und es sind keine Standardressourcen vorhanden. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Die Ressourcen der Standardkultur befinden sich in einer Satellitenassembly, die nicht gefunden werden konnte. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die angegebene Zeichenfolgenressource für die angegebene Kultur oder die aktuelle UI-Kultur zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string -&gt; string&#xA;override this.GetString : string -&gt; string" Usage="resourceManager.GetString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der abzurufenden Ressource.</param>
        <summary>Gibt den Wert der angegebenen Zeichenkette zurück.</summary>
        <returns>Der Wert der Ressource, die für die aktuelle Benutzeroberflächenkultur des Aufrufers lokalisiert wurde, oder <see langword="null" />, wenn <paramref name="name" /> nicht in einen Ressourcensatz gefunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Desktop-Apps  
 In desktop-apps, die Ressource, die zurückgegeben werden lokalisiert wird für die UI-Kultur des aktuellen Threads, gemäß der <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft. Wenn die Ressource nicht für diese Kultur lokalisiert wurde, durchsucht der Ressourcen-Manager für eine Ressource anhand der Schritte im Abschnitt "Ressourcenfallback-Prozess" die [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) Artikel. Wenn kein passender Satz von lokalisierten Ressourcen gefunden wird, greift der Ressourcen-Manager zurück auf die Ressourcen der Standardkultur. Wenn der Ressourcen-Manager die Standardkultur Ressourcensatz nicht geladen werden kann, löst die Methode eine <xref:System.Resources.MissingManifestResourceException> Ausnahme oder, wenn der Ressourcensatz in einer Satellitenassembly befinden soll eine <xref:System.Resources.MissingSatelliteAssemblyException> Ausnahme. Falls der Ressourcen-Manager laden, kann eine entsprechende Ressource festgelegt, aber eine Ressource mit dem Namen wurde nicht gefunden `name`, gibt die Methode zurück `null`.  
  
 Die <xref:System.Resources.ResourceManager.IgnoreCase%2A> Eigenschaft bestimmt, ob der Vergleich `name` mit den Namen der Ressourcen ist Groß-/Kleinschreibung (Standard) oder Groß-/Kleinschreibung beachtet.  
  
> [!CAUTION]
>  Diese Methode kann Ausnahmen mehr als die aufgelisteten auslösen. Ein Grund, dies ist, wenn eine Methode, die diese Methode ruft eine Ausnahme auslöst.  Z. B. eine <xref:System.IO.FileLoadException> Ausnahme ausgelöst werden kann, wenn ein Fehler ausgelöst wurde, bereitstellen oder eine Satellitenassembly zu installieren, oder ein <xref:System.Runtime.Serialization.SerializationException> Ausnahme ausgelöst werden kann, wenn Sie ein benutzerdefinierten Typ eine benutzerdefinierte-Ausnahme auslöst, wenn der Typ deserialisiert wird.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]-Apps  
  
> [!IMPORTANT]
>  Obwohl die <xref:System.Resources.ResourceManager> Klasse wird von unterstützt [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps sollten nicht die Verwendung. Verwenden Sie diese Klasse nur beim Entwickeln von [!INCLUDE[net_portable](~/includes/net-portable-md.md)] Projekte, die mit verwendet werden können [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps. Zum Abrufen von Ressourcen aus [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps verwenden die [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) stattdessen.  
  
 In [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -apps, die <xref:System.Resources.ResourceManager.GetString%28System.String%29> -Methode gibt den Wert von der `name` Zeichenfolgenressource, die für die aktuelle UI-kultureinstellungen des Aufrufers lokalisiert. Die Liste der Kulturen wird aus der Liste des Betriebssystems der bevorzugten Benutzeroberfläche Sprache abgeleitet. Wenn der Ressourcen-Manager keine Übereinstimmung `name`, gibt die Methode zurück `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Resources.ResourceManager.GetString%2A> Methode zum Abrufen von kulturspezifischen Ressourcen. Es besteht aus Ressourcen, die von TXT-Dateien für den Englisch (En), Französisch (Frankreich) (fr-FR) und Russisch (Russische Föderation) (ru-RU) kompiliert Kulturen. Im Beispiel wird die aktuelle Kultur und die aktuelle UI-Kultur Englisch (Vereinigte Staaten), Französisch (Frankreich), Russisch (Russische Föderation) und Schwedisch (Schweden) geändert. Es ruft dann die <xref:System.Resources.ResourceManager.GetString%2A> Methode, um die lokalisierte Zeichenfolge abzurufen, die zusammen mit den aktuellen Tag und Monat angezeigt. Beachten Sie, dass die Ausgabe die entsprechende lokalisierte Zeichenfolge zeigt, es sei denn, die aktuelle Benutzeroberflächenkultur Schwedisch (Schweden). Da die Ressourcen der Schwedischen Sprache nicht verfügbar sind, verwendet die app stattdessen die Ressourcen der Standardkultur-Englisch. Das Beispiel erfordert die textbasierte Ressourcendateien, die in der folgenden Tabelle aufgeführt. Jede hat eine einzelne Zeichenfolgenressource mit dem Namen `DateStart`.  
  
|culture|Dateiname|Ressourcenname|Ressourcenwert|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|Heute ist|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|СЕГОДНЯ|  
  
 Sie können die folgende Batchdatei verwenden, um c#-Beispiel zu kompilieren. Ändern Sie in Visual Basic `csc` in `vbc`und ändern Sie die Erweiterung des Quellcodes von `.cs` in `.vb`.  
  
```  
resgen DateStrings.txt  
csc showdate.cs /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 Hier ist der Quellcode für das Beispiel (ShowDate.vb für Visual Basic-Version) oder ShowDate.cs für die C#-Version.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Wert der angegebenen Ressource ist keine Zeichenfolge.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Es wurde kein passender Satz von Ressourcen gefunden, und es sind keine neutralen Ressourcen für eine neutrale Kultur vorhanden. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Die Ressourcen der Standardkultur befinden sich in einer Satellitenassembly, die nicht gefunden werden konnte. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <threadsafe>Die <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> Methode ist threadsicher.</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eca16922-1c46-4f68-aefe-e7a12283641f">Abrufen von Ressourcen in Satellitenassemblys</related>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string * System.Globalization.CultureInfo -&gt; string&#xA;override this.GetString : string * System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetString (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der abzurufenden Ressource.</param>
        <param name="culture">Das Objekt, das die Kultur darstellt, für die die Ressource lokalisiert wird.</param>
        <summary>Gibt den Wert der Zeichenfolgenressource zurück, die für die angegebene Kultur lokalisiert wurde.</summary>
        <returns>Der Wert der Ressource, die für die angegebene Kultur lokalisiert wurde, oder <see langword="null" />, wenn <paramref name="name" /> nicht in einen Ressourcensatz gefunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>Desktop-Apps  
 In desktop-apps Wenn `culture` ist `null`, wird die <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> -Methode verwendet die aktuelle Benutzeroberflächenkultur abgerufen, die von der <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Die Ressource, die zurückgegeben wird für die durch angegebene Kultur lokalisiert wird die `culture` Parameter. Wenn die Ressource nicht für lokalisiert wurde `culture`, der Ressourcen-Manager-Tests für eine Ressource anhand der Schritte im Abschnitt "Ressourcenfallback-Prozess" die [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) Thema. Wenn kein passender Satz von Ressourcen gefunden wird, greift der Ressourcen-Manager zurück auf die Ressourcen der Standardkultur. Wenn der Ressourcen-Manager die Standardkultur Ressourcensatz nicht geladen werden kann, löst die Methode eine <xref:System.Resources.MissingManifestResourceException> Ausnahme oder, wenn der Ressourcensatz in einer Satellitenassembly befinden soll eine <xref:System.Resources.MissingSatelliteAssemblyException> Ausnahme. Falls der Ressourcen-Manager laden, kann eine entsprechende Ressource festgelegt, aber eine Ressource mit dem Namen wurde nicht gefunden `name`, gibt die Methode zurück `null`.  
  
 Die <xref:System.Resources.ResourceManager.IgnoreCase%2A> Eigenschaft bestimmt, ob der Vergleich `name` mit den Namen der Ressourcen ist Groß-/Kleinschreibung (Standard) oder Groß-/Kleinschreibung beachtet.  
  
> [!CAUTION]
>  Diese Methode kann Ausnahmen mehr als die aufgelisteten auslösen. Ein Grund, dies ist, wenn eine Methode, die diese Methode ruft eine Ausnahme auslöst.  Z. B. eine <xref:System.IO.FileLoadException> Ausnahme ausgelöst werden kann, wenn ein Fehler ausgelöst wurde, bereitstellen oder eine Satellitenassembly zu installieren, oder ein <xref:System.Runtime.Serialization.SerializationException> Ausnahme ausgelöst werden kann, wenn Sie ein benutzerdefinierten Typ eine benutzerdefinierte-Ausnahme auslöst, wenn der Typ deserialisiert wird.  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]-Apps  
  
> [!IMPORTANT]
>  Obwohl die <xref:System.Resources.ResourceManager> Klasse wird von unterstützt [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps sollten nicht die Verwendung. Verwenden Sie diese Klasse nur beim Entwickeln von [!INCLUDE[net_portable](~/includes/net-portable-md.md)] Projekte, die mit verwendet werden können [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps. Zum Abrufen von Ressourcen aus [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] apps verwenden die [Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) stattdessen.  
  
 In [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -apps, die <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> -Methode gibt den Wert von der `name` Zeichenfolgenressource, die für die durch angegebene Kultur lokalisiert die `culture` Parameter. Wenn die Ressource nicht, für lokalisiert ist die `culture` Kultur, die Suche verwendet die gesamte [!INCLUDE[win8](~/includes/win8-md.md)] Language-fallback-Liste, und nicht nach der Suche in der Standardkultur. Wenn der Ressourcen-Manager keine Übereinstimmung `name`, gibt die Methode zurück `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> Methode zum Abrufen von kulturspezifischen Ressourcen. Im Beispiel für die Standardkultur ist Englisch (En) und enthält Satellitenassemblys für Französisch (Frankreich) (fr-FR) und Russisch (Russische Föderation) (ru-RU) Kulturen. Im Beispiel wird nun der aktuellen Kultur und die aktuelle UI-Kultur Russisch (Russische Föderation) vor dem Aufruf <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>. Es ruft dann die <xref:System.Resources.ResourceManager.GetString%2A> Methode und die <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> -Methode auf und übergibt <xref:System.Globalization.CultureInfo> -Objekten, die (Frankreich) Kulturen Französisch und Schwedisch (Schweden) für jede Methode darstellen. In der Ausgabe den Monat und Tag des Monats als auch die Zeichenfolge, die sie vor in Französisch angezeigt, da die <xref:System.Resources.ResourceManager.GetString%2A> Methode ist die französische Sprachressource abrufen können. Allerdings, wenn die Kultur Schwedisch (Schweden) verwendet wird, den Monat und Tag des Monats werden in angezeigt Schwedisch, in englischer Sprache zwar die Zeichenfolge, die sie vor. Dies ist, der Ressourcen-Manager lokalisierte Sprachressourcen für Schwedisch, nicht finden kann, so, dass eine Ressource für die Standardkultur englische stattdessen zurückgegeben.  
  
 Das Beispiel erfordert die textbasierte Ressourcendateien, die in der folgenden Tabelle aufgeführt. Jede hat eine einzelne Zeichenfolgenressource mit dem Namen `DateStart`.  
  
|culture|Dateiname|Ressourcenname|Ressourcenwert|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|Heute ist|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|СЕГОДНЯ|  
  
 Sie können die folgende Batchdatei verwenden, um Visual Basic-Beispiel zu kompilieren. Ändern, um in C# -Code zu kompilieren, `vbc` zu `csc`, und ändern Sie die Erweiterung des Quellcodes von `.vb` zu `.cs`.  
  
```  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 Hier ist der Quellcode für das Beispiel (ShowDate.vb für Visual Basic-Version) oder ShowDate.cs für die C#-Version.  
  
 [!code-csharp[System.Resources.ResourceManager.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate2.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="name" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der Wert der angegebenen Ressource ist keine Zeichenfolge.</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">Es wurde kein passender Satz von Ressourcen gefunden, und es sind keine Ressourcen für eine Standardkultur vorhanden. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Die Ressourcen der Standardkultur befinden sich in einer Satellitenassembly, die nicht gefunden werden konnte. Informationen zur Behandlung dieser Ausnahme finden Sie im Abschnitt über die Behandlung von MissingManifestResourceException- und MissingSatelliteAssemblyException-Ausnahmen im Thema zur <see cref="T:System.Resources.ResourceManager" />-Klasse.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <threadsafe>Die <see cref="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" /> Methode ist threadsicher.</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Verpacken und Bereitstellen von Ressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="HeaderVersionNumber">
      <MemberSignature Language="C#" Value="public static readonly int HeaderVersionNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 HeaderVersionNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderVersionNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int HeaderVersionNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeaderVersionNumber : int" Usage="System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Version der Ressourcendateiheader an, die die aktuelle Implementierung von <see cref="T:System.Resources.ResourceManager" /> interpretieren und erstellen kann.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreCase">
      <MemberSignature Language="C#" Value="public virtual bool IgnoreCase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.IgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IgnoreCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IgnoreCase { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreCase : bool with get, set" Usage="System.Resources.ResourceManager.IgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob der Ressourcen-Manager eine Ressourcensuche ohne Berücksichtigung der Groß- und Kleinschreibung in der <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />-Methode und der <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" />-Methode zulässt, oder legt diesen fest.</summary>
        <value><see langword="true" />, um die Groß-/Kleinschreibung während der Ressourcensuche zu ignorieren; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert des der <xref:System.Resources.ResourceManager.IgnoreCase%2A> Eigenschaft `false`, eine Ressource mit dem Namen "Ressource" entspricht nicht der Ressource mit dem Namen "Resource". Wenn <xref:System.Resources.ResourceManager.IgnoreCase%2A> ist `true`, eine Ressource mit dem Namen "Ressource" die Ressource mit dem Namen "Resource" entspricht. Beachten Sie jedoch, bei <xref:System.Resources.ResourceManager.IgnoreCase%2A> ist `true`, <xref:System.Resources.ResourceManager.GetString%2A?displayProperty=nameWithType> und <xref:System.Resources.ResourceManager.GetObject%2A?displayProperty=nameWithType> Methoden führen die Groß-/Kleinschreibung Zeichenfolgenvergleiche mit der invarianten Kultur. Der Vorteil ist, dass sich die Ergebnisse von Groß-/Kleinschreibung Zeichenfolgenvergleichen von diesen Methoden auf allen Computern unabhängig von der Kultur entsprechen. Der Nachteil ist, dass die Ergebnisse nicht mit den Regeln der Groß-und Kleinschreibung aller Kulturen konsistent sind.  
  
 Beispielsweise hat im türkische Alphabet, zwei Versionen des Zeichens I: mit einem Punkt und ohne Punkt. Im türkischen ist ich (Unicode 0049) das Zeichen Großbuchstaben in der ein anderes Zeichen ı (Unicode 0131) betrachtet. Das Zeichen i (Unicode-0069) die kleinschreibungsvariante eines weiteren Zeichen (Unicode 0130) betrachtet. Gemäß diesen Regeln der Groß-und Kleinschreibung, einen Zeichenfolgenvergleich von den Zeichen i (Unicode-0069) und (Unicode 0049) für die Kultur "tr-TR" (Türkisch (Türkei) fehlschlagen sollte. Aber da der Vergleich durchgeführt wird, mit der Groß-/ Kleinschreibregeln der invarianten Kultur, wenn <xref:System.Resources.ResourceManager.IgnoreCase%2A> ist `true`, dieser Vergleich erfolgreich ausgeführt.  
  
> [!NOTE]
>  Aus Leistungsgründen empfiehlt es sich, immer die Groß-/Kleinschreibung für die Ressourcennamen anzugeben. Festlegen von <xref:System.Resources.ResourceManager.IgnoreCase%2A> zu `true` kann dazu führen, dass eine erhebliche Leistungssteigerung im Workingset und die eine erhebliche Abnahme der Leistung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalGetResourceSet">
      <MemberSignature Language="C#" Value="protected virtual System.Resources.ResourceSet InternalGetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Resources.ResourceSet InternalGetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function InternalGetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Resources::ResourceSet ^ InternalGetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.InternalGetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="tryParents" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">Das Kulturobjekt, nach dem gesucht werden soll.</param>
        <param name="createIfNotExists"><see langword="true" />, um den Ressourcensatz zu laden, falls er noch nicht geladen wurde; andernfalls <see langword="false" />.</param>
        <param name="tryParents"><see langword="true" />, um übergeordnete <see cref="T:System.Globalization.CultureInfo" />-Objekte zu prüfen, wenn der Ressourcensatz nicht geladen werden kann; andernfalls <see langword="false" />.</param>
        <summary>Stellt die Implementierung zum Suchen eines Ressourcensatzes bereit.</summary>
        <returns>Der angegebene Ressourcensatz.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Die Hauptassembly enthält keine .resources-Datei, die erforderlich ist, um eine Ressource zu suchen.</exception>
        <exception cref="T:System.ExecutionEngineException">In der Laufzeit ist ein interner Fehler aufgetreten.</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">Die <paramref name="culture" /> zugeordnete Satellitenassembly konnte sich nicht gefunden werden.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <block subset="none" type="overrides"><para>Diese Methode schließt alle erforderlichen Schritte zum finden Sie eine Ressource festgelegt und kann "Recursive" und Reentrant sein. Das heißt, diese Methode lädt möglicherweise eine Assembly und der Trigger ein <see cref="E:System.AppDomain.AssemblyLoad" /> -Ereignis, das dann aufruft eine <see cref="T:System.Resources.ResourceManager" /> -Objekt, das nicht vollständig initialisiert wurde. Um zu vermeiden, zusätzlichen Sperren benötigt, ist diese Methode nicht threadsicher. Die <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />, <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />, und <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> Methoden führen alle notwendige Synchronisierung.</para></block>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">Globalisieren und Lokalisieren von .NET-Anwendungen</related>
      </Docs>
    </Member>
    <Member MemberName="MagicNumber">
      <MemberSignature Language="C#" Value="public static readonly int MagicNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MagicNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MagicNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MagicNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int MagicNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable MagicNumber : int" Usage="System.Resources.ResourceManager.MagicNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält die Nummer für die Bezeichnung von Ressourcendateien.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert wird auf 0xBEEFCACE festgelegt. Die ersten vier Bytes der Datei-Standardformat des Systems enthalten eine 32-Bit-Ganzzahl mit Vorzeichen im little-Endian-Format (finden Sie unter <xref:System.Text.Encoding>).  
  
 Wenn die <xref:System.Resources.ResourceManager.MagicNumber> gefunden wird, werden die folgenden Bytes werden eine Versionsnummer für eine <xref:System.Resources.ResourceManager> -Header, gefolgt von einer Zahl, der angibt, wie viele Bytes übersprungen werden soll, um nach dieser Header zu erhalten. Die nächste Zahl gibt die Version des der <xref:System.Resources.ResourceManager> , die die Header, gefolgt von versionsspezifischen Informationen erstellt.  
  
 Die Versionsnummer für die aktuelle Implementierung ist eine. Die nächsten Bytes sind eine Längenpräfix-Zeichenfolge, die mit dem Namen des ein <xref:System.Resources.IResourceReader>, dem diese Datei lesen kann.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainAssembly">
      <MemberSignature Language="C#" Value="protected System.Reflection.Assembly MainAssembly;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Reflection.Assembly MainAssembly" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MainAssembly" />
      <MemberSignature Language="VB.NET" Value="Protected MainAssembly As Assembly " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Reflection::Assembly ^ MainAssembly;" />
      <MemberSignature Language="F#" Value="val mutable MainAssembly : System.Reflection.Assembly" Usage="System.Resources.ResourceManager.MainAssembly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Hauptassembly an, die die Ressourcen enthält.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Resources.ResourceManager.MainAssembly> Feld ist nur nützlich, wenn Sie eine eigene Klasse, die Schreiben von abgeleitet ist die <xref:System.Resources.ResourceManager> Klasse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllResources">
      <MemberSignature Language="C#" Value="public virtual void ReleaseAllResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseAllResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.ReleaseAllResources" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReleaseAllResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseAllResources();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseAllResources : unit -&gt; unit&#xA;override this.ReleaseAllResources : unit -&gt; unit" Usage="resourceManager.ReleaseAllResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Teilt dem Ressourcenmanager mit, die Methode <see cref="M:System.Resources.ResourceSet.Close" /> bei allen <see cref="T:System.Resources.ResourceSet" />-Objekten aufzurufen und alle Ressourcen freizugeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird der Arbeitssatz in einer ausgeführten app verkleinert. Alle nachfolgenden Suchvorgänge auf diesem <xref:System.Resources.ResourceManager> Objekt wird so teuer wie die erste Suche sein, da der Ressourcen-Manager zu suchen und Laden Sie die Ressourcen erneut. Dies kann in den in einigen komplexen Szenarien threading nützlich sein, wobei es sich bei Erstellen eines neuen <xref:System.Resources.ResourceManager> Objekt ist das entsprechende Verhalten.  
  
> [!NOTE]
>  Ab .NET Framework, Version 2.0 der <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> Methode ist nicht threadsicher in Bezug auf <xref:System.Resources.ResourceManager.GetObject%2A>, <xref:System.Resources.ResourceManager.GetString%2A>, und <xref:System.Resources.ResourceManager.GetStream%2A> Vorgänge. Der Vorteil dieser Änderung ist eine Leistungssteigerung für mehrere Threads, die Zugriff auf Ressourcen. Allerdings Aufrufen der <xref:System.Resources.ResourceManager.ReleaseAllResources%2A> -Methode in einem Thread, während gleichzeitig eine Ressource in einem anderen Thread, der Get-Vorgang kann Auslösen einer <xref:System.ObjectDisposedException> Ausnahme.  
  
 Sie können diese Methode auch in Situationen verwenden, in denen die verwalteten Instanzen für die Ressourcen, die von der aktuellen Ressourcen-Manager erstellt haben, deterministisch, ohne zu warten, für die Ressourcen-Manager vollständig außerhalb des gültigen Bereichs und Garbage Collection freigegeben werden.  
  
> [!NOTE]
>  Das Aufrufen dieser Methode wird die Satellitenassemblys nicht entladen. Verwenden Sie zum Entladen von Assemblys der Ressourcensatelliten der <xref:System.AppDomain.Unload%2A> Methode.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ResourceSets">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable ResourceSets;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Hashtable ResourceSets" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.ResourceSets" />
      <MemberSignature Language="VB.NET" Value="Protected ResourceSets As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Collections::Hashtable ^ ResourceSets;" />
      <MemberSignature Language="F#" Value="val mutable ResourceSets : System.Collections.Hashtable" Usage="System.Resources.ResourceManager.ResourceSets" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("call InternalGetResourceSet instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält eine <see cref="T:System.Collections.Hashtable" /> die eine Zuordnung von Kulturen zu <see cref="T:System.Resources.ResourceSet" />-Objekten zurückgibt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSetType">
      <MemberSignature Language="C#" Value="public virtual Type ResourceSetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ResourceSetType" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.ResourceSetType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ResourceSetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ResourceSetType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ResourceSetType : Type" Usage="System.Resources.ResourceManager.ResourceSetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des Ressourcensatzobjekts ab, das der Ressourcen-Manager verwendet, um ein <see cref="T:System.Resources.ResourceSet" />-Objekt zu erstellen.</summary>
        <value>Der Typ des Ressourcensatzobjekts, das der Ressourcen-Manager verwendet, um ein <see cref="T:System.Resources.ResourceSet" />-Objekt zu erstellen.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>