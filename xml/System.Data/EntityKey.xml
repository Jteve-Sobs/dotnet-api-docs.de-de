<Type Name="EntityKey" FullName="System.Data.EntityKey">
  <Metadata><Meta Name="ms.openlocfilehash" Value="57d2602577864e93f9c5733f9b15b555c902ffb2" /><Meta Name="ms.sourcegitcommit" Value="1bb00d2f4343e73ae8d58668f02297a3cf10a4c1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="06/15/2019" /><Meta Name="ms.locfileid" Value="63889650" /></Metadata><TypeSignature Language="C#" Value="public sealed class EntityKey : IEquatable&lt;System.Data.EntityKey&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityKey extends System.Object implements class System.IEquatable`1&lt;class System.Data.EntityKey&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Data.EntityKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityKey&#xA;Implements IEquatable(Of EntityKey)" />
  <TypeSignature Language="C++ CLI" Value="public ref class EntityKey sealed : IEquatable&lt;System::Data::EntityKey ^&gt;" />
  <TypeSignature Language="F#" Value="type EntityKey = class&#xA;    interface IEquatable&lt;EntityKey&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Data.EntityKey&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{ConcatKeyValue()}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.DataContract(IsReference=true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine permanente Referenz auf ein Objekt bereit, das eine Instanz eines Entitätstyps ist.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.EntityKey>-Objekte sind unveränderlich, d. h. sie können nach ihrer Erstellung nicht geändert werden.  
  
 Weitere Informationen finden Sie unter [arbeiten mit Entitätsschlüsseln](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/dd283139(v=vs.100)).  
  
   
  
## Examples  
 Diese Beispiele beruhen auf der [AdventureWorks Sales-Modell](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Die Beispiele veranschaulichen, wie zum Erstellen und Verwenden einer <xref:System.Data.EntityKey>.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.EntityKey" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.EntityKey" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; entityKeyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, entityKeyValues As IEnumerable(Of KeyValuePair(Of String, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ entityKeyValues);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, entityKeyValues)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">Ein <see cref="T:System.String" />, der den vom Entitätencontainernamen qualifizierten Entitätenmengennamen darstellt.</param>
        <param name="entityKeyValues">Eine generische <see cref="T:System.Collections.Generic.KeyValuePair" />-Auflistung.  
  
Jedes Schlüssel/Wert-Paar hat einen Eigenschaftsnamen als Schlüssel und den Wert dieser Eigenschaft als Wert. Für jede Eigenschaft, die zu <see cref="T:System.Data.EntityKey" /> gehört, sollte ein Paar existieren. Die Reihenfolge der Schlüssel/Wert-Paare ist nicht von Bedeutung. Es sollte jedoch jede Schlüsseleigenschaft enthalten sein. Die Eigenschaftsnamen sind einfache Namen, die nicht mit einem Entitätstypennamen oder dem Schemanamen qualifiziert sind.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.EntityKey" />-Klasse mit einem Entitätenmengennamen und einer generischen <see cref="T:System.Collections.Generic.KeyValuePair" />-Auflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel basiert auf der [AdventureWorks Sales-Modell](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Das Beispiel zeigt, wie zum Erstellen und Verwenden einer <xref:System.Data.EntityKey>.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.EntityKeyMember&gt; entityKeyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Data.EntityKeyMember})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, entityKeyValues As IEnumerable(Of EntityKeyMember))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::Collections::Generic::IEnumerable&lt;System::Data::EntityKeyMember ^&gt; ^ entityKeyValues);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * seq&lt;System.Data.EntityKeyMember&gt; -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, entityKeyValues)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">Ein <see cref="T:System.String" />, der den vom Entitätencontainernamen qualifizierten Entitätenmengennamen darstellt.</param>
        <param name="entityKeyValues">Eine <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung von <see cref="T:System.Data.EntityKeyMember" />-Objekten, mit denen der Schlüssel initialisiert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.EntityKey" />-Klasse mit einem Entitätenmengennamen und einer <see cref="T:System.Collections.Generic.IEnumerable`1" />-Auflistung von <see cref="T:System.Data.EntityKeyMember" />-Objekten.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, string keyName, object keyValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, string keyName, object keyValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, keyName As String, keyValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::String ^ keyName, System::Object ^ keyValue);" />
      <MemberSignature Language="F#" Value="new System.Data.EntityKey : string * string * obj -&gt; System.Data.EntityKey" Usage="new System.Data.EntityKey (qualifiedEntitySetName, keyName, keyValue)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="keyValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">Ein <see cref="T:System.String" />, der den vom Entitätencontainernamen qualifizierten Entitätenmengennamen darstellt.</param>
        <param name="keyName">Ein <see cref="T:System.String" />, der den Namen des Schlüssels darstellt.</param>
        <param name="keyValue">Ein <see cref="T:System.Object" />, das den Schlüsselwert darstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.EntityKey" />-Klasse mit einem Entitätenmengennamen und einem spezifischen Entitätsschlüsselpaar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 In diesem Beispiel basiert auf der [AdventureWorks Sales-Modell](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Das Beispiel zeigt, wie zum Erstellen und Verwenden einer <xref:System.Data.EntityKey>.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityContainerName">
      <MemberSignature Language="C#" Value="public string EntityContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntityContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntityContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EntityContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntityContainerName : string with get, set" Usage="System.Data.EntityKey.EntityContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Entitätscontainers ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.String" />-Wert, der den Namen des Entitätencontainers für die Entität darstellt, zu der der <see cref="T:System.Data.EntityKey" /> gehört.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityKeyValues">
      <MemberSignature Language="C#" Value="public System.Data.EntityKeyMember[] EntityKeyValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.EntityKeyMember[] EntityKeyValues" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntityKeyValues" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityKeyValues As EntityKeyMember()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ EntityKeyValues { cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ get(); void set(cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntityKeyValues : System.Data.EntityKeyMember[] with get, set" Usage="System.Data.EntityKey.EntityKeyValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.EntityKeyMember[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die diesem <see cref="T:System.Data.EntityKey" /> zugeordneten Schlüsselwerte ab oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> von Schlüsselwerten für diesen <see cref="T:System.Data.EntityKey" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.EntityKey>-Klasse enthält eine Kopie der Werte, aus denen der für diesen Entitätstyp angegebene logische Schlüssel besteht.  
  
 Die Member der <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> haben je einen Eigenschaftsnamen und einen Wert in einem <xref:System.Collections.Generic.KeyValuePair%602>. Dabei ist der Eigenschaftsname der Schlüssel und der tatsächliche Wert dieser Eigenschaft für dieses Objekt der Wert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityNotValidKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey EntityNotValidKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey EntityNotValidKey" />
      <MemberSignature Language="DocId" Value="F:System.Data.EntityKey.EntityNotValidKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EntityNotValidKey As EntityKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::EntityKey ^ EntityNotValidKey;" />
      <MemberSignature Language="F#" Value=" staticval mutable EntityNotValidKey : System.Data.EntityKey" Usage="System.Data.EntityKey.EntityNotValidKey" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine einfache <see cref="T:System.Data.EntityKey" />-Klasse, die eine Entität identifiziert, die bei einer fehlgeschlagenen [TREAT](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md)-Operation erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt verschiedene Möglichkeiten, eine ungültige Entität abzurufen. Das häufigste Szenario ist, wenn ein [!INCLUDE[esql](~/includes/esql-md.md)] Abfrage verwendet die [BEHANDELN](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md) Operator Interpretieren von einer Instanz eines polymorphen Typs als einen bestimmten Typ und die betreffende Instanz stimmt nicht überein. ([BEHANDELN](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md) ist vergleichbar mit der C#- `as` Operator). In diesem Fall gibt die Abfrage eine ungültige Entität zurück, deren Entitätsschlüssel auf <xref:System.Data.EntityKey.EntityNotValidKey> festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntitySetName">
      <MemberSignature Language="C#" Value="public string EntitySetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntitySetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntitySetName" />
      <MemberSignature Language="VB.NET" Value="Public Property EntitySetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EntitySetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EntitySetName : string with get, set" Usage="System.Data.EntityKey.EntitySetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der Entitätenmenge ab oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.String" />-Wert, der den Namen der Entitätenmenge für die Entität darstellt, zu der der <see cref="T:System.Data.EntityKey" /> gehört.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Data.EntityKey other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Data.EntityKey other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.Equals(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Data::EntityKey ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Data.EntityKey -&gt; bool" Usage="entityKey.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="other">Ein <see cref="T:System.Data.EntityKey" />-Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen <see cref="T:System.Data.EntityKey" /> ist.</summary>
        <returns><see langword="true" />, wenn diese Instanz und <paramref name="other" /> gleiche Werte aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Temporäre Schlüssel verfügen über eine andere Vergleichssemantik als permanente Schlüssel:  
  
-   Temporäre Schlüssel verwenden Verweisgleichheit. Das heißt, zwei Verweise auf dieselbe temporäre <xref:System.Data.EntityKey>-Instanz sind gleich. Andere <xref:System.Data.EntityKey>-Instanzen sind nicht gleich.  
  
-   Permanente Schlüssel bestimmen Gleichheit auf Grundlage der Werte der enthaltenen Schlüsseleigenschaften und der <xref:System.Data.Metadata.Edm.EntitySet>. Das heißt, dass zwei verschiedene <xref:System.Data.EntityKey>-Instanzen gleich sind, wenn ihre Entitätenmengen und ihre Schlüsselwerte gleich sind.  
  
 Außerdem verfügen temporäre Schlüssel im Gegensatz zu permanenten Schlüsseln über keine <xref:System.Data.Metadata.Edm.EntitySet> oder Schlüsselwerte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="entityKey.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein <see cref="T:System.Object" />, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
        <returns><see langword="true" />, wenn diese Instanz und <paramref name="obj" /> gleiche Werte aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Temporäre Schlüssel verfügen über eine andere Vergleichssemantik als permanente Schlüssel:  
  
-   Temporäre Schlüssel verwenden Verweisgleichheit. Das heißt, zwei Verweise auf dieselbe temporäre <xref:System.Data.EntityKey>-Instanz sind gleich. Andere <xref:System.Data.EntityKey>-Instanzen sind nicht gleich.  
  
-   Permanente Schlüssel bestimmen Gleichheit auf Grundlage der Werte der enthaltenen Schlüsseleigenschaften und der <xref:System.Data.Metadata.Edm.EntitySet>. Das heißt, dass zwei verschiedene <xref:System.Data.EntityKey>-Instanzen gleich sind, wenn sie über dieselben <xref:System.Data.Metadata.Edm.EntitySet>-Objekte verfügen und ihre Schlüsselwerte gleich sind.  
  
 Außerdem verfügen temporäre Schlüssel im Gegensatz zu permanenten Schlüsseln über keine <xref:System.Data.Metadata.Edm.EntitySet> oder Schlüsselwerte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntitySet">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.EntitySet GetEntitySet (System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Metadata.Edm.EntitySet GetEntitySet(class System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.GetEntitySet(System.Data.Metadata.Edm.MetadataWorkspace)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Metadata::Edm::EntitySet ^ GetEntitySet(System::Data::Metadata::Edm::MetadataWorkspace ^ metadataWorkspace);" />
      <MemberSignature Language="F#" Value="member this.GetEntitySet : System.Data.Metadata.Edm.MetadataWorkspace -&gt; System.Data.Metadata.Edm.EntitySet" Usage="entityKey.GetEntitySet metadataWorkspace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.EntitySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataWorkspace" Type="System.Data.Metadata.Edm.MetadataWorkspace" />
      </Parameters>
      <Docs>
        <param name="metadataWorkspace">Die Metadaten-Arbeitsbereich, der die Entität enthält.</param>
        <summary>Ruft die Entitätenmenge für diesen Entitätsschlüssel vom angegebenen Metadaten-Arbeitsbereich ab.</summary>
        <returns>Die <see cref="T:System.Data.Metadata.Edm.EntitySet" /> für den Entitätsschlüssel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Auf die Entitätenmenge wird mithilfe der Entitätencontainer- und Entitätenmengennamen des Schlüssels zugegriffen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die Entitätenmenge konnte im angegebenen Metadaten-Arbeitsbereich nicht gefunden werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="entityKey.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fungiert als Hashfunktion für das aktuelle <see cref="T:System.Data.EntityKey" />-Objekt. <see cref="M:System.Data.EntityKey.GetHashCode" /> eignet sich zur Verwendung in Hashalgorithmen und -datenstrukturen, z. B. in einer Hashtabelle.</summary>
        <returns>Ein Hashcode für die aktuelle <see cref="T:System.Data.EntityKey" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.EntityKey.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Data.EntityKey" /> temporär ist.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Data.EntityKey" /> temporär ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Erstellung einer neuen Entität definiert [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] einen temporären Schlüssel und legt die <xref:System.Data.EntityKey.IsTemporary%2A>-Eigenschaft auf `true` fest. Beim Aufrufen der <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> -Methode, die [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] weist einen permanenten Schlüssel zu und legt sie fest der <xref:System.Data.EntityKey.IsTemporary%2A> Eigenschaft `false`.  
  
> [!NOTE]
>  Temporäre Schlüssel werden automatisch vom Framework erstellt. Sie können vom Benutzer nicht direkt erstellt werden.  
  
 Temporäre Schlüssel verfügen über eine andere Vergleichssemantik als permanente Schlüssel:  
  
-   Temporäre Schlüssel verwenden Verweisgleichheit. Das heißt, zwei Verweise auf dieselbe temporäre <xref:System.Data.EntityKey>-Instanz sind gleich. Andere <xref:System.Data.EntityKey>-Instanzen sind nicht gleich.  
  
-   Permanente Schlüssel bestimmen Gleichheit auf Grundlage der Werte der enthaltenen Schlüsseleigenschaften und der <xref:System.Data.Metadata.Edm.EntitySet>. Das heißt, dass zwei verschiedene <xref:System.Data.EntityKey>-Instanzen gleich sind, wenn ihre Entitätenmengen und ihre Schlüsselwerte gleich sind.  
  
 Außerdem verfügen temporäre Schlüssel im Gegensatz zu permanenten Schlüsseln über keine <xref:System.Data.Metadata.Edm.EntitySet> oder Schlüsselwerte.  
  
 Wenn die <xref:System.Data.Objects.ObjectStateEntry.AcceptChanges%2A>-Methode für den <xref:System.Data.Objects.ObjectStateEntry> einer Entität aufgerufen wird und die Entität aus dem <xref:System.Data.EntityState.Added>-Zustand in den <xref:System.Data.EntityState.Unchanged>-Zustand übergeht, berechnet [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] automatisch einen neuen permanenten Schlüssel für die Entität und synchronisiert alle temporären Schlüsselverweise.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoEntitySetKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey NoEntitySetKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey NoEntitySetKey" />
      <MemberSignature Language="DocId" Value="F:System.Data.EntityKey.NoEntitySetKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoEntitySetKey As EntityKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::EntityKey ^ NoEntitySetKey;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoEntitySetKey : System.Data.EntityKey" Usage="System.Data.EntityKey.NoEntitySetKey" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ein Singleton-<see cref="T:System.Data.EntityKey" />, durch den eine schreibgeschützte Entität identifiziert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine schreibgeschützte Entität identifiziert eine Entität, die in jeder Hinsicht gültig ist, jedoch nicht mit einer tatsächlichen Entitätenmenge verknüpft ist. Dies kann als Ergebnis einer [!INCLUDE[esql](~/includes/esql-md.md)]-Abfrage auftreten, die eine im Text der Abfrage angegebene Entitätsinstanz erstellt und zurückgibt (im Gegensatz zu einer von einer Datenbanktabelle abgerufenen Entität). Eine Entität ohne Entitätenmenge kann nicht in der Datenbank gespeichert werden, bevor sie einer Entitätenmenge zugeordnet wird. Daher behandelt das Objektmaterialisierungsprogramm diese Art von Entität so, als wäre die <xref:System.Data.Objects.MergeOption.NoTracking>-Zusammenführungsoption angegeben, unabhängig von der tatsächlich angegebenen Zusammenführungsoption. Ein Entitätsobjekt wird erstellt, jedoch wird dessen Identität nicht aufgelöst, und es wird dem Status-Manager für den Materialisierungsvorgang nicht hinzugefügt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialized">
      <MemberSignature Language="C#" Value="public void OnDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.OnDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnDeserialized : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityKey.OnDeserialized context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Beschreibt die Quelle und das Ziel eines angegebenen serialisierten Streams und stellt einen zusätzlichen, vom Aufrufer definierten Kontext bereit.</param>
        <summary>Hilfsmethode zur Deserialisierung eines <see cref="T:System.Data.EntityKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Object Services verwendet <xref:System.Data.EntityKey.OnDeserialized%2A> zur Deserialisierung eines <xref:System.Data.EntityKey>. Weitere Informationen finden Sie unter [Serialisieren von Objekten](https://msdn.microsoft.com/library/06c77f9b-5b2e-4c78-b3e3-8c148ba0ea99).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserializing">
      <MemberSignature Language="C#" Value="public void OnDeserializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.OnDeserializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnDeserializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnDeserializing : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityKey.OnDeserializing context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnDeserializing</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Beschreibt die Quelle und das Ziel eines angegebenen serialisierten Streams und stellt einen zusätzlichen aufruferdefinierten Kontext bereit.</param>
        <summary>Hilfsmethode zur Deserialisierung eines <see cref="T:System.Data.EntityKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Object Services verwendet <xref:System.Data.EntityKey.OnDeserializing%2A> zur Deserialisierung eines <xref:System.Data.EntityKey>. Weitere Informationen finden Sie unter [Serialisieren von Objekten](https://msdn.microsoft.com/library/06c77f9b-5b2e-4c78-b3e3-8c148ba0ea99).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Equality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (key1 As EntityKey, key2 As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Data::EntityKey ^ key1, System::Data::EntityKey ^ key2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Data.EntityKey * System.Data.EntityKey -&gt; bool" Usage="key1 = key2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1">Ein zu vergleichender <see cref="T:System.Data.EntityKey" />.</param>
        <param name="key2">Ein zu vergleichender <see cref="T:System.Data.EntityKey" />.</param>
        <summary>Vergleicht zwei <see cref="T:System.Data.EntityKey" />-Objekte.</summary>
        <returns><see langword="true" />, wenn der <paramref name="key1" />-Wert und der <paramref name="key2" />-Wert gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Temporäre Schlüssel verfügen über eine andere Vergleichssemantik als permanente Schlüssel:  
  
-   Temporäre Schlüssel verwenden Verweisgleichheit. Das heißt, zwei Verweise auf dieselbe temporäre <xref:System.Data.EntityKey>-Instanz sind gleich. Andere <xref:System.Data.EntityKey>-Instanzen sind nicht gleich.  
  
-   Permanente Schlüssel bestimmen Gleichheit auf Grundlage der Werte der enthaltenen Schlüsseleigenschaften und der <xref:System.Data.Metadata.Edm.EntitySet>. Das heißt, dass zwei verschiedene <xref:System.Data.EntityKey>-Instanzen gleich sind, wenn ihre Entitätenmengen und ihre Schlüsselwerte gleich sind.  
  
 Außerdem verfügen temporäre Schlüssel im Gegensatz zu permanenten Schlüsseln über keine <xref:System.Data.Metadata.Edm.EntitySet> oder Schlüsselwerte.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality"> <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Inequality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberType>Methode</MemberType> <AssemblyInfo> <AssemblyName>System.Data.Entity</AssemblyName> <AssemblyVersion>4.0.0.0</AssemblyVersion> </AssemblyInfo>
      <ReturnValue> <ReturnType>System.Boolean</ReturnType> </ReturnValue>
      <Parameters> <Parameter Name="key1" Type="System.Data.EntityKey" /> <Parameter Name="key2" Type="System.Data.EntityKey" /> </Parameters>
      <Docs>
        <param name="key1">Ein zu vergleichender <see cref="T:System.Data.EntityKey" />.</param>
        <param name="key2">Ein zu vergleichender <see cref="T:System.Data.EntityKey" />.</param>
        <summary>Vergleicht zwei <see cref="T:System.Data.EntityKey" />-Objekte.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="key1" />-Wert und der <paramref name="key2" />-Wert nicht gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Temporäre Schlüssel verfügen über eine andere Vergleichssemantik als permanente Schlüssel:  
  
-   Temporäre Schlüssel verwenden Verweisgleichheit. Das heißt, zwei Verweise auf dieselbe temporäre <xref:System.Data.EntityKey>-Instanz sind gleich. Andere <xref:System.Data.EntityKey>-Instanzen sind nicht gleich.  
  
-   Permanente Schlüssel bestimmen Gleichheit auf Grundlage der Werte der enthaltenen Schlüsseleigenschaften und der <xref:System.Data.Metadata.Edm.EntitySet>. Das heißt, dass zwei verschiedene <xref:System.Data.EntityKey>-Instanzen gleich sind, wenn ihre Entitätenmengen und ihre Schlüsselwerte gleich sind.  
  
 Außerdem verfügen temporäre Schlüssel im Gegensatz zu regulären Schlüsseln über keine <xref:System.Data.Metadata.Edm.EntitySet> oder Schlüsselwerte.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Inequality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (key1 As EntityKey, key2 As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Data::EntityKey ^ key1, System::Data::EntityKey ^ key2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Data.EntityKey * System.Data.EntityKey -&gt; bool" Usage="System.Data.EntityKey.op_Inequality (key1, key2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1">Ein zu vergleichender <see cref="T:System.Data.EntityKey" />.</param>
        <param name="key2">Ein zu vergleichender <see cref="T:System.Data.EntityKey" />.</param>
        <summary>Vergleicht zwei <see cref="T:System.Data.EntityKey" />-Objekte.</summary>
        <returns><see langword="true" />, wenn der <paramref name="key1" />-Wert und der <paramref name="key2" />-Wert nicht gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Temporäre Schlüssel verfügen über eine andere Vergleichssemantik als permanente Schlüssel:  
  
-   Temporäre Schlüssel verwenden Verweisgleichheit. Das heißt, zwei Verweise auf dieselbe temporäre <xref:System.Data.EntityKey>-Instanz sind gleich. Andere <xref:System.Data.EntityKey>-Instanzen sind nicht gleich.  
  
-   Permanente Schlüssel bestimmen Gleichheit auf Grundlage der Werte der enthaltenen Schlüsseleigenschaften und der <xref:System.Data.Metadata.Edm.EntitySet>. Das heißt, dass zwei verschiedene <xref:System.Data.EntityKey>-Instanzen gleich sind, wenn ihre Entitätenmengen und ihre Schlüsselwerte gleich sind.  
  
 Außerdem verfügen temporäre Schlüssel im Gegensatz zu regulären Schlüsseln über keine <xref:System.Data.Metadata.Edm.EntitySet> oder Schlüsselwerte.]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>