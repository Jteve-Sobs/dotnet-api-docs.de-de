<Type Name="IDataAdapter" FullName="System.Data.IDataAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="04acc5f938041cbe186142d2bbb5fe676f37af4c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69122091" /></Metadata><TypeSignature Language="C#" Value="public interface IDataAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDataAdapter" />
  <TypeSignature Language="DocId" Value="T:System.Data.IDataAdapter" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDataAdapter" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDataAdapter" />
  <TypeSignature Language="F#" Value="type IDataAdapter = interface" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Ermöglicht einem Objekt das Implementieren eines DataAdapter und stellt eine Gruppe von Methoden und zuordnungsbezogenen Eigenschaften dar, mit denen ein <see cref="T:System.Data.DataSet" /> gefüllt und aktualisiert sowie eine Datenquelle aktualisiert wird.  
  
 <see cref="T:System.Data.IDbDataAdapter" />-Instanzen gelten für Datenquellen, die relationale Datenbanken mit Textbefehlen (wie Transact-SQL) sind (oder ihnen ähneln), während <see cref="T:System.Data.IDataAdapter" />-Instanzen jeden Datenquelltyp verwenden können.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.IDataAdapter> -Schnittstelle ermöglicht es einer erbenden Klasse, eine DataAdapter-Klasse zu implementieren, die die Bridge zwischen einer <xref:System.Data.DataSet>Datenquelle und einem darstellt. Weitere Informationen zu DataAdapter-Klassen finden Sie unter Auffüllen [eines Datasets aus einem DataAdapter](~/docs/framework/data/adonet/populating-a-dataset-from-a-dataadapter.md).  
  
 Eine Anwendung erstellt nicht direkt eine Instanz der <xref:System.Data.IDataAdapter> Schnittstelle, sondern implementiert eine Instanz einer Klasse, die erbt. <xref:System.Data.IDataAdapter>  
  
 Klassen, die <xref:System.Data.IDataAdapter> erben, müssen die geerbten Member implementieren, und Sie definieren in der Regel zusätzliche Member, um anbieterspezifische Funktionen hinzuzufügen. Die <xref:System.Data.IDataAdapter> -Schnittstelle definiert z. <xref:System.Data.IDataAdapter.Fill%2A> b. eine Methode <xref:System.Data.DataSet> , die einen als Parameter annimmt. Wiederum erbt die <xref:System.Data.OleDb.OleDbDataAdapter> -Klasse die <xref:System.Data.Common.DbDataAdapter.Fill%2A> -Methode und definiert außerdem zwei <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> zusätzliche über Ladungen der-Methode, die ein ADO-Recordset-Objekt als Parameter annehmen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die abgeleiteten Klassen <xref:System.Data.SqlClient.SqlCommand> <xref:System.Data.SqlClient.SqlDataAdapter>,, und <xref:System.Data.SqlClient.SqlConnection>verwendet, um Datensätze aus einer Datenbank auszuwählen. Der ausgefüllte <xref:System.Data.DataSet> wird dann zurückgegeben. Zu diesem Zweck wird der Methode eine initialisierte <xref:System.Data.DataSet>, eine Verbindungs Zeichenfolge und eine Abfrage Zeichenfolge, die eine Transact-SQL-SELECT-Anweisung ist, übermittelt.  
  
 [!code-csharp[Classic WebData SqlDataAdapter Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlDataAdapter Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlDataAdapter Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlDataAdapter Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Um die Konsistenz zwischen .NET Framework Datenanbietern zu fördern, benennen Sie die erbende Klasse <paramref name="Prv" /> in der Form DataAdapter, wobei <paramref name="Prv" /> das einheitliche Präfix ist, das für alle Klassen in einem bestimmten .NET Framework Datenanbieter-Namespace angegeben wird. Beispielsweise <paramref name="Sql" /> ist das Präfix <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> der-Klasse im <see langword="System.Data.SqlClient" /> -Namespace.  
  
Wenn Sie von der <see cref="T:System.Data.IDataAdapter" /> -Schnittstelle erben, sollten Sie die folgenden Konstruktoren implementieren: 
 <list type="table"><listheader><term> Element 
 </term><description> Beschreibung 
 </description></listheader><item><term> PrvDataAdapter() 
 </term><description> Initialisiert eine neue Instanz der PrvDataAdapter-Klasse.  
  
 </description></item><item><term> PrvDataAdapter (PrvCommand SelectCommand) 
 </term><description> Initialisiert eine neue Instanz der PrvDataAdapter-Klasse, indem die angegebene SQL SELECT-Anweisung verwendet wird.  
  
 </description></item><item><term> PrvDataAdapter (String selectCommandText, String selectConnectionString) 
 </term><description> Initialisiert eine neue Instanz der PrvDataAdapter-Klasse mit einer SQL-SELECT-Anweisung und einer Verbindungs Zeichenfolge.  
  
 </description></item><item><term> PrvDataAdapter (String selectCommandText, PrvConnection selectconnection) 
 </term><description> Initialisiert eine neue Instanz der PrvDataAdapter-Klasse mit einer SQL-SELECT-Anweisung und einem PrvConnection-Objekt.  
  
 </description></item></list></para></block>
  </Docs>
  <Members>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="abstract member Fill : System.Data.DataSet -&gt; int" Usage="iDataAdapter.Fill dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">Ein <see cref="T:System.Data.DataSet" />, das mit Datensätzen und bei Bedarf mit einem Schema gefüllt wird.</param>
        <summary>Fügt dem <see cref="T:System.Data.DataSet" /> unter Verwendung des <see cref="T:System.Data.DataSet" />-Namens Zeilen hinzu bzw. aktualisiert diese, um eine Übereinstimmung mit den Zeilen in der Datenquelle zu erzielen, und erstellt eine <see cref="T:System.Data.DataTable" /> mit der Bezeichnung "Table".</summary>
        <returns>Die Anzahl der Zeilen, die dem <see cref="T:System.Data.DataSet" /> erfolgreich hinzufügt bzw. darin aktualisiert wurden. Dies schließt keine Zeilen ein, die von Anweisungen betroffen sind, die keine Zeilen zurückgeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.IDataAdapter.Fill%2A>Ruft Zeilen aus der Datenquelle mithilfe der SELECT-Anweisung ab, die von <xref:System.Data.IDbDataAdapter.SelectCommand%2A> einer zugeordneten Eigenschaft angegeben wird. Das Verbindungs Objekt, das der SELECT-Anweisung zugeordnet ist, muss gültig sein, aber es muss nicht geöffnet sein. Wenn die Verbindung geschlossen wird, <xref:System.Data.IDataAdapter.Fill%2A> bevor aufgerufen wird, wird Sie geöffnet, um Daten abzurufen und dann geschlossen zu werden. Wenn die Verbindung geöffnet ist, <xref:System.Data.IDataAdapter.Fill%2A> bevor aufgerufen wird, bleibt Sie geöffnet.  
  
 Der <xref:System.Data.IDataAdapter.Fill%2A> -Vorgang fügt dann die Zeilen zu <xref:System.Data.DataTable> den Ziel Objekten <xref:System.Data.DataSet>in hinzu und <xref:System.Data.DataTable> erstellt die Objekte, wenn Sie nicht bereits vorhanden sind. Beim Erstellen <xref:System.Data.DataTable> von Objekten erstellt <xref:System.Data.IDataAdapter.Fill%2A> der Vorgang in der Regel nur Spaltennamen Metadaten. Wenn die-Eigenschaft <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> jedoch auf `AddWithKey`festgelegt ist, werden auch die entsprechenden Primärschlüssel und Einschränkungen erstellt.  
  
 Wenn vom `SelectCommand` die Ergebnisse eines OUTER JOIN zurückgegeben werden, wird vom `DataAdapter` kein <xref:System.Data.DataTable.PrimaryKey%2A> -Wert für die resultierende <xref:System.Data.DataTable>festgelegt. Sie müssen den Primärschlüssel explizit definieren, um sicherzustellen, dass doppelte Zeilen ordnungsgemäß aufgelöst werden. Weitere Informationen finden Sie unter [Definieren von primär Schlüsseln](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
 Wenn beim Auffüllen von doppelte Spalten <xref:System.Data.DataTable>gefunden werden, werden die Namen für die aufeinander folgenden Spalten mit dem Muster "columnname1", "columnname2", "columnname3" usw. generiert. <xref:System.Data.IDataAdapter> Wenn die eingehenden Daten unbenannte Spalten enthalten, werden Sie <xref:System.Data.DataSet> gemäß dem Muster "Column1", "Column2" usw. in eingefügt. Wenn der <xref:System.Data.DataSet>mehrere Resultsets hinzugefügt werden, wird jedes Resultset in einer separaten Tabelle abgelegt. Zusätzliche Resultsets werden benannt, indem ganzzahlige Werte an den angegebenen Tabellennamen angehängt werden (z. b. "Table", "table1", "table2" usw.). Anwendungen sollten bei der Verwendung von Spalten-und Tabellennamen Vorsicht walten lassen, um sicherzustellen, dass keine Konflikte mit diesen Benennungs Mustern auftreten.  
  
 Wenn die SELECT-Anweisung, die <xref:System.Data.DataSet> zum Auffüllen von verwendet wird, mehrere Ergebnisse zurückgibt, wie z. b. eine Batch-SQL-Anweisung, werden alle nachfolgenden Ergebnisse übersprungen und der <xref:System.Data.DataSet>nicht hinzugefügt.  
  
 Die <xref:System.Data.IDataAdapter.Fill%2A> -Methode kann mehrmals auf demselben <xref:System.Data.DataTable>verwendet werden. Wenn ein Primärschlüssel vorhanden ist, werden eingehende Zeilen mit übereinstimmenden Zeilen zusammengeführt, die bereits vorhanden sind. Wenn kein Primärschlüssel vorhanden ist, werden eingehende Zeilen an <xref:System.Data.DataTable>das angefügt.  
  
> [!NOTE]
>  Bei der Verarbeitung von Batch-SQL-Anweisungen, die mehrere Ergebnisse <xref:System.Data.IDataAdapter.Fill%2A> zurück <xref:System.Data.IDataAdapter.FillSchema%2A> geben, ruft die Implementierung von und für einen .NET Framework-Datenanbieter Schema Informationen nur für das erste Ergebnis ab.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType);" />
      <MemberSignature Language="F#" Value="abstract member FillSchema : System.Data.DataSet * System.Data.SchemaType -&gt; System.Data.DataTable[]" Usage="iDataAdapter.FillSchema (dataSet, schemaType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataSet">Die mit dem Schema aus der Datenquelle zu füllende <see cref="T:System.Data.DataSet" />.</param>
        <param name="schemaType">Einer der <see cref="T:System.Data.SchemaType" />-Werte.</param>
        <summary>Fügt eine <see cref="T:System.Data.DataTable" /> namens „Tabelle“ zum angegebenen <see cref="T:System.Data.DataSet" /> hinzu und konfiguriert das Schema auf der Grundlage des angegebenen <see cref="T:System.Data.SchemaType" /> so, dass es mit dem Schema in der Datenquelle übereinstimmt.</summary>
        <returns>Ein Array von <see cref="T:System.Data.DataTable" />-Objekten, die aus der Datenquelle zurückgegebene Schemainformationen enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.IDataAdapter.FillSchema%2A> -Methode ruft das Schema <xref:System.Data.IDbDataAdapter.SelectCommand%2A>mithilfe von aus der Datenquelle ab. Das Verbindungs Objekt, das <xref:System.Data.IDbDataAdapter.SelectCommand%2A> zugeordnet ist, muss gültig sein, aber es muss nicht geöffnet sein. Wenn die Verbindung geschlossen wird, <xref:System.Data.IDataAdapter.FillSchema%2A> bevor aufgerufen wird, wird Sie geöffnet, um Daten abzurufen und dann geschlossen zu werden. Wenn die Verbindung geöffnet ist, <xref:System.Data.IDataAdapter.FillSchema%2A> bevor aufgerufen wird, bleibt Sie geöffnet.  
  
 Ein <xref:System.Data.IDataAdapter.FillSchema%2A> -Vorgang fügt <xref:System.Data.DataTable> dem Ziel <xref:System.Data.DataSet>einen hinzu. Anschließend werden der <xref:System.Data.DataColumnCollection> <xref:System.Data.DataTable> von Spalten hinzugefügt, und die folgenden <xref:System.Data.DataColumn> Eigenschaften werden konfiguriert, wenn Sie in der Datenquelle vorhanden sind:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Sie müssen und <xref:System.Data.DataColumn.AutoIncrementStep%2A> <xref:System.Data.DataColumn.AutoIncrementSeed%2A> separat festlegen.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.IDataAdapter.FillSchema%2A>konfiguriert auch die <xref:System.Data.DataTable.PrimaryKey%2A> Eigenschaften und <xref:System.Data.DataTable.Constraints%2A> gemäß den folgenden Regeln:  
  
-   Wenn eine oder mehrere Primärschlüssel Spalten von <xref:System.Data.IDbDataAdapter.SelectCommand%2A>zurückgegeben werden, werden diese als Primärschlüssel Spalten für das <xref:System.Data.DataTable>verwendet.  
  
-   Wenn keine Primärschlüssel Spalten zurückgegeben werden, aber eindeutige Spalten sind, werden die eindeutigen Spalten als Primärschlüssel verwendet, wenn für alle eindeutigen Spalten keine NULL-Werte zulässig sind. Wenn eine der Spalten NULL-Werte zulässt, wird <xref:System.Data.UniqueConstraint> ein hinzugefügt <xref:System.Data.ConstraintCollection>, aber die <xref:System.Data.DataTable.PrimaryKey%2A> -Eigenschaft ist nicht festgelegt.  
  
-   Wenn sowohl Primärschlüssel Spalten als auch eindeutige Spalten zurückgegeben werden, werden die Primärschlüssel Spalten als Primärschlüssel Spalten für das <xref:System.Data.DataTable>verwendet.  
  
 Beachten Sie, dass Primärschlüssel und UNIQUE-Einschränkungen <xref:System.Data.ConstraintCollection> gemäß den vorherigen Regeln zu hinzugefügt werden, andere Einschränkungs Typen jedoch nicht hinzugefügt werden.  
  
 Wenn ein eindeutiger gruppierter Index für eine Spalte oder Spalten in einer SQL Server Tabelle definiert ist und die PRIMARY KEY-Einschränkung für einen separaten Satz von Spalten definiert ist, werden die Namen der Spalten im gruppierten Index zurückgegeben. Um die Namen oder Namen der Primärschlüssel Spalten zurückzugeben, verwenden Sie einen Abfrage Hinweis mit der SELECT-Anweisung, die den Namen des Primärschlüssel Indexes angibt. Weitere Informationen zum Angeben von Abfrage hinweisen finden Sie unter [Query Hint (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).  
  
 Wenn beim Auffüllen von doppelte Spalten <xref:System.Data.DataTable>gefunden werden, werden die Namen für die aufeinander folgenden Spalten mit dem Muster "columnname1", "columnname2", "columnname3" usw. generiert. <xref:System.Data.IDataAdapter> Wenn die eingehenden Daten unbenannte Spalten enthalten, werden Sie <xref:System.Data.DataSet> gemäß dem Muster "Column1", "Column2" usw. in eingefügt. Wenn der <xref:System.Data.DataSet>mehrere Resultsets hinzugefügt werden, wird jedes Resultset in einer separaten Tabelle abgelegt. Zusätzliche Resultsets werden benannt, indem ganzzahlige Werte an den angegebenen Tabellennamen angehängt werden (z. b. "Table", "table1", "table2" usw.). Anwendungen sollten bei der Verwendung von Spalten-und Tabellennamen Vorsicht walten lassen, um sicherzustellen, dass keine Konflikte mit diesen Benennungs Mustern auftreten.  
  
 <xref:System.Data.IDataAdapter.FillSchema%2A>gibt keine Zeilen zurück. Verwenden Sie <xref:System.Data.IDataAdapter.Fill%2A> die-Methode, um Zeilen <xref:System.Data.DataTable>zu hinzuzufügen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" />
      </Docs>
    </Member>
    <Member MemberName="GetFillParameters">
      <MemberSignature Language="C#" Value="public System.Data.IDataParameter[] GetFillParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.IDataParameter[] GetFillParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.GetFillParameters" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFillParameters () As IDataParameter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::IDataParameter ^&gt; ^ GetFillParameters();" />
      <MemberSignature Language="F#" Value="abstract member GetFillParameters : unit -&gt; System.Data.IDataParameter[]" Usage="iDataAdapter.GetFillParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Parameter ab, die vom Benutzer beim Ausführen einer SQL-SELECT-Anweisung festgelegt wurden.</summary>
        <returns>Ein Array von <see cref="T:System.Data.IDataParameter" />-Objekten, das die vom Benutzer festgelegten Parameter enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
```  
private static void GetParameters(String connectionString) {  
           using (SqlConnection conn = new SqlConnection(connectionString)) {  
              String queryString = "Select [CourseID],[Title],[Credits] from [MySchool].[dbo].[Course] where [Year]=@Year and [Credits]>=@Credits";   
              SqlParameter year = new SqlParameter("@Year", 2012);   
              SqlParameter credits = new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits");   
              credits.Value = 4; SqlCommand command = new SqlCommand(queryString, conn);   
              command.Parameters.Add(year);   
              command.Parameters.Add(credits);   
              IDbDataAdapter mySchool = new SqlDataAdapter(command);   
              IDataParameter[] parameters = mySchool.GetFillParameters();  
              Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", "ParameterName", "SourceColumn", "Direction", "DbType", "Value");   
              foreach (IDataParameter parameter in parameters) {   
                 Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", parameter.ParameterName, parameter.SourceColumn, parameter.Direction, parameter.DbType, parameter.Value);   
              }  
           }  
        }  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MissingMappingAction">
      <MemberSignature Language="C#" Value="public System.Data.MissingMappingAction MissingMappingAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.MissingMappingAction MissingMappingAction" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.MissingMappingAction" />
      <MemberSignature Language="VB.NET" Value="Public Property MissingMappingAction As MissingMappingAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::MissingMappingAction MissingMappingAction { System::Data::MissingMappingAction get(); void set(System::Data::MissingMappingAction value); };" />
      <MemberSignature Language="F#" Value="member this.MissingMappingAction : System.Data.MissingMappingAction with get, set" Usage="System.Data.IDataAdapter.MissingMappingAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MissingMappingAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob nicht zugeordnete Quelltabellen oder Spalten mit ihren Quellnamen zum Filtern übergeben werden, oder ob ein Fehler ausgelöst wird.</summary>
        <value>Einer der <see cref="T:System.Data.MissingMappingAction" />-Werte. Die Standardeinstellung ist <see langword="Passthrough" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.IDataAdapter.TableMappings%2A> -Eigenschaft stellt die Master Zuordnung zwischen den zurückgegebenen Daten <xref:System.Data.DataSet>Sätzen und der bereit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der festgelegte Wert ist keiner der <see cref="T:System.Data.MissingMappingAction" />-Werte.</exception>
        <altmember cref="P:System.Data.IDataAdapter.MissingSchemaAction" />
      </Docs>
    </Member>
    <Member MemberName="MissingSchemaAction">
      <MemberSignature Language="C#" Value="public System.Data.MissingSchemaAction MissingSchemaAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.MissingSchemaAction MissingSchemaAction" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.MissingSchemaAction" />
      <MemberSignature Language="VB.NET" Value="Public Property MissingSchemaAction As MissingSchemaAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::MissingSchemaAction MissingSchemaAction { System::Data::MissingSchemaAction get(); void set(System::Data::MissingSchemaAction value); };" />
      <MemberSignature Language="F#" Value="member this.MissingSchemaAction : System.Data.MissingSchemaAction with get, set" Usage="System.Data.IDataAdapter.MissingSchemaAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MissingSchemaAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob fehlende Quelltabellen, Spalten und ihre Beziehungen dem Datasetschema hinzugefügt oder ignoriert werden, oder ob ein Fehler ausgelöst wird.</summary>
        <value>Einer der <see cref="T:System.Data.MissingSchemaAction" />-Werte. Die Standardeinstellung ist <see langword="Add" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der festgelegte Wert ist keiner der <see cref="T:System.Data.MissingSchemaAction" />-Werte.</exception>
        <altmember cref="P:System.Data.Common.DataAdapter.MissingMappingAction" />
      </Docs>
    </Member>
    <Member MemberName="TableMappings">
      <MemberSignature Language="C#" Value="public System.Data.ITableMappingCollection TableMappings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ITableMappingCollection TableMappings" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.TableMappings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TableMappings As ITableMappingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ITableMappingCollection ^ TableMappings { System::Data::ITableMappingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TableMappings : System.Data.ITableMappingCollection" Usage="System.Data.IDataAdapter.TableMappings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.ITableMappingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, wie eine Quelltabelle einer Datasettabelle zugeordnet wird.</summary>
        <value>Eine Auflistung, die die Masterzuordnung zwischen den zurückgegebenen Datensätzen und dem <see cref="T:System.Data.DataSet" /> bereitstellt. Der Standardwert ist eine leere Auflistung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.IDataAdapter> Verwendet nur die Zuordnungen für die Quell Tabelle mit dem Namen "Table". Alle SELECT-, INSERT-, DELETE-und Update-Anweisungen, die Daten zurückgeben, müssen dies mithilfe der konsistenten Spalten Benennung tun Die in den Datensätzen zurückgegebenen Spaltennamen müssen eindeutig sein, andernfalls überschreiben Spalten mit doppelten Namen vorherige Daten. Bei <xref:System.Data.IDataAdapter.Update%2A>werden die Änderungen nur für die Tabelle, die der Quell Tabelle mit dem Namen "Table" zugeordnet ist, ausgeglichen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Update(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="abstract member Update : System.Data.DataSet -&gt; int" Usage="iDataAdapter.Update dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">Die <see cref="T:System.Data.DataSet" />, mit der die Datenquelle aktualisiert wird.</param>
        <summary>Ruft für jede Zeile im angegebenen <see cref="T:System.Data.DataSet" /> einer <see cref="T:System.Data.DataTable" /> mit dem Namen "Table", die eingefügt, aktualisiert oder gelöscht wird, die INSERT-Anweisung, die UPDATE-Anweisung bzw. die DELETE-Anweisung auf.</summary>
        <returns>Die Anzahl der erfolgreich aktualisierten Zeilen im <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Anwendung die <xref:System.Data.IDataAdapter.Update%2A> -Methode aufruft <xref:System.Data.IDataAdapter> , wird die <xref:System.Data.DataRow.RowState%2A> -Eigenschaft von überprüft, und die erforderlichen INSERT-, Update-oder DELETE-Anweisungen werden iterativ für jede Zeile ausgeführt, basierend auf der Reihenfolge der Indizes, die im <xref:System.Data.DataSet>. Beispielsweise <xref:System.Data.IDataAdapter.Update%2A> kann eine DELETE-Anweisung, gefolgt von einer INSERT-Anweisung, und dann eine weitere DELETE-Anweisung ausführen, aufgrund der Reihenfolge der Zeilen <xref:System.Data.DataTable>im.  
  
 Beachten Sie, dass diese Anweisungen nicht als Batch Prozess ausgeführt werden. jede Zeile wird einzeln aktualisiert. Eine Anwendung kann die <xref:System.Data.DataSet.GetChanges%2A> -Methode aufzurufen, wenn Sie die Reihenfolge der Anweisungstypen steuern müssen (z. b. vor Updates einfügen). Weitere Informationen finden Sie unter [Aktualisieren von Datenquellen mit DataAdapters](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Wenn INSERT-, Update-oder DELETE-Anweisungen nicht angegeben wurden, <xref:System.Data.Common.DataAdapter.Update%2A> generiert die Methode eine Ausnahme. Sie können jedoch ein <xref:System.Data.SqlClient.SqlCommandBuilder> -oder <xref:System.Data.OleDb.OleDbCommandBuilder> -Objekt zum automatischen Generieren von SQL-Anweisungen für Updates mit einer einzelnen Tabelle erstellen `SelectCommand` , wenn Sie die-Eigenschaft eines .NET Framework Datenanbieters festlegen. Anschließend werden alle zusätzlichen SQL-Anweisungen, die Sie nicht festlegen, vom CommandBuilder generiert. Diese Generierungs Logik erfordert, dass Schlüssel Spalten Informationen in <xref:System.Data.DataSet>vorhanden sind. Weitere Informationen finden Sie [unter Erstellen von Befehlen mit CommandBuilder](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 Die <xref:System.Data.Common.DataAdapter.Update%2A> -Methode ruft Zeilen aus der Tabelle ab, die in der ersten Zuordnung aufgeführt ist, bevor ein Update durchgeführt wird. Der <xref:System.Data.Common.DataAdapter.Update%2A> aktualisiert dann die Zeile mit dem Wert <xref:System.Data.IDbCommand.UpdatedRowSource%2A> der-Eigenschaft. Alle zurückgegebenen zusätzlichen Zeilen werden ignoriert.  
  
 Nachdem alle Daten wieder in den <xref:System.Data.DataSet>geladen wurden, wird das <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> -Ereignis ausgelöst, sodass der <xref:System.Data.DataSet> Benutzer die abgeglichen Zeile und alle Ausgabeparameter, die vom Befehl zurückgegeben werden, überprüfen kann. Nachdem eine Zeile erfolgreich aktualisiert wurde, werden die Änderungen an dieser Zeile akzeptiert.  
  
 Bei Verwendung <xref:System.Data.IDataAdapter.Update%2A>von lautet die Reihenfolge der Ausführung wie folgt:  
  
1.  Die Werte in <xref:System.Data.DataRow> werden in die Parameterwerte verschoben.  
  
2.  Das <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A>-Ereignis wird ausgelöst.  
  
3.  Der Befehl wird ausgeführt.  
  
4.  Wenn der Befehl auf `FirstReturnedRecord`festgelegt ist, wird das erste zurückgegebene Ergebnis <xref:System.Data.DataRow>in eingefügt.  
  
5.  Wenn Ausgabeparameter vorhanden sind, werden diese in die <xref:System.Data.DataRow>eingefügt.  
  
6.  Das <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A>-Ereignis wird ausgelöst.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> wird aufgerufen.  
  
 Jedem zugeordneten <xref:System.Data.IDataAdapter> Befehl ist normalerweise eine Parameter Auflistung zugeordnet. Parameter werden mithilfe der `SourceColumn` -Eigenschaft und `SourceVersion` der-Eigenschaft der-Klasse eines .NET Framework- `Parameter` Datenanbieters der aktuellen Zeile zugeordnet. `SourceColumn`verweist auf eine <xref:System.Data.DataTable> Spalte, auf <xref:System.Data.IDataAdapter> die von verwiesen wird, um Parameterwerte für die aktuelle Zeile abzurufen.  
  
 `SourceColumn`verweist auf den Namen der nicht zugeordneten Spalte, bevor Tabellen Zuordnungen angewendet wurden. Wenn `SourceColumn` auf eine nicht vorhandene Spalte verweist, hängt die ausgeführte Aktion von einem der folgenden <xref:System.Data.MissingMappingAction> Werte ab.  
  
|Enumerationswert|Ausgeführte Aktion|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Verwenden Sie die Quell Spaltennamen und Tabellennamen in <xref:System.Data.DataSet> der, wenn keine Zuordnung vorhanden ist.|  
|`MissingMappingAction.Ignore`|Eine <xref:System.SystemException> wird generiert. Wenn die Zuordnungen explizit festgelegt werden, wird eine fehlende Zuordnung für einen Eingabeparameter in der Regel durch einen Fehler verursacht.|  
|`MissingMappingAction.Error`|Eine <xref:System.SystemException> wird generiert.|  
  
 Die `SourceColumn` -Eigenschaft wird auch verwendet, um den Wert für die Ausgabe-oder Eingabe-/Ausgabeparameter wieder dem `DataSet`zuzuordnen. Eine Ausnahme wird generiert, wenn Sie auf eine nicht vorhandene Spalte verweist.  
  
 Die `SourceVersion` -Eigenschaft der-Klasse eines .NET Framework `Parameter` Datenanbieters bestimmt, ob die `Original`-,- `Proposed` oder-Version des Spaltenwerts verwendet werden `Current`soll. Diese Funktion wird häufig verwendet, um ursprüngliche Werte in die WHERE-Klausel einer Update-Anweisung einzuschließen, um auf Verletzungen der vollständigen Parallelität zu prüfen.  
  
> [!NOTE]
>  Wenn beim Aktualisieren einer Zeile ein Fehler auftritt, wird eine Ausnahme ausgelöst, und die Ausführung des Updates wird nicht mehr unterstützt. Um den Aktualisierungs Vorgang fortzusetzen, ohne beim Auftreten eines Fehlers Ausnahmen zu erzeugen <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> , legen `true` Sie die <xref:System.Data.Common.DbDataAdapter.Update%2A>-Eigenschaft auf fest, bevor Sie aufrufen. Im `RowUpdated` Fall eines DataAdapter können Sie auch zeilenweise auf Fehler reagieren. Wenn Sie den Aktualisierungs Vorgang fortsetzen möchten, ohne `RowUpdated` eine Ausnahme innerhalb des <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> Ereignisses <xref:System.Data.Common.RowUpdatedEventArgs> zu erzeugen, <xref:System.Data.UpdateStatus.Continue>legen Sie die-Eigenschaft von auf fest.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die abgeleitete Klasse <xref:System.Data.OleDb.OleDbDataAdapter>,, <xref:System.Data.Common.DataAdapter.Update%2A> für die Datenquelle verwendet. In diesem Beispiel wird davon ausgegangen, dass <xref:System.Data.OleDb.OleDbDataAdapter> Sie eine <xref:System.Data.DataSet>und eine erstellt haben.  
  
 [!code-csharp[Classic WebData DataAdapter.IDataAdapter.Update Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataAdapter.IDataAdapter.Update Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataAdapter.IDataAdapter.Update Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataAdapter.IDataAdapter.Update Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DBConcurrencyException">Der Versuch, eine INSERT-Anweisung, UPDATE-Anweisung oder DELETE-Anweisung auszuführen, ergab 0 (null) betroffene Datensätze.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
