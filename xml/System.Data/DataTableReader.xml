<Type Name="DataTableReader" FullName="System.Data.DataTableReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="29593a8cafbdc6b69f6caeda60868612a408b7dc" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/24/2018" /><Meta Name="ms.locfileid" Value="37670270" /></Metadata><TypeSignature Language="C#" Value="public sealed class DataTableReader : System.Data.Common.DbDataReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DataTableReader extends System.Data.Common.DbDataReader" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTableReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DataTableReader&#xA;Inherits DbDataReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTableReader sealed : System::Data::Common::DbDataReader" />
  <TypeSignature Language="F#" Value="type DataTableReader = class&#xA;    inherit DbDataReader" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbDataReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Der <see cref="T:System.Data.DataTableReader" /> ruft den Inhalt eines oder mehrerer <see cref="T:System.Data.DataTable" />-Objekte in Form eines oder mehrerer schreibgeschützter vorwärts gerichteter Resultsets ab.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTableReader> funktioniert ähnlich wie andere Datenreader, z. B. die <xref:System.Data.SqlClient.SqlDataReader>, außer dass die <xref:System.Data.DataTableReader> bietet zum Durchlaufen der Zeilen in einer <xref:System.Data.DataTable>. Das heißt, bietet es zum Durchlaufen der Zeilen in einem Cache. Die zwischengespeicherten Daten können geändert werden während der <xref:System.Data.DataTableReader> aktiv ist, und der Reader behält seine Position automatisch.  
  
 Bei der Erstellung einer <xref:System.Data.DataTableReader> aus einer <xref:System.Data.DataTable>, die resultierende <xref:System.Data.DataTableReader> Objekt enthält die gleichen Daten wie ein Resultset der <xref:System.Data.DataTable> aus dem er, mit Ausnahme von Zeilen erstellt wurde, die als gelöscht markiert wurden. Die Spalten angezeigt werden, in der gleichen Reihenfolge wie in der ursprünglichen <xref:System.Data.DataTable>. Die Struktur des zurückgegebenen Ergebnisses ist im Schema und Daten mit dem Original identisch <xref:System.Data.DataTable>. Ein <xref:System.Data.DataTableReader> , erstellt wurde, durch den Aufruf der <xref:System.Data.DataSet.CreateDataReader*> -Methode der eine <xref:System.Data.DataSet> Objekt enthält mehrere Resultsets aus, wenn die <xref:System.Data.DataSet> enthält mehr als einer Tabelle. Die Ergebnisse werden in derselben Reihenfolge wie die <xref:System.Data.DataTable> Objekte in der <xref:System.Data.DataTableCollection> von der <xref:System.Data.DataSet> Objekt.  
  
 Das zurückgegebene Resultset enthält nur die aktuelle Version der einzelnen <xref:System.Data.DataRow>; Zeilen, die zum Löschen markiert sind, werden übersprungen.  
  
 Die `DataTableReader` bietet eine stabile Iterator, d. h. den Inhalt der `DataTableReader` werden nicht ungültig werden, wenn die Größe des zugrunde liegenden Auflistung während der Iteration geändert wird. Z. B. wenn eine oder mehr Zeilen in der <xref:System.Data.DataTable.Rows%2A> Auflistung gelöscht oder entfernt werden, während der Iteration die aktuelle Position in der `DataTableReader` entsprechend beibehalten und den Iterator wird nicht ungültig.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataTableReader" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTable" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">Die <see cref="T:System.Data.DataTable" />, von der der neue <see cref="T:System.Data.DataTableReader" /> sein Resultset erhält.</param>
        <summary>Initialisiert unter Verwendung von Daten aus der bereitgestellten <see cref="T:System.Data.DataTableReader" /> eine neue Instanz der <see cref="T:System.Data.DataTable" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataTables As DataTable())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTables" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
      </Parameters>
      <Docs>
        <param name="dataTables">Das Array von <see cref="T:System.Data.DataTable" />-Objekten, das die Ergebnisse für das neue <see cref="T:System.Data.DataTableReader" />-Objekt bereitstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataTableReader" />-Klasse unter Verwendung des bereitgestellten Arrays von <see cref="T:System.Data.DataTable" />-Objekten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellen einer <xref:System.Data.DataTableReader> basierend auf allen oder nur eine Teilmenge der Tabellen innerhalb einer bestimmten <xref:System.Data.DataSet>, rufen Sie die `DataSet`des <xref:System.Data.DataSet.CreateDataReader*> Methode. Wenn Sie ein neues erstellen möchten <xref:System.Data.DataTableReader> -Instanz basierend auf einer Gruppe von `DataTable` Instanzen, die nicht anderweitig in Beziehung zueinander, verwenden Sie diesen Konstruktor. Außerdem profitieren Sie von diesen Konstruktor, um Sie neu anordnen, die Reihenfolge der der `DataTables` innerhalb der `DataTableReader`, wenn ihre Sortierung innerhalb ihrer Quelle `DataSet` Ihren Anforderungen nicht erfüllt.  
  
   
  
## Examples  
 Im folgenden Beispiel erstellt die TestConstructor-Methode zwei <xref:System.Data.DataTable> Instanzen. Um diesen Konstruktor für veranschaulichen die <xref:System.Data.DataTableReader> -Klasse, die das Beispiel erstellt ein neues `DataTableReader` basierend auf ein Array mit den beiden `DataTables`, und führt einen einfachen Vorgang, und Drucken des Inhalts aus der ersten Spalten in der Konsole Fenster. Um diese Anwendung zu testen, erstellen Sie eine neue Konsolenanwendung, und fügen Sie den Beispielcode in die neu erstellte Datei.  
  
 [!code-csharp[DataWorks DataTableReader.ctor#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/VB/source.vb#1)]  
  
 Das Konsolenfenster zeigt die folgenden Ergebnisse:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="dataTableReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den aktuellen <see cref="T:System.Data.DataTableReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von `Close()` für ein geschlossenes `DataTableReader` Objekt ist kein Fehler ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Data.DataTableReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die Tiefe der Schachtelung für die aktuelle Zeile des <see cref="T:System.Data.DataTableReader" />.</summary>
        <value>Die Tiefe der Schachtelung für die aktuelle Zeile, immer 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DataTableReader` unterstützt die Schachtelung nicht. Die `Depth` Eigenschaft gibt immer 0 (null) zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldCount">
      <MemberSignature Language="C#" Value="public override int FieldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FieldCount" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.FieldCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FieldCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int FieldCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.FieldCount : int" Usage="System.Data.DataTableReader.FieldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Anzahl der Spalten in der aktuellen Zeile zurück.</summary>
        <value>Wenn die Position außerhalb eines gültigen Resultsets liegt, 0 (null), andernfalls die Anzahl der Spalten in der aktuellen Zeile.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, die Feldanzahl in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> abzurufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public override bool GetBoolean (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool GetBoolean(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBoolean(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBoolean (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool GetBoolean(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetBoolean : int -&gt; bool" Usage="dataTableReader.GetBoolean ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als <see cref="T:System.Boolean" /> ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten entweder bereits ein boolescher Wert oder in einen booleschen Wert umgewandelt, oder wird eine Ausnahme generiert.  
  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Spalte, Nummer 2 innerhalb der übergegebenen <xref:System.Data.DataTableReader>. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte nicht den richtigen Typ ist, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keinen <see langword="Boolean" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public override byte GetByte (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8 GetByte(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetByte(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByte (ordinal As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Byte GetByte(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetByte : int -&gt; byte" Usage="dataTableReader.GetByte ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als ein Byte ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten bereits ein Byte oder coercible in ein Byte sein.  
  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Spalte, Nummer 2 innerhalb der übergegebenen <xref:System.Data.DataTableReader>. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte nicht den richtigen Typ ist, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetByte#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetByte#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält kein Byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override long GetBytes (int ordinal, long dataIndex, byte[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetBytes(int32 ordinal, int64 dataIndex, unsigned int8[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (ordinal As Integer, dataIndex As Long, buffer As Byte(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetBytes(int ordinal, long dataIndex, cli::array &lt;System::Byte&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int * int64 * byte[] * int * int -&gt; int64" Usage="dataTableReader.GetBytes (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <param name="dataIndex">Der Index in dem Feld, in dem der Lesevorgang beginnen soll.</param>
        <param name="buffer">Der Puffer, in den der Bytedatenstrom gelesen werden soll.</param>
        <param name="bufferIndex">Der Index innerhalb des Puffers, an dem mit dem Platzieren der Daten begonnen werden soll.</param>
        <param name="length">Die maximale Länge, die in den Puffer kopiert werden soll.</param>
        <summary>Liest beginnend am jeweiligen Pufferoffset einen Stream von Bytes aus dem angegebenen Spaltenoffset als Array in den Puffer.</summary>
        <returns>Die tatsächlich gelesene Anzahl von Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetBytes` Gibt die Anzahl der verfügbaren Bytes in das Feld zurück. In den meisten Fällen ist dies die genaue Länge des Felds. Jedoch die zurückgegebene Anzahl kann niedriger sein als die tatsächliche Länge des Felds Wenn `GetBytes` wurde bereits zum Abrufen von Bytes aus dem Feld verwendet. Dies kann z. B. der Fall sein, wenn die <xref:System.Data.DataTableReader> ist eine große Datenstruktur in einen Puffer lesen  
  
 Wenn Sie einen Puffer übergeben, ist `null` (`Nothing` in Visual Basic), `GetBytes` gibt die Länge das gesamte Feld in Bytes, der nicht die verbleibende Größe basierend auf der Offsetparameter Puffer zurück.  
  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten bereits ein Byte-Array sein oder in ein Bytearray umgewandelt.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTableReader> basierend auf Daten in der AdventureWorks-Beispieldatenbank, und speichert, die jedes Image in eine separate Datei im Ordner "C:\" abgerufen. Um diese Anwendung zu testen, erstellen Sie eine neue Konsolenanwendung, verweisen auf die Assembly "System.Drawing.dll" hinzu und fügen Sie den Beispielcode in die neu erstellte Datei.  
  
 [!code-csharp[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält kein Bytearray.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChar">
      <MemberSignature Language="C#" Value="public override char GetChar (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance char GetChar(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChar(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChar (ordinal As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override char GetChar(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetChar : int -&gt; char" Usage="dataTableReader.GetChar ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als Zeichen ab.</summary>
        <returns>Der Wert der Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten bereits ein Zeichen oder coercible in ein Zeichen sein.  
  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Nummer 2 im DataTableReader übergebene Spalte. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte nicht den richtigen Typ ist, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetChar#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChar#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Das angegebene Feld enthält kein Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override long GetChars (int ordinal, long dataIndex, char[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetChars(int32 ordinal, int64 dataIndex, char[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (ordinal As Integer, dataIndex As Long, buffer As Char(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetChars(int ordinal, long dataIndex, cli::array &lt;char&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetChars : int * int64 * char[] * int * int -&gt; int64" Usage="dataTableReader.GetChars (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <param name="dataIndex">Der Index in dem Feld, in dem der Lesevorgang beginnen soll.</param>
        <param name="buffer">Der Puffer, in den der Zeichenstream gelesen werden soll.</param>
        <param name="bufferIndex">Der Index innerhalb des Puffers, an dem mit dem Platzieren der Daten begonnen werden soll.</param>
        <param name="length">Die maximale Länge, die in den Puffer kopiert werden soll.</param>
        <summary>Gibt den Wert der angegebenen Spalte als Zeichenarray zurück.</summary>
        <returns>Die tatsächlich gelesene Anzahl von Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetChars` Gibt die Anzahl der verfügbaren Zeichen in das Feld zurück. In den meisten Fällen ist dies die genaue Länge des Felds. Jedoch die zurückgegebene Anzahl kann niedriger sein als die tatsächliche Länge des Felds Wenn `GetChars` wurde bereits zum Abrufen von Zeichen aus dem Feld verwendet.  
  
 Kleiner als die Länge der angeforderten, kann die tatsächliche Anzahl der gelesenen Zeichen sein, wenn das Ende des Felds erreicht ist. Wenn Sie einen Puffer übergeben, der null ist (`Nothing` in Visual Basic), `GetChars` Zeichen, nicht die verbleibende Größe basierend auf den Puffer-Offset-Parameter gibt die Länge des gesamten Felds zurück.  
  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die Daten abgerufen werden sollen bereits ein Zeichenarray sein oder in ein Array von Zeichen umgewandelt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die `GetChars` Methode. Die `TestGetChars` Methode zu übergebenden erwartet eine `DataTableReader` mit zwei Spalten mit Daten gefüllt: einen Dateinamen in der ersten Spalte und ein Array von Zeichen in der zweiten. Darüber hinaus `TestGetChars` ermöglicht die Angabe die Puffergröße verwendet werden, da es die Daten aus dem Array von Zeichen in liest die `DataTableReader`. `TestGetChars` erstellt eine Datei, die für jede Zeile der Daten in die `DataTableReader`, verwendet die angegebenen Daten in der ersten Spalte von der `DataTableReader` als Dateiname.  
  
 Dieses Verfahren veranschaulicht die Verwendung der `GetChars` Methode Lesen von Daten, die in gespeichert wurde die `DataTable` als ein Array von Zeichen. Eine andere Art von Datentyp bewirkt, dass die `GetChars` Methode zum Auslösen einer `InvalidCastException`.  
  
 [!code-csharp[DataWorks DataTableReader.GetChars#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält kein Zeichenarray.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDataTypeName">
      <MemberSignature Language="C#" Value="public override string GetDataTypeName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetDataTypeName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDataTypeName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDataTypeName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetDataTypeName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDataTypeName : int -&gt; string" Usage="dataTableReader.GetDataTypeName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft eine Zeichenfolge ab, die den Datentyp der angegebenen Spalte darstellt.</summary>
        <returns>Eine Zeichenfolge, die den Datentyp der Spalte darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTableReader.GetDataTypeName%2A> Methode gibt immer den Typ des zugrunde liegenden <xref:System.Data.DataColumn> anstelle eines anbieterspezifischen Typs.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung zeigt eine Liste von Feldern und ihre Namen von einem einfachen <xref:System.Data.DataTable>:  
  
 [!code-csharp[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/VB/source.vb#1)]  
  
 Das Konsolenfenster zeigt die folgenden Ergebnisse:  
  
```  
ID: Int32  
Name: String  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public override DateTime GetDateTime (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.DateTime GetDateTime(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDateTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDateTime (ordinal As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override DateTime GetDateTime(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDateTime : int -&gt; DateTime" Usage="dataTableReader.GetDateTime ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als <see cref="T:System.DateTime" />-Objekt ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten bereits sein ein <xref:System.DateTime> oder coercible zu einem `DataTime`.  
  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Spalte, Nummer 2 innerhalb der übergegebenen <xref:System.Data.DataTableReader>. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte nicht den richtigen Typ ist, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keinen DateTime-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public override decimal GetDecimal (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Decimal GetDecimal(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDecimal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecimal (ordinal As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Decimal GetDecimal(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDecimal : int -&gt; decimal" Usage="dataTableReader.GetDecimal ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als <see cref="T:System.Decimal" /> ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten bereits sein ein <xref:System.Decimal> oder coercible zu einem `Decimal`.  
  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Spalte, Nummer 2 innerhalb der übergegebenen <xref:System.Data.DataTableReader>. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte nicht den richtigen Typ ist, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keinen <see langword="Decimal" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public override double GetDouble (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float64 GetDouble(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDouble(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDouble (ordinal As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override double GetDouble(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDouble : int -&gt; double" Usage="dataTableReader.GetDouble ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der Spalte als Gleitkommazahl mit doppelter Genauigkeit ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten bereits eine Gleitkommazahl mit doppelter Genauigkeit oder in eine Gleitkommazahl mit doppelter Genauigkeit umgewandelt werden müssen.  
  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Spalte, Nummer 2 innerhalb der übergegebenen <xref:System.Data.DataTableReader>. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte nicht den richtigen Typ ist, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine Gleitkommazahl mit doppelter Genauigkeit.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public override System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="dataTableReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der zum Durchlaufen der Elementauflistung verwendet werden kann.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das die Elementauflistung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit Enumeratoren können nur zum Lesen der Daten in die <xref:System.Data.DataTableReader>. Enumeratoren können nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zunächst wird der Enumerator vor dem ersten Element in der Auflistung positioniert. An dieser position Aufrufen <xref:System.Collections.IEnumerator.Current%2A> löst eine Ausnahme aus. Daher muss der Enumerator durch einen Aufruf von `MoveNext` auf das erste Element der Auflistung gesetzt werden, bevor der Wert von `Current` gelesen werden kann.  
  
 `Current` Gibt eine <xref:System.Data.Common.DbDataRecord>, und gibt dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> oder <xref:System.Collections.IEnumerator.Reset%2A> aufgerufen wird. `MoveNext` legt `Current` auf das nächste Element fest.  
  
 Nach das Ende der Auflistung übergeben wird, wird der Enumerator hinter dem letzten Element in der Auflistung, und ein Aufruf `MoveNext` "false" zurückgibt. Wenn der letzte Aufruf `MoveNext` zurückgegebenen `false`, wird beim Aufruf `Current` löst eine Ausnahme aus. Darüber hinaus da die <xref:System.Data.DataTableReader> bietet vorwärts-Zugriff auf seine Daten Aufrufen der <xref:System.Collections.IEnumerator.Reset%2A> Methode des IEnumerator löst eine <xref:System.NotSupportedException>.  
  
 Die <xref:System.Data.DataTableReader> stellt einen stabile Enumerator bereit. Dies bedeutet, dass, auch wenn Zeilen gelöscht oder hinzugefügt, in den zugrunde liegenden Daten auftreten, der Enumerator zurückgegeben durch einen Aufruf von <xref:System.Data.DataTableReader.GetEnumerator%2A> noch gültig ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Data.DataTableReader.GetEnumerator%2A>-Methode gezeigt. Dies schließt das Verhalten des Enumerators, wenn Zeilen, aus der zugrunde liegenden gelöscht werden <xref:System.Data.DataTable> während der Enumerator aktiv ist.  
  
 [!code-csharp[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/VB/source.vb#1)]  
  
 Die Prozedur wird der folgenden Text im Konsolenfenster angezeigt:  
  
```  
Peter  
Mary  
Russ  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldType">
      <MemberSignature Language="C#" Value="public override Type GetFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFieldType : int -&gt; Type" Usage="dataTableReader.GetFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den <see cref="T:System.Type" /> ab, der den Datentyp des Objekts darstellt.</summary>
        <returns>Der <see cref="T:System.Type" />, der der Datentyp des Objekts ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Rufen Sie die folgende Prozedur übergeben eine <xref:System.Data.DataTableReader> Instanz um eine Liste aller Felder und den vollständigen Namen für jeden Typ im Konsolenfenster anzuzeigen.  
  
 [!code-csharp[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFloat">
      <MemberSignature Language="C#" Value="public override float GetFloat (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float32 GetFloat(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFloat(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFloat (ordinal As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override float GetFloat(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFloat : int -&gt; single" Usage="dataTableReader.GetFloat ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als Gleitkommazahl mit einfacher Genauigkeit ab.</summary>
        <returns>Der Wert der Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten bereits eine Gleitkommazahl mit einfacher Genauigkeit oder in eine Gleitkommazahl mit einfacher Genauigkeit umgewandelt werden müssen.  
  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Spalte, Nummer 2 innerhalb der übergegebenen <xref:System.Data.DataTableReader>. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte nicht den richtigen Typ ist, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine Gleitkommazahl mit einfacher Genauigkeit.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public override Guid GetGuid (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Guid GetGuid(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetGuid(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGuid (ordinal As Integer) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Guid GetGuid(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetGuid : int -&gt; Guid" Usage="dataTableReader.GetGuid ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als global eindeutigen Bezeichner (Globally Unique Identifier, GUID) ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten bereits sein ein <xref:System.Guid> oder coercible zu einem `Guid`.  
  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Nummer 2 im DataTableReader übergebene Spalte. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte nicht den richtigen Typ ist, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine GUID.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt16">
      <MemberSignature Language="C#" Value="public override short GetInt16 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int16 GetInt16(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt16(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt16 (ordinal As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override short GetInt16(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt16 : int -&gt; int16" Usage="dataTableReader.GetInt16 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als 16-Bit-Ganzzahl mit Vorzeichen ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten bereits sein ein <xref:System.Int16> oder coercible, um eine `Int16`.  
  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Spalte, Nummer 2 innerhalb der übergegebenen <xref:System.Data.DataTableReader>. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte nicht den richtigen Typ ist, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine 16-Bit-Ganzzahl mit Vorzeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public override int GetInt32 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetInt32(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt32 (ordinal As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetInt32(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt32 : int -&gt; int" Usage="dataTableReader.GetInt32 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als ganze Zahl mit Vorzeichen und einer Länge von 32 Bit ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten bereits sein ein <xref:System.Int32> oder coercible, um eine `Int32`.  
  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Spalte, Nummer 2 innerhalb der übergegebenen <xref:System.Data.DataTableReader>. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte nicht den richtigen Typ ist, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keinen 32-Bit-Ganzzahlwert mit Vorzeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public override long GetInt64 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetInt64(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt64(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt64 (ordinal As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetInt64(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt64 : int -&gt; int64" Usage="dataTableReader.GetInt64 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als 64-Bit-Ganzzahl mit Vorzeichen ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt; aus diesem Grund müssen die abgerufenen Daten bereits sein ein <xref:System.Int64> oder coercible, um eine `Int64`.  
  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Spalte, Nummer 2 innerhalb der übergegebenen <xref:System.Data.DataTableReader>. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte nicht den richtigen Typ ist, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine ganze Zahl mit Vorzeichen und einer Länge von 64 Bit.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public override string GetName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetName : int -&gt; string" Usage="dataTableReader.GetName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als <see cref="T:System.String" /> ab.</summary>
        <returns>Der Name der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `GetName` und <xref:System.Data.DataTableReader.GetOrdinal%2A> Methoden stellen die inverse Funktionalität bereit. D. h. Aufrufen `GetOrdinal` für den Rückgabewert des Aufrufs `GetName` sollte den an übergebenen, ursprüngliche Parameter zurückgeben `GetName`; das gleiche gilt für die Prozeduren in umgekehrter Reihenfolge aufrufen.  
  
   
  
## Examples  
 Das folgende einfache Beispiel enthält eine Prozedur, die die Namen aller Spalten innerhalb des angegebenen auflistet `DataTableReader`, und die Ordnungsposition der Spalte an das Konsolenfenster ausgibt.  
  
 [!code-csharp[DataWorks DataTableReader.GetName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrdinal">
      <MemberSignature Language="C#" Value="public override int GetOrdinal (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetOrdinal(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetOrdinal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetOrdinal (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetOrdinal(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetOrdinal : string -&gt; int" Usage="dataTableReader.GetOrdinal name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Spalte.</param>
        <summary>Ruft bei angegebenem Spaltennamen die Ordnungszahl der Spalte ab.</summary>
        <returns>Die nullbasierte Ordnungszahl der Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da die meisten Methoden vom bereitgestellt. die <xref:System.Data.DataTableReader> Klasse muss sein, sofern mit einer Spaltenordnungszahl, Sie verwenden können die `GetOrdinal` Methode, um die Nummer der Spalte abzurufen, wenn der Name der Spalte.  
  
 `GetOrdinal` führt zuerst eine Suche Groß-/Kleinschreibung beachtet. Wenn ein Fehler auftritt, erfolgt eine zweite Groß-und Kleinschreibung gesucht. Wenn die Nummer der Spalte nicht gefunden wurde ein `IndexOutOfRangeException` ausgelöst.  
  
 `GetOrdinal` wird die Laufweite von Kana nicht unterschieden.  
  
 Da Nachschlagevorgänge auf der Basis Suchvorgänge effizienter als Nachschlagevorgänge nach Namen, ist es ineffizient, Sie rufen `GetOrdinal` innerhalb einer Schleife. Sparen Sie Zeit durch Aufrufen von `GetOrdinal` einmal und die Ergebnisse eine ganzzahlige Variable für die Verwendung innerhalb der Schleife zuweisen  
  
   
  
## Examples  
 Wenn Sie nur einen Spaltennamen haben, in diesem Fall den Namen der Spalte Benutzer angegeben wird, und müssen Sie Informationen abrufen, aus der Spalte ist, können Sie eine Prozedur wie folgt um die erforderliche Informationen zu extrahieren. In diesem Beispiel ist die Prozedur akzeptiert einen Spaltennamen an, und gibt die Daten, die in dieser Spalte für die aktuelle Zeile in enthalten ist das <xref:System.Data.DataTableReader> :  
  
 [!code-csharp[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Name ist kein gültiger Spaltenname.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificFieldType">
      <MemberSignature Language="C#" Value="public override Type GetProviderSpecificFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetProviderSpecificFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetProviderSpecificFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificFieldType : int -&gt; Type" Usage="dataTableReader.GetProviderSpecificFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Typ der angegebenen Spalte im anbieterspezifischen Format ab.</summary>
        <returns>Der <see cref="T:System.Type" />, der der Datentyp des Objekts ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da die <xref:System.Data.DataTableReader> immer zurück in den zugrunde liegenden gespeicherten Typ <xref:System.Data.DataColumn>, den Rückgabewert von Aufrufen der <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> Methode gibt immer denselben Typ wie die in der gespeicherten Typ der <xref:System.Data.DataTable>. Beim Arbeiten mit der <xref:System.Data.DataTableReader> für die Klasse, das Aufrufen der <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> Methode gibt denselben Typ wie das Aufrufen der <xref:System.Type.GetType%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValue">
      <MemberSignature Language="C#" Value="public override object GetProviderSpecificValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetProviderSpecificValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetProviderSpecificValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValue : int -&gt; obj" Usage="dataTableReader.GetProviderSpecificValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Anzahl der Spalten, deren Wert abgerufen wird.</param>
        <summary>Ruft den Wert der angegebenen Spalte im anbieterspezifischen Format ab.</summary>
        <returns>Ruft den Wert der angegebenen Spalte im anbieterspezifischen Format ab.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da die <xref:System.Data.DataTableReader> immer zurück in den zugrunde liegenden gespeicherten Typ <xref:System.Data.DataColumn>, den Rückgabewert von Aufrufen der <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> Methode gibt immer die Daten des gleichen Typs wie die Daten innerhalb der <xref:System.Data.DataTable>. Beim Arbeiten mit der <xref:System.Data.DataTableReader> Klasse Aufrufen der <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> Methode gibt zurück, die gleichen Wert und Typ wie das Aufrufen der <xref:System.Data.DataTableReader.GetValue%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValues">
      <MemberSignature Language="C#" Value="public override int GetProviderSpecificValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetProviderSpecificValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetProviderSpecificValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValues : obj[] -&gt; int" Usage="dataTableReader.GetProviderSpecificValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Ein Objektarray, das mit Typinformationen für die Spalten im <see cref="T:System.Data.DataTableReader" /> aufgefüllt werden soll.</param>
        <summary>Füllt das angegebene Array mit anbieterspezifischen Typinformationen für alle Spalten im <see cref="T:System.Data.DataTableReader" /> auf.</summary>
        <returns>Die Anzahl der in das Array kopierten Spaltenwerte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da die <xref:System.Data.DataTableReader> gibt immer die die Daten des Typs gespeichert, in der zugrunde liegenden <xref:System.Data.DataColumn>, die Werte zurückgegeben, indem die <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> Methode ist immer dieselben Typen wie die Daten in der <xref:System.Data.DataTable>. Beim Arbeiten mit der <xref:System.Data.DataTableReader> für die Klasse, das Aufrufen der <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> Methode gibt die gleichen Werte und Typen zurück, wie das Aufrufen der <xref:System.Data.DataTableReader.GetValues%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="GetSchemaTable">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchemaTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchemaTable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetSchemaTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchemaTable () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchemaTable();" />
      <MemberSignature Language="F#" Value="override this.GetSchemaTable : unit -&gt; System.Data.DataTable" Usage="dataTableReader.GetSchemaTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine <see cref="T:System.Data.DataTable" /> zurück, die die Spaltenmetadaten des <see cref="T:System.Data.DataTableReader" /> beschreibt.</summary>
        <returns>Eine <see cref="T:System.Data.DataTable" />, die die Spaltenmetadaten beschreibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die GetSchemaTable-Methode gibt die Metadaten über jede Spalte in der folgenden Reihenfolge:  
  
|DataReader-Spalte|Beschreibung |  
|-----------------------|-----------------|  
|Spaltenname|Der Name der Spalte, wie er angezeigt wird, der <xref:System.Data.DataTable>.|  
|ColumnOrdinal|Die Ordnungszahl der Spalte|  
|ColumnSize|-1, wenn die <xref:System.Data.Common.SchemaTableColumn.ColumnSize> (oder <xref:System.Data.DataColumn.MaxLength%2A>)-Eigenschaft die <xref:System.Data.DataColumn> kann nicht bestimmt werden oder ist nicht relevant ist, andernfalls 0 oder eine positive ganze Zahl, die enthält die `MaxLength` Wert.|  
|NumericPrecision|Wenn der Spaltentyp ein numerischer Typ ist, ist dies die maximale Genauigkeit der Spalte. Wenn der Spaltentyp keinen numerischen Datentyp ist, ist dies ein null-Wert.|  
|NumericScale|Datentyp der Spalte eine Skalierungskomponente zurück Wenn die Anzahl der Ziffern rechts vom Dezimaltrennzeichen an. Andernfalls einen null-Wert zurückgegeben.|  
|DataType|Die zugrunde liegende Typ der Spalte.|  
|ProviderType|Der Indikator des Datentyps der Spalte. Wenn der Datentyp der Spalte von Zeile zu Zeile unterschiedlich ist, wird dieser Wert ist <xref:System.Object>. Diese Spalte kann nicht auf einen null-Wert enthalten.|  
|IsLong|`true` Wenn der Datentyp der Spalte <xref:System.String> und die zugehörige <xref:System.Data.DataColumn.MaxLength%2A> -Eigenschaft ist 1. Andernfalls `false`.|  
|AllowDBNull|`true` Wenn die AllowDbNull-Einschränkung festgelegt ist auf "true", für die Spalte aus. andernfalls `false`.|  
|IsReadOnly|`true` Wenn die Spalte kann nicht geändert werden; andernfalls `false`.|  
|IsRowVersion|`false`, für jede Spalte.|  
|IsUnique|`true`: Keine zwei Zeilen in der <xref:System.Data.DataTable> haben den gleichen Wert in dieser Spalte. `IsUnique` ist immer "true", wenn die Spalte stellt einen Schlüssel selbst oder wenn es eine Einschränkung des Typs UNIQUE, die nur für diese Spalte gilt. `false`: Die Spalte darf doppelte Werte in der `DataTable`. Der Standardwert für diese Spalte ist `false`.|  
|IsKey|`true`: Die Spalte gehört zu einer Gruppe von Spalten, die zusammen die Zeile im eindeutig bezeichnen die <xref:System.Data.DataTable>. Der Satz von Spalten mit `IsKey` festgelegt `true` muss eindeutig identifizieren eine Zeile in der `DataTable`. Es ist nicht erforderlich, dass dieser Satz von Spalten einen minimalen Satz von Spalten ist. Dieser Satz von Spalten wird generiert, die von einem `DataTable` primary key-, eine unique-Einschränkung oder einen eindeutigen Index. `false`: Die Spalte ist nicht erforderlich, um die Zeile eindeutig zu identifizieren. Dieser Wert ist `true` , wenn die Spalte in einem Primärschlüssel Einzel- oder verbunddomäne beteiligt ist. Andernfalls wird der Wert `false`.|  
|IsAutoIncrement|`true`: Die Spalte neuen Zeilen in festen Schritten Werte zugewiesen. `false`: Die Spalte ist keine neuen Zeilen in festen Schritten Werte zuweisen. Der Standardwert für diese Spalte ist `false`.|  
|BaseCatalogName|Der Name des Katalogs im Datenspeicher, der die Spalte enthält. `Null` Wenn der Name des Basiskatalogs nicht bestimmt werden kann. Der Standardwert für diese Spalte ist eine `null` Wert.|  
|BaseSchemaName|Dieser Wert ist immer `Null`.|  
|"BaseTableName"|Der Name des <xref:System.Data.DataTable>.|  
|BaseColumnName|Der Name der Spalte in der <xref:System.Data.DataTable>.|  
|AutoIncrementSeed|Der Wert des der <xref:System.Data.DataTable>des <xref:System.Data.DataColumn.AutoIncrementSeed%2A> Eigenschaft.|  
|AutoIncrementStep|Der Wert des der <xref:System.Data.DataTable>des <xref:System.Data.DataColumn.AutoIncrementStep%2A> Eigenschaft.|  
|DefaultValue|Der Wert des der <xref:System.Data.DataColumn>des <xref:System.Data.DataColumn.DefaultValue%2A> Eigenschaft.|  
|Ausdruck|Die Ausdruckszeichenfolge, wenn die aktuelle Spalte eine Ausdrucksspalte ist und alle Spalten, die im Ausdruck verwendeten zu demselben gehören `T:System.Data.DataTable` , der die Ausdrucksspalte enthält; andernfalls `null`.|  
|ColumnMapping|Die <xref:System.Data.MappingType> zugeordnete Wert den <xref:System.Data.DataColumn>. Der Typ kann eine der `Attribute`, `Element`, `Hidden`, oder `SimpleContent`. Der Standardwert ist `Element`.|  
|BaseTableNamespace|Der Wert des der <xref:System.Data.DataTable>des <xref:System.Data.DataTable.Namespace%2A> Eigenschaft.|  
|BaseColumnNamespace|Der Wert des der <xref:System.Data.DataColumn>des <xref:System.Data.DataColumn.Namespace%2A> Eigenschaft.|  
  
   
  
## Examples  
 Im folgenden Konsolenanwendungsbeispiel Ruft die Schemainformationen über die angegebene Spalte ab. Übergeben der `DisplaySchemaTableInfo` Verfahren einen <xref:System.Data.DataTableReader> und eine ganze Zahl, die die Ordnungsposition einer Spalte innerhalb der `DataTableReader`, und die Prozedur gibt die Schemainformationen in das Konsolenfenster.  
  
 [!code-csharp[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Data.DataTableReader" /> ist geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetString : int -&gt; string" Usage="dataTableReader.GetString ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als eine Zeichenfolge ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie <xref:System.Data.DataTableReader.IsDBNull%2A> zu überprüfen, ob null-Werte vor dem Aufrufen dieser Methode sind.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Spalte, Nummer 2 innerhalb der übergegebenen <xref:System.Data.DataTableReader>. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte den richtigen Typ aufweist, die im Beispiel wird eine Fehlermeldung für jede Zeile angezeigt wird.  
  
 [!code-csharp[DataWorks DataTableReader.GetString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public override object GetValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetValue : int -&gt; obj" Usage="dataTableReader.GetValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte im systemeigenen Format ab.</summary>
        <returns>Der Wert der angegebenen Spalte. Die Methode gibt für Spalten mit NULL-Werten <see langword="DBNull" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl Sie aufrufen können <xref:System.Data.DataTableReader.IsDBNull%2A> angezeigt, wenn vor dem Aufrufen dieser Methode sind NULL-Werte enthalten, müssen Sie nicht dazu.  
  
   
  
## Examples  
 Das folgende Beispiel durchläuft alle Spalten innerhalb der aktuellen Zeile in einer <xref:System.Data.DataTableReader>, Anzeigen des Inhalts der einzelnen Spalten und den Namen der Spalte. In der Regel, wenn Ihre Absicht darin besteht, funktioniert mit allen Spalten in einer Zeile abgerufen, indem eine <xref:System.Data.DataTableReader>, erwägen Sie die Verwendung der <xref:System.Data.DataTableReader.GetValues%2A> Methode stattdessen, da dies effizienter ist.  
  
 [!code-csharp[DataWorks DataTableReader.GetValue#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, die Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override int GetValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetValues : obj[] -&gt; int" Usage="dataTableReader.GetValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Ein Array vom Typ <see cref="T:System.Object" />, in das die Spaltenwerte aus dem <see cref="T:System.Data.DataTableReader" /> kopiert werden sollen.</param>
        <summary>Füllt ein Array von Objekten mit den Spaltenwerten der aktuellen Zeile auf.</summary>
        <returns>Die Anzahl der in das Array kopierten Spaltenwerte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für die meisten Anwendungen ist diese Methode ein effizientes Instrument für alle Spalten, anstatt jede Spalte einzeln abgerufen. Wenn Ihre Absicht darin, zum Abrufen von alle Spaltenwerte aus einer Zeile innerhalb besteht der <xref:System.Data.DataTableReader>, `GetValues` Methode bietet die effizienteste Lösung.  
  
 Sie können übergeben eine <xref:System.Object> Array, das weniger als die Anzahl der Spalten enthält, die in der resultierenden Zeile enthalten sind. Nur die Menge der Daten die `Object` Array enthalten kann, wird in das Array kopiert. Sie können auch übergeben eine `Object` Array, dessen Länge größer als die Anzahl der Spalten, die in der resultierenden Zeile befinden ist, in dem Fall zusätzliche Arrayelemente bleibt, durch den Methodenaufruf unverändert.  
  
 Diese Methode setzt `DBNull` im Ausgabearray für null-Spalten.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung eines Arrays, die der richtigen Größe zum Lesen der Werte aus der aktuellen Zeile in der angegebenen <xref:System.Data.DataTableReader>. Darüber hinaus wird das Beispiel mit der ein Array mit fester Größe, die kleiner oder größer als die Anzahl der verfügbaren Spalten sein können.  
  
 [!code-csharp[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasRows">
      <MemberSignature Language="C#" Value="public override bool HasRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasRows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.HasRows" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasRows As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasRows { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasRows : bool" Usage="System.Data.DataTableReader.HasRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Data.DataTableReader" /> eine oder mehrere Zeilen enthält.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Data.DataTableReader" /> eine oder mehrere Zeilen enthält, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `HasRows` Eigenschaft gibt Informationen über das aktuelle Resultset zurück. Wenn die <xref:System.Data.DataTableReader> mehrere Resultsets enthält Mengen, untersuchen Sie den Wert der die `HasRows` Eigenschaft sofort nach dem Aufrufen der <xref:System.Data.DataTableReader.NextResult%2A> Methode, um zu bestimmen, ob das neue Resultset Zeilen enthält.  
  
 Verwenden der `HasRows` Eigenschaft vermeiden Sie die Anforderung zum Aufrufen der <xref:System.Data.DataTableReader.Read%2A> -Methode der der <xref:System.Data.DataTableReader> , wenn keine Zeilen in das aktuelle Resultset vorhanden sind.  
  
   
  
## Examples  
 Das folgende Beispiel füllt zwei <xref:System.Data.DataTable> Instanzen mit Daten. Die erste <xref:System.Data.DataTable> enthält eine Zeile, und die zweite enthält keine Zeilen. Im Beispiel wird dann erstellt eine <xref:System.Data.DataTableReader> , enthält sowohl <xref:System.Data.DataTable> -Objekte und ruft die Objekts-Methode zum Anzeigen des Inhalts der einzelnen, des Werts von der <xref:System.Data.DataTableReader.HasRows%2A> Eigenschaft der einzelnen, bevor sie die Objekts aufruft.  
  
 [!code-csharp[DataWorks DataTableReader.HasRows#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.HasRows#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, Informationen über einen geschlossenen <see cref="T:System.Data.DataTableReader" /> abzurufen.</exception>
        <altmember cref="M:System.Data.DataTableReader.NextResult" />
        <altmember cref="M:System.Data.DataTableReader.Read" />
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public override bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Data.DataTableReader.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Data.DataTableReader" /> synchronisiert ist.</summary>
        <value>Gibt <see langword="true" /> zurück, wenn der <see cref="T:System.Data.DataTableReader" /> geschlossen ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTableReader.Close%2A> ist die einzige Methode und `IsClosed` und <xref:System.Data.DataTableReader.RecordsAffected%2A> sind die einzigen Eigenschaften, die nach dem zugegriffen werden können die <xref:System.Data.DataTableReader> wurde geschlossen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDBNull">
      <MemberSignature Language="C#" Value="public override bool IsDBNull (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDBNull(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.IsDBNull(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDBNull (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDBNull(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.IsDBNull : int -&gt; bool" Usage="dataTableReader.IsDBNull ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft einen Wert ab, der angibt, ob die Spalte nicht vorhandene oder fehlende Werte enthält.</summary>
        <returns><see langword="true" />, wenn der angegebene Spaltenwert <see cref="T:System.DBNull" /> entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode, um festzustellen, ob null-Werte vor dem Aufrufen der typisierten Get-Methoden (z. B. <xref:System.Data.DataTableReader.GetByte%2A>, <xref:System.Data.DataTableReader.GetChar%2A>usw.) das Auslösen eines Fehlers zu vermeiden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt der Spalte, Nummer 2 innerhalb der übergegebenen <xref:System.Data.DataTableReader>. Wenn der Wert die Spalte innerhalb einer bestimmten Zeile null ist, zeigt der Code den Text \<NULL >. Wenn die Daten in der Spalte den richtigen Typ aufweist, die im Beispiel wird eine Fehlermeldung für jede Zeile angezeigt wird.  
  
 [!code-csharp[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert der angegebenen Spalte im systemeigenen Format ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[int ordinal] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int ordinal); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft bei angegebener Spaltenordnungszahl den Wert der angegebenen Spalte im systemeigenen Format ab.</summary>
        <value>Der Wert der angegebenen Spalte im systemeigenen Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung für <xref:System.Data.DataTableReader.Item%2A> verhält sich genauso wie die <xref:System.Data.DataTableReader.GetValue%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt den Inhalt aller Spalten in allen Zeilen aus der angegebenen <xref:System.Data.DataTableReader>. Der Code verwendet die <xref:System.Data.DataTableReader.Item%2A> (Indexer in Microsoft C# -Code)-Methode zum Abrufen des Werts, der in jeder Spalte enthalten ist.  
  
 [!code-csharp[DataWorks DataTableReader.Item#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Item#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Spalte.</param>
        <summary>Ruft bei angegebenem Spaltennamen den Wert der angegebenen Spalte im systemeigenen Format ab.</summary>
        <value>Der Wert der angegebenen Spalte im systemeigenen Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Suche Groß-/Kleinschreibung beachtet wird zuerst ausgeführt. Wenn ein Fehler auftritt, erfolgt eine zweite Groß-und Kleinschreibung gesucht.  
  
 Diese Methode ist die Laufweite von Kana nicht Akzent.  
  
 Diese überladene Version von <xref:System.Data.DataTableReader.Item%2A> entspricht dem Aufrufen der <xref:System.Data.DataTableReader.GetOrdinal%2A> -Methode, und dem anschließenden Aufrufen der <xref:System.Data.DataTableReader.GetValue%2A> Methode.  
  
   
  
## Examples  
 Erhält eine <xref:System.Data.DataTableReader> und einen Spaltennamen, die GetValueByName-Prozedur gibt den Wert der angegebenen Spalte. Vor dem Aufrufen dieser Methode müssen Sie ein neues erstellen <xref:System.Data.DataTableReader> -Instanz und rufen Sie seine Read-Methode zumindest einmal, um die Zeilenzeiger auf eine Zeile mit Daten zu positionieren.  
  
 [!code-csharp[DataWorks DataTableReader.ItemName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ItemName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Name ist kein gültiger Spaltenname.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextResult">
      <MemberSignature Language="C#" Value="public override bool NextResult ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool NextResult() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.NextResult" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function NextResult () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool NextResult();" />
      <MemberSignature Language="F#" Value="override this.NextResult : unit -&gt; bool" Usage="dataTableReader.NextResult " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den <see cref="T:System.Data.DataTableReader" /> auf das nächste Resultset, sofern vorhanden.</summary>
        <returns><see langword="true" />, wenn ein anderes Resultsets vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendet, um mehrere Ergebnisse zu verarbeiten, die durch das Erstellen generiert werden, können eine <xref:System.Data.DataTableReader> über eine <xref:System.Data.DataSet> , enthält zwei oder mehr Tabellen oder ein Array mit zwei oder mehr <xref:System.Data.DataTable> Instanzen.  
  
 Ein neues <xref:System.Data.DataTableReader> befindet sich auf das erste Ergebnis.  
  
   
  
## Examples  
 Im folgenden Beispiel erstellt die TestConstructor-Methode zwei <xref:System.Data.DataTable> Instanzen. Um diesen Konstruktor für veranschaulichen die <xref:System.Data.DataTableReader> -Klasse, die das Beispiel erstellt ein neues `DataTableReader` basierend auf ein Array mit den beiden `DataTables`, und führt einen einfachen Vorgang, und Drucken des Inhalts aus der ersten Spalten in der Konsole Fenster. Um diese Anwendung zu testen, erstellen Sie eine neue Konsolenanwendung, und fügen Sie den Beispielcode in die neu erstellte Datei.  
  
 [!code-csharp[DataWorks DataTableReader.NextResult#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.NextResult#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/VB/source.vb#1)]  
  
 Das Konsolenfenster zeigt die folgenden Ergebnisse:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, innerhalb eines geschlossenen <see cref="T:System.Data.DataTableReader" /> zu navigieren.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; bool" Usage="dataTableReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den <see cref="T:System.Data.DataTableReader" /> auf den nächsten Datensatz.</summary>
        <returns><see langword="true" />, wenn eine andere zu lesende Zeile vorhanden war, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardposition des der <xref:System.Data.DataTableReader> steht vor dem ersten Datensatz. Aus diesem Grund müssen Sie aufrufen `Read` um den Zugriff auf Daten zu starten.  
  
   
  
## Examples  
 Die Prozedur PrintColumns durchläuft alle Zeilen in der <xref:System.Data.DataTableReader>, den Inhalt der einzelnen Spalten im Konsolenfenster angezeigt.  
  
 [!code-csharp[DataWorks DataTableReader.Read#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Read#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="RecordsAffected">
      <MemberSignature Language="C#" Value="public override int RecordsAffected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecordsAffected" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.RecordsAffected" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RecordsAffected As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int RecordsAffected { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecordsAffected : int" Usage="System.Data.DataTableReader.RecordsAffected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der durch die Ausführung der SQL-Anweisung eingefügten, geänderten oder gelöschten Zeilen ab.</summary>
        <value>Der <see cref="T:System.Data.DataTableReader" /> unterstützt diese Eigenschaft nicht und gibt immer 0 zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>