<Type Name="DataTableReader" FullName="System.Data.DataTableReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f86464005e30acfd4d0dac6af6136d4819e27a1a" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69367662" /></Metadata><TypeSignature Language="C#" Value="public sealed class DataTableReader : System.Data.Common.DbDataReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DataTableReader extends System.Data.Common.DbDataReader" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTableReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DataTableReader&#xA;Inherits DbDataReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTableReader sealed : System::Data::Common::DbDataReader" />
  <TypeSignature Language="F#" Value="type DataTableReader = class&#xA;    inherit DbDataReader" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbDataReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Der <see cref="T:System.Data.DataTableReader" /> ruft den Inhalt eines oder mehrerer <see cref="T:System.Data.DataTable" />-Objekte in Form eines oder mehrerer schreibgeschützter vorwärts gerichteter Resultsets ab.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Data.DataTableReader> funktioniert ähnlich wie jeder andere Daten Leser, wie z <xref:System.Data.SqlClient.SqlDataReader>. b., mit <xref:System.Data.DataTableReader> der Ausnahme, dass der zum Durchlaufen <xref:System.Data.DataTable>von Zeilen in einer bereitstellt. Das heißt, Sie ermöglicht das Durchlaufen von Zeilen in einem Cache. Die zwischengespeicherten Daten können geändert werden, <xref:System.Data.DataTableReader> während aktiv ist, und der Reader behält seine Position automatisch.  
  
 Wenn Sie einen <xref:System.Data.DataTableReader> aus einem <xref:System.Data.DataTable>erstellen, enthält das <xref:System.Data.DataTableReader> resultierende-Objekt ein Resultset mit denselben Daten wie <xref:System.Data.DataTable> das, aus dem es erstellt wurde, mit Ausnahme von Zeilen, die als gelöscht markiert wurden. Die Spalten werden in derselben Reihenfolge wie in der ursprünglichen <xref:System.Data.DataTable>angezeigt. Die Struktur des zurückgegebenen Ergebnisses ist identisch mit dem Schema und den Daten mit <xref:System.Data.DataTable>dem ursprünglichen. Ein <xref:System.Data.DataTableReader> , der durch Aufrufen der <xref:System.Data.DataSet.CreateDataReader*> -Methode eines <xref:System.Data.DataSet> -Objekts erstellt wurde, enthält mehrere Resultsets, wenn <xref:System.Data.DataSet> mehr als eine Tabelle enthält. Die Ergebnisse befinden sich in derselben Reihenfolge wie <xref:System.Data.DataTable> die Objekte <xref:System.Data.DataTableCollection> in der des <xref:System.Data.DataSet> -Objekts.  
  
 Das zurückgegebene Resultset enthält nur die aktuelle Version <xref:System.Data.DataRow>, die Zeilen, die zum Löschen markiert sind, werden übersprungen.  
  
 Stellt einen stabilen Iterator bereit, d. h. der Inhalt `DataTableReader` von wird nicht ungültig, wenn die Größe der zugrunde liegenden Auflistung während der Iterations Änderung geändert wird. `DataTableReader` Wenn z. b. eine oder mehrere Zeilen in <xref:System.Data.DataTable.Rows%2A> der Auflistung während der Iterationen gelöscht oder entfernt werden, wird die aktuelle `DataTableReader` Position innerhalb der ordnungsgemäß verwaltet, und der Iterator wird nicht für ungültig erklärt.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataTableReader" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTable" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">Die <see cref="T:System.Data.DataTable" />, von der der neue <see cref="T:System.Data.DataTableReader" /> sein Resultset erhält.</param>
        <summary>Initialisiert unter Verwendung von Daten aus der bereitgestellten <see cref="T:System.Data.DataTableReader" /> eine neue Instanz der <see cref="T:System.Data.DataTable" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataTables As DataTable())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTables" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
      </Parameters>
      <Docs>
        <param name="dataTables">Das Array von <see cref="T:System.Data.DataTable" />-Objekten, das die Ergebnisse für das neue <see cref="T:System.Data.DataTableReader" />-Objekt bereitstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataTableReader" />-Klasse unter Verwendung des bereitgestellten Arrays von <see cref="T:System.Data.DataTable" />-Objekten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie einen <xref:System.Data.DataTableReader> basierend auf allen oder einer Teilmenge der Tabellen innerhalb eines bestimmten <xref:System.Data.DataSet>erstellen müssen, rufen Sie die `DataSet`- <xref:System.Data.DataSet.CreateDataReader*> Methode auf. Verwenden Sie diesen Konstruktor, wenn <xref:System.Data.DataTableReader> Sie eine neue Instanz erstellen möchten `DataTable` , die auf einer Gruppe von Instanzen basiert, die ansonsten nicht verknüpft sind. Sie können diesen Konstruktor auch verwenden, um die Reihen `DataTables` Folge der in der neu anzuordnen, wenn die Reihenfolge innerhalb der `DataSet` `DataTableReader`Quelle nicht Ihren Anforderungen entspricht.  
  
   
  
## Examples  
 Im folgenden Beispiel erstellt die TestConstructor-Methode zwei <xref:System.Data.DataTable> -Instanzen. Um diesen Konstruktor für die <xref:System.Data.DataTableReader> -Klasse zu veranschaulichen, erstellt das Beispiel einen neuen `DataTableReader` auf der Grundlage eines Arrays, das die beiden `DataTables`enthält, und führt einen einfachen Vorgang aus, der den Inhalt aus den ersten Spalten in der Konsole druckt. ster. Um diese Anwendung zu testen, erstellen Sie eine neue Konsolenanwendung, und fügen Sie den Beispielcode in die neu erstellte Datei ein.  
  
 [!code-csharp[DataWorks DataTableReader.ctor#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/VB/source.vb#1)]  
  
 Im Konsolenfenster werden folgende Ergebnisse angezeigt:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="dataTableReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den aktuellen <see cref="T:System.Data.DataTableReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim `Close()` Aufrufen von für `DataTableReader` ein geschlossenes Objekt wird kein Fehler ausgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Data.DataTableReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Die Tiefe der Schachtelung für die aktuelle Zeile des <see cref="T:System.Data.DataTableReader" />.</summary>
        <value>Die Tiefe der Schachtelung für die aktuelle Zeile, immer 0 (null).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DataTableReader`unterstützt keine Schachtelung. Die `Depth` -Eigenschaft gibt immer NULL zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldCount">
      <MemberSignature Language="C#" Value="public override int FieldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FieldCount" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.FieldCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FieldCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int FieldCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.FieldCount : int" Usage="System.Data.DataTableReader.FieldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt die Anzahl der Spalten in der aktuellen Zeile zurück.</summary>
        <value>Wenn die Position außerhalb eines gültigen Resultsets liegt, 0 (null), andernfalls die Anzahl der Spalten in der aktuellen Zeile.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, die Feldanzahl in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> abzurufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public override bool GetBoolean (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool GetBoolean(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBoolean(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBoolean (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool GetBoolean(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetBoolean : int -&gt; bool" Usage="dataTableReader.GetBoolean ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als <see cref="T:System.Boolean" /> ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten entweder ein boolescher Wert sein oder in einen booleschen Wert umgewandelt werden, oder es wird eine Ausnahme generiert.  
  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte in der- <xref:System.Data.DataTableReader>Spalte mit der Nummer 2 angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte nicht den richtigen Typ haben, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keinen <see langword="Boolean" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public override byte GetByte (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8 GetByte(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetByte(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByte (ordinal As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Byte GetByte(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetByte : int -&gt; byte" Usage="dataTableReader.GetByte ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als ein Byte ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten bereits ein Byte oder eine Umwandlung in ein Byte sein.  
  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte in der- <xref:System.Data.DataTableReader>Spalte mit der Nummer 2 angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte nicht den richtigen Typ haben, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetByte#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetByte#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält kein Byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override long GetBytes (int ordinal, long dataIndex, byte[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetBytes(int32 ordinal, int64 dataIndex, unsigned int8[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (ordinal As Integer, dataIndex As Long, buffer As Byte(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetBytes(int ordinal, long dataIndex, cli::array &lt;System::Byte&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int * int64 * byte[] * int * int -&gt; int64" Usage="dataTableReader.GetBytes (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <param name="dataIndex">Der Index in dem Feld, in dem der Lesevorgang beginnen soll.</param>
        <param name="buffer">Der Puffer, in den der Bytestream gelesen werden soll.</param>
        <param name="bufferIndex">Der Index innerhalb des Puffers, an dem mit dem Platzieren der Daten begonnen werden soll.</param>
        <param name="length">Die maximale Länge, die in den Puffer kopiert werden soll.</param>
        <summary>Liest beginnend am jeweiligen Pufferoffset einen Stream von Bytes aus dem angegebenen Spaltenoffset als Array in den Puffer.</summary>
        <returns>Die tatsächlich gelesene Anzahl von Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetBytes`Gibt die Anzahl der verfügbaren Bytes im-Feld zurück. In den meisten Fällen ist dies die genaue Länge des Felds. Die zurückgegebene Zahl kann jedoch kleiner als die tatsächliche Länge des Felds sein, wenn `GetBytes` bereits zum Abrufen von Bytes aus dem Feld verwendet wurde. Dies kann z. b. der Fall sein, wenn <xref:System.Data.DataTableReader> der eine große Datenstruktur in einen Puffer liest.  
  
 Wenn Sie einen Puffer übergeben, der `null` (`Nothing` in Visual Basic) ist `GetBytes` , gibt die Länge des gesamten Felds in Bytes zurück, nicht die verbleibende Größe basierend auf dem Puffer offset Parameter.  
  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten bereits ein Bytearray sein oder in ein Bytearray umgewandelt werden können.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Data.DataTableReader> auf der Grundlage von Daten in der AdventureWorks-Beispieldatenbank erstellt, und jedes abgerufene Image wird in einer separaten Datei in C:\ gespeichert. Pfalz. Um diese Anwendung zu testen, erstellen Sie eine neue Konsolenanwendung, verweisen auf die Assembly "System. Drawing. dll" und fügen den Beispielcode in die neu erstellte Datei ein.  
  
 [!code-csharp[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält kein Bytearray.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChar">
      <MemberSignature Language="C#" Value="public override char GetChar (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance char GetChar(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChar(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChar (ordinal As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override char GetChar(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetChar : int -&gt; char" Usage="dataTableReader.GetChar ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als Zeichen ab.</summary>
        <returns>Der Wert der Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten bereits ein Zeichen oder eine Umwandlung in ein Zeichen sein.  
  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte mit der Nummer 2 innerhalb des bestandenen DataTableReader angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte nicht den richtigen Typ haben, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetChar#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChar#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Das angegebene Feld enthält kein Zeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override long GetChars (int ordinal, long dataIndex, char[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetChars(int32 ordinal, int64 dataIndex, char[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (ordinal As Integer, dataIndex As Long, buffer As Char(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetChars(int ordinal, long dataIndex, cli::array &lt;char&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetChars : int * int64 * char[] * int * int -&gt; int64" Usage="dataTableReader.GetChars (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <param name="dataIndex">Der Index im Feld, an dem der Lesevorgang beginnen soll.</param>
        <param name="buffer">Der Puffer, in den der Zeichenstream gelesen werden soll.</param>
        <param name="bufferIndex">Der Index innerhalb des Puffers, an dem mit dem Platzieren der Daten begonnen werden soll.</param>
        <param name="length">Die maximale Länge, die in den Puffer kopiert werden soll.</param>
        <summary>Gibt den Wert der angegebenen Spalte als Zeichenarray zurück.</summary>
        <returns>Die tatsächlich gelesene Anzahl von Zeichen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetChars`Gibt die Anzahl der im Feld verfügbaren Zeichen zurück. In den meisten Fällen ist dies die genaue Länge des Felds. Allerdings kann die zurückgegebene Zahl kleiner als die tatsächliche Länge des Felds sein, `GetChars` wenn bereits zum Abrufen von Zeichen aus dem Feld verwendet wurde.  
  
 Die tatsächliche Anzahl von gelesenen Zeichen kann kleiner als die angeforderte Länge sein, wenn das Ende des Felds erreicht ist. Wenn Sie einen Puffer übergeben, der NULL (`Nothing` in Visual Basic) ist `GetChars` , gibt die Länge des gesamten Felds in Zeichen zurück, nicht die verbleibende Größe basierend auf dem Puffer offset Parameter.  
  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abzurufenden Daten bereits ein Zeichen Array sein oder in ein Zeichen Array umgewandelt werden können.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die `GetChars` Methode. Die `TestGetChars` -Methode erwartet, dass eine `DataTableReader` mit zwei Spalten von Daten ausgefüllt wird: ein Dateiname in der ersten Spalte und ein Array von Zeichen in der zweiten Spalte. Außerdem können Sie `TestGetChars` die Puffergröße angeben, die beim Lesen der Daten aus dem Zeichen Array `DataTableReader`in verwendet werden soll. `TestGetChars`erstellt eine Datei, die jeder Daten Zeile in der `DataTableReader`entspricht, wobei die in der ersten Spalte `DataTableReader` der angegebenen Daten als Dateiname verwendet werden.  
  
 Diese Prozedur veranschaulicht die Verwendung `GetChars` der-Methode, mit der Daten gelesen werden, die `DataTable` in als Zeichen Array gespeichert wurden. Alle anderen Datentypen bewirken, dass `GetChars` die-Methode eine `InvalidCastException`auslöst.  
  
 [!code-csharp[DataWorks DataTableReader.GetChars#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält kein Zeichenarray.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDataTypeName">
      <MemberSignature Language="C#" Value="public override string GetDataTypeName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetDataTypeName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDataTypeName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDataTypeName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetDataTypeName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDataTypeName : int -&gt; string" Usage="dataTableReader.GetDataTypeName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft eine Zeichenfolge ab, die den Datentyp der angegebenen Spalte darstellt.</summary>
        <returns>Eine Zeichenfolge, die den Datentyp der Spalte darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTableReader.GetDataTypeName%2A> -Methode gibt immer den Typ des zugrunde <xref:System.Data.DataColumn> liegenden anstelle eines anbieterspezifischen Typs zurück.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung zeigt eine Liste von Feldern und deren Typnamen aus einer einfachen <xref:System.Data.DataTable>an:  
  
 [!code-csharp[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/VB/source.vb#1)]  
  
 Im Konsolenfenster werden folgende Ergebnisse angezeigt:  
  
```  
ID: Int32  
Name: String  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public override DateTime GetDateTime (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.DateTime GetDateTime(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDateTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDateTime (ordinal As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override DateTime GetDateTime(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDateTime : int -&gt; DateTime" Usage="dataTableReader.GetDateTime ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als <see cref="T:System.DateTime" />-Objekt ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten bereits ein <xref:System.DateTime> oder eine Umwandlung in einen `DataTime`sein.  
  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte in der- <xref:System.Data.DataTableReader>Spalte mit der Nummer 2 angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte nicht den richtigen Typ haben, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keinen DateTime-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public override decimal GetDecimal (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Decimal GetDecimal(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDecimal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecimal (ordinal As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Decimal GetDecimal(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDecimal : int -&gt; decimal" Usage="dataTableReader.GetDecimal ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als <see cref="T:System.Decimal" /> ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten bereits ein <xref:System.Decimal> oder eine Umwandlung in einen `Decimal`sein.  
  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte in der- <xref:System.Data.DataTableReader>Spalte mit der Nummer 2 angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte nicht den richtigen Typ haben, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keinen <see langword="Decimal" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public override double GetDouble (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float64 GetDouble(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDouble(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDouble (ordinal As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override double GetDouble(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDouble : int -&gt; double" Usage="dataTableReader.GetDouble ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der Spalte als Gleitkommazahl mit doppelter Genauigkeit ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten bereits eine Gleit Komma Zahl mit doppelter Genauigkeit sein, oder Sie müssen in eine Gleit Komma Zahl mit doppelter Genauigkeit umgewandelt werden.  
  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte in der- <xref:System.Data.DataTableReader>Spalte mit der Nummer 2 angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte nicht den richtigen Typ haben, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see langword="DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine Gleitkommazahl mit doppelter Genauigkeit.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public override System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="dataTableReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Enumerator zurück, der zum Durchlaufen der Elementauflistung verwendet werden kann.</summary>
        <returns>Ein <see cref="T:System.Collections.IEnumerator" />-Objekt, das die Elementauflistung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enumeratoren ermöglichen nur das Lesen der Daten in <xref:System.Data.DataTableReader>. Enumeratoren können nicht zum Ändern der zugrunde liegenden Auflistung verwendet werden.  
  
 Zuerst wird der Enumerator vor dem ersten Element in der Auflistung positioniert. An dieser Position löst der <xref:System.Collections.IEnumerator.Current%2A> Aufruf von eine Ausnahme aus. Daher muss der Enumerator durch einen Aufruf von `MoveNext` auf das erste Element der Auflistung gesetzt werden, bevor der Wert von `Current` gelesen werden kann.  
  
 `Current`Gibt einen <xref:System.Data.Common.DbDataRecord>zurück und gibt dasselbe Objekt zurück, bis <xref:System.Collections.IEnumerator.MoveNext%2A> entweder <xref:System.Collections.IEnumerator.Reset%2A> oder aufgerufen wird. `MoveNext` legt `Current` auf das nächste Element fest.  
  
 Nachdem das Ende der Auflistung überschritten wurde, wird der Enumerator hinter dem letzten Element in der Auflistung positioniert, und der `MoveNext` Aufruf von gibt false zurück. Wenn der letzte Aufruf von `MoveNext` zurück `false`gegeben wird `Current` , löst der Aufruf von eine Ausnahme aus. Außerdem wird durch das Aufrufen <xref:System.Data.DataTableReader> der <xref:System.Collections.IEnumerator.Reset%2A> -Methode von IEnumerator eine <xref:System.NotSupportedException>ausgelöst, da der vorwärts Zugriff auf seine Daten bereitstellt.  
  
 <xref:System.Data.DataTableReader> Stellt einen stabilen Enumerator bereit. Dies bedeutet, dass selbst dann, wenn Zeilen Löschungen oder Ergänzungen in den zugrunde liegenden Daten auftreten, der Enumerator, <xref:System.Data.DataTableReader.GetEnumerator%2A> der von einem-Rückruf zurückgegeben wurde, weiterhin gültig ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Data.DataTableReader.GetEnumerator%2A>-Methode gezeigt. Dies schließt das Verhalten des Enumerators ein, wenn Zeilen aus der zugrunde liegenden <xref:System.Data.DataTable> gelöscht werden, während der Enumerator aktiv ist.  
  
 [!code-csharp[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/VB/source.vb#1)]  
  
 Die Prozedur zeigt den folgenden Text im Konsolenfenster an:  
  
```  
Peter  
Mary  
Russ  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldType">
      <MemberSignature Language="C#" Value="public override Type GetFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFieldType : int -&gt; Type" Usage="dataTableReader.GetFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den <see cref="T:System.Type" /> ab, der den Datentyp des Objekts darstellt.</summary>
        <returns>Der <see cref="T:System.Type" />, der der Datentyp des Objekts ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Wenden Sie das folgende Verfahren an, und <xref:System.Data.DataTableReader> übergeben Sie eine-Instanz, um eine Liste aller Felder und den vollständigen Namen für jeden Typ im Konsolenfenster anzuzeigen.  
  
 [!code-csharp[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFloat">
      <MemberSignature Language="C#" Value="public override float GetFloat (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float32 GetFloat(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFloat(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFloat (ordinal As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override float GetFloat(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFloat : int -&gt; single" Usage="dataTableReader.GetFloat ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als Gleitkommazahl mit einfacher Genauigkeit ab.</summary>
        <returns>Der Wert der Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten bereits eine Gleit Komma Zahl mit einfacher Genauigkeit sein, oder Sie müssen in eine Gleit Komma Zahl mit einfacher Genauigkeit umgewandelt werden.  
  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte in der- <xref:System.Data.DataTableReader>Spalte mit der Nummer 2 angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte nicht den richtigen Typ haben, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine Gleitkommazahl mit einfacher Genauigkeit.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public override Guid GetGuid (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Guid GetGuid(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetGuid(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGuid (ordinal As Integer) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Guid GetGuid(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetGuid : int -&gt; Guid" Usage="dataTableReader.GetGuid ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Wert der angegebenen Spalte als global eindeutigen Bezeichner (Globally Unique Identifier, GUID) ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten bereits ein <xref:System.Guid> oder eine Umwandlung in einen `Guid`sein.  
  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte mit der Nummer 2 innerhalb des bestandenen DataTableReader angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte nicht den richtigen Typ haben, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine GUID.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt16">
      <MemberSignature Language="C#" Value="public override short GetInt16 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int16 GetInt16(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt16(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt16 (ordinal As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override short GetInt16(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt16 : int -&gt; int16" Usage="dataTableReader.GetInt16 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte</param>
        <summary>Ruft den Wert der angegebenen Spalte als 16-Bit-Ganzzahl mit Vorzeichen ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten bereits ein <xref:System.Int16> oder eine Umwandlung in einen `Int16`sein.  
  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte in der- <xref:System.Data.DataTableReader>Spalte mit der Nummer 2 angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte nicht den richtigen Typ haben, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine 16-Bit-Ganzzahl mit Vorzeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public override int GetInt32 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetInt32(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt32 (ordinal As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetInt32(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt32 : int -&gt; int" Usage="dataTableReader.GetInt32 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte</param>
        <summary>Ruft den Wert der angegebenen Spalte als ganze Zahl mit Vorzeichen und einer Länge von 32 Bit ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten bereits ein <xref:System.Int32> oder eine Umwandlung in einen `Int32`sein.  
  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte in der- <xref:System.Data.DataTableReader>Spalte mit der Nummer 2 angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte nicht den richtigen Typ haben, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keinen 32-Bit-Ganzzahlwert mit Vorzeichen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public override long GetInt64 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetInt64(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt64(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt64 (ordinal As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetInt64(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt64 : int -&gt; int64" Usage="dataTableReader.GetInt64 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte</param>
        <summary>Ruft den Wert der angegebenen Spalte als 64-Bit-Ganzzahl mit Vorzeichen ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es werden keine Konvertierungen ausgeführt. Daher müssen die abgerufenen Daten bereits ein <xref:System.Int64> oder eine Umwandlung in einen `Int64`sein.  
  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte in der- <xref:System.Data.DataTableReader>Spalte mit der Nummer 2 angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte nicht den richtigen Typ haben, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine ganze Zahl mit Vorzeichen und einer Länge von 64 Bit.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public override string GetName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetName : int -&gt; string" Usage="dataTableReader.GetName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte</param>
        <summary>Ruft den Wert der angegebenen Spalte als <see cref="T:System.String" /> ab.</summary>
        <returns>Der Name der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `GetName` - <xref:System.Data.DataTableReader.GetOrdinal%2A> Methode und die-Methode stellen umgekehrte Funktionen bereit. Das heißt, dass `GetOrdinal` beim Aufrufen von für den Rückgabe `GetName` Wert des aufrufenden den ursprünglichen an `GetName`übergebenen Parameter zurückgeben soll. Dies gilt auch für den Aufruf der Prozeduren in umgekehrter Reihenfolge.  
  
   
  
## Examples  
 Das folgende einfache Beispiel enthält eine Prozedur, die die Namen aller Spalten im angegebenen `DataTableReader`und die Ordnungsposition der Spalte im Konsolenfenster auflistet.  
  
 [!code-csharp[DataWorks DataTableReader.GetName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrdinal">
      <MemberSignature Language="C#" Value="public override int GetOrdinal (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetOrdinal(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetOrdinal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetOrdinal (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetOrdinal(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetOrdinal : string -&gt; int" Usage="dataTableReader.GetOrdinal name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Spalte.</param>
        <summary>Ruft bei angegebenem Spaltennamen die Ordnungszahl der Spalte ab.</summary>
        <returns>Die nullbasierte Ordnungszahl der Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da die meisten der Methoden, die von <xref:System.Data.DataTableReader> der-Klasse bereitgestellt werden, mit einer ordinalspaltennummer bereit `GetOrdinal` gestellt werden müssen, können Sie die-Methode verwenden, um die Spaltennummer abzurufen, wenn der Name der Spalte angegeben ist.  
  
 `GetOrdinal`führt zuerst eine Suche mit Berücksichtigung der Groß-und Kleinschreibung durch. Bei einem Fehler wird eine zweite Suche ohne Beachtung der Groß-/Kleinschreibung durchgeführt. Wenn die Spaltennummer nicht gefunden wird, `IndexOutOfRangeException` wird eine ausgelöst.  
  
 `GetOrdinal`ist Kana-Breite nicht beachtet.  
  
 Da ordinalbasierte Suchvorgänge effizienter als benannte suchen sind, ist es ineffizient, innerhalb einer-Schleife `GetOrdinal` aufzurufen. Sparen Sie Zeit, `GetOrdinal` indem Sie ein Mal aufrufen und die Ergebnisse einer ganzzahligen Variablen zur Verwendung innerhalb der Schleife zuweisen.  
  
   
  
## Examples  
 Wenn Sie nur einen Spaltennamen haben, in diesem Fall der Spaltenname vom Benutzer angegeben ist, und Sie Informationen aus der Spalte abrufen müssen, können Sie eine Prozedur wie die folgende verwenden, um die erforderlichen Informationen zu extrahieren. In diesem Beispiel akzeptiert die Prozedur einen Spaltennamen und gibt die Daten zurück, die in dieser Spalte für die aktuelle Zeile in der <xref:System.Data.DataTableReader> enthalten sind:  
  
 [!code-csharp[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.ArgumentException">Der angegebene Name ist kein gültiger Spaltenname.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificFieldType">
      <MemberSignature Language="C#" Value="public override Type GetProviderSpecificFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetProviderSpecificFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetProviderSpecificFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificFieldType : int -&gt; Type" Usage="dataTableReader.GetProviderSpecificFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft den Typ der angegebenen Spalte im anbieterspezifischen Format ab.</summary>
        <returns>Der <see cref="T:System.Type" />, der der Datentyp des Objekts ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da immer den Typ zurückgibt, der im zugrunde <xref:System.Data.DataColumn>liegenden gespeichert ist, gibt der Wert <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> , der durch Aufrufen der-Methode zurückgegeben wird, immer <xref:System.Data.DataTable>denselben Typ zurück wie der im gespeicherte Typ. <xref:System.Data.DataTableReader> Wenn Sie mit der <xref:System.Data.DataTableReader> -Klasse arbeiten, gibt der Aufruf der <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> -Methode denselben Typ zurück <xref:System.Type.GetType%2A> wie das Aufrufen der-Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValue">
      <MemberSignature Language="C#" Value="public override object GetProviderSpecificValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetProviderSpecificValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetProviderSpecificValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValue : int -&gt; obj" Usage="dataTableReader.GetProviderSpecificValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Anzahl der Spalten, deren Wert abgerufen wird.</param>
        <summary>Ruft den Wert der angegebenen Spalte im anbieterspezifischen Format ab.</summary>
        <returns>Ruft den Wert der angegebenen Spalte im anbieterspezifischen Format ab.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da immer den Typ zurückgibt, der im zugrunde <xref:System.Data.DataColumn>liegenden gespeichert ist, gibt der durch <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> den Aufruf der-Methode zurückgegebene Wert immer Daten <xref:System.Data.DataTable>desselben Typs zurück wie die in gespeicherten Daten. <xref:System.Data.DataTableReader> Wenn Sie mit der <xref:System.Data.DataTableReader> -Klasse arbeiten, gibt der Aufruf der <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> -Methode denselben Wert und denselben Typ <xref:System.Data.DataTableReader.GetValue%2A> wie das Aufrufen der-Methode zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValues">
      <MemberSignature Language="C#" Value="public override int GetProviderSpecificValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetProviderSpecificValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetProviderSpecificValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValues : obj[] -&gt; int" Usage="dataTableReader.GetProviderSpecificValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Ein Objektarray, das mit Typinformationen für die Spalten im <see cref="T:System.Data.DataTableReader" /> aufgefüllt werden soll.</param>
        <summary>Füllt das angegebene Array mit anbieterspezifischen Typinformationen für alle Spalten im <see cref="T:System.Data.DataTableReader" /> auf.</summary>
        <returns>Die Anzahl der in das Array kopierten Spaltenwerte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Da immer die Daten des Typs zurückgibt, die in der zugrunde <xref:System.Data.DataColumn>liegenden gespeichert sind, sind die Werte <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> , die durch den Aufruf der-Methode zurückgegeben werden, immer <xref:System.Data.DataTable>dieselben Typen wie die in gespeicherten Daten. <xref:System.Data.DataTableReader> Wenn Sie mit der <xref:System.Data.DataTableReader> -Klasse arbeiten, werden beim Aufrufen der <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> -Methode dieselben Werte und Typen wie <xref:System.Data.DataTableReader.GetValues%2A> beim Aufrufen der-Methode zurückgegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="GetSchemaTable">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchemaTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchemaTable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetSchemaTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchemaTable () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchemaTable();" />
      <MemberSignature Language="F#" Value="override this.GetSchemaTable : unit -&gt; System.Data.DataTable" Usage="dataTableReader.GetSchemaTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine <see cref="T:System.Data.DataTable" /> zurück, die die Spaltenmetadaten des <see cref="T:System.Data.DataTableReader" /> beschreibt.</summary>
        <returns>Eine <see cref="T:System.Data.DataTable" />, die die Spaltenmetadaten beschreibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die getschemabel-Methode gibt Metadaten zu jeder Spalte in der folgenden Reihenfolge zurück:  
  
|DataReader-Spalte|Beschreibung|  
|-----------------------|-----------------|  
|Spaltenname|Der Name der Spalte, wie Sie in der <xref:System.Data.DataTable>angezeigt wird.|  
|Columnordinon|Die Ordnungszahl der Spalte.|  
|ColumnSize|-1, wenn <xref:System.Data.Common.SchemaTableColumn.ColumnSize> die- <xref:System.Data.DataColumn.MaxLength%2A>Eigenschaft (oder) <xref:System.Data.DataColumn> von nicht bestimmt werden kann oder nicht relevant ist, andernfalls 0 oder eine positive ganze Zahl, `MaxLength` die den Wert enthält.|  
|NumericPrecision|Wenn es sich bei dem Spaltentyp um einen numerischen Typ handelt, ist dies die maximale Genauigkeit der Spalte. Wenn der Spaltentyp kein numerischer Datentyp ist, ist dies ein NULL-Wert.|  
|NumericScale|Wenn der Spaltendatentyp eine Skalierungs Komponente aufweist, wird die Anzahl der Ziffern rechts vom Dezimaltrennzeichen zurückgegeben. Andernfalls wird ein NULL-Wert zurückgegeben.|  
|DataType|Der zugrunde liegende Typ der Spalte.|  
|ProviderType|Der Indikator des Datentyps der Spalte. Wenn sich der Datentyp der Spalte von Zeile zu Zeile unterscheidet, ist <xref:System.Object>dieser Wert. Diese Spalte darf keinen NULL-Wert enthalten.|  
|IsLong|`true`, wenn der Datentyp der Spalte ist <xref:System.String> <xref:System.Data.DataColumn.MaxLength%2A> und die-Eigenschaft-1 ist. Andernfalls `false`.|  
|AllowDBNull|`true`, wenn die AllowDBNull-Einschränkung für die Spalte auf true festgelegt ist. `false`andernfalls.|  
|IsReadOnly|`true`, wenn die Spalte nicht geändert werden kann. andernfalls `false`.|  
|IsRowVersion|`false`für jede Spalte.|  
|IsUnique|`true`: In dieser Spalte können keine <xref:System.Data.DataTable> zwei Zeilen in der denselben Wert aufweisen. `IsUnique`ist garantiert true, wenn die Spalte einen Schlüssel allein darstellt, oder wenn eine Einschränkung vom Typ UNIQUE vorliegt, die nur für diese Spalte gilt. `false`: Die Spalte kann doppelte Werte in `DataTable`enthalten. Der Standardwert dieser Spalte ist `false`.|  
|IsKey|`true`: Bei der Spalte handelt es sich um eine Gruppe von Spalten, die die Zeile in <xref:System.Data.DataTable>eindeutig identifizieren. Der Satz von Spalten, `IsKey` bei denen `true` auf festgelegt ist, muss eine `DataTable`Zeile in eindeutig identifizieren. Es ist nicht erforderlich, dass es sich bei diesem Satz von Spalten um einen minimalen Satz von Spalten handelt. Dieser Spalten Satz kann aus einem `DataTable` Primärschlüssel, einer UNIQUE-Einschränkung oder einem eindeutigen Index generiert werden. `false`: Die Spalte ist nicht erforderlich, um die Zeile eindeutig zu identifizieren. Dieser Wert ist `true` , wenn die Spalte an einem einzelnen oder zusammengesetzten Primärschlüssel beteiligt ist. Andernfalls ist `false`der Wert.|  
|IsAutoIncrement|`true`: In der Spalte werden neuen Zeilen in fester Inkrementen Werte zugewiesen. `false`: In der Spalte werden neuen Zeilen in fester Inkrementen keine Werte zugewiesen. Der Standardwert dieser Spalte ist `false`.|  
|BaseCatalogName|Der Name des Katalogs im Datenspeicher, der die Spalte enthält. `Null`, wenn der Name des Basis Katalogs nicht bestimmt werden kann. Der Standardwert für diese Spalte ist ein `null` -Wert.|  
|BaseSchemaName|Dieser Wert ist immer `Null`.|  
|BaseTableName|Der Name des <xref:System.Data.DataTable>.|  
|BaseColumnName|Der Name der Spalte in <xref:System.Data.DataTable>.|  
|AutoIncrementSeed|Der Wert der <xref:System.Data.DataTable>-Eigenschaft <xref:System.Data.DataColumn.AutoIncrementSeed%2A> des-Objekts.|  
|AutoIncrementStep|Der Wert der <xref:System.Data.DataTable>-Eigenschaft <xref:System.Data.DataColumn.AutoIncrementStep%2A> des-Objekts.|  
|DefaultValue|Der Wert der <xref:System.Data.DataColumn>-Eigenschaft <xref:System.Data.DataColumn.DefaultValue%2A> des-Objekts.|  
|Ausdruck|Die Ausdrucks Zeichenfolge, wenn die aktuelle Spalte eine Ausdrucks Spalte ist und alle Spalten, die im Ausdruck verwendet werden `T:System.Data.DataTable` , derselben angehören, die die Ausdrucks `null`Spalte enthält; andernfalls.|  
|ColumnMapping|Der <xref:System.Data.MappingType> Wert, der dem <xref:System.Data.DataColumn>zugeordnet ist. Der Typ `Attribute`kann einer der Typen, `Element`, `Hidden`oder `SimpleContent`sein. Der Standardwert ist `Element`sein.|  
|BaseTableNamespace|Der Wert der <xref:System.Data.DataTable>-Eigenschaft <xref:System.Data.DataTable.Namespace%2A> des-Objekts.|  
|BaseColumnNamespace|Der Wert der <xref:System.Data.DataColumn>-Eigenschaft <xref:System.Data.DataColumn.Namespace%2A> des-Objekts.|  
  
   
  
## Examples  
 Im folgenden Beispiel für eine Konsolenanwendung werden Schema Informationen zur angegebenen Spalte abgerufen. Übergeben Sie `DisplaySchemaTableInfo` die Prozedur <xref:System.Data.DataTableReader> a und eine ganze Zahl `DataTableReader`, die die Ordnungsposition einer Spalte innerhalb von darstellt, und die Prozedur gibt Schema Informationen im Konsolenfenster aus.  
  
 [!code-csharp[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Data.DataTableReader" /> ist geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetString : int -&gt; string" Usage="dataTableReader.GetString ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte</param>
        <summary>Ruft den Wert der angegebenen Spalte als eine Zeichenfolge ab.</summary>
        <returns>Der Wert der angegebenen Spalte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen <xref:System.Data.DataTableReader.IsDBNull%2A> Sie auf, um festzustellen, ob vor dem Aufruf dieser Methode NULL-Werte vorhanden sind  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte in der- <xref:System.Data.DataTableReader>Spalte mit der Nummer 2 angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte des richtigen Typs angezeigt werden, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.GetString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
        <exception cref="T:System.InvalidCastException">Die angegebene Spalte enthält keine Zeichenfolge.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public override object GetValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetValue : int -&gt; obj" Usage="dataTableReader.GetValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte</param>
        <summary>Ruft den Wert der angegebenen Spalte im systemeigenen Format ab.</summary>
        <returns>Der Wert der angegebenen Spalte. Die Methode gibt für Spalten mit NULL-Werten <see langword="DBNull" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl Sie aufrufen <xref:System.Data.DataTableReader.IsDBNull%2A> können, um festzustellen, ob NULL-Werte vorhanden sind, bevor Sie diese Methode aufrufen, müssen Sie dies nicht tun.  
  
   
  
## Examples  
 Das folgende Beispiel durchläuft alle Spalten in der aktuellen Zeile in einer <xref:System.Data.DataTableReader>und zeigt den Inhalt der einzelnen Spalten und den Spaltennamen an. Wenn Sie in der Regel mit allen Spalten in einer Zeile arbeiten möchten, die von einem <xref:System.Data.DataTableReader>abgerufen wurde, sollten Sie stattdessen die <xref:System.Data.DataTableReader.GetValues%2A> -Methode verwenden, da Sie effizienter ist.  
  
 [!code-csharp[DataWorks DataTableReader.GetValue#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, die Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override int GetValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetValues : obj[] -&gt; int" Usage="dataTableReader.GetValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Ein Array vom Typ <see cref="T:System.Object" />, in das die Spaltenwerte aus dem <see cref="T:System.Data.DataTableReader" /> kopiert werden sollen.</param>
        <summary>Füllt ein Array von Objekten mit den Spaltenwerten der aktuellen Zeile auf.</summary>
        <returns>Die Anzahl der in das Array kopierten Spaltenwerte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei den meisten Anwendungen bietet diese Methode eine effiziente Möglichkeit zum Abrufen aller Spalten, anstatt jede Spalte einzeln abzurufen. Wenn Sie beabsichtigen <xref:System.Data.DataTableReader>, alle Spaltenwerte aus einer Zeile innerhalb von abzurufen, bietet die `GetValues` -Methode die effizienteste Lösung.  
  
 Sie können ein <xref:System.Object> Array übergeben, das weniger als die Anzahl der Spalten enthält, die in der resultierenden Zeile enthalten sind. Nur die Datenmenge, die `Object` das Array enthalten kann, wird in das Array kopiert. Sie können auch ein `Object` Array übergeben, dessen Länge größer ist als die Anzahl der Spalten, die in der resultierenden Zeile enthalten sind. in diesem Fall bleiben die zusätzlichen Array Elemente durch den Methodenaufrufe unverändert.  
  
 Diese Methode platziert `DBNull` das Ausgabe Array für NULL-Spalten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein Array mit der richtigen Größe verwendet wird, um alle Werte aus der aktuellen Zeile in <xref:System.Data.DataTableReader>der angegebenen zu lesen. Außerdem veranschaulicht das Beispiel die Verwendung eines Arrays mit fester Größe, das entweder kleiner oder größer als die Anzahl der verfügbaren Spalten sein könnte.  
  
 [!code-csharp[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasRows">
      <MemberSignature Language="C#" Value="public override bool HasRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasRows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.HasRows" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasRows As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasRows { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasRows : bool" Usage="System.Data.DataTableReader.HasRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Data.DataTableReader" /> eine oder mehrere Zeilen enthält.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Data.DataTableReader" /> eine oder mehrere Zeilen enthält, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `HasRows` -Eigenschaft gibt Informationen zum aktuellen Resultset zurück. Wenn mehrere Resultsets `HasRows` <xref:System.Data.DataTableReader.NextResult%2A> enthält,könnenSiedenWertder-Eigenschaftunmittelbarnachdemaufzurufender-Methodeüberprüfen,umzubestimmen,obdasneueResultset<xref:System.Data.DataTableReader> Zeilen enthält.  
  
 Verwenden Sie `HasRows` die-Eigenschaft, um die Anforderung zu <xref:System.Data.DataTableReader.Read%2A> vermeiden, die <xref:System.Data.DataTableReader> -Methode von aufzurufen, wenn keine Zeilen innerhalb des aktuellen Resultsets vorhanden sind.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei <xref:System.Data.DataTable> -Instanzen mit Daten gefüllt. Der erste <xref:System.Data.DataTable> enthält eine Zeile, die zweite enthält keine Zeilen. Im Beispiel wird dann ein <xref:System.Data.DataTableReader> erstellt, das <xref:System.Data.DataTable> beide-Objekte enthält, und die PrintData-Methode wird aufgerufen, um den Inhalt jedes anzuzeigen, <xref:System.Data.DataTableReader.HasRows%2A> wobei der Wert der-Eigenschaft jedes Objekts überprüft wird, bevor PrintData aufgerufen wird.  
  
 [!code-csharp[DataWorks DataTableReader.HasRows#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.HasRows#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, Informationen über einen geschlossenen <see cref="T:System.Data.DataTableReader" /> abzurufen.</exception>
        <altmember cref="M:System.Data.DataTableReader.NextResult" />
        <altmember cref="M:System.Data.DataTableReader.Read" />
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public override bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Data.DataTableReader.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Data.DataTableReader" /> synchronisiert ist.</summary>
        <value><see langword="true" /> wenn der <see cref="T:System.Data.DataTableReader" /> geschlossen ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTableReader.Close%2A>ist die einzige Methode, `IsClosed` und <xref:System.Data.DataTableReader.RecordsAffected%2A> und sind die einzigen Eigenschaften, auf die zugegriffen werden <xref:System.Data.DataTableReader> kann, nachdem der geschlossen wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDBNull">
      <MemberSignature Language="C#" Value="public override bool IsDBNull (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDBNull(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.IsDBNull(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDBNull (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDBNull(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.IsDBNull : int -&gt; bool" Usage="dataTableReader.IsDBNull ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte</param>
        <summary>Ruft einen Wert ab, der angibt, ob die Spalte nicht vorhandene oder fehlende Werte enthält.</summary>
        <returns><see langword="true" />, wenn der angegebene Spaltenwert <see cref="T:System.DBNull" /> entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie diese Methode auf, um festzustellen, ob NULL-Spaltenwerte vorhanden sind, bevor Sie die <xref:System.Data.DataTableReader.GetByte%2A>typisierten Get-Methoden aufrufen (z <xref:System.Data.DataTableReader.GetChar%2A>. b., usw.), um eine Fehlermeldung zu vermeiden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt der Spalte in der- <xref:System.Data.DataTableReader>Spalte mit der Nummer 2 angezeigt. Wenn der Wert für die Spalte in einer bestimmten Zeile NULL ist, zeigt der Code den \<Text NULL-> an. Wenn die Daten in der Spalte des richtigen Typs angezeigt werden, zeigt das Beispiel eine Fehlermeldung für jede Zeile an.  
  
 [!code-csharp[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Wert der angegebenen Spalte im systemeigenen Format ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[int ordinal] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int ordinal); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Die nullbasierte Ordnungszahl der Spalte.</param>
        <summary>Ruft bei angegebener Spaltenordnungszahl den Wert der angegebenen Spalte im systemeigenen Format ab.</summary>
        <value>Der Wert der angegebenen Spalte im systemeigenen Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung <xref:System.Data.DataTableReader.Item%2A> für verhält sich identisch mit <xref:System.Data.DataTableReader.GetValue%2A> der-Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Inhalt aller Spalten in allen Zeilen der angegebenen <xref:System.Data.DataTableReader>angezeigt. Der Code verwendet die <xref:System.Data.DataTableReader.Item%2A> -Methode (der Indexer in Microsoft C#), um den Wert abzurufen, der in den einzelnen Spalten enthalten ist.  
  
 [!code-csharp[DataWorks DataTableReader.Item#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Item#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Der übergebene Index lag außerhalb des Bereichs von 0 bis <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Spalte.</param>
        <summary>Ruft bei angegebenem Spaltennamen den Wert der angegebenen Spalte im systemeigenen Format ab.</summary>
        <value>Der Wert der angegebenen Spalte im systemeigenen Format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zuerst wird eine Suche mit Unterscheidung nach Groß-/Kleinschreibung ausgeführt. Bei einem Fehler wird eine zweite Suche ohne Beachtung der Groß-/Kleinschreibung durchgeführt.  
  
 Diese Methode hat keine unempfindliche Breite von Kana.  
  
 Diese überladene <xref:System.Data.DataTableReader.Item%2A> Version von entspricht dem <xref:System.Data.DataTableReader.GetOrdinal%2A> Aufrufen der-Methode und dem anschließenden <xref:System.Data.DataTableReader.GetValue%2A> Aufrufen der-Methode.  
  
   
  
## Examples  
 Wenn ein <xref:System.Data.DataTableReader> und ein Spaltenname angegeben sind, gibt die GetValueByName-Prozedur den Wert der angegebenen Spalte zurück. Bevor Sie diese Prozedur aufrufen, müssen Sie eine neue <xref:System.Data.DataTableReader> -Instanz erstellen und die Read-Methode mindestens einmal aufrufen, um den Zeilen Zeiger in einer Daten Zeile zu positionieren.  
  
 [!code-csharp[DataWorks DataTableReader.ItemName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ItemName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der angegebene Name ist kein gültiger Spaltenname.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Es wurde versucht, Daten aus einer gelöschten Zeile abzurufen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder darauf zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextResult">
      <MemberSignature Language="C#" Value="public override bool NextResult ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool NextResult() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.NextResult" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function NextResult () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool NextResult();" />
      <MemberSignature Language="F#" Value="override this.NextResult : unit -&gt; bool" Usage="dataTableReader.NextResult " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den <see cref="T:System.Data.DataTableReader" /> auf das nächste Resultset, sofern vorhanden.</summary>
        <returns><see langword="true" />, wenn ein anderes Resultsets vorhanden ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird verwendet, um mehrere Ergebnisse zu verarbeiten, die generiert werden <xref:System.Data.DataTableReader> können, <xref:System.Data.DataSet> indem ein über ein erstellt wird, das zwei oder mehr Tabellen enthält, oder <xref:System.Data.DataTable> ein Array, das zwei oder mehr-Instanzen enthält.  
  
 Ein neuer <xref:System.Data.DataTableReader> wird auf dem ersten Ergebnis positioniert.  
  
   
  
## Examples  
 Im folgenden Beispiel erstellt die TestConstructor-Methode zwei <xref:System.Data.DataTable> -Instanzen. Um diesen Konstruktor für die <xref:System.Data.DataTableReader> -Klasse zu veranschaulichen, erstellt das Beispiel einen neuen `DataTableReader` auf der Grundlage eines Arrays, das die beiden `DataTables`enthält, und führt einen einfachen Vorgang aus, der den Inhalt aus den ersten Spalten in der Konsole druckt. ster. Um diese Anwendung zu testen, erstellen Sie eine neue Konsolenanwendung, und fügen Sie den Beispielcode in die neu erstellte Datei ein.  
  
 [!code-csharp[DataWorks DataTableReader.NextResult#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.NextResult#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/VB/source.vb#1)]  
  
 Im Konsolenfenster werden folgende Ergebnisse angezeigt:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, innerhalb eines geschlossenen <see cref="T:System.Data.DataTableReader" /> zu navigieren.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; bool" Usage="dataTableReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den <see cref="T:System.Data.DataTableReader" /> auf den nächsten Datensatz.</summary>
        <returns><see langword="true" />, wenn eine andere zu lesende Zeile vorhanden war, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Standardposition des der <xref:System.Data.DataTableReader> steht vor dem ersten Datensatz. Daher müssen Sie aufrufen `Read` , um mit dem Zugriff auf Daten zu beginnen.  
  
   
  
## Examples  
 Die PrintColumns-Prozedur durchläuft alle Zeilen im <xref:System.Data.DataTableReader>und zeigt den Inhalt der einzelnen Spalten im Konsolenfenster an.  
  
 [!code-csharp[DataWorks DataTableReader.Read#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Read#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, eine Spalte in einem geschlossenen <see cref="T:System.Data.DataTableReader" /> zu lesen oder auf sie zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="RecordsAffected">
      <MemberSignature Language="C#" Value="public override int RecordsAffected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecordsAffected" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.RecordsAffected" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RecordsAffected As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int RecordsAffected { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecordsAffected : int" Usage="System.Data.DataTableReader.RecordsAffected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der durch die Ausführung der SQL-Anweisung eingefügten, geänderten oder gelöschten Zeilen ab.</summary>
        <value>Der <see cref="T:System.Data.DataTableReader" /> unterstützt diese Eigenschaft nicht und gibt immer 0 zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
