<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ebfc2930ba77d02811472dac7449a79e1eea9c8a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36679904" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataTable = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents one table of in-memory data.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable> ist ein zentrale Objekt in der Bibliothek für ADO.NET. Von anderen Objekten verwendet werden, die <xref:System.Data.DataTable> enthalten die <xref:System.Data.DataSet> und <xref:System.Data.DataView>.  
  
 Beim Zugriff auf <xref:System.Data.DataTable> Objekte, beachten Sie, dass sie bedingt Groß-/Kleinschreibung unterschieden werden. Angenommen, eine <xref:System.Data.DataTable> "Mydatatable" benannt ist und eine andere "Mydatatable" benannt ist, wird in eine Zeichenfolge, die zur Suche nach einer der Tabellen die Groß-/ Kleinschreibung. Allerdings wird Wenn "Mydatatable" vorhanden ist, und "Mydatatable", nicht aber, die zu suchende Zeichenfolge wie Groß-/Kleinschreibung beachten betrachtet. Ein <xref:System.Data.DataSet> können enthalten zwei <xref:System.Data.DataTable> Objekte, die dieselbe <xref:System.Data.DataTable.TableName%2A> Eigenschaftswert, aber unterschiedliche <xref:System.Data.DataTable.Namespace%2A> Eigenschaftswerte. Weitere Informationen zum Arbeiten mit <xref:System.Data.DataTable> anzuzeigen, [Erstellen einer "DataTable"](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Beim Erstellen einer <xref:System.Data.DataTable> programmgesteuert, müssen Sie zuerst das Schema definieren, durch Hinzufügen von <xref:System.Data.DataColumn> Datenbankobjekte in der <xref:System.Data.DataColumnCollection> (erfolgt über die <xref:System.Data.DataTable.Columns%2A> Eigenschaft). Weitere Informationen zum Hinzufügen von <xref:System.Data.DataColumn> anzuzeigen, [Hinzufügen von Spalten zu einer "DataTable"](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md).  
  
 Zum Hinzufügen von Zeilen zu einer <xref:System.Data.DataTable>, müssen Sie zunächst mithilfe der <xref:System.Data.DataTable.NewRow%2A> Methode, um ein neues zurückzugeben <xref:System.Data.DataRow> Objekt. Die <xref:System.Data.DataTable.NewRow%2A> Methode gibt eine Zeile mit dem Schema der <xref:System.Data.DataTable>, wie sie von der Tabelle definiert ist <xref:System.Data.DataColumnCollection>. Die maximale Anzahl von Zeilen, die eine <xref:System.Data.DataTable> können Speicher ist 16.777.216. Weitere Informationen finden Sie unter [Hinzufügen von Daten zu einer "DataTable"](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md).  
  
 Die <xref:System.Data.DataTable> enthält auch eine Auflistung von <xref:System.Data.Constraint> Objekte, die verwendet werden können, um die Integrität der Daten sicherzustellen. Weitere Informationen finden Sie unter [DataTable-Einschränkungen](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
 Es gibt viele <xref:System.Data.DataTable> Ereignisse, die verwendet werden können, um zu bestimmen, wann Änderungen an einer Tabelle vorgenommen werden. Dazu gehören <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting> und <xref:System.Data.DataTable.RowDeleted>. Weitere Informationen zu den Ereignissen, die mit verwendet werden, kann eine <xref:System.Data.DataTable>, finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
 Wenn eine Instanz von <xref:System.Data.DataTable> wird erstellt, einige Eigenschaften werden von der Lese-/Schreibzugriff auf Ausgangswerte festgelegt. Eine Liste der folgenden Werte sind, finden Sie unter der <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> Thema Konstruktor.  
  
> [!NOTE]
>  Die <xref:System.Data.DataSet> und <xref:System.Data.DataTable> Objekte erben von <xref:System.ComponentModel.MarshalByValueComponent>, und unterstützt die <xref:System.Runtime.Serialization.ISerializable> Schnittstelle für das .NET Framework-Remoting. Dies sind die einzigen ADO.NET-Objekte, die für .NET Framework Remoting verwendet werden können.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt zwei <xref:System.Data.DataTable> Objekte und eine <xref:System.Data.DataRelation> -Objekt und fügt die neuen Objekte auf einer <xref:System.Data.DataSet>. Die Tabellen werden dann angezeigt, einem <xref:System.Windows.Forms.DataGridView> Steuerelement.  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 Dieses Beispiel veranschaulicht, wie eine "DataTable" manuell mit bestimmten Schemadefinitionen erstellen:  
  
-   Erstellen Sie mehrere Datentabellen und definieren Sie die ursprünglichen Spalten.  
  
-   Erstellen Sie die tabelleneinschränkungen.  
  
-   Fügen Sie die Werte, und zeigen Sie die Tabellen.  
  
-   Erstellen Sie die Spalten für Ausdrücke, und zeigen Sie die Tabellen.  
  
 C# und Visual Basic-Projekte mit diesem Codebeispiel finden Sie in der [Developer Code Samples](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist für schreibgeschützte Vorgänge mit mehreren Threads sicher. Sie müssen alle Schreibvorgänge synchronisieren.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with no arguments.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor legt die Anfangswerte für alle Eigenschaften des der <xref:System.Data.DataTable> Objekt. Die folgende Tabelle zeigt die Eigenschaften und ihre Standardwerte. Wenn eine Instanz von <xref:System.Data.DataTable> erstellt wird, werden die folgenden Eigenschaften werden festgelegt, um die Anfangswerte Lese-/Schreibzugriff.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|**CaseSensitive**|Identisch mit der übergeordneten <xref:System.Data.DataSet>, wenn es zu einem gehört. Andernfalls `false`.|  
|**DisplayExpression**|leere Zeichenfolge ("")|  
|**Locale**|Wie das übergeordnete Element <xref:System.Data.DataSet> des Objekts <xref:System.Globalization.CultureInfo> (zurückgegebenes der <xref:System.Data.DataSet.Locale%2A> Eigenschaft), wenn kein übergeordnetes Element vorhanden ist, der Standardwert ist das aktuelle System <xref:System.Globalization.CultureInfo>.|  
|**MinimumCapacity**|50 Zeilen.|  
  
 Sie können den Wert für alle diese Eigenschaften über einen separaten Aufruf der Eigenschaft ändern.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Data.DataTable> mit <xref:System.Data.DataColumn> und <xref:System.Data.DataRow>, und zeigt ihn in einem <xref:System.Windows.Forms.DataGridView> Steuerelement.  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable tableName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">The name to give the table. If <c>tableName</c> is <see langword="null" /> or an empty string, a default name is given when added to the <see cref="T:System.Data.DataTableCollection" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with the specified table name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> und zeigt ihn in einem <xref:System.Windows.Forms.DataGridView> Steuerelement.  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">The data needed to serialize or deserialize an object.</param>
        <param name="context">The source and destination of a given serialized stream.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class with the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and the <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung der <xref:System.Data.DataTable> Konstruktor ist erforderlich, damit <xref:System.Runtime.Serialization.ISerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string * string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (tableName, tableNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">The name to give the table. If <c>tableName</c> is <see langword="null" /> or an empty string, a default name is given when added to the <see cref="T:System.Data.DataTableCollection" />.</param>
        <param name="tableNamespace">The namespace for the XML representation of the data stored in the <see langword="DataTable" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Data.DataTable" /> class using the specified table name and namespace.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataTable.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commits all the changes made to this table since the last time <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Data.DataTable.AcceptChanges%2A> aufgerufen wird, eine <xref:System.Data.DataRow> Objekt immer noch im Bearbeitungsmodus Bearbeitungsvorgänge erfolgreich beendet. Die <xref:System.Data.DataRowState> ändert sich ebenfalls: alle `Added` und `Modified` Zeilen werden `Unchanged`, und `Deleted` Zeilen entfernt werden.  
  
 Die <xref:System.Data.DataTable.AcceptChanges%2A> Methode in der Regel aufgerufen wird eine <xref:System.Data.DataTable> Sie versucht haben, aktualisieren Sie die <xref:System.Data.DataSet> mithilfe der <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel testet jede Tabelle auf Fehler. Wenn die Tabelle Fehler abgeglichen werden können (durch Übergabe an eine nicht definierte Funktion), <xref:System.Data.DataTable.AcceptChanges%2A> aufgerufen wurde, andernfalls <xref:System.Data.DataTable.RejectChanges%2A> aufgerufen wird.  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataTable.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Begins the initialization of a <see cref="T:System.Data.DataTable" /> that is used on a form or used by another component. The initialization occurs at run time.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die entwurfsumgebung für Visual Studio .NET verwendet diese Methode, um die Initialisierung einer Komponente zu starten, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Data.DataTable.EndInit%2A> -Methode beendet die Initialisierung. Mithilfe der <xref:System.Data.DataTable.BeginInit%2A> und <xref:System.Data.DataTable.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberSignature Language="F#" Value="member this.BeginLoadData : unit -&gt; unit" Usage="dataTable.BeginLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Turns off notifications, index maintenance, and constraints while loading data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Data.DataTable.BeginLoadData%2A> in Verbindung mit <xref:System.Data.DataTable.LoadDataRow%2A> und <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates whether string comparisons within the table are case-sensitive.</summary>
        <value>
          <see langword="true" /> Wenn der Vergleich Groß-/Kleinschreibung beachtet wird; andernfalls <see langword="false" />. Der Standardsatz an das übergeordnete Element <see cref="T:System.Data.DataSet" /> des Objekts <see cref="P:System.Data.DataSet.CaseSensitive" /> Eigenschaft oder <see langword="false" /> Wenn die <see cref="T:System.Data.DataTable" /> unabhängig von der Erstellung einer <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.CaseSensitive%2A> Eigenschaft wirkt sich auf Zeichenfolgenvergleichen in sortieren, suchen und filtern.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.Select%2A> Methode zweimal auf eine <xref:System.Data.DataTable>. Erstmals ausführen, die <xref:System.Data.DataTable.CaseSensitive%2A> -Eigenschaftensatz auf `false`, wird die zweite, auf `true`.  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of child relations for this <see cref="T:System.Data.DataTable" />.</summary>
        <value>Ein <see cref="T:System.Data.DataRelationCollection" /> , die die untergeordnete Beziehungen für die Tabelle enthält. Eine leere Auflistung wird zurückgegeben, wenn keine <see cref="T:System.Data.DataRelation" /> Objekte vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.DataRelation> definiert die Beziehung zwischen zwei Tabellen. In der Regel werden zwei Tabellen über ein einzelnes Feld verknüpft, die dieselben Daten enthält. Z. B. möglicherweise eine Tabelle, die Adressdaten enthält ein einzelnes Feld mit Codes, die Länder/Regionen darstellen. Eine zweite Tabelle, die Land/Region-Daten enthält, müssen ein einzelnes Feld mit dem Code, der das Land/Region identifiziert, und es ist dieser Code die in das entsprechende Feld in der ersten Tabelle eingefügt wird. Ein <xref:System.Data.DataRelation>, dann enthält mindestens vier Arten von Informationen: (1) den Namen der ersten Tabelle, (2) den Spaltennamen in der ersten Tabelle, (3) den Namen der zweiten Tabelle und (4) der Spaltenname in der zweiten Tabelle.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.ChildRelations%2A> -Eigenschaft zum Zurückgeben von jedem untergeordneten Element <xref:System.Data.DataRelation> in einem <xref:System.Data.DataTable>. Jede Beziehung wird dann verwendet, als Argument in der <xref:System.Data.DataRow.GetChildRows%2A> Methode der <xref:System.Data.DataRow> ein Array von Zeilen zurückgegeben. Der Wert der einzelnen Spalten in der Zeile wird dann ausgegeben.  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears the <see cref="T:System.Data.DataTable" /> of all data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Zeilen in allen Tabellen werden entfernt. Eine Ausnahme wird generiert, wenn die Tabelle erzwungene untergeordnete Beziehungen, die untergeordneten Zeilen verfügt verwaist werden würde.  
  
 Wenn die <xref:System.Data.DataSet> gebunden ist ein <xref:System.Xml.XmlDataDocument>Aufrufen <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> oder <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> löst die <xref:System.NotSupportedException>. Um diese Situation zu vermeiden, Durchsuchen Sie jede Tabelle, entfernen Sie jede Zeile zu einem Zeitpunkt. Bei Verwendung von <xref:System.Data.DataTable.NewRow%2A> um neue Zeilen zu erstellen, die Zeilen vor dem Aufruf verarbeitet werden müssen <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel löscht die Tabelle aller Daten.  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataTable&#xA;override this.Clone : unit -&gt; System.Data.DataTable" Usage="dataTable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clones the structure of the <see cref="T:System.Data.DataTable" />, including all <see cref="T:System.Data.DataTable" /> schemas and constraints.</summary>
        <returns>A new <see cref="T:System.Data.DataTable" /> with the same schema as the current <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Klassen abgeleitet wurden, wird der Klon denselben abgeleiteten Klassen aufweisen.  
  
 Klon erstellt ein neues <xref:System.Data.DataTable> mit derselben Struktur wie der ursprüngliche <xref:System.Data.DataTable>, aber keine Daten kopiert (die neue <xref:System.Data.DataTable> enthält keine `DataRows`). So kopieren Sie die Struktur und die Daten in eine neue <xref:System.Data.DataTable>, verwenden Sie <xref:System.Data.DataTable.Copy%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht, wie die Struktur und die Einschränkungen der Zieltabelle aktualisiert, nachdem Sie DataTable.Clone ausgeführt wird. Die Klasse ClonedDataTable eine Zieltabelle zurück und umfasst die Aktualisierung Ereignisse. Nach der Klon wird nicht Strukturänderungen in der Quelltabelle in der Zieltabelle dargestellt werden. Insbesondere wird in diesem Beispiel:  
  
-   Aktualisieren Sie die Änderungen der Spalten in der Quelltabelle an.  
  
-   Aktualisieren Sie die Änderungen der UniqueConstraint in der Quelltabelle an.  
  
-   Aktualisieren Sie die Änderungen der ForeignKeyConstraint in der Quelltabelle an.  
  
 C# und Visual Basic-Projekte mit diesem Codebeispiel finden Sie in der [Developer Code Samples](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 Dieses Beispiel zeigt, wie Daten in einer "DataTable" ändern und Aktualisieren der Datenquelle.  
  
 Erstellen Sie zunächst eine Datenbank aus:  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 Sie können jetzt kompilieren und Ausführen des Beispiels. [Gewusst wie: Ändern von Daten in DataTable und aktualisieren Sie auf die Datenquelle](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) Visual Basic- und C#-Projekte in diesem Beispiel hat.  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a value has been changed for the specified <see cref="T:System.Data.DataColumn" /> in a <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a value is being changed for the specified <see cref="T:System.Data.DataColumn" /> in a <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Columns : System.Data.DataColumnCollection" Usage="System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of columns that belong to this table.</summary>
        <value>Ein <see cref="T:System.Data.DataColumnCollection" /> , enthält die Auflistung der <see cref="T:System.Data.DataColumn" /> Objekte für die Tabelle. Eine leere Auflistung wird zurückgegeben, wenn keine <see cref="T:System.Data.DataColumn" /> Objekte vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataColumnCollection> bestimmt das Schema einer Tabelle durch den Datentyp jeder Spalte definieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird jeder Wert jeder Zeile in einer Tabelle mithilfe der <xref:System.Data.DataTable.Columns%2A> Eigenschaft.  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Compute : string * string -&gt; obj" Usage="dataTable.Compute (expression, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">The expression to compute.</param>
        <param name="filter">The filter to limit the rows that evaluate in the expression.</param>
        <summary>Computes the given expression on the current rows that pass the filter criteria.</summary>
        <returns>An <see cref="T:System.Object" />, set to the result of the computation. If the expression evaluates to null, the return value will be <see cref="F:System.DBNull.Value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `expression` Parameter erfordert eine Aggregatfunktion. Folgendes ist z. B. ein gültiger Ausdruck:  
  
 `Count(Quantity)`  
  
 Dieser Ausdruck ist jedoch nicht:  
  
 `Sum (Quantity * UnitPrice)`  
  
 Wenn Sie eine Operation für zwei oder mehr Spalten durchführen müssen, sollten Sie erstellen eine <xref:System.Data.DataColumn>legen dessen <xref:System.Data.DataColumn.Expression%2A> Eigenschaft, um einen entsprechenden Ausdruck ein, und verwenden Sie ein Aggregatausdruck für die resultierende Spalte. In diesem Fall erhält eine <xref:System.Data.DataColumn> mit dem Namen "Total", und die <xref:System.Data.DataColumn.Expression%2A> Festlegen dieser Eigenschaft:  
  
 `"Quantity * UnitPrice"`  
  
 Die Expression-Argument für die <xref:System.Data.DataTable.Compute%2A> Methode wäre dann dies:  
  
 `Sum(total)`  
  
 Der zweite Parameter `filter`, bestimmt, welche Zeilen im Ausdruck verwendet werden. Wenn die Tabelle eine Datumsspalte mit dem Namen "colDate" enthält, können Sie beispielsweise die Zeilen mit dem folgenden Ausdruck begrenzen:  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 Regeln zum Erstellen von Ausdrücken für beide Parameter finden Sie unter der <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> Eigenschaft.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Werte einer Spalte mit dem Namen "Total" für den Verkäufer, dessen ID 5 summiert.  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraints : System.Data.ConstraintCollection" Usage="System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of constraints maintained by this table.</summary>
        <value>Ein <see cref="T:System.Data.ConstraintCollection" /> , enthält die Auflistung der <see cref="T:System.Data.Constraint" /> Objekte für die Tabelle. Eine leere Auflistung wird zurückgegeben, wenn keine <see cref="T:System.Data.Constraint" /> Objekte vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.ForeignKeyConstraint> schränkt die Aktion ausgeführt, wenn ein Wert in einer Spalte (oder Spalten) entweder gelöscht oder aktualisiert wird. Eine solche Einschränkung soll mit den Schlüsselspalten verwendet werden. In einer über-/unterordnungsbeziehung zwischen zwei Tabellen kann einen Wert aus der übergeordneten Tabelle gelöscht untergeordneten Zeilen in einem der folgenden Arten wirken sich auf.  
  
-   Das untergeordnete Element, Zeilen, auch sein können, gelöscht (eine kaskadierende Aktion).  
  
-   Die Werte in die untergeordnete Spalte (oder Spalten) können auf null-Werte festgelegt werden.  
  
-   Die Werte in die untergeordnete Spalte (oder Spalten) können auf Standardwerte festgelegt werden.  
  
-   Eine Ausnahme kann ausgelöst werden.  
  
 Ein <xref:System.Data.UniqueConstraint> wird aktiviert, bei dem Versuch, einen Wert in einem Primärschlüssel auf einen nicht eindeutigen Wert festzulegen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Data.ForeignKeyConstraint> auf die Auflistung von Einschränkungen.  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataTable" Usage="dataTable.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copies both the structure and data for this <see cref="T:System.Data.DataTable" />.</summary>
        <returns>A new <see cref="T:System.Data.DataTable" /> with the same structure (table schemas and constraints) and data as this <see cref="T:System.Data.DataTable" />.  If these classes have been derived, the copy will also be of the same derived classes.  
  
 <see cref="M:System.Data.DataTable.Copy" /> creates a new <see cref="T:System.Data.DataTable" /> with the same structure and data as the original <see cref="T:System.Data.DataTable" />. To copy the structure to a new <see cref="T:System.Data.DataTable" />, but not the data, use <see cref="M:System.Data.DataTable.Clone" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.Copy%2A> Methode zum Erstellen einer Kopie des Originals <xref:System.Data.DataTable>. Der Name des Namespaces wird nicht beibehalten, wenn er von einem übergeordneten Element geerbt wird <xref:System.Data.DataTable> oder <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataTable.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <see cref="T:System.Data.DataTableReader" /> corresponding to the data within this <see cref="T:System.Data.DataTable" />.</summary>
        <returns>A <see cref="T:System.Data.DataTableReader" /> containing one result set, corresponding to the source <see cref="T:System.Data.DataTable" /> instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine <xref:System.Data.DataTable>-Instanz. Im Beispiel übergibt dann das ausgefüllte <xref:System.Data.DataTable> an eine Prozedur, die Aufrufe der <xref:System.Data.DataTable.CreateDataReader%2A> -Methode, die Ergebnisse der enthaltenen durchläuft die <xref:System.Data.DataTableReader>.  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : unit -&gt; System.Data.DataTable&#xA;override this.CreateInstance : unit -&gt; System.Data.DataTable" Usage="dataTable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new instance of <see cref="T:System.Data.DataTable" />.</summary>
        <returns>The new expression.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Data.DataSet" /> to which this table belongs.</summary>
        <value>Die <see cref="T:System.Data.DataSet" /> zu dem diese Tabelle gehört.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Steuerelement datengebunden ist auf eine <xref:System.Data.DataTable>, und die Tabelle gehört zu einer <xref:System.Data.DataSet>, erhalten Sie auf der <xref:System.Data.DataSet> über diese Eigenschaft.  
  
   
  
## Examples  
 Im folgende Beispiel gibt die übergeordnete <xref:System.Data.DataSet> einer angegebenen Tabelle über die <xref:System.Data.DataTable.DataSet%2A> Eigenschaft.  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultView : System.Data.DataView" Usage="System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a customized view of the table that may include a filtered view, or a cursor position.</summary>
        <value>Der mit dem <see cref="T:System.Data.DataView" /> verknüpfte <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.DefaultView%2A> Eigenschaft gibt eine <xref:System.Data.DataView> können Sie sortieren, Filtern und Suchen einer <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Eigenschaft der <xref:System.Data.DataTable> des Objekts <xref:System.Data.DataView> über die <xref:System.Data.DataTable.DefaultView%2A> Eigenschaft. Außerdem wird gezeigt, die Bindung von einer <xref:System.Windows.Forms.DataGridView> die Steuerung an eine <xref:System.Data.DataTable> mit dem Namen "Suppliers", die eine Spalte mit dem Namen "CompanyName".  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayExpression : string with get, set" Usage="System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the expression that returns a value used to represent this table in the user interface. The <see langword="DisplayExpression" /> property lets you display the name of this table in a user interface.</summary>
        <value>Eine Anzeigezeichenfolge.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataTable.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ends the initialization of a <see cref="T:System.Data.DataTable" /> that is used on a form or used by another component. The initialization occurs at run time.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die entwurfsumgebung für Visual Studio .NET verwendet diese Methode, um die Initialisierung einer Komponente zu beenden, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Data.DataTable.BeginInit%2A> -Methode startet die Initialisierung. Mithilfe der <xref:System.Data.DataTable.BeginInit%2A> und <xref:System.Data.DataTable.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberSignature Language="F#" Value="member this.EndLoadData : unit -&gt; unit" Usage="dataTable.EndLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Turns on notifications, index maintenance, and constraints after loading data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Data.DataTable.EndLoadData%2A> in Verbindung mit <xref:System.Data.DataTable.LoadDataRow%2A> und <xref:System.Data.DataTable.BeginLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of customized user information.</summary>
        <value>Ein <see cref="T:System.Data.PropertyCollection" /> , die benutzerdefinierte Informationen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ExtendedProperties%2A> benutzerdefinierte Informationen zum Hinzufügen einer <xref:System.Data.DataTable>. Hinzufügen von Daten mit der `Add` Methode. Abrufen von Informationen mit der `Item` Methode.  
  
 Erweiterte Eigenschaften muss vom Typ <xref:System.String>. Eigenschaften, die nicht vom Typ Zeichenfolge sind, werden nicht beibehalten. wenn die <xref:System.Data.DataTable> als XML geschrieben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen Timestamp-Wert, der <xref:System.Data.DataTable> über die <xref:System.Data.DataTable.ExtendedProperties%2A> Eigenschaft.  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberSignature Language="F#" Value="val mutable fInitInProgress : bool" Usage="System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Checks whether initialization is in progress. The initialization occurs at run time.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets a copy of the <see cref="T:System.Data.DataTable" /> containing all changes made to it since it was last loaded, or since <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataTable" Usage="dataTable.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a copy of the <see cref="T:System.Data.DataTable" /> that contains all changes made to it since it was loaded or <see cref="M:System.Data.DataTable.AcceptChanges" /> was last called.</summary>
        <returns>A copy of the changes from this <see cref="T:System.Data.DataTable" />, or <see langword="null" /> if no changes are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues <xref:System.Data.DataSet> , enthält eine Kopie aller Zeilen in der ursprünglichen <xref:System.Data.DataSet> , ausstehende Änderungen aufweisen. Beziehung Einschränkungen können dazu führen, dass zusätzliche unveränderte Zeilen in die neue hinzuzufügende <xref:System.Data.DataSet> enthält die unveränderten Zeilen Primärschlüsseln, Fremdschlüsseln in der geänderten Zeilen entspricht. Gibt die Methode `null` (`Nothing` in Visual Basic), wenn keine Zeilen vorhanden, in der ursprünglichen sind <xref:System.Data.DataSet> mit ausstehenden Änderungen.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataTable" Usage="dataTable.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">One of the <see cref="T:System.Data.DataRowState" /> values.</param>
        <summary>Gets a copy of the <see cref="T:System.Data.DataTable" /> containing all changes made to it since it was last loaded, or since <see cref="M:System.Data.DataTable.AcceptChanges" /> was called, filtered by <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>A filtered copy of the <see cref="T:System.Data.DataTable" /> that can have actions performed on it, and later be merged back in the <see cref="T:System.Data.DataTable" /> using <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. If no rows of the desired <see cref="T:System.Data.DataRowState" /> are found, the method returns <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.GetChanges%2A> Methode wird verwendet, um eine zweite erzeugen <xref:System.Data.DataTable> Objekt, das nur die Änderungen enthält, die in der ursprünglichen eingeführt. Verwenden der `rowStates` Argument, um die Art von Änderungen anzugeben, sollte das neue Objekt enthalten.  
  
 Einschränkungen der Beziehung möglicherweise unverändert übergeordneten Zeilen eingeschlossen werden sollen.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataTableSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataTable.GetDataTableSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">An <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance.</param>
        <summary>This method returns an <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance containing the Web Services Description Language (WSDL) that describes the <see cref="T:System.Data.DataTable" /> for Web Services.</summary>
        <returns>The <see cref="T:System.Xml.Schema.XmlSchemaSet" /> instance.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberSignature Language="F#" Value="member this.GetErrors : unit -&gt; System.Data.DataRow[]" Usage="dataTable.GetErrors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an array of <see cref="T:System.Data.DataRow" /> objects that contain errors.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects that have errors.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt die Liste der <xref:System.Data.DataRow> Objekte mit <xref:System.Data.DataRow.RowError%2A> festgelegt. Fehler können z. B. auftreten, beim Aufrufen von <xref:System.Data.Common.DataAdapter.Update%2A> mit <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> festgelegt **"true"**. Nicht aufgerufen werden <xref:System.Data.DataTable.AcceptChanges%2A> auf die <xref:System.Data.DataTable> , bis Sie alle Fehler zu beheben, und senden Sie erneut die <xref:System.Data.DataSet> für die Aktualisierung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.GetErrors%2A> Methode, um ein Array von zurückzugeben <xref:System.Data.DataRow> Objekte, die Fehler enthalten.  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataTable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that holds the serialized data associated with the <see cref="T:System.Data.DataTable" />.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains the source and destination of the serialized stream associated with the <see cref="T:System.Data.DataTable" />.</param>
        <summary>Populates a serialization information object with the data needed to serialize the <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberSignature Language="F#" Value="abstract member GetRowType : unit -&gt; Type&#xA;override this.GetRowType : unit -&gt; Type" Usage="dataTable.GetRowType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the row type.</summary>
        <returns>Returns the type of the <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberSignature Language="F#" Value="abstract member GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataTable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> method.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether there are errors in any of the rows in any of the tables of the <see cref="T:System.Data.DataSet" /> to which the table belongs.</summary>
        <value>
          <see langword="true" /> Wenn Fehler vorhanden sind; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Benutzer auf einen Satz von Daten in der Arbeit ein <xref:System.Data.DataTable>, Sie können jede Änderung mit einem Fehler markieren, wenn die Änderung das Fehlschlagen der Validierung verursacht. Sie können eine gesamte kennzeichnen <xref:System.Data.DataRow> mit einer Fehlermeldung mit der <xref:System.Data.DataRow.RowError%2A> Eigenschaft. Sie können auch Fehler festlegen, auf den einzelnen Spalten der Zeile mit der <xref:System.Data.DataRow.SetColumnError%2A> Methode.  
  
 Vor dem Aktualisieren einer Datenquelle mit einem <xref:System.Data.DataSet>, es wird empfohlen, Sie zuerst rufen die <xref:System.Data.DataSet.GetChanges%2A> Methode auf dem Ziel <xref:System.Data.DataSet>. Die Methode führt zu einem <xref:System.Data.DataSet> , enthält nur die mit dem ursprünglichen vorgenommenen Änderungen. Vor dem Senden der <xref:System.Data.DataSet> wie die Datenquelle für das Aktualisieren, finden Sie in der <xref:System.Data.DataTable.HasErrors%2A> Eigenschaft jeder Tabelle, um festzustellen, ob die Zeilen oder Spalten in den Zeilen Fehler angefügt wurde.  
  
 Nach dem Abgleichen aller Fehler, deaktivieren Sie die Fehler mit der <xref:System.Data.DataRow.ClearErrors%2A> Methode der `DataRow`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.HasErrors%2A> Eigenschaft zu überprüfen, ob eine Tabelle Fehler enthält.  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberSignature Language="F#" Value="member this.ImportRow : System.Data.DataRow -&gt; unit" Usage="dataTable.ImportRow row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">The <see cref="T:System.Data.DataRow" /> to be imported.</param>
        <summary>Copies a <see cref="T:System.Data.DataRow" /> into a <see cref="T:System.Data.DataTable" />, preserving any property settings, as well as original and current values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen von <xref:System.Data.DataTable.NewRow%2A> Fügt eine Zeile der Tabelle mit dem vorhandenen Tabellenschema, jedoch mit den Standardwerten für die Zeile, und legt die <xref:System.Data.DataRowState> auf `Detached`. Aufrufen von <xref:System.Data.DataTable.ImportRow%2A> behält den vorhandenen <xref:System.Data.DataRowState> zusammen mit anderen Werten in der Zeile. Wenn die `DataRow` übergeben wird, wie ein Parameter im getrennten Zustand befindet ist, ignoriert wird und keine Ausnahme ausgelöst wird.  
  
 Die neue Zeile wird an das Ende der Datentabelle hinzugefügt werden.  
  
 Wenn die neue Zeile hinzugefügt in der Datentabelle wird nicht gegen eine Einschränkung verstößt.  
  
 Sie können den Index der neuen Zeile mit DataTable.Rows.Find und DataTable.Rows.IndexOf abrufen. Weitere Informationen finden Sie unter <xref:System.Data.DataRowCollection> und <xref:System.Data.DataTable.Rows%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after the <see cref="T:System.Data.DataTable" /> is initialized.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Data.DataTable.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="T:System.Data.DataTable" /> is initialized.</summary>
        <value>
          <see langword="true" /> um anzugeben, die Komponente die Initialisierung abgeschlossen; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt den Status der <xref:System.Data.DataTable> während der Erstellung, für die Instanz von Visual Studio. Die <xref:System.Data.DataTable.BeginInit%2A> Methode wird auf `false` und <xref:System.Data.DataTable.EndInit%2A> Methode wird auf `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />. If the <see langword="DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Load` Methode kann verwendet werden, in mehrere allgemeine Szenarien, darum Abrufen von Daten aus einer bestimmten Datenquelle und den aktuellen Datencontainer hinzugefügt (in diesem Fall eine `DataTable`). Diese Szenarien beschreiben Standardverfahren für die eine `DataTable`, beschreiben Sie das Update und merge-Verhalten.  
  
 Ein `DataTable` anhand einer einzigen primären Datenquelle synchronisiert oder aktualisiert. Die `DataTable` verfolgt Änderungen, sodass die Synchronisierung mit der primären Datenquelle. Darüber hinaus eine `DataTable` inkrementelle Daten aus einem oder mehreren sekundären Datenquellen akzeptieren können. Die `DataTable` ist nicht verantwortlich für das Nachverfolgen von Änderungen um Synchronisierung mit der sekundären Datenquelle zu ermöglichen.  
  
 Wenn Sie diese beiden hypothetischen Datenquellen, ist ein Benutzer voraussichtlich benötigt eine der folgenden Verhaltensweisen:  
  
-   Initialisieren `DataTable` aus einer primären Datenquelle. In diesem Szenario wird der Benutzer ein leeres initialisieren möchte `DataTable` mit Werten aus der primären Datenquelle. Der Benutzer möchte später Weitergeben von Änderungen an der primären Datenquelle.  
  
-   Änderungen beibehalten und erneut über die primäre Datenquelle synchronisieren. In diesem Szenario möchte der Benutzer wird die `DataTable` im vorherigen Szenario gefüllt, und führen Sie eine inkrementelle Synchronisierung mit der primären Datenquelle beibehalten der Änderungen der `DataTable`.  
  
-   Inkrementelle Datenfeed aus sekundären Datenquellen. In diesem Szenario möchten die Benutzer zum Zusammenführen von Änderungen aus einem oder mehreren sekundären Datenquellen und zurück an die primäre Datenquelle weitergeben.  
  
 Die `Load` Methode ermöglicht all diesen Szenarien. Alle außer einer der Überladungen dieser Methode Sie einen Auslastungstest Optionsparameter angeben, kann die Verarbeitung, der angibt, wie Zeilen bereits in einer <xref:System.Data.DataTable> mit geladenen Zeilen kombiniert werden. (Die Überladung, die Sie zum Festlegen des Verhaltens ermöglichen keine verwendet die Standardoption für die Auslastung.) Die folgende Tabelle beschreibt die drei Ladeoptionen gebotenen der <xref:System.Data.LoadOption> Enumeration. In jedem Fall gibt die Beschreibung des Verhaltens, wenn der Primärschlüssel einer Zeile in den empfangenen Daten den Primärschlüssel einer vorhandenen Zeile übereinstimmt.  
  
|Laden Sie die Option|Beschreibung|  
|-----------------|-----------------|  
|`PreserveChanges` (Standardwert)|Aktualisiert die ursprüngliche Version der Zeile mit dem Wert der hinzukommenden Zeile an.|  
|`OverwriteChanges`|Die aktuellen und ursprüngliche Version der Zeile aktualisiert mit dem Wert der hinzukommenden Zeile.|  
|`Upsert`|Aktualisiert die aktuelle Version der Zeile mit dem Wert der hinzukommenden Zeile an.|  
  
 Im Allgemeinen die `PreserveChanges` und `OverwriteChanges` Optionen dienen für Szenarien, in denen der Benutzer synchronisieren muss, die `DataSet` und die Änderungen mit der primären Datenquelle. Die `Upsert` Option erleichtert das Aggregieren Änderungen aus einem oder mehreren sekundären Datenquellen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einige der Probleme, die beim Aufruf der <xref:System.Data.DataTable.Load%2A> Methode. Im Beispiel zunächst schwerpunktmäßig schemaprobleme, einschließlich Ableiten eines Schemas aus dem geladenen <xref:System.Data.IDataReader>, und klicken Sie dann zur Behandlung von inkompatible Schemas und Schemas mit fehlenden oder zusätzliche Spalten. Im Beispiel wird schwerpunktmäßig dann Datenprobleme, einschließlich der Handhabung der verschiedenen Optionen für das Laden.  
  
> [!NOTE]
>  In diesem Beispiel wird gezeigt, wie mit einer der überladenen Versionen der `Load`. Weitere Beispiele für die Verfügbarkeit, finden Sie unter den einzelnen Überladung-Themen.  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader -&gt; unit" Usage="dataTable.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">An <see cref="T:System.Data.IDataReader" /> that provides a result set.</param>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />. If the <see cref="T:System.Data.DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.Load%2A> Methode nutzt das erste Resultset aus dem geladenen <xref:System.Data.IDataReader>, und legt Sie die Position des Readers nach dem erfolgreichen Abschluss des Vorgangs auf das nächste Resultset, falls vorhanden. Beim Konvertieren von Daten, die `Load` Methode verwendet die gleichen Konvertierungsregeln als die <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Data.DataTable.Load%2A> Methode muss berücksichtigt drei bestimmte Probleme beim Laden der Daten aus einer <xref:System.Data.IDataReader> Instanz: Schema, Daten und Ereignisvorgänge. Bei der Arbeit mit dem Schema der <xref:System.Data.DataTable.Load%2A> Methode kann Bedingungen auftreten, wie in der folgenden Tabelle beschrieben. Die Schemavorgänge stattfinden für alle importierten Resultsets, auch solche, die keine Daten enthält.  
  
|Bedingung|Verhalten|  
|---------------|--------------|  
|Die <xref:System.Data.DataTable> verfügt über kein Schema.|Die <xref:System.Data.DataTable.Load%2A> -Methode leitet das Schema basierend auf das Resultset aus dem importierten <xref:System.Data.IDataReader>.|  
|Die <xref:System.Data.DataTable> ein Schema aufweist, aber es ist nicht kompatibel mit dem Schema geladen.|Die <xref:System.Data.DataTable.Load%2A> Methode löst eine Ausnahme, die bestimmte Fehler, der auftritt, beim Laden von Daten in das inkompatible Schema entspricht.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält, Spalten, die in nicht vorhanden sind die <xref:System.Data.DataTable>.|Die <xref:System.Data.DataTable.Load%2A> Methode fügt die zusätzlichen Spalten `DataTable`des Schemas. Die Methode löst eine Ausnahme aus, wenn die entsprechenden Spalten in der <xref:System.Data.DataTable> Resultset geladen sind und nicht kompatiblen Wert. Die Methode ruft auch Einschränkungsinformationen aus dem Resultset für alle hinzugefügten Spalten ab. Außer bei Primary Key-Einschränkung, diese Einschränkungsinformationen wird nur verwendet, wenn die aktuelle <xref:System.Data.DataTable> enthält keine Spalten zu Beginn des Ladevorgangs ausführt.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält weniger Spalten als die `DataTable`.|Wenn eine fehlende Spalte einen Standardwert definiert oder der Datentyp der Spalte NULL-Werte zulässt, ist die <xref:System.Data.DataTable.Load%2A> Methode ermöglicht die Zeilen hinzugefügt werden, ersetzen die Standardeinstellung oder `null` Wert für die Spalte fehlt. Wenn kein Standardwert oder `null` verwendet werden können, und klicken Sie dann die `Load` Methode löst eine Ausnahme aus. Wenn kein bestimmter Standardwert angegeben wurde, die `Load` -Methode verwendet die `null` Wert als der implizite Standardwert.|  
  
 Anzusehen das Verhalten von der `Load` Methode in Bezug auf Datenvorgänge, berücksichtigen, die jede Zeile innerhalb einer <xref:System.Data.DataTable> behält den aktuellen Wert und der ursprüngliche Wert für jede Spalte. Diese Werte können identisch sein, oder möglicherweise anders, wenn die Daten in die Zeile seit füllen geändert wurde die `DataTable`.  Weitere Informationen finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Diese Version von den `Load` Methode versucht, die aktuellen Werten in jeder Zeile wird den ursprünglichen Wert unverändert beibehalten. (Sie ggf. eine genauere Steuerung des Verhaltens der eingehenden Daten finden Sie unter <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) Wenn die vorhandene Zeile und die empfangene Zeile entsprechende primäre Schlüsselwerte enthalten, die Zeile mit den aktuellen Wert der Zeile Status verarbeitet, andernfalls wird dies als eine neue Zeile behandelt.  
  
 In Bezug auf Ereignisvorgänge die <xref:System.Data.DataTable.RowChanging> Ereignis tritt auf, bevor jede Zeile geändert wird, und die <xref:System.Data.DataTable.RowChanged> Ereignis tritt auf, nachdem jede Zeile geändert wurde. In jedem Fall die <xref:System.Data.DataRowChangeEventArgs.Action%2A> Eigenschaft von der <xref:System.Data.DataRowChangeEventArgs> an den Ereignishandler übergebene Instanz enthält Informationen über die jeweilige Aktion, die dem Ereignis zugeordnet. Dieser Wert hängt von den Zustand der Zeile vor der Ladevorgang ab. In jedem Fall beide Ereignisse auftreten, und die Aktion ist für beide identisch. Die Aktion kann auf die aktuelle oder die ursprüngliche Version jeder Zeile oder beides, abhängig von den aktuellen Zeilenzustand angewendet werden.  
  
 In der folgenden Tabelle wird das Verhalten für die `Load` Methode. Die letzte Zeile (mit der Bezeichnung "(nicht vorhanden)") beschreibt das Verhalten für eingehende Zeilen, die keiner vorhandene Zeile nicht übereinstimmen. Jede Zelle in dieser Tabelle beschreibt die aktuellen und ursprünglichen Wert für ein Feld innerhalb einer Zeile zusammen mit den <xref:System.Data.DataRowState> für den Wert nach der `Load` -Methode abgeschlossen wurde. In diesem Fall die Methode lässt nicht den Load-Option anzugeben, und die standardmäßige `PreserveChanges`.  
  
|Vorhandene DataRowState|Werte, nach dem `Load` -Methode und Ereignisaktion|  
|---------------------------|--------------------------------------------------|  
|Hinzugefügt|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
|Modified|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
|Deleted|Aktuelle = \<nicht verfügbar ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<gelöscht ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
|(Nicht vorhanden)|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Werte in einer <xref:System.Data.DataColumn> kann durch Verwendung von Eigenschaften, eingeschränkt werden, z. B. <xref:System.Data.DataColumn.ReadOnly%2A> und <xref:System.Data.DataColumn.AutoIncrement%2A>. Die `Load` -Methode behandelt solche Spalten in einer Weise, die konsistent mit dem Verhalten, indem Sie die Eigenschaften der Spalte definiert ist. Die schreibgeschützte nur Einschränkung für eine <xref:System.Data.DataColumn> gilt nur für Änderungen, die im Arbeitsspeicher auftreten. Die `Load` Methode überschreibt die schreibgeschützte Spaltenwerte bei Bedarf.  
  
 Bestimmen, welche Version des primären Schlüsselfelds zum Vergleichen von der aktuellen Zeile mit einer eingehenden Zeile, die `Load` Methode verwendet die ursprüngliche Version des primären Schlüsselwert innerhalb einer Zeile aus, falls vorhanden. Andernfalls die `Load` Methode verwendet die aktuelle Version des Feld für den Primärschlüssel.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einige der Probleme, die beim Aufruf der <xref:System.Data.DataTable.Load%2A> Methode. Im Beispiel zunächst schwerpunktmäßig schemaprobleme, einschließlich Ableiten eines Schemas aus dem geladenen <xref:System.Data.IDataReader>, und klicken Sie dann zur Behandlung von inkompatible Schemas und Schemas mit fehlenden oder zusätzliche Spalten. Das Beispiel ruft dann die `Load` -Methode, Anzeigen der Daten vor und nach dem Ladevorgang.  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption -&gt; unit" Usage="dataTable.Load (reader, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">An <see cref="T:System.Data.IDataReader" /> that provides one or more result sets.</param>
        <param name="loadOption">A value from the <see cref="T:System.Data.LoadOption" /> enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" /> are combined with incoming rows that share the same primary key.</param>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" />. If the <see langword="DataTable" /> already contains rows, the incoming data from the data source is merged with the existing rows according to the value of the <paramref name="loadOption" /> parameter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Load` Methode nutzt das erste Resultset aus dem geladenen <xref:System.Data.IDataReader>, und legt Sie die Position des Readers nach dem erfolgreichen Abschluss des Vorgangs auf das nächste Resultset, falls vorhanden. Beim Konvertieren von Daten, die `Load` Methode verwendet die gleichen Konvertierungsregeln als die <xref:System.Data.Common.DbDataAdapter.Fill%2A> Methode.  
  
 Die `Load` Methode muss berücksichtigt drei bestimmte Probleme beim Laden der Daten aus einer <xref:System.Data.IDataReader> Instanz: Schema, Daten und Ereignisvorgänge. Bei der Arbeit mit dem Schema der `Load` Methode kann Bedingungen auftreten, wie in der folgenden Tabelle beschrieben. Die Schemavorgänge stattfinden für alle importierten Resultsets, auch solche, die keine Daten enthält.  
  
|Bedingung|Verhalten|  
|---------------|--------------|  
|Die <xref:System.Data.DataTable> verfügt über kein Schema.|Die `Load` -Methode leitet das Schema basierend auf das Resultset aus dem importierten <xref:System.Data.IDataReader>.|  
|Die <xref:System.Data.DataTable> ein Schema aufweist, aber es ist nicht kompatibel mit dem Schema geladen.|Die `Load` Methode löst eine Ausnahme, die bestimmte Fehler, der auftritt, beim Laden von Daten in das inkompatible Schema entspricht.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält, Spalten, die in nicht vorhanden waren die `DataTable`.|Die `Load` Methode fügt die zusätzlichen Spalten `DataTable`des Schemas. Die Methode löst eine Ausnahme aus, wenn die entsprechenden Spalten in der <xref:System.Data.DataTable> Resultset geladen sind und nicht kompatiblen Wert. Die Methode ruft auch Einschränkungsinformationen aus dem Resultset für alle hinzugefügten Spalten ab. Außer bei Primary Key-Einschränkung, diese Einschränkungsinformationen wird nur verwendet, wenn die aktuelle <xref:System.Data.DataTable> enthält keine Spalten zu Beginn des Ladevorgangs ausführt.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält weniger Spalten als die `DataTable`.|Wenn eine fehlende Spalte einen Standardwert definiert oder der Datentyp der Spalte NULL-Werte zulässt, ist die `Load` Methode ermöglicht die Zeilen hinzugefügt werden, ersetzen den Default und Null-Wert für die fehlende Spalte. Wenn kein Standardwert oder Null verwendet werden kann, und klicken Sie dann die `Load` Methode löst eine Ausnahme aus. Wenn kein bestimmter Standardwert angegeben wurde, die `Load` Methode wird den null-Wert als der implizite Standardwert verwendet.|  
  
 Anzusehen das Verhalten von der `Load` Methode in Bezug auf Datenvorgänge, berücksichtigen, die jede Zeile innerhalb einer <xref:System.Data.DataTable> behält den aktuellen Wert und der ursprüngliche Wert für jede Spalte. Diese Werte können identisch sein, oder möglicherweise anders, wenn die Daten in die Zeile seit füllen geändert wurde die `DataTable`. Finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) für Weitere Informationen.  
  
 In diesem Methodenaufruf, der dem angegebenen <xref:System.Data.LoadOption> Parameter wirkt sich auf die Verarbeitung der eingehenden Daten. Behandelt die Load-Methode sollte wie Laden von Zeilen, die den gleiche Primärschlüssel wie vorhandene Zeilen haben? Sollte es aktuelle Werte, die ursprünglichen Werte oder beides ändern? Diese Probleme und vieles mehr, hängen von der `loadOption` Parameter.  
  
 Wenn die vorhandene Zeile und die empfangene Zeile entsprechende primäre Schlüsselwerte enthalten, die Zeile mit den aktuellen Wert der Zeile Status verarbeitet, andernfalls wird dies als eine neue Zeile behandelt.  
  
 In Bezug auf Ereignisvorgänge die <xref:System.Data.DataTable.RowChanging> Ereignis tritt auf, bevor jede Zeile geändert wird, und die <xref:System.Data.DataTable.RowChanged> Ereignis tritt auf, nachdem jede Zeile geändert wurde. In jedem Fall die <xref:System.Data.DataRowChangeEventArgs.Action%2A> Eigenschaft von der <xref:System.Data.DataRowChangeEventArgs> an den Ereignishandler übergebene Instanz enthält Informationen über die jeweilige Aktion, die dem Ereignis zugeordnet. Dieser Wert hängt vom Status der Zeile vor der Ladevorgang. In jedem Fall beide Ereignisse auftreten, und die Aktion ist für beide identisch. Die Aktion kann auf die aktuelle oder die ursprüngliche Version jeder Zeile oder beides, abhängig von den aktuellen Zeilenzustand angewendet werden.  
  
 In der folgenden Tabelle wird das Verhalten für die Load-Methode, die bei einem Aufruf mit einzelnen der `LoadOption` Werte und zeigt außerdem, wie die Werte mit dem Zeilenstatus für die zu ladenden Zeile interagieren. Die letzte Zeile (mit der Bezeichnung "(nicht vorhanden)") beschreibt das Verhalten für eingehende Zeilen, die keiner vorhandene Zeile nicht übereinstimmen. Jede Zelle in dieser Tabelle beschreibt die aktuellen und ursprünglichen Wert für ein Feld innerhalb einer Zeile zusammen mit den <xref:System.Data.DataRowState> für den Wert nach der `Load` -Methode abgeschlossen wurde.  
  
|Vorhandene DataRowState|Upsert|OverwriteChanges|PreserveChanges (Standardverhalten)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Hinzugefügt|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = -\<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
|Modified|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
eleted|(Last ist nicht auf Zeilen auswirken, die gelöscht)<br /><br /> Aktuelle =---<br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<gelöscht ><br /><br /> (Neue Zeile wird mit den folgenden Merkmalen hinzugefügt)<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Löschvorgang rückgängig zu machen und<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<nicht verfügbar ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<gelöscht ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Wenn der neue Wert ist identisch mit den vorhandenen Wert dann<br /><br /> Status = \<unverändert ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> Status = \<geändert ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Nicht vorhanden)|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Werte in einer <xref:System.Data.DataColumn> kann durch Verwendung von Eigenschaften, eingeschränkt werden, z. B. <xref:System.Data.DataColumn.ReadOnly%2A> und <xref:System.Data.DataColumn.AutoIncrement%2A>. Die `Load` -Methode behandelt solche Spalten in einer Weise, die konsistent mit dem Verhalten, indem Sie die Eigenschaften der Spalte definiert ist. Die schreibgeschützte nur Einschränkung für eine <xref:System.Data.DataColumn> gilt nur für Änderungen, die im Arbeitsspeicher auftreten. Die `Load` Methode überschreibt die schreibgeschützte Spaltenwerte bei Bedarf.  
  
 Wenn Sie die Optionen OverwriteChanges oder PreserveChanges, beim Aufrufen angeben der `Load` -Methode, und klicken Sie dann auf der Annahme besteht, dass die eingehenden Daten stammen die `DataTable`des primäre Datenquelle und der DataTable Änderungen nachverfolgt und weitergeben können die Änderungen werden wieder an die Datenquelle. Wenn Sie die Upsert-Option auswählen, wird davon ausgegangen, dass die Daten aus einer sekundären Datenquelle, z. B. Daten von einer Komponente der mittleren Ebene stammen, z. B. von einem Benutzer geändert. In diesem Fall wird von die Annahme, dass die Absicht zum Aggregieren von Daten aus einem oder mehreren Datenquellen in ist die `DataTable`, und klicken Sie dann möglicherweise die Daten zurück in die primäre Datenquelle übertragen. Die <xref:System.Data.LoadOption> Parameter wird verwendet, um zu bestimmen die spezifische Version der Zeile, die für den primären Schlüssel Vergleich verwendet werden soll. In der folgenden Tabelle enthält die Details an.  
  
|Laden Sie die option|DataRow-Version, die für den primären Schlüssel Vergleich|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Originalversion, falls vorhanden, andernfalls die aktuelle version|  
|`PreserveChanges`|Originalversion, falls vorhanden, andernfalls die aktuelle version|  
|`Upsert`|Aktuelle Version, falls vorhanden, andernfalls die ursprüngliche version|  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einige der Probleme, die beim Aufruf der <xref:System.Data.DataTable.Load%2A> Methode. Im Beispiel zunächst schwerpunktmäßig schemaprobleme, einschließlich Ableiten eines Schemas aus dem geladenen <xref:System.Data.IDataReader>, und klicken Sie dann zur Behandlung von inkompatible Schemas und Schemas mit fehlenden oder zusätzliche Spalten. Im Beispiel wird schwerpunktmäßig dann Datenprobleme, einschließlich der Handhabung der verschiedenen Optionen für das Laden.  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit" Usage="dataTable.Load (reader, loadOption, errorHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Data.IDataReader" /> that provides a result set.</param>
        <param name="loadOption">A value from the <see cref="T:System.Data.LoadOption" /> enumeration that indicates how rows already in the <see cref="T:System.Data.DataTable" /> are combined with incoming rows that share the same primary key.</param>
        <param name="errorHandler">A <see cref="T:System.Data.FillErrorEventHandler" /> delegate to call when an error occurs while loading data.</param>
        <summary>Fills a <see cref="T:System.Data.DataTable" /> with values from a data source using the supplied <see cref="T:System.Data.IDataReader" /> using an error-handling delegate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Load` Methode nutzt das erste Resultset aus dem geladenen <xref:System.Data.IDataReader>, und legt Sie die Position des Readers nach dem erfolgreichen Abschluss des Vorgangs auf das nächste Resultset, falls vorhanden. Beim Konvertieren von Daten, die `Load` Methode verwendet die gleichen Konvertierungsregeln als die <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> Methode.  
  
 Die `Load` Methode muss berücksichtigt drei bestimmte Probleme beim Laden der Daten aus einer <xref:System.Data.IDataReader> Instanz: Schema, Daten und Ereignisvorgänge. Bei der Arbeit mit dem Schema der `Load` Methode kann Bedingungen auftreten, wie in der folgenden Tabelle beschrieben. Die Schemavorgänge stattfinden für alle importierten Resultsets, auch solche, die keine Daten enthält.  
  
|Bedingung|Verhalten|  
|---------------|--------------|  
|Die <xref:System.Data.DataTable> verfügt über kein Schema.|Die `Load` -Methode leitet das Schema basierend auf das Resultset aus dem importierten <xref:System.Data.IDataReader>.|  
|Die <xref:System.Data.DataTable> ein Schema aufweist, aber es ist nicht kompatibel mit dem Schema geladen.|Die `Load` Methode löst eine Ausnahme, die bestimmte Fehler, der auftritt, beim Laden von Daten in das inkompatible Schema entspricht.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält, Spalten, die in nicht vorhanden waren die `DataTable`.|Die `Load` Methode fügt die zusätzlichen Spalten zu `DataTable`des Schemas. Die Methode löst eine Ausnahme aus, wenn die entsprechenden Spalten in der <xref:System.Data.DataTable> Resultset geladen sind und nicht kompatiblen Wert. Die Methode ruft auch Einschränkungsinformationen aus dem Resultset für alle hinzugefügten Spalten ab. Außer bei Primary Key-Einschränkung, diese Einschränkungsinformationen wird nur verwendet, wenn die aktuelle <xref:System.Data.DataTable> enthält keine Spalten zu Beginn des Ladevorgangs ausführt.|  
|Die Schemas sind kompatibel, aber das geladene ResultSetSchema enthält weniger Spalten als die `DataTable`.|Wenn eine fehlende Spalte einen Standardwert definiert oder der Datentyp der Spalte NULL-Werte zulässt, ist die `Load` Methode ermöglicht die Zeilen hinzugefügt werden, ersetzen den Default und Null-Wert für die fehlende Spalte. Wenn kein Standardwert oder Null verwendet werden kann, und klicken Sie dann die `Load` Methode löst eine Ausnahme aus. Wenn kein bestimmter Standardwert angegeben wurde, die `Load` Methode wird den null-Wert als der implizite Standardwert verwendet.|  
  
 Anzusehen das Verhalten von der `Load` Methode in Bezug auf Datenvorgänge, berücksichtigen, die jede Zeile innerhalb einer <xref:System.Data.DataTable> behält den aktuellen Wert und der ursprüngliche Wert für jede Spalte. Diese Werte können identisch sein, oder möglicherweise anders, wenn die Daten in die Zeile seit füllen geändert wurde die `DataTable`. Finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) für Weitere Informationen.  
  
 In diesem Methodenaufruf, der dem angegebenen <xref:System.Data.LoadOption> Parameter wirkt sich auf die Verarbeitung der eingehenden Daten. Behandelt die Load-Methode sollte wie Laden von Zeilen, die den gleiche Primärschlüssel wie vorhandene Zeilen haben? Sollte es aktuelle Werte, die ursprünglichen Werte oder beides ändern? Diese Probleme und vieles mehr, hängen von der `loadOption` Parameter.  
  
 Wenn die vorhandene Zeile und die empfangene Zeile entsprechende primäre Schlüsselwerte enthalten, die Zeile mit den aktuellen Wert der Zeile Status verarbeitet, andernfalls wird dies als eine neue Zeile behandelt.  
  
 In Bezug auf Ereignisvorgänge die <xref:System.Data.DataTable.RowChanging> Ereignis tritt auf, bevor jede Zeile geändert wird, und die <xref:System.Data.DataTable.RowChanged> Ereignis tritt auf, nachdem jede Zeile geändert wurde. In jedem Fall die <xref:System.Data.DataRowChangeEventArgs.Action%2A> Eigenschaft von der <xref:System.Data.DataRowChangeEventArgs> an den Ereignishandler übergebene Instanz enthält Informationen über die jeweilige Aktion, die dem Ereignis zugeordnet. Dieser Wert hängt vom Status der Zeile vor der Ladevorgang. In jedem Fall beide Ereignisse auftreten, und die Aktion ist für beide identisch. Die Aktion kann auf die aktuelle oder die ursprüngliche Version jeder Zeile oder beides, abhängig von den aktuellen Zeilenzustand angewendet werden.  
  
 In der folgenden Tabelle wird das Verhalten für die Load-Methode, die bei einem Aufruf mit einzelnen der `LoadOption` Werte und zeigt außerdem, wie die Werte mit dem Zeilenstatus für die zu ladenden Zeile interagieren. Die letzte Zeile (mit der Bezeichnung "(nicht vorhanden)") beschreibt das Verhalten für eingehende Zeilen, die keiner vorhandene Zeile nicht übereinstimmen. Jede Zelle in dieser Tabelle beschreibt die aktuellen und ursprünglichen Wert für ein Feld innerhalb einer Zeile zusammen mit den <xref:System.Data.DataRowState> für den Wert nach der `Load` -Methode abgeschlossen wurde.  
  
|Vorhandene DataRowState|Upsert|OverwriteChanges|PreserveChanges (Standardverhalten)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Hinzugefügt|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = -\<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
|Modified|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<geändert ><br /><br /> RowAction = ChangeOriginal|  
eleted|(Last ist nicht auf Zeilen auswirken, die gelöscht)<br /><br /> Aktuelle =---<br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<gelöscht ><br /><br /> (Neue Zeile wird mit den folgenden Merkmalen hinzugefügt)<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Löschvorgang rückgängig zu machen und<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<nicht verfügbar ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<gelöscht ><br /><br /> RowAction = ChangeOriginal|  
|Unchanged|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Wenn der neue Wert ist identisch mit den vorhandenen Wert dann<br /><br /> Status = \<unverändert ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> Status = \<geändert ><br /><br /> RowAction = ändern|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Nicht vorhanden)|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Werte in einer <xref:System.Data.DataColumn> kann durch Verwendung von Eigenschaften, eingeschränkt werden, z. B. <xref:System.Data.DataColumn.ReadOnly%2A> und <xref:System.Data.DataColumn.AutoIncrement%2A>. Die `Load` -Methode behandelt solche Spalten in einer Weise, die konsistent mit dem Verhalten, indem Sie die Eigenschaften der Spalte definiert ist. Die schreibgeschützte nur Einschränkung für eine <xref:System.Data.DataColumn> gilt nur für Änderungen, die im Arbeitsspeicher auftreten. Die `Load` Methode überschreibt die schreibgeschützte Spaltenwerte bei Bedarf.  
  
 Wenn Sie die Optionen OverwriteChanges oder PreserveChanges, beim Aufrufen angeben der `Load` -Methode, und klicken Sie dann auf der Annahme besteht, dass die eingehenden Daten stammen die `DataTable`des primäre Datenquelle und der DataTable Änderungen nachverfolgt und weitergeben können die Änderungen werden wieder an die Datenquelle. Wenn Sie die Upsert-Option auswählen, wird davon ausgegangen, dass die Daten aus einer sekundären Datenquelle, z. B. Daten von einer Komponente der mittleren Ebene stammen, z. B. von einem Benutzer geändert. In diesem Fall wird von die Annahme, dass die Absicht zum Aggregieren von Daten aus einem oder mehreren Datenquellen in ist die `DataTable`, und klicken Sie dann möglicherweise die Daten zurück in die primäre Datenquelle übertragen. Die <xref:System.Data.LoadOption> Parameter wird verwendet, um zu bestimmen die spezifische Version der Zeile, die für den primären Schlüssel Vergleich verwendet werden soll. In der folgenden Tabelle enthält die Details an.  
  
|Laden Sie die option|DataRow-Version, die für den primären Schlüssel Vergleich|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Originalversion, falls vorhanden, andernfalls die aktuelle version|  
|`PreserveChanges`|Originalversion, falls vorhanden, andernfalls die aktuelle version|  
|`Upsert`|Aktuelle Version, falls vorhanden, andernfalls die ursprüngliche version|  
  
 Die `errorHandler` Parameter ist ein <xref:System.Data.FillErrorEventHandler> Delegat, der auf eine Prozedur, die aufgerufen wird verweist, tritt ein Fehler beim Laden von Daten. Die <xref:System.Data.FillErrorEventArgs> an die Prozedur übergebenen Parameter enthält Eigenschaften, die Sie zum Abrufen von Informationen zu den aufgetretenen Fehler, die aktuelle Zeile der Daten zu ermöglichen und die <xref:System.Data.DataTable> gefüllt wird. Mithilfe dieses Delegatmechanismus, anstatt ein einfacher Try/Catch-Block, können Sie den Fehler ermitteln die Situation zu behandeln, und die Verarbeitung fortzusetzen bei Bedarf. Die <xref:System.Data.FillErrorEventArgs> Parameter liefert eine <xref:System.Data.FillErrorEventArgs.Continue%2A> Eigenschaft: Legen Sie diese Eigenschaft auf `true` , um anzugeben, dass Sie den Fehler behandelt haben und die Verarbeitung ansonsten fortgesetzt werden soll. Legen Sie die Eigenschaft auf `false` um anzugeben, dass die Verarbeitung angehalten werden soll. Beachten Sie das Festlegen der Eigenschaft auf `false` bewirkt, dass den Code, der das Problem, um eine Ausnahme ausgelöst.  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Finds and updates a specific row. If no matching row is found, a new row is created using the given values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * bool -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, fAcceptChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">An array of values used to create the new row.</param>
        <param name="fAcceptChanges">
          <see langword="true" /> to accept changes; otherwise <see langword="false" />.</param>
        <summary>Finds and updates a specific row. If no matching row is found, a new row is created using the given values.</summary>
        <returns>The new <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.LoadDataRow%2A> Methode nimmt ein Array von Werten und sucht übereinstimmende Werte in die Primärschlüsselspalte(n).  
  
 Wenn eine Spalte einen Standardwert verfügt, übergeben Sie einen null-Wert im Array, der Standardwert für diese Spalte festgelegt. Auf ähnliche Weise, wenn eine Spalte enthält die <xref:System.Data.DataColumn.AutoIncrement%2A> -Eigenschaft auf true festgelegt ist, übergeben einen null-Wert im Array, legen Sie den automatisch generierten Wert für die Zeile festgelegt.  
  
 Wenn die `fAcceptChanges` Parameter ist `true` oder nicht angegeben ist, werden die neuen Daten hinzugefügt und dann <xref:System.Data.DataTable.AcceptChanges%2A> wird aufgerufen, um alle Änderungen in akzeptieren die <xref:System.Data.DataTable>; Wenn das Argument ist `false`, neu hinzugefügten Zeilen werden als Einfüge- und Änderungen an vorhandene Zeilen werden als geändert markiert.  
  
 Ausnahmen können auch auftreten, während eine <xref:System.Data.DataTable.ColumnChanging> oder <xref:System.Data.DataTable.RowChanging> Ereignis. Wenn eine Ausnahme auftritt, wird die Zeile der Tabelle nicht hinzugefügt.  
  
 Verwendung <xref:System.Data.DataTable.LoadDataRow%2A> in Verbindung mit <xref:System.Data.DataTable.BeginLoadData%2A> und <xref:System.Data.DataTable.EndLoadData%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.LoadDataRow%2A> Methode versucht, eine Zeile zu finden. Wenn keine solche Zeile gefunden wird, werden die Werte verwendet, um eine neue Zeile zu erstellen.  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The array is larger than the number of columns in the table.</exception>
        <exception cref="T:System.InvalidCastException">A value doesn't match its respective column type.</exception>
        <exception cref="T:System.Data.ConstraintException">Adding the row invalidates a constraint.</exception>
        <exception cref="T:System.Data.NoNullAllowedException">Attempting to put a null in a column where <see cref="P:System.Data.DataColumn.AllowDBNull" /> is false.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * System.Data.LoadOption -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">An array of values used to create the new row.</param>
        <param name="loadOption">Used to determine how the array values are applied to the corresponding values in an existing row.</param>
        <summary>Finds and updates a specific row. If no matching row is found, a new row is created using the given values.</summary>
        <returns>The new <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.LoadDataRow%2A> Methode nimmt ein Array von Werten und sucht übereinstimmende Werte in die Primärschlüsselspalte(n).  
  
 Wenn eine Spalte einen Standardwert verfügt, übergeben Sie einen null-Wert im Array, der Standardwert für diese Spalte festgelegt. Auf ähnliche Weise, wenn eine Spalte enthält die <xref:System.Data.DataColumn.AutoIncrement%2A> -Eigenschaft auf true festgelegt ist, übergeben einen null-Wert im Array, legen Sie den automatisch generierten Wert für die Zeile festgelegt.  
  
 Der Wert, der die `loadOption` Parameter wird verwendet, um zu bestimmen, wie die Werte im Array auf eine vorhandene Zeile angewendet werden. Z. B. wenn `loadOption` festgelegt ist, um `OverwriteChanges`, die `Original` und `Current` Werte der einzelnen Spalten werden mit den Werten in der hinzukommenden Zeile ersetzt und die `RowState` -Eigenschaftensatz auf `Unchanged`.  
  
 Ausnahmen können auch auftreten, während eine <xref:System.Data.DataTable.ColumnChanging> oder <xref:System.Data.DataTable.RowChanging> Ereignis. Wenn eine Ausnahme auftritt, wird die Zeile der Tabelle nicht hinzugefügt.  
  
 Verwendung <xref:System.Data.DataTable.LoadDataRow%2A> in Verbindung mit <xref:System.Data.DataTable.BeginLoadData%2A> und <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the locale information used to compare strings within the table.</summary>
        <value>Ein <see cref="T:System.Globalization.CultureInfo" /> , das Daten über die Computergebietsschema des Benutzers enthält. Die Standardeinstellung ist die <see cref="T:System.Data.DataSet" /> des Objekts <see cref="T:System.Globalization.CultureInfo" /> (zurückgegebenes der <see cref="P:System.Data.DataSet.Locale" /> Eigenschaft), der die <see cref="T:System.Data.DataTable" /> gehört; Wenn die Tabelle nicht angehört, eine <see cref="T:System.Data.DataSet" />, der Standardwert ist das aktuelle System <see cref="T:System.Globalization.CultureInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Globalization.CultureInfo> stellt die Einstellungen für die Software von einer bestimmten Kultur oder der Community.  
  
 Wenn Sie für Zeichenfolgenvergleiche verwendet die <xref:System.Globalization.CultureInfo> wirkt sich auf vergleichen, Sortieren und filtern.  
  
> [!NOTE]
>  In Spalten, Ausdrücke, enthalten, die <xref:System.StringComparison.InvariantCulture> verwendet wird. Die <xref:System.StringComparison.CurrentCulture> wird ignoriert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Globalization.CultureInfo> über die <xref:System.Data.DataTable.Locale%2A> und gibt den Namen der ISO-Sprache.  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Merge` Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataTable>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Der Zusammenführungsvorgang berücksichtigt nur die ursprüngliche Tabelle, und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung veranschaulicht das Verhalten von der `missingSchemaAction` Parameter von der <xref:System.Data.DataTable.Merge%2A> Methode. Dieses Beispiel erstellt zwei Versionen der gleichen Tabelle aus, ändern das Schema für die zweite Version. Der Code versucht, die zweite Tabelle mit dem ersten zusammengeführt.  
  
> [!NOTE]
>  Dieses Beispiel zeigt, wie mit einer der überladenen Versionen der Zusammenführung. Weitere Beispiele für die Verfügbarkeit, finden Sie unter den einzelnen Überladung-Themen.  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataTable.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">The <see cref="T:System.Data.DataTable" /> to be merged with the current <see cref="T:System.Data.DataTable" />.</param>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Merge-Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataTable>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Der Zusammenführungsvorgang berücksichtigt nur die ursprüngliche Tabelle, und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
 Die `Merge` Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataTable>.  
  
 Bei der Ausführung einer Zusammenführung werden Änderungen an die vorhandenen Daten vor der Zusammenführung während der Merge-Vorgang standardmäßig beibehalten. Entwickler können dieses Verhalten ändern, indem Sie eine der anderen zwei Überladungen für diese Methode aufrufen und Angeben von einen false-Wert für die `preserveChanges` Parameter.  
  
 In einer Clientanwendung ist es üblich, haben ein einzelnes Optionsfeld an, dem der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene. In diesem Szenario die <xref:System.Data.DataTable.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataTable> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataTable> Objekt enthält nur die <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataTable>. Diese Teilmenge wird in der Regel kleiner und somit effizienter an eine Komponente der mittleren Ebene zurückgegeben. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataTable> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataTable> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataTable> mit der <xref:System.Data.DataTable.Merge%2A> Methode.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataTable> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted`, zum von Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen wird. Zeilen mit Quelle ein <xref:System.Data.DataRowState> Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine einfache <xref:System.Data.DataTable> und die Tabelle Daten hinzugefügt. Das Beispiel erstellt dann eine Kopie der Tabelle, die Kopie Zeilen hinzugefügt. Zum Schluss das Beispiel ruft die <xref:System.Data.DataTable.Merge%2A> Methode, um die Daten in der zweiten Tabelle mit den Daten in der ersten Tabelle zusammenzuführen.  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool -&gt; unit" Usage="dataTable.Merge (table, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">The <see langword="DataTable" /> to be merged with the current <see langword="DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, to preserve changes in the current <see langword="DataTable" />; otherwise <see langword="false" />.<see langword="" /></param>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see langword="DataTable" />, indicating whether to preserve changes in the current <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Merge-Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataTable>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Der Zusammenführungsvorgang berücksichtigt nur die ursprüngliche Tabelle, und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
 Die `Merge` Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataTable>.  
  
 Bei der Ausführung einer Zusammenführung werden Änderungen an die vorhandenen Daten vor der Zusammenführung während der Zusammenführung beibehalten, es sei denn, der Entwickler "false" für gibt die `preserveChanges` Parameter. Wenn die `preserveChanges` Parametersatz auf `true`, empfangenen Werten nicht vorhandene Werte in der aktuellen-Zeilenversion der vorhandenen Zeile überschrieben. Wenn die `preserveChanges` Parametersatz auf `false`, empfangenen Werten werden die vorhandenen Werte in der aktuellen-Zeilenversion der vorhandenen Zeile überschrieben. Weitere Informationen zu Zeilenversionen finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 In einer Clientanwendung ist es üblich, haben ein einzelnes Optionsfeld an, dem der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene. In diesem Szenario die <xref:System.Data.DataTable.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataTable> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataTable> Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataTable>. Diese Teilmenge wird in der Regel kleiner und wird daher effizienter an eine Komponente der mittleren Ebene zurückgegeben. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataTable> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataTable> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataTable> mit der <xref:System.Data.DataTable.Merge%2A> Methode.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataTable> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen werden. Zeilen mit Quelle ein <xref:System.Data.DataRowState> Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine <xref:System.Data.DataTable> mit Zeilen, einige der Daten in diesen Zeilen ändert und versucht, Daten aus einer anderen zusammengeführt <xref:System.Data.DataTable>. Im Beispiel wird veranschaulicht, die unterschiedliche Verhaltensweisen für die `preserveChanges` Parameter.  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataTable.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">The <see cref="T:System.Data.DataTable" /> to be merged with the current <see cref="T:System.Data.DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, to preserve changes in the current <see cref="T:System.Data.DataTable" />; otherwise <see langword="false" />.</param>
        <param name="missingSchemaAction">One of the <see cref="T:System.Data.MissingSchemaAction" /> values.</param>
        <summary>Merge the specified <see cref="T:System.Data.DataTable" /> with the current <see langword="DataTable" />, indicating whether to preserve changes and how to handle missing schema in the current <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Merge` Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataTable>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Der Zusammenführungsvorgang berücksichtigt nur die ursprüngliche Tabelle, und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
 Die `Merge` Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataTable>.  
  
 Bei der Ausführung einer Zusammenführung werden Änderungen an die vorhandenen Daten vor der Zusammenführung während der Zusammenführung beibehalten, es sei denn, der Entwickler "false" für gibt die `preserveChanges` Parameter. Wenn die `preserveChanges` Parametersatz auf `true`, empfangenen Werten nicht vorhandene Werte in der aktuellen-Zeilenversion der vorhandenen Zeile überschrieben. Wenn die `preserveChanges` Parametersatz auf `false`, empfangenen Werten werden die vorhandenen Werte in der aktuellen-Zeilenversion der vorhandenen Zeile überschrieben. Weitere Informationen zu Zeilenversionen finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 In einer Clientanwendung ist es üblich, haben ein einzelnes Optionsfeld an, dem der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene. In diesem Szenario die <xref:System.Data.DataTable.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataTable> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataTable> Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataTable>. Diese Teilmenge wird in der Regel kleiner und wird daher effizienter an eine Komponente der mittleren Ebene zurückgegeben. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataTable> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataTable> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataTable> mit der <xref:System.Data.DataTable.Merge%2A> Methode.  
  
 Wenn die <xref:System.Data.DataTable.Merge%2A> -Methode aufgerufen wird, werden die Schemas der beiden <xref:System.Data.DataTable> Objekte verglichen werden, da es möglich ist, dass die Schemas möglicherweise geändert wurden. Z. B. in einem Business-to-Business-Szenario wurden neue Spalten möglicherweise auf ein XML-Schema durch einen automatisierten Prozess hinzugefügt haben. Wenn die Quelle <xref:System.Data.DataTable> Schemaelemente enthält (hinzugefügt <xref:System.Data.DataColumn> Objekte), die nicht im Ziel vorhanden sind, die Elemente des Schemas können mit dem Ziel hinzugefügt werden, durch Festlegen der `missingSchemaAction` Argument `MissingSchemaAction.Add`. In diesem Fall wird das zusammengeführte <xref:System.Data.DataTable> hinzugefügte Schema und Daten enthält.  
  
 Nach dem Zusammenführen von Schemas, werden die Daten zusammengeführt.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataTable> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen werden. Zeilen mit Quelle ein <xref:System.Data.DataRowState> Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung veranschaulicht das Verhalten von der `missingSchemaAction` Parameter von der <xref:System.Data.DataTable.Merge%2A> Methode. Dieses Beispiel erstellt zwei Versionen der gleichen Tabelle aus, ändern das Schema für die zweite Version. Der Code versucht, die zweite Tabelle mit dem ersten zusammengeführt.  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumCapacity : int with get, set" Usage="System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the initial starting size for this table.</summary>
        <value>Die Ausgangsgröße in Zeilen dieser Tabelle. Der Standardwert ist 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.MinimumCapacity%2A> kann das System vor dem Abrufen der Daten einen entsprechenden Satz von Ressourcen zu erstellen. In einer Situation Wenn Leistung kritisch ist, wird kann durch Festlegen dieser Eigenschaft Leistung optimiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.MinimumCapacity%2A> von einem <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the namespace for the XML representation of the data stored in the <see cref="T:System.Data.DataTable" />.</summary>
        <value>Der Namespace von <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberSignature Language="F#" Value="member this.NewRow : unit -&gt; System.Data.DataRow" Usage="dataTable.NewRow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a new <see cref="T:System.Data.DataRow" /> with the same schema as the table.</summary>
        <returns>A <see cref="T:System.Data.DataRow" /> with the same schema as the <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Data.DataTable.NewRow%2A> Methode zum Erstellen neuer <xref:System.Data.DataRow> Objekte mit dem gleichen Schema wie die <xref:System.Data.DataTable>. Nach dem Erstellen einer <xref:System.Data.DataRow>, können Sie ihn zum Hinzufügen der <xref:System.Data.DataRowCollection>, bis die <xref:System.Data.DataTable> des Objekts <xref:System.Data.DataTable.Rows%2A> Eigenschaft. Bei Verwendung von <xref:System.Data.DataTable.NewRow%2A> um neue Zeilen zu erstellen, die Zeilen müssen hinzugefügt oder aus der Tabelle gelöscht wird, vor dem Aufruf <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable>, addiert zwei <xref:System.Data.DataColumn> Objekte bestimmen das Schema der Tabelle, und erstellt mehrere neue <xref:System.Data.DataRow> -Objekten mit den <xref:System.Data.DataTable.NewRow%2A> Methode. Die <xref:System.Data.DataRow> Objekte werden dann hinzugefügt, um die <xref:System.Data.DataRowCollection> mithilfe der <xref:System.Data.DataRowCollection.Add%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberSignature Language="F#" Value="member this.NewRowArray : int -&gt; System.Data.DataRow[]" Usage="dataTable.NewRowArray size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">A <see cref="T:System.Int32" /> value that describes the size of the array.</param>
        <summary>Returns an array of <see cref="T:System.Data.DataRow" />.</summary>
        <returns>The new array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow&#xA;override this.NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow" Usage="dataTable.NewRowFromBuilder builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">A <see cref="T:System.Data.DataRowBuilder" /> object.</param>
        <summary>Creates a new row from an existing row.</summary>
        <returns>A <see cref="T:System.Data.DataRow" /> derived class.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataColumnChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.ColumnChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataColumnChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.ColumnChanging" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataTable.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">A <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveColumn : System.Data.DataColumn -&gt; unit&#xA;override this.OnRemoveColumn : System.Data.DataColumn -&gt; unit" Usage="dataTable.OnRemoveColumn column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">The <see cref="T:System.Data.DataColumn" /> being removed.</param>
        <summary>Notifies the <see cref="T:System.Data.DataTable" /> that a <see cref="T:System.Data.DataColumn" /> is being removed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowChanged" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowChanging" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowDeleted" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.RowDeleting" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableCleared e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableClearEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.TableCleared" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst das <xref:System.Data.DataTable.TableCleared> -Ereignis, das ausgelöst wird, sofort, nachdem alle Zeilen, jedoch bevor wurden erfolgreich gelöscht wurden die <xref:System.Data.DataTable.Clear%2A> -Methode die Steuerung wieder an den Aufrufer zurückgibt.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableClearing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableClearEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.TableClearing" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst das <xref:System.Data.DataTable.TableClearing> Ereignis, das ausgelöst wird, bevor die Verarbeitung der der <xref:System.Data.DataTable.Clear%2A> -Vorgang beginnt.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit&#xA;override this.OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit" Usage="dataTable.OnTableNewRow e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableNewRowEventArgs" /> that contains the event data.</param>
        <summary>Raises the <see cref="E:System.Data.DataTable.TableNewRow" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst das <xref:System.Data.DataTable.TableNewRow> Ereignis, das ausgelöst, nachdem ein neues wird <xref:System.Data.DataRow> mit erstellt wurde <xref:System.Data.DataTable.NewRow%2A>.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of parent relations for this <see cref="T:System.Data.DataTable" />.</summary>
        <value>Ein <see cref="T:System.Data.DataRelationCollection" /> , die die übergeordneten Beziehungen für die Tabelle enthält. Eine leere Auflistung wird zurückgegeben, wenn keine <see cref="T:System.Data.DataRelation" /> Objekte vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.ParentRelations%2A> -Eigenschaft zum Zurückgeben von jedem übergeordneten Element <xref:System.Data.DataRelation> in einem <xref:System.Data.DataTable>. Jede Beziehung wird dann verwendet, als Argument in der <xref:System.Data.DataRow.GetParentRows%2A> Methode der <xref:System.Data.DataRow> ein Array von Zeilen zurückgegeben. Der Wert der einzelnen Spalten in der Zeile wird dann ausgegeben.  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the namespace for the XML representation of the data stored in the <see cref="T:System.Data.DataTable" />.</summary>
        <value>Das Präfix des der <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : System.Data.DataColumn[] with get, set" Usage="System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an array of columns that function as primary keys for the data table.</summary>
        <value>Ein Array von <see cref="T:System.Data.DataColumn" />-Objekten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Primärschlüssel einer Tabelle muss zum Identifizieren des Datensatzes in der Tabelle eindeutig sein. Es ist auch möglich, eine Tabelle mit einem Primärschlüssel setzt sich aus zwei oder mehr Spalten enthalten. Dies tritt auf, wenn eine einzelne Spalte genügend eindeutige Werte enthalten kann. Beispielsweise kann ein Primärschlüssel zweispaltigen einer Spalte "FirstName" und "LastName" bestehen. Da der Primärschlüssel von mehr als eine Spalte vorgenommen werden können die <xref:System.Data.DataTable.PrimaryKey%2A> Eigenschaft besteht aus einem Array von <xref:System.Data.DataColumn> Objekte.  
  
   
  
## Examples  
 Im erste Beispiel wird gezeigt, wie die Primärschlüsselspalten für die zurückzugebenden eine <xref:System.Data.DataTable> angezeigt, die einem `DataGrid`. Im zweite Beispiel veranschaulicht das Festlegen der Primärschlüsselspalten für eine <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">The key is a foreign key.</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument während der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema. Verwenden Sie zum Lesen von Daten und Schema eine der der `ReadXML` Überladungen, die die `XmlReadMode` Parameter, und legen Sie dessen Wert auf `ReadSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">An object that derives from <see cref="T:System.IO.Stream" /></param>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.Stream" />.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine untergeordneten Objekte werden geladen, mit den Daten aus dem angegebenen <xref:System.IO.Stream>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument während der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schema und Daten in einen Speicherstream, durch den Aufruf der <xref:System.Data.DataTable.WriteXml%2A> Methode. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.IO.TextReader" /> that will be used to read the data.</param>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextReader" />.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine untergeordneten Objekte werden geladen, mit den Daten aus dem angegebenen <xref:System.IO.TextReader>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument während der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schema und Daten in einen Speicherstream, durch den Aufruf der <xref:System.Data.DataTable.WriteXml%2A> Methode. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file from which to read the data.</param>
        <summary>Reads XML schema and data into the <see cref="T:System.Data.DataTable" /> from the specified file.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine untergeordneten Objekte werden geladen, mit den Daten aus der Datei mit dem Namen in der bereitgestellten <xref:System.String>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument während der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schema und Daten auf dem Datenträger. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.Xml.XmlReader" /> that will be used to read the data.</param>
        <summary>Reads XML Schema and Data into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns>The <see cref="T:System.Data.XmlReadMode" /> used to read the data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine untergeordneten Objekte werden geladen, mit den Daten aus der Datei mit dem Namen in der bereitgestellten <xref:System.Xml.XmlReader>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataTable.ReadXml%2A> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument während der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schemas und Daten zu einem <xref:System.Xml.XmlReader>. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten füllen die <xref:System.Xml.XmlReader> Instanz.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `ReadXmlSchema` Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird gemäß dem XSD-standard interpretiert.  
  
 Die `ReadXmlSchema` Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The stream used to read the schema.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird gemäß dem XSD-standard interpretiert.  
  
 Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die `ReadXmlSchema` Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
 Verwenden Sie zum Erstellen einer geschachtelten Beziehungs mithilfe von XML-Schema implizite geschachtelte Elemente ein. Sie können auch die geschachtelte Beziehung Verwendung expliziter Spaltennamen konfigurieren. Elemente müssen implizit in der Reihenfolge für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehungs geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und schreibt das Schema für diese Tabelle zu einer <xref:System.IO.MemoryStream>. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus dem gespeicherten XML-Schema.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.IO.TextReader" /> used to read the schema information.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird gemäß dem XSD-standard interpretiert.  
  
 Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die `ReadXmlSchema` Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
 Verwenden Sie zum Erstellen einer geschachtelten Beziehungs mithilfe von XML-Schema implizite geschachtelte Elemente ein. Sie können auch die geschachtelte Beziehung Verwendung expliziter Spaltennamen neu konfigurieren. Elemente müssen implizit in der Reihenfolge für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehungs geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und schreibt das Schema für diese Tabelle zu einer <xref:System.IO.MemoryStream>. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus dem gespeicherten XML-Schema mithilfe einer <xref:System.IO.StreamReader> (geerbt von <xref:System.IO.TextReader>) als Updatequelle.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataTable.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file from which to read the schema information.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> from the specified file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird gemäß dem XSD-standard interpretiert.  
  
 Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die `ReadXmlSchema` Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der `DataTable`.  
  
 Verwenden Sie zum Erstellen einer geschachtelten Beziehungs mithilfe von XML-Schema implizite geschachtelte Elemente ein. Sie können auch die geschachtelte Beziehung Verwendung expliziter Spaltennamen neu konfigurieren. Elemente müssen implizit in der Reihenfolge für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehungs geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und das Schema für diese Tabelle in eine Datei schreibt. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus dem gespeicherten XML-Schema mithilfe der Datei als Quelle.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.Xml.XmlReader" /> used to read the schema information.</param>
        <summary>Reads an XML schema into the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird gemäß dem XSD-standard interpretiert.  
  
 Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die `ReadXmlSchema` Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Die Möglichkeit zum Erstellen einer geschachtelten Beziehungs mithilfe von XML-Schema werden implizite geschachtelter Elemente aufweisen. Darüber hinaus könnte die geschachtelte Beziehung neu konfiguriert werden, um explizite Spaltennamen sein. Es ist zwingend erforderlich, für Elemente, die implizit für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehungs geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und schreibt das Schema für diese Tabelle zu einer <xref:System.IO.MemoryStream>. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus dem gespeicherten XML-Schema mithilfe einer <xref:System.Xml.XmlTextReader> (geerbt von <xref:System.Xml.XmlReader>) als Updatequelle.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Xml.XmlReader" /> object.</param>
        <summary>Reads from an XML stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberSignature Language="F#" Value="member this.RejectChanges : unit -&gt; unit" Usage="dataTable.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rolls back all changes that have been made to the table since it was loaded, or the last time <see cref="M:System.Data.DataTable.AcceptChanges" /> was called.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Data.DataTable.RejectChanges%2A> aufgerufen wird, eine <xref:System.Data.DataRow> Objekte, die immer noch im Bearbeitungsmodus befinden Bearbeitungsvorgänge abgebrochen. Neue Zeilen werden entfernt. Zeilen mit den <xref:System.Data.DataRowState> festgelegt `Modified` oder `Deleted` wieder auf den ursprünglichen Zustand zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel werden mehrere Änderungen an einer <xref:System.Data.DataTable>, jedoch weist die Änderungen durch Aufrufen der <xref:System.Data.DataTable.RejectChanges%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the serialization format.</summary>
        <value>Ein <see cref="T:System.Data.SerializationFormat" /> -Enumeration, der entweder angibt <see langword="Binary" /> oder <see langword="Xml" /> Serialisierung.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataTable.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the <see cref="T:System.Data.DataTable" /> to its original state. Reset removes all data, indexes, relations, and columns of the table. If a DataSet includes a DataTable, the table will still be part of the DataSet after the table is reset.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberSignature Language="F#" Value="member this.RowChanged : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanged : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a <see cref="T:System.Data.DataRow" /> has been changed successfully.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberSignature Language="F#" Value="member this.RowChanging : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanging : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a <see cref="T:System.Data.DataRow" /> is changing.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberSignature Language="F#" Value="member this.RowDeleted : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleted : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a row in the table has been deleted.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberSignature Language="F#" Value="member this.RowDeleting : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleting : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs before a row in the table is about to be deleted.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Rows : System.Data.DataRowCollection" Usage="System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of rows that belong to this table.</summary>
        <value>Ein <see cref="T:System.Data.DataRowCollection" /> enthält <see cref="T:System.Data.DataRow" /> Objekte; andernfalls eine Null-Wert, wenn kein <see cref="T:System.Data.DataRow" /> Objekte vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Erstellen eines neuen <xref:System.Data.DataRow>, verwenden Sie die <xref:System.Data.DataTable.NewRow%2A> Methode, um ein neues Objekt zurückzugeben. Ein solches Objekt wird automatisch konfiguriert, gemäß dem Schema definierten für die <xref:System.Data.DataTable> durch die Auflistung der <xref:System.Data.DataColumn> Objekte. Fügen Sie nach dem Erstellen einer neuen Zeile, und Festlegen der Werte für jede Spalte in der Zeile, die Zeile an die <xref:System.Data.DataRowCollection> mithilfe der `Add` Methode.  
  
 Jede <xref:System.Data.DataRow> in der Auflistung stellt eine Datenzeile in der Tabelle. Um eine Änderung auf den Wert einer Spalte in der Zeile einen Commit auszuführen, rufen Sie die <xref:System.Data.DataTable.AcceptChanges%2A> Methode.  
  
   
  
## Examples  
 Im folgenden sehen zwei Beispiele für zurückgeben und Festlegen von Zeilen. Im ersten Beispiel wird die <xref:System.Data.DataTable.Rows%2A> Eigenschaft und die Werte der einzelnen Spalten für jede Zeile ausgegeben. Im zweiten Beispiel wird die <xref:System.Data.DataTable> des Objekts <xref:System.Data.DataTable.NewRow%2A> Methode zum Erstellen eines neuen <xref:System.Data.DataRow> Objekt mit dem Schema der <xref:System.Data.DataTable>. Nach dem Festlegen der Werte der Zeilen, die Zeile hinzugefügt wird die <xref:System.Data.DataRowCollection> über die `Add` Methode.  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets an array of <see cref="T:System.Data.DataRow" /> objects.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; System.Data.DataRow[]" Usage="dataTable.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die richtigen Sortierreihenfolge sicherzustellen möchten, geben Sie Sortierkriterien mit <xref:System.Data.DataTable.Select%2A> oder <xref:System.Data.DataTable.Select%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel gibt ein Array von <xref:System.Data.DataRow> Objekte über die <xref:System.Data.DataTable.Select%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberSignature Language="F#" Value="member this.Select : string -&gt; System.Data.DataRow[]" Usage="dataTable.Select filterExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter criteria.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Erstellen der `filterExpression` Argument verwenden, gelten, die gleichen Regeln die <xref:System.Data.DataColumn> Klasse <xref:System.Data.DataColumn.Expression%2A> Eigenschaftswert für das Erstellen von Filtern.  
  
 Um die richtigen Sortierreihenfolge sicherzustellen möchten, geben Sie Sortierkriterien mit <xref:System.Data.DataTable.Select%2A> oder <xref:System.Data.DataTable.Select%2A>.  
  
 Wenn die Spalte für den Filter einen null-Wert enthält, werden sie nicht Teil des Resultsets.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen Filterausdruck, ein Array von zurückzugebenden <xref:System.Data.DataRow> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">A string specifying the column and sort direction.</param>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter criteria, in the specified sort order.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects matching the filter expression.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Form der `filterExpression` Argument, verwenden Sie die gleichen Regeln zum Erstellen der <xref:System.Data.DataColumn> Klasse <xref:System.Data.DataColumn.Expression%2A> Eigenschaftswert. Die `Sort` Argument verwendet auch die gleichen Regeln zum Erstellen der Klasse <xref:System.Data.DataColumn.Expression%2A> Zeichenfolgen.  
  
 Wenn die Spalte für den Filter einen null-Wert enthält, werden sie nicht Teil des Resultsets.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen Filterausdruck, ein Array von zurückzugebenden <xref:System.Data.DataRow> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string * System.Data.DataViewRowState -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort, recordStates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">The criteria to use to filter the rows. For examples on how to filter rows, see [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">A string specifying the column and sort direction.</param>
        <param name="recordStates">One of the <see cref="T:System.Data.DataViewRowState" /> values.</param>
        <summary>Gets an array of all <see cref="T:System.Data.DataRow" /> objects that match the filter in the order of the sort that match the specified state.</summary>
        <returns>An array of <see cref="T:System.Data.DataRow" /> objects.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Form der `filterExpression` Argument, verwenden Sie die gleichen Regeln zum Erstellen der <xref:System.Data.DataColumn> Klasse <xref:System.Data.DataColumn.Expression%2A> Eigenschaftswert. Die `Sort` Argument verwendet auch die gleichen Regeln zum Erstellen der Klasse <xref:System.Data.DataColumn.Expression%2A> Zeichenfolgen.  
  
 Wenn die Spalte für den Filter einen null-Wert enthält, werden sie nicht Teil des Resultsets.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Ausdruck und Datensatz-Filterstatus zurückzugebenden ein Array von <xref:System.Data.DataRow> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an <see cref="T:System.ComponentModel.ISite" /> for the <see cref="T:System.Data.DataTable" />.</summary>
        <value>Ein <see cref="T:System.ComponentModel.ISite" /> für das <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites Binden einer <xref:System.ComponentModel.Component> auf eine <xref:System.ComponentModel.Container> und ermöglichen die Kommunikation zwischen diesen sowie bieten eine Möglichkeit für den Container, seine Komponenten zu verwalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Data.DataTable.System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>
          <see langword="true" /> Wenn die Auflistung eine Auflistung von <see cref="T:System.Collections.IList" /> Objekte; anderenfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataTable>-Instanz in eine <xref:System.ComponentModel.IListSource>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>For a description of this member, see <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>An <see cref="T:System.Collections.IList" /> that can be bound to a data source from the object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataTable>-Instanz in eine <xref:System.ComponentModel.IListSource>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">An XmlReader.</param>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">An XmlWriter.</param>
        <summary>For a description of this member, see <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmember-Implementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberSignature Language="F#" Value="member this.TableCleared : System.Data.DataTableClearEventHandler " Usage="member this.TableCleared : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs after a <see cref="T:System.Data.DataTable" /> is cleared.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.TableCleared> Ereignis wird ausgelöst, unmittelbar nachdem alle Zeilen, jedoch bevor wurden erfolgreich gelöscht wurden die <xref:System.Data.DataTable.Clear%2A> -Methode die Steuerung wieder an den Aufrufer zurückgibt. Die <xref:System.Data.DataTable.TableCleared> Ereignis wird nicht ausgelöst, wenn alle Ausnahmen während der Löschvorgang.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberSignature Language="F#" Value="member this.TableClearing : System.Data.DataTableClearEventHandler " Usage="member this.TableClearing : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a <see cref="T:System.Data.DataTable" /> is cleared.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.TableClearing> Ereignis wird ausgelöst, bevor die Verarbeitung der der <xref:System.Data.DataTable.Clear%2A> -Vorgang beginnt. Dieses Ereignis wird immer ausgelöst, wenn die <xref:System.Data.DataTable.Clear%2A> Methode aufgerufen wird, selbst wenn die Tabelle keine Zeilen enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the <see cref="T:System.Data.DataTable" />.</summary>
        <value>Der Name des <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.TableName%2A> wird verwendet, um diese Tabelle aus dem übergeordneten zurückgeben <xref:System.Data.DataSet> des Objekts <xref:System.Data.DataTableCollection> (zurückgegebenes der <xref:System.Data.DataSet.Tables%2A> Eigenschaft).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.TableName%2A> für jede Tabelle in einer Auflistung von <xref:System.Data.DataTable> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="null" /> or empty string ("") is passed in and this table belongs to a collection.</exception>
        <exception cref="T:System.Data.DuplicateNameException">The table belongs to a collection that already has a table with the same name. (Comparison is case-sensitive).</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberSignature Language="F#" Value="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " Usage="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a new <see cref="T:System.Data.DataRow" /> is inserted.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird ausgelöst, nachdem ein neues <xref:System.Data.DataRow> mit erstellt wurde <xref:System.Data.DataTable.NewRow%2A>. Dieses Ereignis wird ausgelöst, bevor die aufgerufene `NewRow` -Methode zurückkehrt. Die neue <xref:System.Data.DataRow> Instanz getrennt ist, wurde nicht auf die Auflistung hinzugefügt wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="dataTable.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the <see cref="P:System.Data.DataTable.TableName" /> and <see cref="P:System.Data.DataTable.DisplayExpression" />, if there is one as a concatenated string.</summary>
        <returns>A string consisting of the <see cref="P:System.Data.DataTable.TableName" /> and the <see cref="P:System.Data.DataTable.DisplayExpression" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft die <xref:System.Data.DataTable.TableName%2A> und <xref:System.Data.DataTable.DisplayExpression%2A> für die <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 Das folgende Beispiel gibt die <xref:System.Data.DataTable.TableName%2A> und <xref:System.Data.DataTable.DisplayExpression%2A> mithilfe der <xref:System.Data.DataTable.ToString%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> Instanzen, fügt Sie jedes Element eine <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXml%2A> -Methode, die Daten in der übergeordneten Tabelle, eine Schreiben<xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
> [!NOTE]
>  Dieses Beispiel zeigt, wie Sie eine der überladenen Versionen von WriteXml verwenden. Weitere Beispiele für die Verfügbarkeit, finden Sie unter den einzelnen Überladung-Themen.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write the content.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataTable.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The file to which to write the XML data.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> with which to write the contents.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXml (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.Stream" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und alle untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> to the specified file using the specified <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write the content.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.IO.TextWriter" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und alle seine untergeordneten, verwandten Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> Instanzen, fügt Sie jedes Element eine <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXml%2A> -Methode, die Daten in der übergeordneten Tabelle, eine Schreiben<xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter `true`.  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">The file to which to write the XML data.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified file. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und alle untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified file and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> with which to write the contents.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current contents of the <see cref="T:System.Data.DataTable" /> as XML using the specified <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit der `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (stream, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> to the specified file using the specified <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer `DataTable` in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die `XmlWriteMode` Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 In der Regel wird die `WriteXml` Methode speichert die Daten nur für die aktuelle Tabelle. Die `WriteXml` Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer `DataTable` in ein XML-Dokument während der `WriteXmlSchema` Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die `XmlWriteMode` Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und alle untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.IO.TextWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 In der Regel wird die `WriteXml` Methode speichert die Daten nur für die aktuelle Tabelle. Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und alle untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> Instanzen, fügt Sie jedes Element eine <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXml%2A> -Methode, die Daten in der übergeordneten Tabelle, eine Schreiben<xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to which the data will be written.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified file and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 In der Regel wird die `WriteXml` Methode speichert die Daten nur für die aktuelle Tabelle. Wenn die Daten für die aktuelle Tabelle und alle Schemas gespeichert werden soll die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und alle abhängigen verknüpften Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</param>
        <param name="mode">One of the <see cref="T:System.Data.XmlWriteMode" /> values.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the contents of the current table and all its descendants. If <see langword="false" /> (the default value), write the data for the current table only.</param>
        <summary>Writes the current data, and optionally the schema, for the <see cref="T:System.Data.DataTable" /> using the specified <see cref="T:System.Xml.XmlWriter" /> and <see cref="T:System.Data.XmlWriteMode" />. To write the schema, set the value for the <paramref name="mode" /> parameter to <see langword="WriteSchema" />. To save the data for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in ein XML-Dokument während der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die implizit enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit der `writeHierarchy` Parametersatz auf `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> Instanzen, fügt Sie jedes Element eine <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, die Daten in der übergeordneten Tabelle, eine Schreiben<xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
> [!NOTE]
>  In diesem Beispiel wird gezeigt, wie mit einer der überladenen Versionen der `WriteXmlSchema` andere Beispiele, die möglicherweise verfügbar ist, finden Sie in den einzelnen Überladung Themen.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the XML schema will be written.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataTable.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to use.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> to use.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">The stream to which the XML schema will be written.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified stream. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` Methode schreibt das Schema nur für die aktuelle Tabelle. Um das Schema für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.IO.TextWriter" /> with which to write.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.IO.TextWriter" />. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` Methode schreibt das Schema nur für die aktuelle Tabelle. Um das Schema für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> Instanzen, fügt Sie jedes Element eine <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, die Daten in der übergeordneten Tabelle, eine Schreiben<xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">The name of the file to use.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema to the specified file. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` Methode schreibt das Schema nur für die aktuelle Tabelle. Um das Schema für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> used to write the document.</param>
        <param name="writeHierarchy">If <see langword="true" />, write the schema of the current table and all its descendants. If <see langword="false" /> (the default value), write the schema for the current table only.</param>
        <summary>Writes the current data structure of the <see cref="T:System.Data.DataTable" /> as an XML schema using the specified <see cref="T:System.Xml.XmlWriter" />. To save the schema for the table and all its descendants, set the <paramref name="writeHierarchy" /> parameter to <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataTable> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` Methode schreibt das Schema nur für die aktuelle Tabelle. Um das Schema für die aktuelle Tabelle und ihre gesamten zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz auf `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>