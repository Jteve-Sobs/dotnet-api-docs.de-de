<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3c7275f8e320825365ef5f42dfaaf0363b3ae9e9" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51889110" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataTable = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Tabelle mit Daten im Arbeitsspeicher dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable> ist ein zentrale Objekt in der Bibliothek für ADO.NET. Anderen Objekten, die <xref:System.Data.DataTable> enthalten die <xref:System.Data.DataSet> und <xref:System.Data.DataView>.  
  
 Beim Zugriff auf <xref:System.Data.DataTable> Objekte, beachten Sie, dass sie bedingt Groß-/Kleinschreibung beachtet werden. Angenommen, ein <xref:System.Data.DataTable> "Mydatatable" den Namen und eine weitere "Mydatatable" benannt ist, wird in eine Zeichenfolge, die zum Suchen nach einer der Tabellen verwendet die Groß-/ Kleinschreibung. Allerdings wird Wenn "Mydatatable" vorhanden ist, und "Mydatatable", nicht aber, die zu suchende Zeichenfolge Groß-/Kleinschreibung betrachtet. Ein <xref:System.Data.DataSet> können enthalten zwei <xref:System.Data.DataTable> Objekte mit dem gleichen <xref:System.Data.DataTable.TableName%2A> Eigenschaftswert, aber unterschiedliche <xref:System.Data.DataTable.Namespace%2A> Eigenschaftswerte. Weitere Informationen zum Arbeiten mit <xref:System.Data.DataTable> anzuzeigen, [Erstellen einer "DataTable"](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Bei der Erstellung einer <xref:System.Data.DataTable> programmgesteuert, müssen Sie zuerst ihr Schema definieren, durch das Hinzufügen <xref:System.Data.DataColumn> Objekte die <xref:System.Data.DataColumnCollection> (Zugriff erfolgt über die <xref:System.Data.DataTable.Columns%2A> Eigenschaft). Weitere Informationen zum Hinzufügen von <xref:System.Data.DataColumn> Objekten finden Sie [Hinzufügen von Spalten zu einer DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md).  
  
 Zum Hinzufügen von Zeilen zu einer <xref:System.Data.DataTable>, müssen Sie zunächst mithilfe der <xref:System.Data.DataTable.NewRow%2A> Methode, um ein neues zurückzugeben <xref:System.Data.DataRow> Objekt. Die <xref:System.Data.DataTable.NewRow%2A> Methode gibt eine Zeile mit dem Schema der der <xref:System.Data.DataTable>, von der Tabelle definierten <xref:System.Data.DataColumnCollection>. Die maximale Anzahl von Zeilen, die eine <xref:System.Data.DataTable> können Speicher ist 16.777.216. Weitere Informationen finden Sie unter [Hinzufügen von Daten zu einer DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md).  
  
 Die <xref:System.Data.DataTable> enthält auch eine Auflistung von <xref:System.Data.Constraint> Objekte, die verwendet werden können, um die Integrität der Daten sicherzustellen. Weitere Informationen finden Sie unter [DataTable-Einschränkungen](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
 Es gibt viele <xref:System.Data.DataTable> Ereignisse, die verwendet werden können, um zu bestimmen, wann Änderungen an einer Tabelle vorgenommen werden. Dazu gehören <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting> und <xref:System.Data.DataTable.RowDeleted>. Weitere Informationen zu den Ereignissen, die mit einem <xref:System.Data.DataTable>, finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
 Wenn eine Instanz des <xref:System.Data.DataTable> wird erstellt, einige Eigenschaften werden von der Lese-/Schreibzugriff auf die ursprünglichen Werte festgelegt. Eine Liste dieser Werte finden Sie in der <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> Konstruktor Thema.  
  
> [!NOTE]
>  Die <xref:System.Data.DataSet> und <xref:System.Data.DataTable> Objekte erben von <xref:System.ComponentModel.MarshalByValueComponent>, und unterstützen die <xref:System.Runtime.Serialization.ISerializable> -Schnittstelle für das .NET Framework-Remoting. Dies sind die einzigen ADO.NET-Objekte, die für .NET Framework-Remoting verwendet werden können.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt zwei <xref:System.Data.DataTable> Objekte und eines <xref:System.Data.DataRelation> -Objekt und fügt die neuen Objekte auf einer <xref:System.Data.DataSet>. Die Tabellen werden dann angezeigt, einem <xref:System.Windows.Forms.DataGridView> Steuerelement.  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 Dieses Beispiel zeigt, wie eine "DataTable" mit bestimmten Schemadefinitionen manuell zu erstellen:  
  
-   Erstellen Sie mehrere DataTables und definieren Sie die ursprünglichen Spalten.  
  
-   Erstellen Sie die tabelleneinschränkungen.  
  
-   Fügen Sie die Werte, und zeigen Sie die Tabellen.  
  
-   Erstellen Sie die Spalten für Ausdrücke, und zeigen Sie die Tabellen.  
  
 C# und Visual Basic-Projekte mit diesem Codebeispiel finden Sie unter [Codebeispiele für Entwickler](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist für schreibgeschützte Vorgänge mit mehreren Threads sicher. Sie müssen die Schreibvorgänge synchronisieren.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataTable" />-Klasse.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataTable" />-Klasse ohne Argumente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor legt die Anfangswerte für alle Eigenschaften der <xref:System.Data.DataTable> Objekt. Die folgende Tabelle zeigt die Eigenschaften und ihre Standardwerte zurück. Wenn eine Instanz des <xref:System.Data.DataTable> erstellt wird, werden die folgenden Lese-/Schreibzugriff auf die ursprünglichen Werte Eigenschaften festgelegt werden.  
  
|Eigenschaft|Standardwert|  
|--------------|-------------------|  
|**CaseSensitive**|Identisch mit dem übergeordneten <xref:System.Data.DataSet>, wenn es zu einem gehört. Andernfalls `false`.|  
|**DisplayExpression**|eine leere Zeichenfolge ("")|  
|**Locale**|Wie das übergeordnete Element <xref:System.Data.DataSet> des Objekts <xref:System.Globalization.CultureInfo> (zurückgegeben von der <xref:System.Data.DataSet.Locale%2A> Eigenschaft); Wenn kein übergeordnetes Element vorhanden ist, der Standardwert ist das aktuelle System <xref:System.Globalization.CultureInfo>.|  
|**MinimumCapacity**|50 Zeilen.|  
  
 Sie können den Wert für eine dieser Eigenschaften über einen separaten Aufruf der Eigenschaft ändern.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Data.DataTable> mit <xref:System.Data.DataColumn> und <xref:System.Data.DataRow>, und zeigt ihn in eine <xref:System.Windows.Forms.DataGridView> Steuerelement.  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable tableName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Der Name, der der Tabelle gegeben werden soll. Wenn <c>tableName</c><see langword="null" /> oder eine leere Zeichenfolge ist, wird beim Hinzufügen zu <see cref="T:System.Data.DataTableCollection" /> ein Standardname vergeben.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataTable" />-Klasse mit dem angegebenen Tabellennamen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> und zeigt ihn in eine <xref:System.Windows.Forms.DataGridView> Steuerelement.  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Die zum Serialisieren bzw. Deserialisieren eines Objekts benötigten Daten.</param>
        <param name="context">Die Quelle und das Ziel eines angegebenen serialisierten Streams.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataTable" />-Klasse mit der <see cref="T:System.Runtime.Serialization.SerializationInfo" /> und dem <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung von der <xref:System.Data.DataTable> Konstruktor ist erforderlich, damit <xref:System.Runtime.Serialization.ISerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string * string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (tableName, tableNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Der Name, der der Tabelle gegeben werden soll. Wenn <c>tableName</c><see langword="null" /> oder eine leere Zeichenfolge ist, wird beim Hinzufügen zu <see cref="T:System.Data.DataTableCollection" /> ein Standardname vergeben.</param>
        <param name="tableNamespace">Der Namespace für die XML-Darstellung der in der <see langword="DataTable" /> gespeicherten Daten.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataTable" />-Klasse mit dem angegebenen Tabellennamen und Namespace.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataTable.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Übernimmt alle Änderungen, die an dieser Tabelle seit dem letzten Aufruf von <see cref="M:System.Data.DataTable.AcceptChanges" /> vorgenommen wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Data.DataTable.AcceptChanges%2A> aufgerufen wird, eine <xref:System.Data.DataRow> Objekt immer noch im Bearbeitungsmodus Bearbeitungsvorgänge erfolgreich beendet. Die <xref:System.Data.DataRowState> ändert sich ebenfalls: alle `Added` und `Modified` Zeilen werden `Unchanged`, und `Deleted` Zeilen entfernt werden.  
  
 Die <xref:System.Data.DataTable.AcceptChanges%2A> Methode heißt in der Regel auf ein <xref:System.Data.DataTable> nach dem Versuch, Aktualisieren der <xref:System.Data.DataSet> mithilfe der <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel testet jede Tabelle auf Fehler. Wenn die Fehler einer Tabelle (durch Übergabe an eine nicht definierte Funktion), abgeglichen werden können <xref:System.Data.DataTable.AcceptChanges%2A> aufgerufen wird; andernfalls, <xref:System.Data.DataTable.RejectChanges%2A> aufgerufen wird.  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataTable.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Initialisierung einer <see cref="T:System.Data.DataTable" />, die in einem Formular oder von einer anderen Komponente verwendet wird. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die entwurfsumgebung für Visual Studio .NET verwendet diese Methode, um die Initialisierung einer Komponente zu starten, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Data.DataTable.EndInit%2A> -Methode beendet die Initialisierung. Mithilfe der <xref:System.Data.DataTable.BeginInit%2A> und <xref:System.Data.DataTable.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberSignature Language="F#" Value="member this.BeginLoadData : unit -&gt; unit" Usage="dataTable.BeginLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deaktiviert während des Ladens von Daten Benachrichtigungen, Indexverwaltung und Einschränkungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Data.DataTable.BeginLoadData%2A> in Verbindung mit <xref:System.Data.DataTable.LoadDataRow%2A> und <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob Vergleiche zwischen Zeichenfolgen in der Tabelle unter Berücksichtigung der Groß- und Kleinschreibung ausgeführt werden.</summary>
        <value>
          <see langword="true" />, wenn beim Vergleich zwischen Groß- und Kleinschreibung unterschieden wird, andernfalls <see langword="false" />. Der Standard ist auf die <see cref="T:System.Data.DataSet" />-Eigenschaft des übergeordneten <see cref="P:System.Data.DataSet.CaseSensitive" />-Objekts festgelegt oder auf <see langword="false" />, wenn die <see cref="T:System.Data.DataTable" /> unabhängig von einem <see cref="T:System.Data.DataSet" /> erstellt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.CaseSensitive%2A> Eigenschaft wirkt sich auf Zeichenfolgenvergleichen in sortieren, durchsuchen und filtern.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.Select%2A> -Methode zweimal für ein <xref:System.Data.DataTable>. Erstmals ausführen, die <xref:System.Data.DataTable.CaseSensitive%2A> -Eigenschaftensatz auf `false`, wird die zweite ist, auf `true`.  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableChildRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung untergeordneter Beziehungen für diese <see cref="T:System.Data.DataTable" /> ab.</summary>
        <value>Eine <see cref="T:System.Data.DataRelationCollection" />, die die untergeordneten Beziehungen für die Tabelle enthält. Wenn keine <see cref="T:System.Data.DataRelation" />-Objekte vorhanden sind, wird eine leere Auflistung zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.DataRelation> definiert die Beziehung zwischen zwei Tabellen. In der Regel werden zwei Tabellen über ein einzelnes Feld verknüpft, die die gleichen Daten enthält. Z. B. möglicherweise eine Tabelle, die Adressdaten enthält ein einzelnes Feld, enthält die Fehlercodes, die Länder/Regionen darstellen. Eine zweite Tabelle, die Land/Region-Daten enthält, müssen ein einzelnes Feld mit dem Code, der die Land/Region identifiziert, und es ist dieser Code, der in das entsprechende Feld in der ersten Tabelle eingefügt wird. Ein <xref:System.Data.DataRelation>, dann enthält mindestens vier Arten von Informationen: (1) den Namen der ersten Tabelle, (2) der Spaltenname in der ersten Tabelle, (3) der Name der zweiten Tabelle und (4) den Spaltennamen in der zweiten Tabelle.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.ChildRelations%2A> jedes untergeordnete Element zurückzugebende Eigenschaft <xref:System.Data.DataRelation> in einem <xref:System.Data.DataTable>. Jede Beziehung wird dann verwendet, als Argument in der <xref:System.Data.DataRow.GetChildRows%2A> Methode der <xref:System.Data.DataRow> ein Array von Zeilen zurückgegeben. Klicken Sie dann der Wert der einzelnen Spalten in der Zeile ausgegeben.  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Daten aus der <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Zeilen in allen Tabellen werden entfernt. Es wird eine Ausnahme generiert, wenn die Tabelle erzwungene untergeordneten Beziehungen enthält, die untergeordneten Zeilen verwaist verursachen würde.  
  
 Wenn die <xref:System.Data.DataSet> gebunden ist, um eine <xref:System.Xml.XmlDataDocument>, wird beim Aufruf <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> oder <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> löst die <xref:System.NotSupportedException>. Um dies zu vermeiden, durchlaufen Sie jede Tabelle, entfernen Sie jede Zeile zu einem Zeitpunkt. Bei Verwendung von <xref:System.Data.DataTable.NewRow%2A> um neue Zeilen zu erstellen, die Zeilen vor dem Aufruf verarbeitet werden müssen <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel löscht alle Daten die Tabelle.  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataTable&#xA;override this.Clone : unit -&gt; System.Data.DataTable" Usage="dataTable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Klont die Struktur der <see cref="T:System.Data.DataTable" />, einschließlich aller Schemas und Einschränkungen der <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Eine neue <see cref="T:System.Data.DataTable" /> mit demselben Schema wie die aktuelle <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Klassen abgeleitet wurden, werden auch der Klon aus denselben abgeleiteten Klassen.  
  
 Klon erstellt ein neues <xref:System.Data.DataTable> mit der gleichen Struktur wie die ursprüngliche <xref:System.Data.DataTable>, aber keine Daten kopiert (die neue <xref:System.Data.DataTable> enthält keine `DataRows`). Kopieren Sie die Struktur und die Daten in eine neue <xref:System.Data.DataTable>, verwenden Sie <xref:System.Data.DataTable.Copy%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird veranschaulicht, wie Sie die Struktur und die Einschränkungen der Zieltabelle zu aktualisieren, nachdem Sie DataTable.Clone ausgeführt. Die Klasse ClonedDataTable eine Zieltabelle zurück, und enthält alle Vorgänge bei der Aktualisierung. Nach Abschluss des klonauftrags wird nicht in der Zieltabelle Strukturänderungen in der Quelltabelle wiedergegeben. Insbesondere werden in diesem Beispiel:  
  
-   Aktualisieren Sie die Änderungen der Spalten in der Quelltabelle.  
  
-   Aktualisieren Sie die Änderungen der UniqueConstraint in der Quelltabelle.  
  
-   Aktualisieren Sie die Änderungen der ForeignKeyConstraint in der Quelltabelle.  
  
 C# und Visual Basic-Projekte mit diesem Codebeispiel finden Sie unter [Codebeispiele für Entwickler](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 Dieses Beispiel zeigt das Ändern von Daten in einer "DataTable" und die Datenquelle aktualisieren.  
  
 Erstellen Sie zunächst eine Datenbank aus:  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 Sie können jetzt kompilieren und Ausführen des Beispiels. [Gewusst wie: Ändern von Daten in der DataTable "und" Update für die Datenquelle](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) Visual Basic- und C#-Projekte in diesem Beispiel hat.  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem ein Wert für die angegebene <see cref="T:System.Data.DataColumn" /> in einer <see cref="T:System.Data.DataRow" /> geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn ein Wert für die angegebene <see cref="T:System.Data.DataColumn" /> in einer <see cref="T:System.Data.DataRow" /> geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Columns : System.Data.DataColumnCollection" Usage="System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der Spalten ab, die zu dieser Tabelle gehören.</summary>
        <value>Eine <see cref="T:System.Data.DataColumnCollection" />, die die Auflistung von <see cref="T:System.Data.DataColumn" />-Objekten für die Tabelle enthält. Wenn keine <see cref="T:System.Data.DataColumn" />-Objekte vorhanden sind, wird eine leere Auflistung zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataColumnCollection> bestimmt das Schema einer Tabelle durch den Datentyp jeder Spalte zu definieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird jeder Wert der einzelnen Zeilen in einer Tabelle mit den <xref:System.Data.DataTable.Columns%2A> Eigenschaft.  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Compute : string * string -&gt; obj" Usage="dataTable.Compute (expression, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Der zu berechnende Ausdruck.</param>
        <param name="filter">Der Filter zum Begrenzen der Zeilen, die in dem Ausdruck ausgewertet werden.</param>
        <summary>Berechnet den angegebenen Ausdruck für die aktuellen Zeilen, die die Filterkriterien erfüllen.</summary>
        <returns>Ein <see cref="T:System.Object" />, das auf das Ergebnis der Berechnung festgelegt ist. Wenn der Ausdruck NULL ergibt, ist der Rückgabewert <see cref="F:System.DBNull.Value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `expression` Parameter erfordert eine Aggregatfunktion. Folgendes ist beispielsweise ein gültiger Ausdruck:  
  
 `Count(Quantity)`  
  
 Dieser Ausdruck ist jedoch nicht:  
  
 `Sum (Quantity * UnitPrice)`  
  
 Wenn Sie eine Operation für zwei oder mehr Spalten durchführen müssen, sollten Sie erstellen eine <xref:System.Data.DataColumn>legen die <xref:System.Data.DataColumn.Expression%2A> Eigenschaft, um einen entsprechenden Ausdruck einen Aggregatausdruck für die resultierende Spalte. In diesem Fall erhält eine <xref:System.Data.DataColumn> mit dem Namen "Total", und die <xref:System.Data.DataColumn.Expression%2A> Festlegen dieser Eigenschaft:  
  
 `"Quantity * UnitPrice"`  
  
 Die Expression-Argument für die <xref:System.Data.DataTable.Compute%2A> Methode würde dann wie folgt lauten:  
  
 `Sum(total)`  
  
 Der zweite Parameter, `filter`, bestimmt, welche Zeilen im Ausdruck verwendet werden. Wenn die Tabelle eine Datumsspalte, die mit dem Namen "colDate" enthält, können Sie beispielsweise die Zeilen mit dem folgenden Ausdruck begrenzen:  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 Regeln zum Erstellen von Ausdrücken für beide Parameter, finden Sie unter den <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> Eigenschaft.  
  
   
  
## Examples  
 Im folgende Beispiel werden die Werte einer Spalte mit der Bezeichnung "Total" für den Verkäufer, dessen ID 5 summiert.  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraints : System.Data.ConstraintCollection" Usage="System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der Einschränkungen ab, die von dieser Tabelle verwaltet werden.</summary>
        <value>Eine <see cref="T:System.Data.ConstraintCollection" />, die die Auflistung von <see cref="T:System.Data.Constraint" />-Objekten für die Tabelle enthält. Wenn keine <see cref="T:System.Data.Constraint" />-Objekte vorhanden sind, wird eine leere Auflistung zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.ForeignKeyConstraint> schränkt die Aktion ausgeführt wird, wenn ein Wert in einer Spalte (oder Spalten) entweder gelöscht oder aktualisiert wird. Eine solche Einschränkung richtet sich an, die mit den Schlüsselspalten verwendet werden. In einer über-/unterordnungsbeziehung zwischen zwei Tabellen kann einen Wert aus der übergeordneten Tabelle gelöscht untergeordneten Zeilen in einem der folgenden Methoden auswirken.  
  
-   Das untergeordnete Element, auf die Zeilen auch, können gelöscht (eine kaskadierende Aktion).  
  
-   Die Werte in die untergeordnete Spalte (oder Spalten) können auf null-Werte festgelegt werden.  
  
-   Die Werte in die untergeordnete Spalte (oder Spalten) können auf Standardwerte festgelegt werden.  
  
-   Eine Ausnahme kann ausgelöst werden.  
  
 Ein <xref:System.Data.UniqueConstraint> wird aktiviert, bei dem Versuch, einen Wert in einem primären Schlüssel für ein nicht eindeutiger Wert festzulegen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Data.ForeignKeyConstraint> zur Auflistung der Einschränkungen.  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataTable" Usage="dataTable.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Struktur und die Daten für diese <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Eine neue <see cref="T:System.Data.DataTable" /> mit derselben Struktur (Tabellenschemas und Einschränkungen) und denselben Daten wie diese <see cref="T:System.Data.DataTable" />.  
  
Wenn diese Klassen abgeleitet wurden, besteht die Kopie aus denselben abgeleiteten Klassen.  
  
 <see cref="M:System.Data.DataTable.Copy" /> erstellt ein neues <see cref="T:System.Data.DataTable" /> mit der gleichen Struktur und den Daten wie das ursprüngliche <see cref="T:System.Data.DataTable" />. Um die Struktur, nicht jedoch die Daten, zu neuen <see cref="T:System.Data.DataTable" />, zu kopieren, verwenden Sie <see cref="M:System.Data.DataTable.Clone" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.Copy%2A> Methode zum Erstellen einer Kopie des Originals <xref:System.Data.DataTable>. Der Namespacename wird nicht beibehalten, wenn sie von einem übergeordneten Element übernommen wurde <xref:System.Data.DataTable> oder <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataTable.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Data.DataTableReader" /> zurück, der den Daten innerhalb dieser <see cref="T:System.Data.DataTable" /> entspricht.</summary>
        <returns>Ein <see cref="T:System.Data.DataTableReader" />, der entsprechend der <see cref="T:System.Data.DataTable" />-Quellinstanz ein Resultset enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine <xref:System.Data.DataTable>-Instanz. Das Beispiel übergibt anschließend die gefüllte <xref:System.Data.DataTable> an eine Prozedur, die Aufrufe der <xref:System.Data.DataTable.CreateDataReader%2A> -Methode, die Ergebnisse der enthaltenen durchläuft die <xref:System.Data.DataTableReader>.  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : unit -&gt; System.Data.DataTable&#xA;override this.CreateInstance : unit -&gt; System.Data.DataTable" Usage="dataTable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz von <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Der neue Ausdruck.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDataSetDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Data.DataSet" /> ab, zu dem diese Tabelle gehört.</summary>
        <value>Das <see cref="T:System.Data.DataSet" />, zu dem diese Tabelle gehört.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Steuerelement datengebunden ist eine <xref:System.Data.DataTable>, und die Tabelle gehört zu einer <xref:System.Data.DataSet>, erhalten Sie auf die <xref:System.Data.DataSet> über diese Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel gibt das übergeordnete Element <xref:System.Data.DataSet> einer bestimmten Tabelle über die <xref:System.Data.DataTable.DataSet%2A> Eigenschaft.  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultView : System.Data.DataView" Usage="System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine benutzerdefinierte Sicht der Tabelle ab, wobei es sich um eine gefilterte Sicht oder eine Cursorposition handeln kann.</summary>
        <value>Der mit dem <see cref="T:System.Data.DataView" /> verknüpfte <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.DefaultView%2A> -Eigenschaft gibt eine <xref:System.Data.DataView> können Sie sortieren, Filtern und Suchen einer <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Eigenschaft der <xref:System.Data.DataTable> des Objekts <xref:System.Data.DataView> über die <xref:System.Data.DataTable.DefaultView%2A> Eigenschaft. Das Beispiel zeigt auch die Bindung des eine <xref:System.Windows.Forms.DataGridView> die Steuerung an eine <xref:System.Data.DataTable> mit dem Namen "Suppliers", die enthält eine Spalte mit dem Namen "CompanyName".  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayExpression : string with get, set" Usage="System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDisplayExpressionDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Ausdruck ab, der einen Wert für die Darstellung dieser Tabelle auf der Benutzeroberfläche zurückgibt, oder legt diesen fest. Mit der <see langword="DisplayExpression" />-Eigenschaft können Sie den Namen dieser Tabelle auf einer Benutzeroberfläche anzeigen.</summary>
        <value>Eine Anzeigezeichenfolge.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataTable.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Initialisierung einer <see cref="T:System.Data.DataTable" />, die in einem Formular oder von einer anderen Komponente verwendet wird. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die entwurfsumgebung für Visual Studio .NET verwendet diese Methode, um die Initialisierung einer Komponente zu beenden, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Data.DataTable.BeginInit%2A> -Methode startet die Initialisierung. Mithilfe der <xref:System.Data.DataTable.BeginInit%2A> und <xref:System.Data.DataTable.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberSignature Language="F#" Value="member this.EndLoadData : unit -&gt; unit" Usage="dataTable.EndLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktiviert nach dem Laden von Daten Benachrichtigungen, Indexverwaltung und Einschränkungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Data.DataTable.EndLoadData%2A> in Verbindung mit <xref:System.Data.DataTable.LoadDataRow%2A> und <xref:System.Data.DataTable.BeginLoadData%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung benutzerdefinierter Benutzerinformationen ab.</summary>
        <value>Eine <see cref="T:System.Data.PropertyCollection" />, die benutzerdefinierte Benutzerinformationen enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ExtendedProperties%2A> benutzerdefinierte Informationen zum Hinzufügen einer <xref:System.Data.DataTable>. Hinzufügen von Informationen mithilfe der `Add` Methode. Abrufen von Informationen mit den `Item` Methode.  
  
 Erweiterte Eigenschaften muss vom Typ <xref:System.String>. Eigenschaften, die nicht vom Typ "String" sind nicht beibehalten, wenn die <xref:System.Data.DataTable> als XML geschrieben wird.  
  
   
  
## Examples  
 Das folgende Beispiel fügt einen Timestamp-Wert, der <xref:System.Data.DataTable> über die <xref:System.Data.DataTable.ExtendedProperties%2A> Eigenschaft.  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberSignature Language="F#" Value="val mutable fInitInProgress : bool" Usage="System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Überprüft, ob die Initialisierung gegenwärtig ausgeführt wird. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Kopie der <see cref="T:System.Data.DataTable" /> ab, die alle seit dem letzten Laden oder seit dem letzten Aufruf von <see cref="M:System.Data.DataTable.AcceptChanges" /> vorgenommenen Änderungen enthält.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataTable" Usage="dataTable.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Kopie der <see cref="T:System.Data.DataTable" /> ab, die alle seit dem letzten Laden oder seit dem letzten Aufruf von <see cref="M:System.Data.DataTable.AcceptChanges" /> vorgenommenen Änderungen enthält.</summary>
        <returns>Eine Kopie der Änderungen aus dieser <see cref="T:System.Data.DataTable" /> oder <see langword="null" />, wenn keine Änderungen gefunden wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues <xref:System.Data.DataSet> , enthält eine Kopie aller Zeilen in der ursprünglichen <xref:System.Data.DataSet> , die über ausstehende Änderungen verfügen. Einschränkungen der Beziehung können dazu führen, dass zusätzliche nicht geänderte Zeilen in die neue hinzuzufügende <xref:System.Data.DataSet> nicht geänderten Zeilen Primärschlüssel-Fremdschlüssel in der geänderten Zeilen für enthalten. Gibt die Methode zurück `null` (`Nothing` in Visual Basic), wenn keine Zeilen vorhanden, in der ursprünglichen sind <xref:System.Data.DataSet> mit ausstehenden Änderungen.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataTable" Usage="dataTable.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Einer der <see cref="T:System.Data.DataRowState" />-Werte.</param>
        <summary>Ruft eine Kopie der <see cref="T:System.Data.DataTable" /> ab, die alle seit dem letzten Laden oder seit dem letzten Aufruf von <see cref="M:System.Data.DataTable.AcceptChanges" /> vorgenommenen und durch <see cref="T:System.Data.DataRowState" /> gefilterten Änderungen enthält.</summary>
        <returns>Eine gefilterte Kopie der <see cref="T:System.Data.DataTable" />, für die Aktionen ausgeführt werden können und die nachfolgend durch Verwendung von <see cref="T:System.Data.DataTable" /> wieder mit der <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /> zusammengeführt werden kann. Wenn keine Zeilen mit dem gewünschten <see cref="T:System.Data.DataRowState" /> gefunden werden, gibt die Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.GetChanges%2A> Methode wird verwendet, um eine zweite erzeugen <xref:System.Data.DataTable> Objekt, das nur die Änderungen enthält, die in der ursprünglichen eingeführt. Verwenden der `rowStates` Argument, um den Typ der Änderungen anzugeben, sollte das neue Objekt enthalten.  
  
 Einschränkungen der Beziehung möglicherweise unverändert übergeordneten Zeilen eingeschlossen werden sollen.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataTableSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataTable.GetDataTableSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Eine <see cref="T:System.Xml.Schema.XmlSchemaSet" />-Instanz.</param>
        <summary>Diese Methode gibt eine <see cref="T:System.Xml.Schema.XmlSchemaSet" />-Instanz mit der WSDL (Web Services Description Language) zurück, die die <see cref="T:System.Data.DataTable" /> für Webdienste beschreibt.</summary>
        <returns>Die <see cref="T:System.Xml.Schema.XmlSchemaSet" />-Instanz.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberSignature Language="F#" Value="member this.GetErrors : unit -&gt; System.Data.DataRow[]" Usage="dataTable.GetErrors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array von <see cref="T:System.Data.DataRow" />-Objekten ab, die Fehler enthalten.</summary>
        <returns>Ein Array von <see cref="T:System.Data.DataRow" />-Objekten, die Fehler enthalten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt die Liste der <xref:System.Data.DataRow> Objekte mit <xref:System.Data.DataRow.RowError%2A> festgelegt. Fehler können z. B. auftreten, beim Aufrufen von <xref:System.Data.Common.DataAdapter.Update%2A> mit <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> festgelegt **"true"**. Nicht aufgerufen werden <xref:System.Data.DataTable.AcceptChanges%2A> auf die <xref:System.Data.DataTable> bis Sie alle Fehler zu beheben, und senden Sie erneut die <xref:System.Data.DataSet> für die Aktualisierung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.GetErrors%2A> Methode, um ein Array von zurückzugeben <xref:System.Data.DataRow> Objekte, die Fehler enthalten.  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">"DataTables" (ADO.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataTable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Ein <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt mit den serialisierten Daten, die der <see cref="T:System.Data.DataTable" /> zugeordnet sind.</param>
        <param name="context">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt mit Quelle und Ziel des serialisierten Streams, der der <see cref="T:System.Data.DataTable" /> zugeordnet ist.</param>
        <summary>Füllt ein Serialisierungsinformationsobjekt mit den Daten auf, die zum Serialisieren des <see cref="T:System.Data.DataTable" /> erforderlich sind.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="info" />-Parameter ist ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberSignature Language="F#" Value="abstract member GetRowType : unit -&gt; Type&#xA;override this.GetRowType : unit -&gt; Type" Usage="dataTable.GetRowType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Zeilentyp ab.</summary>
        <returns>Gibt den Typ der <see cref="T:System.Data.DataRow" /> zurück.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberSignature Language="F#" Value="abstract member GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataTable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Ein <see cref="T:System.Xml.Schema.XmlSchema" /> zur Beschreibung der XML-Darstellung des Objekts, das von der <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />-Methode erstellt und von der <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />-Methode verwendet wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in einer Zeile in einer Tabelle des <see cref="T:System.Data.DataSet" />, zu dem die Tabelle gehört, Fehler aufgetreten sind.</summary>
        <value>
          <see langword="true" />, wenn Fehler vorhanden sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie funktioniert der Benutzer auf einem Satz von Daten in eine <xref:System.Data.DataTable>, Sie können jede Änderung mit einem Fehler markieren, wenn die Änderung das Fehlschlagen der Validierung verursacht. Sie können eine gesamte markieren <xref:System.Data.DataRow> mit einer Fehlermeldung, indem die <xref:System.Data.DataRow.RowError%2A> Eigenschaft. Sie können auch Fehler festlegen, für jede Spalte der Zeile mit der <xref:System.Data.DataRow.SetColumnError%2A> Methode.  
  
 Vor dem Aktualisieren einer Datenquelle mit einem <xref:System.Data.DataSet>, es wird empfohlen, Sie zuerst rufen die <xref:System.Data.DataSet.GetChanges%2A> Methode auf dem Ziel <xref:System.Data.DataSet>. Die Methode führt eine <xref:System.Data.DataSet> , die nur die Änderungen an der ursprünglichen enthält. Vor dem Senden der <xref:System.Data.DataSet> mit der Datenquelle für die Aktualisierung, überprüfen Sie die <xref:System.Data.DataTable.HasErrors%2A> -Eigenschaft jeder Tabelle, um festzustellen, ob alle Fehler an den Zeilen oder Spalten in den Zeilen angefügt wurden.  
  
 Nach dem Abgleichen von jeder Fehler, deaktivieren Sie die Fehler mit der <xref:System.Data.DataRow.ClearErrors%2A> Methode der `DataRow`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.HasErrors%2A> Eigenschaft zu überprüfen, ob eine Tabelle Fehler enthält.  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberSignature Language="F#" Value="member this.ImportRow : System.Data.DataRow -&gt; unit" Usage="dataTable.ImportRow row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">Die zu importierende <see cref="T:System.Data.DataRow" />.</param>
        <summary>Kopiert eine <see cref="T:System.Data.DataRow" /> in eine <see cref="T:System.Data.DataTable" />, wobei alle Eigenschafteneinstellungen sowie die ursprünglichen und die aktuellen Werte beibehalten werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen <xref:System.Data.DataTable.NewRow%2A> Fügt eine Zeile hinzu, um die Tabelle mit dem vorhandenen Tabellenschema, aber mit den Standardwerten für die Zeile, und legt die <xref:System.Data.DataRowState> zu `Detached`. Aufrufen von <xref:System.Data.DataTable.ImportRow%2A> behält den vorhandenen <xref:System.Data.DataRowState> zusammen mit anderen Werten in der Zeile. Wenn die `DataRow` übergeben wird, wie ein Parameter, die in einem getrennten Status ist, Sie ignoriert wird und keine Ausnahme ausgelöst wird.  
  
 Die neue Zeile wird an das Ende der Datentabelle hinzugefügt werden.  
  
 Wenn die neue Zeile eine Einschränkung verletzt wird nicht es der Datentabelle hinzugefügt werden.  
  
 Sie können den Index der neuen Zeile mit DataTable.Rows.Find und DataTable.Rows.IndexOf abrufen. Weitere Informationen finden Sie unter <xref:System.Data.DataRowCollection> und <xref:System.Data.DataTable.Rows%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5cb86d48-a987-4af4-80e0-8cc2c8373d62">Bearbeiten von Daten in einer "DataTable" (ADO.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt nach dem Initialisieren der <see cref="T:System.Data.DataTable" /> auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Data.DataTable.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Data.DataTable" /> initialisiert wurde.</summary>
        <value>
          <see langword="true" />, um anzugeben, dass die Initialisierung der Komponente abgeschlossen ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt den Status der <xref:System.Data.DataTable> während der Erstellung, für die Instanz von Visual Studio. Die <xref:System.Data.DataTable.BeginInit%2A> Methode wird auf `false` und <xref:System.Data.DataTable.EndInit%2A> Methode wird auf `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt eine <see cref="T:System.Data.DataTable" /> mit Werten aus einer Datenquelle, die den angegebenen <see cref="T:System.Data.IDataReader" /> verwendet. Wenn die <see langword="DataTable" /> bereits Zeilen enthält, werden die eingehenden Daten aus der Datenquelle mit den vorhandenen Zeilen zusammengeführt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Load` Methode kann verwendet werden, in mehreren häufigen Szenarien, darum Abrufen von Daten aus einer angegebenen Datenquelle und dem aktuellen Datencontainer hinzugefügt (in diesem Fall eine `DataTable`). Diese Szenarien beschreiben, Standardverfahren für die ein `DataTable`, beschreiben Sie das Update und merge-Verhalten.  
  
 Ein `DataTable` anhand einer einzelnen primären Datenquelle synchronisiert oder aktualisiert. Die `DataTable` verfolgt die Änderungen, sodass die Synchronisierung mit der primären Datenquelle. Darüber hinaus eine `DataTable` kann inkrementelle Daten aus einer oder mehreren sekundären Datenquellen akzeptieren. Die `DataTable` ist nicht verantwortlich für das Nachverfolgen von Änderungen um Synchronisierung mit der Datenquelle für die sekundäre zu ermöglichen.  
  
 Wenn diese beiden hypothetischen Datenquellen, ist ein Benutzer wahrscheinlich eine der folgenden Verhaltensweisen benötigen:  
  
-   Initialisieren Sie `DataTable` aus einer primären Datenquelle. In diesem Szenario möchte der Benutzer ein leeres initialisieren `DataTable` mit Werten aus der primären Datenquelle. Der Benutzer soll später Änderungen an der primären Datenquelle weitergegeben werden.  
  
-   Änderungen beibehalten und erneut über die primäre Datenquelle synchronisieren. In diesem Szenario möchte der Benutzer wird die `DataTable` gefüllt, die im vorherigen Szenario, und führen Sie eine inkrementelle Synchronisierung mit der primären Datenquelle, das Beibehalten von Änderungen der `DataTable`.  
  
-   Inkrementelle Datenfeed aus sekundären Datenquellen. In diesem Szenario möchte der Benutzer Änderungen, die aus einem oder mehreren sekundären Datenquellen zusammenzuführen, und geben diese Änderungen zurück an die primäre Datenquelle.  
  
 Die `Load` Methode ermöglicht allen diesen Szenarios. Alle außer einer der Überladungen dieser Methode einen Load-Option-Parameter angeben können, der angibt, wie Zeilen bereits in einer <xref:System.Data.DataTable> kombinieren mit Zeilen, die geladen werden. (Die Überladung, die Sie angeben, das Verhalten nicht zulässt, verwendet die Standard-Load-Option.) Die folgende Tabelle beschreibt die drei Ladeoptionen angegeben werden, indem die <xref:System.Data.LoadOption> Enumeration. In jedem Fall gibt die Beschreibung des Verhaltens, wenn der Primärschlüssel einer Zeile in der eingehenden Daten den Primärschlüssel einer vorhandenen Zeile übereinstimmt.  
  
|Option "laden"|Beschreibung |  
|-----------------|-----------------|  
|`PreserveChanges` (Standardwert)|Aktualisiert die ursprüngliche Version der Zeile mit dem Wert der hinzukommenden Zeile an.|  
|`OverwriteChanges`|Aktualisiert die aktuellen und ursprünglichen Versionen der Zeile mit dem Wert der hinzukommenden Zeile an.|  
|`Upsert`|Aktualisiert die aktuelle Version der Zeile mit dem Wert der hinzukommenden Zeile an.|  
  
 Im Allgemeinen die `PreserveChanges` und `OverwriteChanges` Optionen dienen für Szenarien, in dem der Benutzer synchronisieren muss, die `DataSet` und seine Änderungen mit der primären Datenquelle. Die `Upsert` Option erleichtert die aggregieren Änderungen aus einem oder mehreren sekundären Datenquellen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einige der Probleme im Zusammenhang mit Aufrufen der <xref:System.Data.DataTable.Load%2A> Methode. Im Beispiel wird zunächst Mittelpunkt schemaprobleme, einschließlich Ableiten eines Schemas aus dem geladenen <xref:System.Data.IDataReader>, und klicken Sie dann auf die Behandlung inkompatibler Schemas und Schemas mit fehlenden oder zusätzliche Spalten. Im Beispiel ist dann im Mittelpunkt von Datenproblemen, darunter der Umgang mit den verschiedenen Ladeoptionen enthalten.  
  
> [!NOTE]
>  Dieses Beispiel zeigt, wie Sie mit einer der überladenen Versionen der `Load`. Andere Beispiele, die möglicherweise verfügbar sind, finden Sie unter den einzelnen Überladung Themen.  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader -&gt; unit" Usage="dataTable.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Data.IDataReader" />, der ein Resultset bereitstellt.</param>
        <summary>Füllt eine <see cref="T:System.Data.DataTable" /> mit Werten aus einer Datenquelle, die den angegebenen <see cref="T:System.Data.IDataReader" /> verwendet. Wenn die <see cref="T:System.Data.DataTable" /> bereits Zeilen enthält, werden die eingehenden Daten aus der Datenquelle mit den vorhandenen Zeilen zusammengeführt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.Load%2A> Methode nutzt das erste Resultset aus dem geladenen <xref:System.Data.IDataReader>, und legt nach dem erfolgreichen Abschluss, die Position des Readers auf das nächste Resultset, falls vorhanden. Beim Konvertieren von Daten, die `Load` verwendet dieselben Konvertierungsregeln als Methode der <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> Methode.  
  
 Die <xref:System.Data.DataTable.Load%2A> Methode muss berücksichtigt drei spezifische Probleme beim Laden der Daten aus einer <xref:System.Data.IDataReader> Instanz: Schema, Daten und Ereignis-Vorgänge. Bei der Arbeit mit dem Schema der <xref:System.Data.DataTable.Load%2A> Methode kann Bedingungen auftreten, wie in der folgenden Tabelle beschrieben. Die Schemavorgänge erfolgen für alle importierten Resultsets, auch solche, die keine Daten enthält.  
  
|Bedingung|Verhalten|  
|---------------|--------------|  
|Die <xref:System.Data.DataTable> verfügt über kein Schema.|Die <xref:System.Data.DataTable.Load%2A> -Methode leitet das Schema basierend auf das Resultset aus dem importierten <xref:System.Data.IDataReader>.|  
|Die <xref:System.Data.DataTable> verfügt über ein Schema, aber es ist nicht kompatibel mit dem Schema geladen.|Die <xref:System.Data.DataTable.Load%2A> Methode löst eine Ausnahme, die für den bestimmten Fehler, die bei dem Versuch, Daten in das inkompatible Schema zu laden.|  
|Die Schemas sind kompatibel, aber die geladene ResultSetSchema enthält Spalten, die in nicht vorhanden sind die <xref:System.Data.DataTable>.|Die <xref:System.Data.DataTable.Load%2A> Methode fügt die zusätzlichen Spalten zu `DataTable`des Schemas. Die Methode löst eine Ausnahme aus, wenn die entsprechenden Spalten in der <xref:System.Data.DataTable> Resultset geladen sind und nicht kompatiblen Wert. Die Methode ruft auch Einschränkungsinformationen aus dem Resultset für alle hinzugefügten Spalten ab. Außer bei Primary Key-Einschränkung, Informationen zu diesen Einschränkungen wird nur verwendet, wenn die aktuelle <xref:System.Data.DataTable> enthält keine Spalten zu Beginn des Ladevorgangs.|  
|Die Schemas sind kompatibel, aber die geladene ResultSetSchema enthält weniger Spalten als die `DataTable`.|Wenn eine fehlende Spalte einen Standardwert definiert oder Datentyp der Spalte NULL-Werte lässt, die <xref:System.Data.DataTable.Load%2A> Methode ermöglicht die Zeilen hinzugefügt werden soll, und Ersetzen Sie dabei die Standardeinstellung oder `null` Wert für die Spalte nicht vorhanden. Wenn kein Standardwert oder `null` verwendet werden kann, und klicken Sie dann die `Load` Methode löst eine Ausnahme aus. Wenn kein bestimmter Standardwert angegeben wurde, die `Load` -Methode verwendet die `null` Wert als der implizite Standardwert.|  
  
 Anzusehen das Verhalten von der `Load` in Bezug auf die Datenvorgänge, Methode, die jede Zeile innerhalb einer <xref:System.Data.DataTable> verwaltet sowohl den aktuellen Wert und der ursprüngliche Wert für jede Spalte. Diese Werte können identisch sein, oder möglicherweise anders, wenn die Daten in die Zeile seit füllen geändert wurde der `DataTable`.  Weitere Informationen finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Diese Version von der `Load` -Methode versucht, die die aktuellen Werte in jeder Zeile wird der erhalten bleibt des ursprünglichen Werts beizubehalten. (Wenn Sie eine präzisere Kontrolle über das Verhalten der eingehenden Daten möchten, finden Sie unter <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) Wenn die vorhandene Zeile und die empfangene Zeile entsprechende primäre Schlüsselwerte enthalten, die Zeile mit den Wert der aktuellen Zeile Status verarbeitet, andernfalls wird es als eine neue Zeile behandelt.  
  
 In Bezug auf Event-Vorgänge die <xref:System.Data.DataTable.RowChanging> Ereignis tritt auf, bevor jede Zeile geändert wird, und die <xref:System.Data.DataTable.RowChanged> Ereignis tritt auf, nachdem jede Zeile geändert wurde. In jedem Fall die <xref:System.Data.DataRowChangeEventArgs.Action%2A> Eigenschaft der <xref:System.Data.DataRowChangeEventArgs> an den Ereignishandler übergebene Instanz enthält Informationen zu der jeweiligen Aktion, die dem Ereignis zugeordnet. Dieser Wert hängt von den Zustand der Zeile vor der Ladevorgang ab. In jedem Fall beide Ereignisse auftreten, und die Aktion ist für beide identisch. Die Aktion möglicherweise auf die aktuelle oder ursprüngliche Version einer Zeile oder je nach den aktuellen Zeilenzustand angewendet werden.  
  
 In der folgende Tabelle wird das Verhalten für die `Load` Methode. Die letzte Zeile (mit der Bezeichnung "(nicht vorhanden)") beschreibt das Verhalten für eingehende Zeilen, die eine vorhandene Zeile nicht übereinstimmen. Jede Zelle in dieser Tabelle beschreibt den aktuellen und ursprünglichen Wert für ein Feld innerhalb einer Zeile zusammen mit den <xref:System.Data.DataRowState> für den Wert nach der `Load` -Methode abgeschlossen wurde. In diesem Fall die Methode nicht, können Sie die Load-Option anzugeben, und die standardmäßige `PreserveChanges`.  
  
|Vorhandene DataRowState|Werte, nach dem `Load` -Methode und Ereignisaktion|  
|---------------------------|--------------------------------------------------|  
|Hinzugefügt|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<Änderung ><br /><br /> RowAction ChangeOriginal =|  
|Modified|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<Änderung ><br /><br /> RowAction ChangeOriginal =|  
|Deleted|Aktuelle = \<nicht verfügbar ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<gelöscht ><br /><br /> RowAction ChangeOriginal =|  
|Unchanged|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|  
|(Nicht vorhanden)|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|  
  
 Werte in einer <xref:System.Data.DataColumn> kann mithilfe der Eigenschaften, die eingeschränkt werden, z. B. <xref:System.Data.DataColumn.ReadOnly%2A> und <xref:System.Data.DataColumn.AutoIncrement%2A>. Die `Load` Methode verarbeitet solche Spalten in einer Weise, die konsistent mit dem Verhalten, die durch die Eigenschaften der Spalte definiert ist. Die schreibgeschützte einzige Einschränkung auf einen <xref:System.Data.DataColumn> gilt nur für Änderungen, die im Arbeitsspeicher auftreten. Die `Load` Methode überschreibt die schreibgeschützte Spaltenwerte bei Bedarf.  
  
 Um zu bestimmen, welche Version von Feld für den Primärschlüssel zum Vergleichen von der aktuellen Zeile mit einer eingehenden Zeile, die `Load` Methode verwendet die ursprüngliche Version der dem Wert des Primärschlüssels in einer Zeile aus, wenn es vorhanden ist. Andernfalls die `Load` -Methode verwendet die aktuelle Version des Feld für den Primärschlüssel.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einige der Probleme im Zusammenhang mit Aufrufen der <xref:System.Data.DataTable.Load%2A> Methode. Im Beispiel wird zunächst Mittelpunkt schemaprobleme, einschließlich Ableiten eines Schemas aus dem geladenen <xref:System.Data.IDataReader>, und klicken Sie dann auf die Behandlung inkompatibler Schemas und Schemas mit fehlenden oder zusätzliche Spalten. Das Beispiel ruft dann die `Load` -Methode, die Daten anzeigen, vor und nach dem Ladevorgang.  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption -&gt; unit" Usage="dataTable.Load (reader, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Data.IDataReader" />, der ein oder mehrere Resultsets bereitstellt.</param>
        <param name="loadOption">Ein Wert aus der <see cref="T:System.Data.LoadOption" />-Enumeration, der angibt, wie bereits in der <see cref="T:System.Data.DataTable" /> vorhandene Zeilen mit eingehenden Zeilen kombiniert werden, die denselben Primärschlüssel aufweisen.</param>
        <summary>Füllt eine <see cref="T:System.Data.DataTable" /> mit Werten aus einer Datenquelle, die den angegebenen <see cref="T:System.Data.IDataReader" /> verwendet. Wenn die <see langword="DataTable" /> bereits Zeilen enthält, werden die eingehenden Daten gemäß dem Wert des <paramref name="loadOption" />-Parameters aus der Datenquelle mit den vorhandenen Zeilen zusammengeführt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Load` Methode nutzt das erste Resultset aus dem geladenen <xref:System.Data.IDataReader>, und legt nach dem erfolgreichen Abschluss, die Position des Readers auf das nächste Resultset, falls vorhanden. Beim Konvertieren von Daten, die `Load` verwendet dieselben Konvertierungsregeln als Methode der <xref:System.Data.Common.DbDataAdapter.Fill%2A> Methode.  
  
 Die `Load` Methode muss berücksichtigt drei spezifische Probleme beim Laden der Daten aus einer <xref:System.Data.IDataReader> Instanz: Schema, Daten und Ereignis-Vorgänge. Bei der Arbeit mit dem Schema der `Load` Methode kann Bedingungen auftreten, wie in der folgenden Tabelle beschrieben. Die Schemavorgänge erfolgen für alle importierten Resultsets, auch solche, die keine Daten enthält.  
  
|Bedingung|Verhalten|  
|---------------|--------------|  
|Die <xref:System.Data.DataTable> verfügt über kein Schema.|Die `Load` -Methode leitet das Schema basierend auf das Resultset aus dem importierten <xref:System.Data.IDataReader>.|  
|Die <xref:System.Data.DataTable> verfügt über ein Schema, aber es ist nicht kompatibel mit dem Schema geladen.|Die `Load` Methode löst eine Ausnahme, die für den bestimmten Fehler, die bei dem Versuch, Daten in das inkompatible Schema zu laden.|  
|Die Schemas sind kompatibel, aber die geladene ResultSetSchema enthält Spalten, die in nicht vorhanden sind die `DataTable`.|Die `Load` Methode fügt die zusätzlichen Spalten zu `DataTable`des Schemas. Die Methode löst eine Ausnahme aus, wenn die entsprechenden Spalten in der <xref:System.Data.DataTable> Resultset geladen sind und nicht kompatiblen Wert. Die Methode ruft auch Einschränkungsinformationen aus dem Resultset für alle hinzugefügten Spalten ab. Außer bei Primary Key-Einschränkung, Informationen zu diesen Einschränkungen wird nur verwendet, wenn die aktuelle <xref:System.Data.DataTable> enthält keine Spalten zu Beginn des Ladevorgangs.|  
|Die Schemas sind kompatibel, aber die geladene ResultSetSchema enthält weniger Spalten als die `DataTable`.|Wenn eine fehlende Spalte einen Standardwert definiert oder Datentyp der Spalte NULL-Werte lässt, die `Load` Methode ermöglicht die Zeilen hinzugefügt werden soll, und Ersetzen Sie dabei den Default und Null-Wert für die Spalte nicht vorhanden. Wenn kein Standardwert oder Null, verwendet werden kann, und klicken Sie dann die `Load` Methode löst eine Ausnahme aus. Wenn kein bestimmter Standardwert angegeben wurde, die `Load` Methode verwendet wird, wird den null-Wert als der implizite Standardwert verwendet.|  
  
 Anzusehen das Verhalten von der `Load` in Bezug auf die Datenvorgänge, Methode, die jede Zeile innerhalb einer <xref:System.Data.DataTable> verwaltet sowohl den aktuellen Wert und der ursprüngliche Wert für jede Spalte. Diese Werte können identisch sein, oder möglicherweise anders, wenn die Daten in die Zeile seit füllen geändert wurde der `DataTable`. Finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) für Weitere Informationen.  
  
 In diesem Methodenaufruf, der dem angegebenen <xref:System.Data.LoadOption> Parameter wirkt sich auf die Verarbeitung der eingehenden Daten. Behandelt die Load-Methode sollte wie Laden von Zeilen, die den gleichen Primärschlüssel wie vorhandene Zeilen haben? Sollten sie aktuelle Werte, die ursprünglichen Werte oder beides ändern? Diese Probleme und weitere werden gesteuert, von der `loadOption` Parameter.  
  
 Wenn die vorhandene Zeile und die empfangene Zeile entsprechende primäre Schlüsselwerte enthalten, die Zeile mit den Wert der aktuellen Zeile Status verarbeitet, andernfalls wird es als eine neue Zeile behandelt.  
  
 In Bezug auf Event-Vorgänge die <xref:System.Data.DataTable.RowChanging> Ereignis tritt auf, bevor jede Zeile geändert wird, und die <xref:System.Data.DataTable.RowChanged> Ereignis tritt auf, nachdem jede Zeile geändert wurde. In jedem Fall die <xref:System.Data.DataRowChangeEventArgs.Action%2A> Eigenschaft der <xref:System.Data.DataRowChangeEventArgs> an den Ereignishandler übergebene Instanz enthält Informationen zu der jeweiligen Aktion, die dem Ereignis zugeordnet. Dieser Wert hängt vom Status der Zeile vor der Ladevorgang ab. In jedem Fall beide Ereignisse auftreten, und die Aktion ist für beide identisch. Die Aktion möglicherweise auf die aktuelle oder ursprüngliche Version einer Zeile oder je nach den aktuellen Zeilenzustand angewendet werden.  
  
 In der folgende Tabelle wird das Verhalten für die Load-Methode, wenn mit dem Namen der `LoadOption` Werte und zeigt außerdem die Interaktion zwischen der Werten und die Zeile (Zustand) für die Zeile, die geladen werden. Die letzte Zeile (mit der Bezeichnung "(nicht vorhanden)") beschreibt das Verhalten für eingehende Zeilen, die eine vorhandene Zeile nicht übereinstimmen. Jede Zelle in dieser Tabelle beschreibt den aktuellen und ursprünglichen Wert für ein Feld innerhalb einer Zeile zusammen mit den <xref:System.Data.DataRowState> für den Wert nach der `Load` -Methode abgeschlossen wurde.  
  
|Vorhandene DataRowState|"Upsert"|OverwriteChanges|PreserveChanges (Standardverhalten)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Hinzugefügt|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = -\<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = Änderung|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<Änderung ><br /><br /> RowAction ChangeOriginal =|  
|Modified|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<Änderung ><br /><br /> RowAction = Änderung|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<Änderung ><br /><br /> RowAction ChangeOriginal =|  
löschte Elemente|(Last bewirkt nicht beeinflussen, die gelöschte Zeilen)<br /><br /> Aktuelle =---<br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<gelöscht ><br /><br /> (Neue Zeile wird mit den folgenden Eigenschaften hinzugefügt.)<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Löschen rückgängig machen und<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|Aktuelle = \<nicht verfügbar ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<gelöscht ><br /><br /> RowAction ChangeOriginal =|  
|Unchanged|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Wenn der neuer Wert ist identisch mit den vorhandenen Wert dann<br /><br /> Status = \<unverändert ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> Status = \<Änderung ><br /><br /> RowAction = Änderung|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|  
Nicht vorhanden)|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|  
  
 Werte in einer <xref:System.Data.DataColumn> kann mithilfe der Eigenschaften, die eingeschränkt werden, z. B. <xref:System.Data.DataColumn.ReadOnly%2A> und <xref:System.Data.DataColumn.AutoIncrement%2A>. Die `Load` Methode verarbeitet solche Spalten in einer Weise, die konsistent mit dem Verhalten, die durch die Eigenschaften der Spalte definiert ist. Die schreibgeschützte einzige Einschränkung auf einen <xref:System.Data.DataColumn> gilt nur für Änderungen, die im Arbeitsspeicher auftreten. Die `Load` Methode überschreibt die schreibgeschützte Spaltenwerte bei Bedarf.  
  
 Wenn Sie beim Aufrufen die OverwriteChanges oder PreserveChanges-Optionen angeben der `Load` -Methode, und klicken Sie dann auf der Annahme besteht, dass die eingehenden Daten stammen die `DataTable`des primären Datenquelle und der DataTable Änderungen nachverfolgt und können die Änderungen dann mit der Datenquelle zurück. Wenn Sie die Upsert-Option auswählen, wird davon ausgegangen, dass die Daten aus einem von einer sekundären Datenquelle, z. B. Daten von einer Komponente der mittleren Ebene stammen, z. B. von einem Benutzer geändert. In diesem Fall wird von die Annahme, dass der Zweck zum Aggregieren von Daten aus einem oder mehreren Datenquellen in der `DataTable`, und klicken Sie dann die Daten zurück in die primäre Datenquelle möglicherweise übertragen. Die <xref:System.Data.LoadOption> Parameter wird verwendet, um zu bestimmen die spezifische Version der Zeile, die für den primären Schlüssel Vergleich verwendet werden soll. Die folgende Tabelle enthält die Details an.  
  
|Option "laden"|DataRow-Version, die für den primären Schlüssel Vergleich|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Ursprüngliche Version, wenn es vorhanden ist, andernfalls die aktuelle version|  
|`PreserveChanges`|Ursprüngliche Version, wenn es vorhanden ist, andernfalls die aktuelle version|  
|`Upsert`|Aktuelle Version, wenn es vorhanden ist, andernfalls die ursprüngliche version|  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einige der Probleme im Zusammenhang mit Aufrufen der <xref:System.Data.DataTable.Load%2A> Methode. Im Beispiel wird zunächst Mittelpunkt schemaprobleme, einschließlich Ableiten eines Schemas aus dem geladenen <xref:System.Data.IDataReader>, und klicken Sie dann auf die Behandlung inkompatibler Schemas und Schemas mit fehlenden oder zusätzliche Spalten. Im Beispiel ist dann im Mittelpunkt von Datenproblemen, darunter der Umgang mit den verschiedenen Ladeoptionen enthalten.  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit" Usage="dataTable.Load (reader, loadOption, errorHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Data.IDataReader" />, der ein Resultset bereitstellt.</param>
        <param name="loadOption">Ein Wert aus der <see cref="T:System.Data.LoadOption" />-Enumeration, der angibt, wie bereits in der <see cref="T:System.Data.DataTable" /> vorhandene Zeilen mit eingehenden Zeilen kombiniert werden, die denselben Primärschlüssel aufweisen.</param>
        <param name="errorHandler">Ein <see cref="T:System.Data.FillErrorEventHandler" />-Delegat, der aufgerufen wird, wenn beim Laden von Daten Fehler auftreten.</param>
        <summary>Füllt eine <see cref="T:System.Data.DataTable" /> mit Werten aus einer Datenquelle mit dem bereitgestellten <see cref="T:System.Data.IDataReader" /> und unter Verwendung eines Fehlerbehandlungsdelegaten.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Load` Methode nutzt das erste Resultset aus dem geladenen <xref:System.Data.IDataReader>, und legt nach dem erfolgreichen Abschluss, die Position des Readers auf das nächste Resultset, falls vorhanden. Beim Konvertieren von Daten, die `Load` verwendet dieselben Konvertierungsregeln als Methode der <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> Methode.  
  
 Die `Load` Methode muss berücksichtigt drei spezifische Probleme beim Laden der Daten aus einer <xref:System.Data.IDataReader> Instanz: Schema, Daten und Ereignis-Vorgänge. Bei der Arbeit mit dem Schema der `Load` Methode kann Bedingungen auftreten, wie in der folgenden Tabelle beschrieben. Die Schemavorgänge erfolgen für alle importierten Resultsets, auch solche, die keine Daten enthält.  
  
|Bedingung|Verhalten|  
|---------------|--------------|  
|Die <xref:System.Data.DataTable> verfügt über kein Schema.|Die `Load` -Methode leitet das Schema basierend auf das Resultset aus dem importierten <xref:System.Data.IDataReader>.|  
|Die <xref:System.Data.DataTable> verfügt über ein Schema, aber es ist nicht kompatibel mit dem Schema geladen.|Die `Load` Methode löst eine Ausnahme, die für den bestimmten Fehler, die bei dem Versuch, Daten in das inkompatible Schema zu laden.|  
|Die Schemas sind kompatibel, aber die geladene ResultSetSchema enthält Spalten, die in nicht vorhanden sind die `DataTable`.|Die `Load` Methode fügt zusätzliche Spalte(n) `DataTable`des Schemas. Die Methode löst eine Ausnahme aus, wenn die entsprechenden Spalten in der <xref:System.Data.DataTable> Resultset geladen sind und nicht kompatiblen Wert. Die Methode ruft auch Einschränkungsinformationen aus dem Resultset für alle hinzugefügten Spalten ab. Außer bei Primary Key-Einschränkung, Informationen zu diesen Einschränkungen wird nur verwendet, wenn die aktuelle <xref:System.Data.DataTable> enthält keine Spalten zu Beginn des Ladevorgangs.|  
|Die Schemas sind kompatibel, aber die geladene ResultSetSchema enthält weniger Spalten als die `DataTable`.|Wenn eine fehlende Spalte einen Standardwert definiert oder Datentyp der Spalte NULL-Werte lässt, die `Load` Methode ermöglicht die Zeilen hinzugefügt werden soll, und Ersetzen Sie dabei den Default und Null-Wert für die Spalte nicht vorhanden. Wenn kein Standardwert oder Null, verwendet werden kann, und klicken Sie dann die `Load` Methode löst eine Ausnahme aus. Wenn kein bestimmter Standardwert angegeben wurde, die `Load` Methode verwendet wird, wird den null-Wert als der implizite Standardwert verwendet.|  
  
 Anzusehen das Verhalten von der `Load` in Bezug auf die Datenvorgänge, Methode, die jede Zeile innerhalb einer <xref:System.Data.DataTable> verwaltet sowohl den aktuellen Wert und der ursprüngliche Wert für jede Spalte. Diese Werte können identisch sein, oder möglicherweise anders, wenn die Daten in die Zeile seit füllen geändert wurde der `DataTable`. Finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) für Weitere Informationen.  
  
 In diesem Methodenaufruf, der dem angegebenen <xref:System.Data.LoadOption> Parameter wirkt sich auf die Verarbeitung der eingehenden Daten. Behandelt die Load-Methode sollte wie Laden von Zeilen, die den gleichen Primärschlüssel wie vorhandene Zeilen haben? Sollten sie aktuelle Werte, die ursprünglichen Werte oder beides ändern? Diese Probleme und weitere werden gesteuert, von der `loadOption` Parameter.  
  
 Wenn die vorhandene Zeile und die empfangene Zeile entsprechende primäre Schlüsselwerte enthalten, die Zeile mit den Wert der aktuellen Zeile Status verarbeitet, andernfalls wird es als eine neue Zeile behandelt.  
  
 In Bezug auf Event-Vorgänge die <xref:System.Data.DataTable.RowChanging> Ereignis tritt auf, bevor jede Zeile geändert wird, und die <xref:System.Data.DataTable.RowChanged> Ereignis tritt auf, nachdem jede Zeile geändert wurde. In jedem Fall die <xref:System.Data.DataRowChangeEventArgs.Action%2A> Eigenschaft der <xref:System.Data.DataRowChangeEventArgs> an den Ereignishandler übergebene Instanz enthält Informationen zu der jeweiligen Aktion, die dem Ereignis zugeordnet. Dieser Wert hängt vom Status der Zeile vor der Ladevorgang ab. In jedem Fall beide Ereignisse auftreten, und die Aktion ist für beide identisch. Die Aktion möglicherweise auf die aktuelle oder ursprüngliche Version einer Zeile oder je nach den aktuellen Zeilenzustand angewendet werden.  
  
 In der folgende Tabelle wird das Verhalten für die Load-Methode, wenn mit dem Namen der `LoadOption` Werte und zeigt außerdem die Interaktion zwischen der Werten und die Zeile (Zustand) für die Zeile, die geladen werden. Die letzte Zeile (mit der Bezeichnung "(nicht vorhanden)") beschreibt das Verhalten für eingehende Zeilen, die eine vorhandene Zeile nicht übereinstimmen. Jede Zelle in dieser Tabelle beschreibt den aktuellen und ursprünglichen Wert für ein Feld innerhalb einer Zeile zusammen mit den <xref:System.Data.DataRowState> für den Wert nach der `Load` -Methode abgeschlossen wurde.  
  
|Vorhandene DataRowState|"Upsert"|OverwriteChanges|PreserveChanges (Standardverhalten)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Hinzugefügt|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = -\<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = Änderung|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<Änderung ><br /><br /> RowAction ChangeOriginal =|  
|Modified|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<Änderung ><br /><br /> RowAction = Änderung|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|Aktuelle = \<vorhandenen ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<Änderung ><br /><br /> RowAction ChangeOriginal =|  
löschte Elemente|(Last bewirkt nicht beeinflussen, die gelöschte Zeilen)<br /><br /> Aktuelle =---<br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Status = \<gelöscht ><br /><br /> (Neue Zeile wird mit den folgenden Eigenschaften hinzugefügt.)<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Löschen rückgängig machen und<br /><br /> Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|Aktuelle = \<nicht verfügbar ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<gelöscht ><br /><br /> RowAction ChangeOriginal =|  
|Unchanged|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<vorhandenen ><br /><br /> Wenn der neuer Wert ist identisch mit den vorhandenen Wert dann<br /><br /> Status = \<unverändert ><br /><br /> RowAction = Nothing<br /><br /> Else<br /><br /> Status = \<Änderung ><br /><br /> RowAction = Änderung|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|  
Nicht vorhanden)|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<nicht verfügbar ><br /><br /> Status = \<hinzugefügt ><br /><br /> RowAction = hinzufügen|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|Aktuelle = \<eingehende ><br /><br /> Ursprüngliche = \<eingehende ><br /><br /> Status = \<unverändert ><br /><br /> RowAction ChangeCurrentAndOriginal =|  
  
 Werte in einer <xref:System.Data.DataColumn> kann mithilfe der Eigenschaften, die eingeschränkt werden, z. B. <xref:System.Data.DataColumn.ReadOnly%2A> und <xref:System.Data.DataColumn.AutoIncrement%2A>. Die `Load` Methode verarbeitet solche Spalten in einer Weise, die konsistent mit dem Verhalten, die durch die Eigenschaften der Spalte definiert ist. Die schreibgeschützte einzige Einschränkung auf einen <xref:System.Data.DataColumn> gilt nur für Änderungen, die im Arbeitsspeicher auftreten. Die `Load` Methode überschreibt die schreibgeschützte Spaltenwerte bei Bedarf.  
  
 Wenn Sie beim Aufrufen die OverwriteChanges oder PreserveChanges-Optionen angeben der `Load` -Methode, und klicken Sie dann auf der Annahme besteht, dass die eingehenden Daten stammen die `DataTable`des primären Datenquelle und der DataTable Änderungen nachverfolgt und können die Änderungen dann mit der Datenquelle zurück. Wenn Sie die Upsert-Option auswählen, wird davon ausgegangen, dass die Daten aus einem von einer sekundären Datenquelle, z. B. Daten von einer Komponente der mittleren Ebene stammen, z. B. von einem Benutzer geändert. In diesem Fall wird von die Annahme, dass der Zweck zum Aggregieren von Daten aus einem oder mehreren Datenquellen in der `DataTable`, und klicken Sie dann die Daten zurück in die primäre Datenquelle möglicherweise übertragen. Die <xref:System.Data.LoadOption> Parameter wird verwendet, um zu bestimmen die spezifische Version der Zeile, die für den primären Schlüssel Vergleich verwendet werden soll. Die folgende Tabelle enthält die Details an.  
  
|Option "laden"|DataRow-Version, die für den primären Schlüssel Vergleich|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Ursprüngliche Version, wenn es vorhanden ist, andernfalls die aktuelle version|  
|`PreserveChanges`|Ursprüngliche Version, wenn es vorhanden ist, andernfalls die aktuelle version|  
|`Upsert`|Aktuelle Version, wenn es vorhanden ist, andernfalls die ursprüngliche version|  
  
 Die `errorHandler` -Parameter ist ein <xref:System.Data.FillErrorEventHandler> Delegat, der auf eine Prozedur, die aufgerufen wird verweist, tritt ein Fehler beim Laden von Daten. Die <xref:System.Data.FillErrorEventArgs> an die Prozedur übergebene Parameter enthält Eigenschaften, die Sie zum Abrufen von Informationen zu den aufgetretenen Fehler, der aktuellen Zeile von Daten ermöglichen und die <xref:System.Data.DataTable> gefüllt wird. Verwenden diesen Delegatmechanismus, anstatt ein einfacher Try/Catch-Block, können Sie den Fehler zu bestimmen behandeln Sie die Situation, und die fortzusetzen Sie Verarbeitung, wenn Sie möchten. Die <xref:System.Data.FillErrorEventArgs> Parameter liefert eine <xref:System.Data.FillErrorEventArgs.Continue%2A> Eigenschaft: Legen Sie diese Eigenschaft auf `true` , um anzugeben, dass Sie den Fehler verarbeitet wurde und die Verarbeitung ansonsten fortgesetzt werden soll. Legen Sie die Eigenschaft auf `false` um anzugeben, dass die Verarbeitung angehalten werden sollen. Beachten Sie das Festlegen der Eigenschaft auf `false` bewirkt, dass den Code, der das Problem zum Auslösen einer Ausnahme ausgelöst.  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sucht eine bestimmte Zeile und aktualisiert diese. Wenn keine übereinstimmende Zeile gefunden werden kann, wird eine neue Zeile mit den angegebenen Werten erstellt.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * bool -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, fAcceptChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">Ein Array von Werten, mit denen die neue Zeile erstellt wird.</param>
        <param name="fAcceptChanges">
          <see langword="true" />, um Änderungen anzunehmen, andernfalls <see langword="false" />.</param>
        <summary>Sucht eine bestimmte Zeile und aktualisiert diese. Wenn keine übereinstimmende Zeile gefunden werden kann, wird eine neue Zeile mit den angegebenen Werten erstellt.</summary>
        <returns>Die neue <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.LoadDataRow%2A> Methode nimmt ein Array von Werten und sucht übereinstimmende Werte in die Primärschlüsselspalte(n).  
  
 Wenn eine Spalte einen Standardwert verfügt, übergeben Sie einen null-Wert im Array, der Standardwert für diese Spalte festgelegt. Auf ähnliche Weise, wenn eine Spalte der <xref:System.Data.DataColumn.AutoIncrement%2A> -Eigenschaftensatz auf true festgelegt ist, übergeben einen null-Wert in das Array den automatisch generierten Wert für die Zeile festgelegt.  
  
 Wenn die `fAcceptChanges` Parameter `true` oder nicht angegeben ist, werden die neuen Daten hinzugefügt und dann <xref:System.Data.DataTable.AcceptChanges%2A> wird aufgerufen, um alle Änderungen in akzeptieren die <xref:System.Data.DataTable>; Wenn das Argument ist `false`, neu hinzugefügten Zeilen werden als einfügungen und Änderungen an vorhandene Zeilen werden als Änderungen markiert.  
  
 Ausnahmen können auch auftreten, während eine <xref:System.Data.DataTable.ColumnChanging> oder <xref:System.Data.DataTable.RowChanging> Ereignis. Wenn eine Ausnahme auftritt, wird die Zeile der Tabelle nicht hinzugefügt.  
  
 Verwendung <xref:System.Data.DataTable.LoadDataRow%2A> in Verbindung mit <xref:System.Data.DataTable.BeginLoadData%2A> und <xref:System.Data.DataTable.EndLoadData%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.LoadDataRow%2A> Methode versucht, eine Zeile zu finden. Wenn keine Zeile gefunden wird, werden die Werte verwendet, um eine neue Zeile zu erstellen.  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Das Array ist größer als die Anzahl der Spalten in der Tabelle.</exception>
        <exception cref="T:System.InvalidCastException">Ein Wert stimmt nicht mit dem entsprechenden Spaltentyp überein.</exception>
        <exception cref="T:System.Data.ConstraintException">Durch das Hinzufügen der Zeile wird eine Einschränkung für ungültig erklärt.</exception>
        <exception cref="T:System.Data.NoNullAllowedException">Es wird versucht, einen NULL-Wert in einer Spalte zu platzieren, in der <see cref="P:System.Data.DataColumn.AllowDBNull" /> False ist.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * System.Data.LoadOption -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">Ein Array von Werten, mit denen die neue Zeile erstellt wird.</param>
        <param name="loadOption">Wird verwendet, um zu bestimmen, wie die Arraywerte auf die entsprechenden Werte in einer vorhandenen Zeile angewendet werden.</param>
        <summary>Sucht eine bestimmte Zeile und aktualisiert diese. Wenn keine übereinstimmende Zeile gefunden werden kann, wird eine neue Zeile mit den angegebenen Werten erstellt.</summary>
        <returns>Die neue <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.LoadDataRow%2A> Methode nimmt ein Array von Werten und sucht übereinstimmende Werte in die Primärschlüsselspalte(n).  
  
 Wenn eine Spalte einen Standardwert verfügt, übergeben Sie einen null-Wert im Array, der Standardwert für diese Spalte festgelegt. Auf ähnliche Weise, wenn eine Spalte der <xref:System.Data.DataColumn.AutoIncrement%2A> -Eigenschaftensatz auf true festgelegt ist, übergeben einen null-Wert in das Array den automatisch generierten Wert für die Zeile festgelegt.  
  
 Der Wert des der `loadOption` Parameter wird verwendet, um zu bestimmen, wie die Werte im Array in eine vorhandene Zeile angewendet werden. Z. B. wenn `loadOption` nastaven NA hodnotu `OverwriteChanges`, `Original` und `Current` Werte der einzelnen Spalten werden mit den Werten in der hinzukommenden Zeile ersetzt und die `RowState` -Eigenschaftensatz auf `Unchanged`.  
  
 Ausnahmen können auch auftreten, während eine <xref:System.Data.DataTable.ColumnChanging> oder <xref:System.Data.DataTable.RowChanging> Ereignis. Wenn eine Ausnahme auftritt, wird die Zeile der Tabelle nicht hinzugefügt.  
  
 Verwendung <xref:System.Data.DataTable.LoadDataRow%2A> in Verbindung mit <xref:System.Data.DataTable.BeginLoadData%2A> und <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gebietsschemainformationen ab, die für den Vergleich von Zeichenfolgen in der Tabelle verwendet werden, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Globalization.CultureInfo" />, die Daten zum Computergebietsschema des Benutzers enthält. Der Standard ist die <see cref="T:System.Data.DataSet" /> des <see cref="T:System.Globalization.CultureInfo" />-Objekts (von der <see cref="P:System.Data.DataSet.Locale" />-Eigenschaft zurückgegeben), zu der die <see cref="T:System.Data.DataTable" /> gehört. Wenn die Tabelle keinem <see cref="T:System.Data.DataSet" /> angehört, wird die aktuelle <see cref="T:System.Globalization.CultureInfo" /> des Systems standardmäßig verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Globalization.CultureInfo> stellt die softwareeinstellungen für eine bestimmte Kultur oder der Community.  
  
 Bei der Verwendung für Zeichenfolgenvergleiche die <xref:System.Globalization.CultureInfo> wirkt sich auf vergleichen, Sortieren und filtern.  
  
> [!NOTE]
>  In Spalten, die Ausdrücke enthalten die <xref:System.StringComparison.InvariantCulture> verwendet wird. Die <xref:System.StringComparison.CurrentCulture> wird ignoriert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Globalization.CultureInfo> über die <xref:System.Data.DataTable.Locale%2A> und gibt den Namen der ISO-Sprache.  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führen Sie die angegebene <see cref="T:System.Data.DataTable" /> mit der aktuellen <see cref="T:System.Data.DataTable" /> zusammen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Merge` Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einem vorhandenen integrieren <xref:System.Data.DataTable>. Dadurch kann die Clientanwendung eine aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Merge-Vorgangs berücksichtigt nur die ursprüngliche Tabelle und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung zeigt das Verhalten der `missingSchemaAction` Parameter der <xref:System.Data.DataTable.Merge%2A> Methode. Dieses Beispiel erstellt zwei Versionen der gleichen Tabelle, ändern das Schema für die zweite Version. Der Code versucht, die in der zweite Tabelle in der ersten zusammenzuführen.  
  
> [!NOTE]
>  Dieses Beispiel zeigt, wie Sie eine der überladenen Versionen der Zusammenführung zu verwenden. Andere Beispiele, die möglicherweise verfügbar sind, finden Sie unter den einzelnen Überladung Themen.  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataTable.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Die <see cref="T:System.Data.DataTable" />, die mit der aktuellen <see cref="T:System.Data.DataTable" /> zusammengeführt werden soll.</param>
        <summary>Führen Sie die angegebene <see cref="T:System.Data.DataTable" /> mit der aktuellen <see cref="T:System.Data.DataTable" /> zusammen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Merge-Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einem vorhandenen integrieren <xref:System.Data.DataTable>. Dadurch kann die Clientanwendung eine aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Merge-Vorgangs berücksichtigt nur die ursprüngliche Tabelle und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
 Die `Merge` Methode heißt in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, Aktualisieren der Datenquelle mit den Änderungen und zum Schluss aktualisieren die vorhandenen <xref:System.Data.DataTable>.  
  
 Wenn Sie eine Zusammenführung durchführen zu können, werden Änderungen an den vorhandenen Daten vor der Zusammenführung standardmäßig während des Merge-Vorgangs beibehalten. Entwickler können dieses Verhalten ändern, indem eine der anderen zwei Überladungen für diese Methode aufrufen und einen false-Wert für die `preserveChanges` Parameter.  
  
 In einer Clientanwendung ist es üblich, damit eine einzelne Schaltfläche, die der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft vor dem Senden an eine Komponente der mittleren Ebene. In diesem Szenario die <xref:System.Data.DataTable.GetChanges%2A> -Methode zuerst aufgerufen. Dass eine zweite Methodenrückgabe <xref:System.Data.DataTable> optimiert, für das Überprüfen und zusammenführen. Dieses zweite <xref:System.Data.DataTable> -Objekt enthält nur die <xref:System.Data.DataRow> Objekte, die geändert wurden, wodurch eine Teilmenge der ursprünglichen <xref:System.Data.DataTable>. Diese Teilmenge wird in der Regel kleiner und somit effizienter an eine Komponente der mittleren Ebene übergeben. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann senden Sie dann entweder eine neue zurück <xref:System.Data.DataTable> , die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (indem Sie die ursprüngliche Abfrage erneut ausführen) enthält, oder senden wieder die Teilmenge mit den Änderungen, die sie aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Werte Primärschlüssel erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen das zurückgegebene <xref:System.Data.DataTable> zusammengeführt werden können, in der Clientanwendung Original <xref:System.Data.DataTable> mit der <xref:System.Data.DataTable.Merge%2A> Methode.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataTable> in das Ziel einer beliebigen Quelle, die mit Zeilen eine <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted`, Zielzeilen mit den gleichen Primärschlüsselwerten zugeordnet ist. Zeilen mit Quelle ein <xref:System.Data.DataRowState> Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten wie die neuen zugeordnet sind.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine einfache <xref:System.Data.DataTable> und die Tabelle Daten hinzugefügt. Anschließend wird eine Kopie der Tabelle Zeilen hinzufügen, auf die Kopie erstellt. Im Beispiel wird schließlich Ruft die <xref:System.Data.DataTable.Merge%2A> Methode, um die Daten in der zweiten Tabelle mit den Daten in der ersten Tabelle zusammengeführt werden.  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool -&gt; unit" Usage="dataTable.Merge (table, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">Die <see langword="DataTable" />, die mit der aktuellen <see langword="DataTable" /> zusammengeführt werden soll.</param>
        <param name="preserveChanges">
          <see langword="true" />, um an der aktuellen <see langword="DataTable" /> vorgenommene Änderungen beizubehalten, andernfalls <see langword="false" />.</param>
        <summary>Führen Sie die angegebene <see cref="T:System.Data.DataTable" /> mit der aktuellen <see langword="DataTable" /> zusammen, und geben Sie an, ob die Änderungen in der aktuellen <see langword="DataTable" /> beibehalten werden sollen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Merge-Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einem vorhandenen integrieren <xref:System.Data.DataTable>. Dadurch kann die Clientanwendung eine aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Merge-Vorgangs berücksichtigt nur die ursprüngliche Tabelle und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
 Die `Merge` Methode heißt in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, Aktualisieren der Datenquelle mit den Änderungen und zum Schluss aktualisieren die vorhandenen <xref:System.Data.DataTable>.  
  
 Beim Ausführen eines Merge werden Änderungen an den vorhandenen Daten vor der Zusammenführung während des Merge-Vorgangs beibehalten, es sei denn, der Entwickler "false" gibt an, die `preserveChanges` Parameter. Wenn die `preserveChanges` Parametersatz zu `true`, empfangenen Werten nicht vorhandene Werte in der aktuellen-Zeilenversion der vorhandenen Zeile überschrieben. Wenn die `preserveChanges` Parametersatz zu `false`, die vorhandenen Werte in der aktuellen-Zeilenversion der vorhandenen Zeile empfangenen Werten überschrieben. Weitere Informationen zu Zeilenversionen finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 In einer Clientanwendung ist es üblich, damit eine einzelne Schaltfläche, die der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft vor dem Senden an eine Komponente der mittleren Ebene. In diesem Szenario die <xref:System.Data.DataTable.GetChanges%2A> -Methode zuerst aufgerufen. Dass eine zweite Methodenrückgabe <xref:System.Data.DataTable> optimiert, für das Überprüfen und zusammenführen. Dieses zweite <xref:System.Data.DataTable> -Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, wodurch eine Teilmenge der ursprünglichen <xref:System.Data.DataTable>. Diese Teilmenge wird in der Regel kleiner und wird daher eine effizientere an eine Komponente der mittleren Ebene zurückgegeben. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann senden Sie dann entweder eine neue zurück <xref:System.Data.DataTable> , die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (indem Sie die ursprüngliche Abfrage erneut ausführen) enthält, oder senden wieder die Teilmenge mit den Änderungen, die sie aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Werte Primärschlüssel erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen das zurückgegebene <xref:System.Data.DataTable> zusammengeführt werden können, in der Clientanwendung Original <xref:System.Data.DataTable> mit der <xref:System.Data.DataTable.Merge%2A> Methode.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataTable> in das Ziel einer beliebigen Quelle, die mit Zeilen eine <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit denselben primären Schlüssel Werten abgeglichen werden. Zeilen mit Quelle ein <xref:System.Data.DataRowState> Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten wie die neuen zugeordnet sind.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine <xref:System.Data.DataTable> mit Zeilen, einige der Daten in Zeilen ändert und versucht, Daten aus einer anderen zusammenführen <xref:System.Data.DataTable>. Im Beispiel wird veranschaulicht, die unterschiedliche Verhalten für die `preserveChanges` Parameter.  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataTable.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">Die <see cref="T:System.Data.DataTable" />, die mit der aktuellen <see cref="T:System.Data.DataTable" /> zusammengeführt werden soll.</param>
        <param name="preserveChanges">
          <see langword="true" />, um an der aktuellen <see cref="T:System.Data.DataTable" /> vorgenommene Änderungen beizubehalten, andernfalls <see langword="false" />.</param>
        <param name="missingSchemaAction">Einer der <see cref="T:System.Data.MissingSchemaAction" />-Werte.</param>
        <summary>Führen Sie die angegebene <see cref="T:System.Data.DataTable" /> mit der aktuellen <see langword="DataTable" /> zusammen, und geben Sie an, ob die Änderungen in der aktuellen <see langword="DataTable" /> beibehalten werden sollen und wie das fehlende Schema behandelt werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Merge` Methode wird verwendet, um zwei merge <xref:System.Data.DataTable> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einem vorhandenen integrieren <xref:System.Data.DataTable>. Dadurch kann die Clientanwendung eine aktualisiert haben <xref:System.Data.DataTable> mit den neuesten Daten aus der Datenquelle.  
  
 Merge-Vorgangs berücksichtigt nur die ursprüngliche Tabelle und die Tabelle zusammengeführt werden sollen. Untergeordnete Tabellen werden nicht beeinflusst oder enthalten. Bei Tabellen mit einer oder mehreren untergeordneten Tabellen als Teil einer Beziehung definiert, muss jede untergeordnete Tabelle einzeln zusammengeführt werden.  
  
 Die `Merge` Methode heißt in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, Aktualisieren der Datenquelle mit den Änderungen und zum Schluss aktualisieren die vorhandenen <xref:System.Data.DataTable>.  
  
 Beim Ausführen eines Merge werden Änderungen an den vorhandenen Daten vor der Zusammenführung während des Merge-Vorgangs beibehalten, es sei denn, der Entwickler "false" gibt an, die `preserveChanges` Parameter. Wenn die `preserveChanges` Parametersatz zu `true`, empfangenen Werten nicht vorhandene Werte in der aktuellen-Zeilenversion der vorhandenen Zeile überschrieben. Wenn die `preserveChanges` Parametersatz zu `false`, die vorhandenen Werte in der aktuellen-Zeilenversion der vorhandenen Zeile empfangenen Werten überschrieben. Weitere Informationen zu Zeilenversionen finden Sie unter [Zeilenstatus und Zeilenversionen](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 In einer Clientanwendung ist es üblich, damit eine einzelne Schaltfläche, die der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft vor dem Senden an eine Komponente der mittleren Ebene. In diesem Szenario die <xref:System.Data.DataTable.GetChanges%2A> -Methode zuerst aufgerufen. Dass eine zweite Methodenrückgabe <xref:System.Data.DataTable> optimiert, für das Überprüfen und zusammenführen. Dieses zweite <xref:System.Data.DataTable> -Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, wodurch eine Teilmenge der ursprünglichen <xref:System.Data.DataTable>. Diese Teilmenge wird in der Regel kleiner und wird daher eine effizientere an eine Komponente der mittleren Ebene zurückgegeben. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann senden Sie dann entweder eine neue zurück <xref:System.Data.DataTable> , die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (indem Sie die ursprüngliche Abfrage erneut ausführen) enthält, oder senden wieder die Teilmenge mit den Änderungen, die sie aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Werte Primärschlüssel erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen das zurückgegebene <xref:System.Data.DataTable> zusammengeführt werden können, in der Clientanwendung Original <xref:System.Data.DataTable> mit der <xref:System.Data.DataTable.Merge%2A> Methode.  
  
 Wenn die <xref:System.Data.DataTable.Merge%2A> -Methode aufgerufen wird, werden die Schemas der beiden <xref:System.Data.DataTable> Objekte verglichen werden, da es möglich ist, dass die Schemas möglicherweise geändert wurden. Z. B. in einem Business-to-Business-Szenario, neue Spalten möglicherweise ein XML-Schema durch einen automatisierten Prozess hinzugefügt wurden. Wenn die Quelle <xref:System.Data.DataTable> Schemaelemente enthält (hinzugefügt <xref:System.Data.DataColumn> Objekte), die in der das Ziel nicht vorhanden sind, die Elemente des Schemas können an das Ziel hinzugefügt werden, durch Festlegen der `missingSchemaAction` Argument `MissingSchemaAction.Add`. In diesem Fall das zusammengeführte <xref:System.Data.DataTable> enthält das hinzugefügte Schema und Daten.  
  
 Nach dem Zusammenführen von Schemas, werden die Daten zusammengeführt.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataTable> in das Ziel einer beliebigen Quelle, die mit Zeilen eine <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit denselben primären Schlüssel Werten abgeglichen werden. Zeilen mit Quelle ein <xref:System.Data.DataRowState> Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten wie die neuen zugeordnet sind.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung zeigt das Verhalten der `missingSchemaAction` Parameter der <xref:System.Data.DataTable.Merge%2A> Methode. Dieses Beispiel erstellt zwei Versionen der gleichen Tabelle, ändern das Schema für die zweite Version. Der Code versucht, die in der zweite Tabelle in der ersten zusammenzuführen.  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumCapacity : int with get, set" Usage="System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableMinimumCapacityDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Ausgangsgröße für diese Tabelle ab oder legt diese fest.</summary>
        <value>Die Ausgangsgröße dieser Tabelle in Zeilen. Der Standardwert ist 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.MinimumCapacity%2A> kann das System vor dem Abrufen der Daten einen entsprechenden Satz von Ressourcen zu erstellen. In einer Situation Wenn Leistung ankommt, kann durch Festlegen dieser Eigenschaft Leistung optimieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.MinimumCapacity%2A> von einem <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namespace für die XML-Darstellung der in der <see cref="T:System.Data.DataTable" /> gespeicherten Daten ab oder legt diesen fest.</summary>
        <value>Der Namespace von <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberSignature Language="F#" Value="member this.NewRow : unit -&gt; System.Data.DataRow" Usage="dataTable.NewRow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue <see cref="T:System.Data.DataRow" /> mit dem Schema der Tabelle.</summary>
        <returns>Eine <see cref="T:System.Data.DataRow" /> mit demselben Schema wie die <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Data.DataTable.NewRow%2A> Methode zum Erstellen von neuen <xref:System.Data.DataRow> Objekte mit demselben Schema wie die <xref:System.Data.DataTable>. Nach dem Erstellen einer <xref:System.Data.DataRow>, können Sie ihn zum Hinzufügen der <xref:System.Data.DataRowCollection>, über die <xref:System.Data.DataTable> des Objekts <xref:System.Data.DataTable.Rows%2A> Eigenschaft. Bei Verwendung von <xref:System.Data.DataTable.NewRow%2A> um neue Zeilen zu erstellen, die Zeilen hinzugefügt oder aus der Datentabelle gelöscht werden, vor dem Aufruf werden müssen <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable>, addiert zwei <xref:System.Data.DataColumn> Objekte, die das Schema der Tabelle zu bestimmen, und erstellt mehrere neue <xref:System.Data.DataRow> -Objekte mithilfe der <xref:System.Data.DataTable.NewRow%2A> Methode. Die <xref:System.Data.DataRow> Objekte werden dann hinzugefügt, um die <xref:System.Data.DataRowCollection> mithilfe der <xref:System.Data.DataRowCollection.Add%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberSignature Language="F#" Value="member this.NewRowArray : int -&gt; System.Data.DataRow[]" Usage="dataTable.NewRowArray size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">Ein <see cref="T:System.Int32" />-Wert, der die Größe des Arrays beschreibt.</param>
        <summary>Gibt ein Array von <see cref="T:System.Data.DataRow" /> zurück.</summary>
        <returns>Das neue Array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow&#xA;override this.NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow" Usage="dataTable.NewRowFromBuilder builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Ein <see cref="T:System.Data.DataRowBuilder" />-Objekt.</param>
        <summary>Erstellt eine neue Zeile aus einer vorhandenen Zeile.</summary>
        <returns>Eine von <see cref="T:System.Data.DataRow" /> abgeleitete Klasse.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataColumnChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.ColumnChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> Methode.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataColumnChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.ColumnChanging" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> Methode.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataTable.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Ein <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> Methode.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveColumn : System.Data.DataColumn -&gt; unit&#xA;override this.OnRemoveColumn : System.Data.DataColumn -&gt; unit" Usage="dataTable.OnRemoveColumn column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">Die <see cref="T:System.Data.DataColumn" />, die entfernt wird.</param>
        <summary>Benachrichtigt die <see cref="T:System.Data.DataTable" />, dass eine <see cref="T:System.Data.DataColumn" /> entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Weitere Informationen finden Sie unter [Behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> Methode.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataRowChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.RowChanged" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataRowChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.RowChanging" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataRowChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.RowDeleted" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataRowChangeEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.RowDeleting" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Beim Überschreiben von <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> in einer abgeleiteten Klasse, werden Sie sicher, dass der Basisklasse aufrufen <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> Methode.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableCleared e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataTableClearEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.TableCleared" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst die <xref:System.Data.DataTable.TableCleared> -Ereignis, das ausgelöst wird, sobald alle Zeilen, jedoch bevor wurde erfolgreich gelöscht wurde die <xref:System.Data.DataTable.Clear%2A> -Methode die Steuerung an den Aufrufer zurückgibt.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableClearing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataTableClearEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.TableClearing" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst die <xref:System.Data.DataTable.TableClearing> -Ereignis, das ausgelöst wird, bevor die Verarbeitung der der <xref:System.Data.DataTable.Clear%2A> Vorgang beginnt.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit&#xA;override this.OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit" Usage="dataTable.OnTableNewRow e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Ein <see cref="T:System.Data.DataTableNewRowEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="E:System.Data.DataTable.TableNewRow" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Löst die <xref:System.Data.DataTable.TableNewRow> Ereignis, das ausgelöst, nachdem ein neues wird <xref:System.Data.DataRow> wurde mit <xref:System.Data.DataTable.NewRow%2A>.  
  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableParentRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung übergeordneter Beziehungen für diese <see cref="T:System.Data.DataTable" /> ab.</summary>
        <value>Eine <see cref="T:System.Data.DataRelationCollection" />, die die übergeordneten Beziehungen für die Tabelle enthält. Wenn keine <see cref="T:System.Data.DataRelation" />-Objekte vorhanden sind, wird eine leere Auflistung zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataTable.ParentRelations%2A> jede übergeordnete zurückzugebende Eigenschaft <xref:System.Data.DataRelation> in einem <xref:System.Data.DataTable>. Jede Beziehung wird dann verwendet, als Argument in der <xref:System.Data.DataRow.GetParentRows%2A> Methode der <xref:System.Data.DataRow> ein Array von Zeilen zurückgegeben. Klicken Sie dann der Wert der einzelnen Spalten in der Zeile ausgegeben.  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namespace für die XML-Darstellung der in der <see cref="T:System.Data.DataTable" /> gespeicherten Daten ab oder legt diesen fest.</summary>
        <value>Das Präfix der <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : System.Data.DataColumn[] with get, set" Usage="System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrimaryKeyDescr")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array von Spalten ab, die als Primärschlüssel für die Datentabelle verwendet werden, oder legt dieses fest.</summary>
        <value>Ein Array von <see cref="T:System.Data.DataColumn" />-Objekten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Primärschlüssel einer Tabelle muss zum Identifizieren des Datensatzes in der Tabelle eindeutig sein. Es ist auch möglich, eine Tabelle mit einem Primärschlüssel, setzt sich aus zwei oder mehr Spalten enthalten. Dies tritt auf, wenn es sich bei eine einzelne Spalte genügend eindeutige Werte enthalten kann. Beispielsweise kann ein primärer Schlüssel mit zwei Spalten aus einer Spalte "FirstName" und "LastName" bestehen. Da der Primärschlüssel von mehr als eine Spalte erstellt werden können, um die <xref:System.Data.DataTable.PrimaryKey%2A> Eigenschaft besteht aus einem Array von <xref:System.Data.DataColumn> Objekte.  
  
   
  
## Examples  
 Das erste Beispiel zeigt, wie Sie die Primärschlüsselspalten für Zurückgeben einer <xref:System.Data.DataTable> angezeigt, die einer `DataGrid`. Im zweite Beispiel wird veranschaulicht, wie die Primärschlüsselspalten für die festzulegende eine <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">Der Schlüssel ist ein Fremdschlüssel.</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest ein XML-Schema und XML-Daten in das <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument, während die <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema. Um Schemas und Daten zu lesen, verwenden Sie eine der der `ReadXML` Überladungen, die die `XmlReadMode` Parameter, und legen Sie dessen Wert auf `ReadSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw. Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Ein von <see cref="T:System.IO.Stream" /> abgeleitetes Objekt.</param>
        <summary>Liest mit dem angegebenen <see cref="T:System.Data.DataTable" /> das XML-Schema und die XML-Daten in die <see cref="T:System.IO.Stream" />.</summary>
        <returns>Der zum Lesen der Daten verwendete <see cref="T:System.Data.XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine Nachfolger werden geladen, mit den Daten aus der angegebenen <xref:System.IO.Stream>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument, während die <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw. Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird der Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in der gleichen Tabelle, die mit unterschiedlichen Datentypen definiert) ist eine Ausnahme ausgelöst.  
  
 Wenn keine Inline-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann nicht um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ordnet ein XML-Element mit dem entsprechenden `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese nutzen. Bei der zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das-Element während der Verarbeitung ignoriert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schema und Daten in einen arbeitsspeicherdatenstrom, durch den Aufruf der <xref:System.Data.DataTable.WriteXml%2A> Methode. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see cref="T:System.IO.TextReader" />, der verwendet wird, um die Daten zu lesen.</param>
        <summary>Liest mit dem angegebenen <see cref="T:System.Data.DataTable" /> das XML-Schema und die XML-Daten in die <see cref="T:System.IO.TextReader" />.</summary>
        <returns>Der zum Lesen der Daten verwendete <see cref="T:System.Data.XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine Nachfolger werden geladen, mit den Daten aus der angegebenen <xref:System.IO.TextReader>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument, während die <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw. Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird der Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in der gleichen Tabelle, die mit unterschiedlichen Datentypen definiert) ist eine Ausnahme ausgelöst.  
  
 Wenn keine Inline-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann nicht um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ordnet ein XML-Element mit dem entsprechenden `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese nutzen. Bei der zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das-Element während der Verarbeitung ignoriert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schema und Daten in einen arbeitsspeicherdatenstrom, durch den Aufruf der <xref:System.Data.DataTable.WriteXml%2A> Methode. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, aus der die Daten gelesen werden sollen.</param>
        <summary>Liest das XML-Schema und die XML-Daten in die <see cref="T:System.Data.DataTable" /> aus der angegebenen Datei.</summary>
        <returns>Der zum Lesen der Daten verwendete <see cref="T:System.Data.XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine Nachfolger werden geladen, mit den Daten aus der Datei mit dem Namen in der angegebenen <xref:System.String>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument, während die <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw. Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird der Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in der gleichen Tabelle, die mit unterschiedlichen Datentypen definiert) ist eine Ausnahme ausgelöst.  
  
 Wenn keine Inline-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann nicht um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ordnet ein XML-Element mit dem entsprechenden `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese nutzen. Bei der zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das-Element während der Verarbeitung ignoriert.  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schema und Daten auf dem Datenträger. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see cref="T:System.Xml.XmlReader" />, der verwendet wird, um die Daten zu lesen.</param>
        <summary>Liest das XML-Schema und die XML-Daten mit dem angegebenen <see cref="T:System.Data.DataTable" /> in die <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns>Der zum Lesen der Daten verwendete <see cref="T:System.Data.XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle <xref:System.Data.DataTable> und seine Nachfolger werden geladen, mit den Daten aus der Datei mit dem Namen in der angegebenen <xref:System.Xml.XmlReader>. Das Verhalten dieser Methode ist identisch mit der <xref:System.Data.DataTable.ReadXml%2A> -Methode, mit Ausnahme der in diesem Fall, dass, Daten geladen wird, nur für die aktuelle Tabelle und seine Nachfolger.  
  
 Die <xref:System.Data.DataTable.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataTable> aus einem XML-Dokument, während die <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode liest nur das Schema.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.WriteXml%2A> und <xref:System.Data.DataTable.WriteXmlSchema%2A> Methoden bzw. Schreiben von XML-Daten oder Schema und Daten aus der `DataTable`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird der Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in der gleichen Tabelle, die mit unterschiedlichen Datentypen definiert) ist eine Ausnahme ausgelöst.  
  
 Wenn keine Inline-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann nicht um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ordnet ein XML-Element mit dem entsprechenden `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese nutzen. Bei der zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das-Element während der Verarbeitung ignoriert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataTable> mit zwei Spalten und zehn Zeilen. Das Beispiel schreibt die <xref:System.Data.DataTable> Schema und Daten zu einem <xref:System.Xml.XmlReader>. Das Beispiel erstellt eine zweite <xref:System.Data.DataTable> und ruft die <xref:System.Data.DataTable.ReadXml%2A> Methode, um mit dem Schema und Daten zu füllen die <xref:System.Xml.XmlReader> Instanz.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest ein XML-Schema in die <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der `ReadXmlSchema` Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird entsprechend dem XSD-standard interpretiert.  
  
 Die `ReadXmlSchema` Methode wird in der Regel vor dem Aufruf aufgerufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der zum Lesen des Schemas verwendete Stream.</param>
        <summary>Liest ein XML-Schema mit dem angegebenen Stream in die <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird entsprechend dem XSD-standard interpretiert.  
  
 Beschädigung von Daten möglich, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst werden.  
  
 Die `ReadXmlSchema` Methode wird in der Regel vor dem Aufruf aufgerufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
 Um eine geschachtelte Beziehung, die mit XML-Schema zu erstellen, verwenden Sie implizite, geschachtelte Elemente. Sie können auch die geschachtelte Beziehung Verwendung expliziter Spaltennamen konfigurieren. Elemente müssen implizit in der Reihenfolge für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehung geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und schreibt das Schema für die Tabelle zu einer <xref:System.IO.MemoryStream>. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus dem gespeicherten XML-Schema.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der zum Lesen der Schemainformationen verwendete <see cref="T:System.IO.TextReader" />.</param>
        <summary>Liest ein XML-Schema mit dem angegebenen <see cref="T:System.Data.DataTable" /> in die <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird entsprechend dem XSD-standard interpretiert.  
  
 Beschädigung von Daten möglich, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst werden.  
  
 Die `ReadXmlSchema` Methode wird in der Regel vor dem Aufruf aufgerufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
 Um eine geschachtelte Beziehung, die mit XML-Schema zu erstellen, verwenden Sie implizite, geschachtelte Elemente. Sie können auch die geschachtelte Beziehung Verwendung expliziter Spaltennamen neu konfigurieren. Elemente müssen implizit in der Reihenfolge für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehung geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und schreibt das Schema für die Tabelle zu einer <xref:System.IO.MemoryStream>. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus der gespeicherten XML-Schema, eine <xref:System.IO.StreamReader> (erbt von <xref:System.IO.TextReader>) als Quelle.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataTable.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, aus der die Schemainformationen gelesen werden sollen.</param>
        <summary>Liest ein XML-Schema aus der angegebenen Datei in die <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird entsprechend dem XSD-standard interpretiert.  
  
 Beschädigung von Daten möglich, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst werden.  
  
 Die `ReadXmlSchema` Methode wird in der Regel vor dem Aufruf aufgerufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der `DataTable`.  
  
 Um eine geschachtelte Beziehung, die mit XML-Schema zu erstellen, verwenden Sie implizite, geschachtelte Elemente. Sie können auch die geschachtelte Beziehung Verwendung expliziter Spaltennamen neu konfigurieren. Elemente müssen implizit in der Reihenfolge für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehung geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und das Schema für die Tabelle in eine Datei schreibt. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus der gespeicherten XML-Schema mithilfe der Datei als Quelle.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der zum Lesen der Schemainformationen verwendete <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Liest ein XML-Schema mit dem angegebenen <see cref="T:System.Data.DataTable" /> in die <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataTable>. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Um ein Schema in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird entsprechend dem XSD-standard interpretiert.  
  
 Beschädigung von Daten möglich, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst werden.  
  
 Die `ReadXmlSchema` Methode wird in der Regel vor dem Aufruf aufgerufen der <xref:System.Data.DataTable.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Die Möglichkeit zum Erstellen einer geschachtelten Beziehung mithilfe von XML-Schema werden implizite geschachtelter Elemente aufweisen. Darüber hinaus kann die geschachtelte Beziehung neu konfiguriert werden, um explizite Spaltennamen sein. Es ist zwingend erforderlich, damit Elemente implizit für die entsprechenden DataTables zur Teilnahme an einer geschachtelten Beziehung geschachtelt werden.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt eine neue <xref:System.Data.DataTable>, und schreibt das Schema für die Tabelle zu einer <xref:System.IO.MemoryStream>. Klicken Sie dann das Beispiel erstellt ein neues <xref:System.Data.DataTable> und liest das Schema aus der gespeicherten XML-Schema, eine <xref:System.Xml.XmlTextReader> (erbt von <xref:System.Xml.XmlReader>) als Quelle.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Xml.XmlReader" />-Objekt.</param>
        <summary>Liest aus einem XML-Stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberSignature Language="F#" Value="member this.RejectChanges : unit -&gt; unit" Usage="dataTable.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt einen Rollback aller Änderungen durch, die an der Tabelle seit dem Laden oder seit dem letzten Aufruf von <see cref="M:System.Data.DataTable.AcceptChanges" /> vorgenommen wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Data.DataTable.RejectChanges%2A> aufgerufen wird, eine <xref:System.Data.DataRow> Bearbeitungsvorgänge für Objekte, die immer noch im Bearbeitungsmodus sind abgebrochen. Neue Zeilen werden entfernt. Zeilen mit den <xref:System.Data.DataRowState> festgelegt `Modified` oder `Deleted` wieder auf den ursprünglichen Zustand zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel werden mehrere Änderungen an einer <xref:System.Data.DataTable>, jedoch die Änderungen abgelehnt, durch den Aufruf der <xref:System.Data.DataTable.RejectChanges%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Serialisierungsformat ab oder legt dieses fest.</summary>
        <value>Eine <see cref="T:System.Data.SerializationFormat" />-Enumeration, die <see langword="Binary" />- oder <see langword="Xml" />-Serialisierung angibt.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataTable.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="T:System.Data.DataTable" /> auf den ursprünglichen Zustand zurück. Zurücksetzen entfernt alle Daten, Indizes, Beziehungen und Spalten der Tabelle. Wenn ein DataSet ein DataTable umfasst, ist die Tabelle noch ein Teil des DataSet, nachdem die Tabelle zurückgesetzt ist.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberSignature Language="F#" Value="member this.RowChanged : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanged : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, nachdem eine <see cref="T:System.Data.DataRow" /> erfolgreich geändert wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberSignature Language="F#" Value="member this.RowChanging : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanging : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine <see cref="T:System.Data.DataRow" /> geändert wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberSignature Language="F#" Value="member this.RowDeleted : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleted : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem eine Zeile in der Tabelle gelöscht wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberSignature Language="F#" Value="member this.RowDeleting : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleting : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, bevor eine Zeile in der Tabelle gelöscht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter [Behandeln von DataTable-Ereignissen](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Rows : System.Data.DataRowCollection" Usage="System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der Zeilen ab, die zu dieser Tabelle gehören.</summary>
        <value>Eine <see cref="T:System.Data.DataRowCollection" />, die <see cref="T:System.Data.DataRow" />-Objekte enthält, andernfalls ein NULL-Wert, wenn keine <see cref="T:System.Data.DataRow" />-Objekte vorhanden sind.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Erstellen eines neuen <xref:System.Data.DataRow>, verwenden Sie die <xref:System.Data.DataTable.NewRow%2A> Methode, um ein neues Objekt zurückzugeben. Solche Objekte wird automatisch konfiguriert, gemäß dem Schema definiert die <xref:System.Data.DataTable> über deren Auflistung von <xref:System.Data.DataColumn> Objekte. Fügen Sie nach dem Erstellen einer neuen Zeile ein, und Festlegen der Werte für jede Spalte in der Zeile, die Zeile an die <xref:System.Data.DataRowCollection> mithilfe der `Add` Methode.  
  
 Jede <xref:System.Data.DataRow> in der Auflistung stellt eine Zeile mit Daten in der Tabelle. Um eine Änderung an den Wert einer Spalte in der Zeile zu übertragen, müssen Sie den Aufrufen der <xref:System.Data.DataTable.AcceptChanges%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt zwei Beispiele für zurückgeben und Festlegen von Zeilen. Im ersten Beispiel wird die <xref:System.Data.DataTable.Rows%2A> Eigenschaft und die Werte der einzelnen Spalten für jede Zeile ausgegeben. Im zweiten Beispiel wird die <xref:System.Data.DataTable> des Objekts <xref:System.Data.DataTable.NewRow%2A> Methode zum Erstellen eines neuen <xref:System.Data.DataRow> Objekt mit dem Schema der <xref:System.Data.DataTable>. Nach dem Festlegen der Werte der Zeile, die Zeile hinzugefügt wird die <xref:System.Data.DataRowCollection> über die `Add` Methode.  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein Array von <see cref="T:System.Data.DataRow" />-Objekten ab.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; System.Data.DataRow[]" Usage="dataTable.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein Array aller <see cref="T:System.Data.DataRow" />-Objekte ab.</summary>
        <returns>Ein Array von <see cref="T:System.Data.DataRow" />-Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die richtigen Sortierreihenfolge zu gewährleisten, geben Sie die Sortierkriterien mit <xref:System.Data.DataTable.Select%2A> oder <xref:System.Data.DataTable.Select%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel gibt ein Array von <xref:System.Data.DataRow> Objekte über die <xref:System.Data.DataTable.Select%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">NULL-Werte</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberSignature Language="F#" Value="member this.Select : string -&gt; System.Data.DataRow[]" Usage="dataTable.Select filterExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Die beim Filtern der Zeilen zu verwendenden Kriterien. Beispiele zum Filtern von Zeilen finden Sie unter [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <summary>Ruft ein Array aller <see cref="T:System.Data.DataRow" />-Objekte ab, die den Filterkriterien entsprechen.</summary>
        <returns>Ein Array von <see cref="T:System.Data.DataRow" />-Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zum Erstellen der `filterExpression` Argument verwenden, die für gelten dieselben Regeln die <xref:System.Data.DataColumn> Klasse <xref:System.Data.DataColumn.Expression%2A> Eigenschaftswert für das Erstellen von Filtern.  
  
 Um die richtigen Sortierreihenfolge zu gewährleisten, geben Sie die Sortierkriterien mit <xref:System.Data.DataTable.Select%2A> oder <xref:System.Data.DataTable.Select%2A>.  
  
 Wenn die Spalte für den Filter einen null-Wert enthält, werden sie nicht Teil des Ergebnisses.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen Filterausdruck, ein Array von zurückzugeben <xref:System.Data.DataRow> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">NULL-Werte</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Die beim Filtern der Zeilen zu verwendenden Kriterien. Beispiele zum Filtern von Zeilen finden Sie unter [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Eine Zeichenfolge, die die Spalte und die Sortierrichtung angibt.</param>
        <summary>Ruft ein Array aller <see cref="T:System.Data.DataRow" />-Objekte, die die Filterkriterien erfüllen, in der angegebenen Sortierreihenfolge ab.</summary>
        <returns>Ein Array von <see cref="T:System.Data.DataRow" />-Objekten, die dem Filterausdruck entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Form der `filterExpression` -Argument, verwenden Sie die gleichen Regeln zum Erstellen der <xref:System.Data.DataColumn> Klasse <xref:System.Data.DataColumn.Expression%2A> Eigenschaftswert. Die `Sort` Argument verwendet auch die gleichen Regeln für die Erstellung der Klasse <xref:System.Data.DataColumn.Expression%2A> Zeichenfolgen.  
  
 Wenn die Spalte für den Filter einen null-Wert enthält, werden sie nicht Teil des Ergebnisses.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen Filterausdruck, ein Array von zurückzugeben <xref:System.Data.DataRow> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">NULL-Werte</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string * System.Data.DataViewRowState -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort, recordStates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Die beim Filtern der Zeilen zu verwendenden Kriterien. Beispiele zum Filtern von Zeilen finden Sie unter [DataView RowFilter Syntax [C#]](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Eine Zeichenfolge, die die Spalte und die Sortierrichtung angibt.</param>
        <param name="recordStates">Einer der <see cref="T:System.Data.DataViewRowState" />-Werte.</param>
        <summary>Ruft ein Array aller <see cref="T:System.Data.DataRow" />-Objekte ab, die die Filterkriterien in der Sortierreihenfolge erfüllen und zum angegebenen Zustand passen.</summary>
        <returns>Ein Array von <see cref="T:System.Data.DataRow" />-Objekten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In Form der `filterExpression` -Argument, verwenden Sie die gleichen Regeln zum Erstellen der <xref:System.Data.DataColumn> Klasse <xref:System.Data.DataColumn.Expression%2A> Eigenschaftswert. Die `Sort` Argument verwendet auch die gleichen Regeln für die Erstellung der Klasse <xref:System.Data.DataColumn.Expression%2A> Zeichenfolgen.  
  
 Wenn die Spalte für den Filter einen null-Wert enthält, werden sie nicht Teil des Ergebnisses.  
  
   
  
## Examples  
 Im folgenden Beispiel wird einen Filter-Ausdruck und Datensatz-Zustand auf ein Array von zurückzugeben <xref:System.Data.DataRow> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">NULL-Werte</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.ComponentModel.ISite" /> für den <see cref="T:System.Data.DataTable" /> ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.ComponentModel.ISite" /> für das <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites binden ein <xref:System.ComponentModel.Component> auf eine <xref:System.ComponentModel.Container> und ermöglichen die Kommunikation zwischen diesen sowie bieten eine Möglichkeit für den Container, seine Komponenten zu verwalten.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>
          <see langword="true" />, wenn die Auflistung eine Auflistung von <see cref="T:System.Collections.IList" />-Objekten ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataTable>-Instanz in eine <xref:System.ComponentModel.IListSource>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Eine <see cref="T:System.Collections.IList" />, die an eine Datenquelle eines Objekts gebunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataTable>-Instanz in eine <xref:System.ComponentModel.IListSource>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">To be added.</param>
        <param name="context">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Ein <see cref="T:System.Xml.Schema.XmlSchema" /> zur Beschreibung der XML-Darstellung des Objekts, das von der <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />-Methode erstellt und von der <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />-Methode verwendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein XmlReader.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Ein XmlWriter.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberSignature Language="F#" Value="member this.TableCleared : System.Data.DataTableClearEventHandler " Usage="member this.TableCleared : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, nachdem eine <see cref="T:System.Data.DataTable" /> gelöscht wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.TableCleared> Ereignis wird ausgelöst, sobald alle Zeilen, jedoch bevor wurde erfolgreich gelöscht wurde die <xref:System.Data.DataTable.Clear%2A> -Methode die Steuerung an den Aufrufer zurückgibt. Die <xref:System.Data.DataTable.TableCleared> Ereignis wird nicht ausgelöst, wenn Ausnahmen vorhanden, während des Vorgangs löschen sind.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberSignature Language="F#" Value="member this.TableClearing : System.Data.DataTableClearEventHandler " Usage="member this.TableClearing : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine <see cref="T:System.Data.DataTable" /> gelöscht wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.TableClearing> Ereignis wird ausgelöst, bevor die Verarbeitung der der <xref:System.Data.DataTable.Clear%2A> Vorgang beginnt. Dieses Ereignis wird immer ausgelöst, wenn die <xref:System.Data.DataTable.Clear%2A> Methode wird aufgerufen, selbst wenn die Tabelle keine Zeilen enthält.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableTableNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen der <see cref="T:System.Data.DataTable" /> ab oder legt diesen fest.</summary>
        <value>Der Name des <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.TableName%2A> wird verwendet, um diese Tabelle aus dem übergeordneten Element zurückgeben <xref:System.Data.DataSet> des Objekts <xref:System.Data.DataTableCollection> (zurückgegebenes der <xref:System.Data.DataSet.Tables%2A> Eigenschaft).  
  
   
  
## Examples  
 Das folgende Beispiel gibt die <xref:System.Data.DataTable.TableName%2A> für jede Tabelle in einer Auflistung von <xref:System.Data.DataTable> Objekte.  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Es wird <see langword="null" /> oder eine leere Zeichenfolge ("") übergeben, und diese Tabelle gehört zu einer Auflistung.</exception>
        <exception cref="T:System.Data.DuplicateNameException">Die Tabelle gehört zu einer Auflistung, die bereits eine Tabelle mit demselben Namen enthält. (Beim Vergleich wird die Groß- und Kleinschreibung berücksichtigt.)</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberSignature Language="F#" Value="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " Usage="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine neue <see cref="T:System.Data.DataRow" /> eingefügt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wird ausgelöst, nachdem ein neues <xref:System.Data.DataRow> wurde mit <xref:System.Data.DataTable.NewRow%2A>. Dieses Ereignis wird ausgelöst, bevor die aufgerufene `NewRow` Methodenrückgabe. Die neue <xref:System.Data.DataRow> Instanz getrennt ist; sie nicht zur Auflistung hinzugefügt wurde.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Arbeiten mit DataTable-Ereignissen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="dataTable.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den <see cref="P:System.Data.DataTable.TableName" /> und den <see cref="P:System.Data.DataTable.DisplayExpression" />, sofern vorhanden, als verkettete Zeichenfolge ab.</summary>
        <returns>Eine Zeichenfolge, die aus dem <see cref="P:System.Data.DataTable.TableName" />-Wert und dem <see cref="P:System.Data.DataTable.DisplayExpression" />-Wert besteht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ruft die <xref:System.Data.DataTable.TableName%2A> und <xref:System.Data.DataTable.DisplayExpression%2A> für die <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 Das folgende Beispiel gibt die <xref:System.Data.DataTable.TableName%2A> und <xref:System.Data.DataTable.DisplayExpression%2A> mithilfe der <xref:System.Data.DataTable.ToString%2A> Methode.  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt den aktuellen Inhalt der <see cref="T:System.Data.DataTable" /> als XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> -Instanzen, die jeweils hinzugefügt, ein <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXml%2A> -Methode zum Schreiben von Daten, die in der übergeordneten Tabelle, eine <xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
> [!NOTE]
>  Dieses Beispiel zeigt, wie Sie eine der überladenen Versionen von WriteXml verwenden. Andere Beispiele, die möglicherweise verfügbar sind, finden Sie unter den einzelnen Überladung Themen.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, in den die Daten geschrieben werden.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.IO.Stream" /> im XML-Format.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die umfasst die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" />, mit dem der Inhalt geschrieben werden soll.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.IO.TextWriter" /> im XML-Format.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die umfasst die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataTable.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Die Datei, in die die XML-Daten geschrieben werden sollen.</param>
        <summary>Schreibt den aktuellen Inhalt der <see cref="T:System.Data.DataTable" /> als XML mit der angegebenen Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die umfasst die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der <see cref="T:System.Xml.XmlWriter" />, mit dem der Inhalt geschrieben werden soll.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.Xml.XmlWriter" /> im XML-Format.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXml (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, in den die Daten geschrieben werden.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird der Inhalt der aktuellen Tabelle und ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), werden nur die Daten der aktuellen Tabelle geschrieben.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.IO.Stream" /> im XML-Format. Legen Sie zum Speichern der Daten für die Tabelle und ihre Nachfolgerelemente den <paramref name="writeHierarchy" />-Parameter auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode zum Schreiben des Schemas für eine <xref:System.Data.DataTable> als XML-Dokument. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und aller untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, in den die Daten geschrieben werden.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt im angegebenen <see cref="T:System.Data.DataTable" /> die aktuellen Daten und bei Bedarf das Schema für die <see cref="T:System.Data.XmlWriteMode" /> in die angegebene Datei. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die umfasst die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" />, mit dem der Inhalt geschrieben werden soll.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird der Inhalt der aktuellen Tabelle und ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), werden nur die Daten der aktuellen Tabelle geschrieben.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.IO.TextWriter" /> im XML-Format. Legen Sie zum Speichern der Daten für die Tabelle und ihre Nachfolgerelemente den <paramref name="writeHierarchy" />-Parameter auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die umfasst die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und alle seine zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> -Instanzen, die jeweils hinzugefügt, ein <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXml%2A> -Methode zum Schreiben von Daten, die in der übergeordneten Tabelle, eine <xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter `true`.  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Der zum Schreiben des Dokuments verwendete <see cref="T:System.IO.TextWriter" />.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt mit dem angegebenen <see cref="T:System.Data.DataTable" /> und im angegebenen <see cref="T:System.IO.TextWriter" /> die aktuellen Daten und bei Bedarf das Schema für die <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die umfasst die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Die Datei, in die die XML-Daten geschrieben werden sollen.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird der Inhalt der aktuellen Tabelle und ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), werden nur die Daten der aktuellen Tabelle geschrieben.</param>
        <summary>Schreibt den aktuellen Inhalt der <see cref="T:System.Data.DataTable" /> als XML mit der angegebenen Datei. Legen Sie zum Speichern der Daten für die Tabelle und ihre Nachfolgerelemente den <paramref name="writeHierarchy" />-Parameter auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die umfasst die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und aller untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, in die die Daten geschrieben werden.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt mit der angegebenen Datei und im angegebenen <see cref="T:System.Data.DataTable" /> die aktuellen Daten und bei Bedarf das Schema für das <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Der <see cref="T:System.Xml.XmlWriter" />, mit dem der Inhalt geschrieben werden soll.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird der Inhalt der aktuellen Tabelle und ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), werden nur die Daten der aktuellen Tabelle geschrieben.</param>
        <summary>Schreibt den aktuellen Inhalt des <see cref="T:System.Data.DataTable" /> mithilfe des angegebenen <see cref="T:System.Xml.XmlWriter" /> im XML-Format.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und die gesamte zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Der zum Schreiben des Dokuments verwendete <see cref="T:System.Xml.XmlWriter" />.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt mit dem angegebenen <see cref="T:System.Data.DataTable" /> und im angegebenen <see cref="T:System.Xml.XmlWriter" /> die aktuellen Daten und bei Bedarf das Schema für die <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (stream, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, in den die Daten geschrieben werden.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird der Inhalt der aktuellen Tabelle und ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), werden nur die Daten der aktuellen Tabelle geschrieben.</param>
        <summary>Schreibt im angegebenen <see cref="T:System.Data.DataTable" /> die aktuellen Daten und bei Bedarf das Schema für die <see cref="T:System.Data.XmlWriteMode" /> in die angegebene Datei. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest. Legen Sie zum Speichern der Daten für die Tabelle und ihre Nachfolgerelemente den <paramref name="writeHierarchy" />-Parameter auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer `DataTable` in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die umfasst die `XmlWriteMode` Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 In der Regel die `WriteXml` Methode speichert Daten nur für die aktuelle Tabelle. Die `WriteXml` Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer `DataTable` in eine XML-Dokument, während die `WriteXmlSchema` Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die umfasst die `XmlWriteMode` Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und aller untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Der zum Schreiben des Dokuments verwendete <see cref="T:System.IO.TextWriter" />.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird der Inhalt der aktuellen Tabelle und ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), werden nur die Daten der aktuellen Tabelle geschrieben.</param>
        <summary>Schreibt mit dem angegebenen <see cref="T:System.Data.DataTable" /> und im angegebenen <see cref="T:System.IO.TextWriter" /> die aktuellen Daten und bei Bedarf das Schema für die <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest. Legen Sie zum Speichern der Daten für die Tabelle und ihre Nachfolgerelemente den <paramref name="writeHierarchy" />-Parameter auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die umfasst die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 In der Regel die `WriteXml` Methode speichert Daten nur für die aktuelle Tabelle. Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die umfasst die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Zum Schreiben der Daten für die aktuelle Tabelle und aller untergeordneten verknüpfte Tabellen, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> -Instanzen, die jeweils hinzugefügt, ein <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXml%2A> -Methode zum Schreiben von Daten, die in der übergeordneten Tabelle, eine <xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, in die die Daten geschrieben werden.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird der Inhalt der aktuellen Tabelle und ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), werden nur die Daten der aktuellen Tabelle geschrieben.</param>
        <summary>Schreibt mit der angegebenen Datei und im angegebenen <see cref="T:System.Data.DataTable" /> die aktuellen Daten und bei Bedarf das Schema für das <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest. Legen Sie zum Speichern der Daten für die Tabelle und ihre Nachfolgerelemente den <paramref name="writeHierarchy" />-Parameter auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 In der Regel die `WriteXml` Methode speichert Daten nur für die aktuelle Tabelle. Sollten Sie die Daten für die aktuelle Tabelle und alle Schemas, zu speichern die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und alle abhängigen verknüpften Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Der zum Schreiben des Dokuments verwendete <see cref="T:System.Xml.XmlWriter" />.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird der Inhalt der aktuellen Tabelle und ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), werden nur die Daten der aktuellen Tabelle geschrieben.</param>
        <summary>Schreibt mit dem angegebenen <see cref="T:System.Data.DataTable" /> und im angegebenen <see cref="T:System.Xml.XmlWriter" /> die aktuellen Daten und bei Bedarf das Schema für die <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest. Legen Sie zum Speichern der Daten für die Tabelle und ihre Nachfolgerelemente den <paramref name="writeHierarchy" />-Parameter auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.WriteXml%2A> Methode bietet eine Möglichkeit, entweder ausschließlich Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataTable> in eine XML-Dokument, während die <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, verwenden Sie eine der Überladungen, die enthalten die <xref:System.Data.XmlWriteMode> Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataTable.ReadXml%2A> und <xref:System.Data.DataTable.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in die `DataTable`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
 Normalerweise die `WriteXml` Methode schreibt die Daten nur für die aktuelle Tabelle. Um die Daten für die aktuelle Tabelle und die gesamte zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in einer der `DataRow` , die gelesen oder geschrieben, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als XML-Schema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode zum Schreiben des Schemas für eine <xref:System.Data.DataTable> als XML-Dokument. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> -Instanzen, die jeweils hinzugefügt, ein <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode zum Schreiben von Daten, die in der übergeordneten Tabelle, eine <xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
> [!NOTE]
>  Dieses Beispiel zeigt, wie Sie mit einer der überladenen Versionen der `WriteXmlSchema` weiterer Beispiele, die möglicherweise verfügbar sind, finden Sie unter den einzelnen Überladung Themen.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, in den das XML-Schema geschrieben wird.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als XML-Schema in den angegebenen Stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode zum Schreiben des Schemas für eine <xref:System.Data.DataTable> als XML-Dokument. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der <see cref="T:System.IO.TextWriter" />, mit dem geschrieben werden soll.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als XML-Schema unter Verwendung des angegebenen <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode zum Schreiben des Schemas für eine <xref:System.Data.DataTable> als XML-Dokument. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataTable.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der zu verwendenden Datei.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als XML-Schema in die angegebene Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode zum Schreiben des Schemas für eine <xref:System.Data.DataTable> als XML-Dokument. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der zu verwendende <see cref="T:System.Xml.XmlWriter" />.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als XML-Schema unter Verwendung des angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode zum Schreiben des Schemas für eine <xref:System.Data.DataTable> als XML-Dokument. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Der Stream, in den das XML-Schema geschrieben wird.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird das Schema der aktuellen Tabelle und aller ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), wird nur das Schema für die aktuelle Tabelle geschrieben.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als XML-Schema in den angegebenen Stream. Legen Sie zum Speichern des Schemas für die Tabelle und ihre Nachfolgerelemente den <paramref name="writeHierarchy" />-Parameter auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode zum Schreiben des Schemas für eine <xref:System.Data.DataTable> als XML-Dokument. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` -Methode das Schema nur für die aktuelle Tabelle geschrieben. Um das Schema für die aktuelle Tabelle und die gesamte zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Der <see cref="T:System.IO.TextWriter" />, mit dem geschrieben werden soll.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird das Schema der aktuellen Tabelle und aller ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), wird nur das Schema für die aktuelle Tabelle geschrieben.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als XML-Schema unter Verwendung des angegebenen <see cref="T:System.IO.TextWriter" />. Legen Sie zum Speichern des Schemas für die Tabelle und ihre Nachfolgerelemente den <paramref name="writeHierarchy" />-Parameter auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode zum Schreiben des Schemas für eine <xref:System.Data.DataTable> als XML-Dokument. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` -Methode das Schema nur für die aktuelle Tabelle geschrieben. Um das Schema für die aktuelle Tabelle und die gesamte zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
   
  
## Examples  
 Die folgende Konsolenanwendung erstellt zwei <xref:System.Data.DataTable> -Instanzen, die jeweils hinzugefügt, ein <xref:System.Data.DataSet>, erstellt eine <xref:System.Data.DataRelation> verknüpfen die beiden Tabellen und verwendet dann die <xref:System.Data.DataTable.WriteXmlSchema%2A> -Methode zum Schreiben von Daten, die in der übergeordneten Tabelle, eine <xref:System.IO.TextWriter>. Das Beispiel veranschaulicht das Verhalten beim Festlegen der `writeHierarchy` Parameter für jeden seiner Werte.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 Im Beispiel wird die folgende Ausgabe im Konsolenfenster angezeigt:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der zu verwendenden Datei.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird das Schema der aktuellen Tabelle und aller ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), wird nur das Schema für die aktuelle Tabelle geschrieben.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als XML-Schema in die angegebene Datei. Legen Sie zum Speichern des Schemas für die Tabelle und ihre Nachfolgerelemente den <paramref name="writeHierarchy" />-Parameter auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode zum Schreiben des Schemas für eine <xref:System.Data.DataTable> als XML-Dokument. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` -Methode das Schema nur für die aktuelle Tabelle geschrieben. Um das Schema für die aktuelle Tabelle und die gesamte zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Der zum Schreiben des Dokuments verwendete <see cref="T:System.Xml.XmlWriter" />.</param>
        <param name="writeHierarchy">Wenn <see langword="true" />, wird das Schema der aktuellen Tabelle und aller ihrer Nachfolgerelemente geschrieben. Wenn <see langword="false" /> (der Standardwert), wird nur das Schema für die aktuelle Tabelle geschrieben.</param>
        <summary>Schreibt die aktuelle Datenstruktur der <see cref="T:System.Data.DataTable" /> als XML-Schema unter Verwendung des angegebenen <see cref="T:System.Xml.XmlWriter" />. Legen Sie zum Speichern des Schemas für die Tabelle und ihre Nachfolgerelemente den <paramref name="writeHierarchy" />-Parameter auf <see langword="true" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataTable.WriteXmlSchema%2A> Methode zum Schreiben des Schemas für eine <xref:System.Data.DataTable> als XML-Dokument. Das Schema enthält die Tabelle, Beziehungs-und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden Sie die <xref:System.Data.DataTable.WriteXml%2A> Methode.  
  
 Normalerweise die `WriteXmlSchema` -Methode das Schema nur für die aktuelle Tabelle geschrieben. Um das Schema für die aktuelle Tabelle und die gesamte zugehörigen Tabellen zu schreiben, rufen Sie die Methode mit dem `writeHierarchy` Parametersatz zu `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Erstellen und Verwenden von DataTables</related>
      </Docs>
    </Member>
  </Members>
</Type>