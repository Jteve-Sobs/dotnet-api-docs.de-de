<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5e84607c810b7307a449ac176f00e6a7a789c10a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36680145" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataSet = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen speicherresidenten Datencache dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet>, eine Hauptkomponente der ADO.NET-Architektur ist ein in-Memory-Cache von Daten aus einer Datenquelle abgerufen wird. Die <xref:System.Data.DataSet> besteht aus einer Auflistung von <xref:System.Data.DataTable> Objekte, die Sie mit miteinander verknüpft sein können <xref:System.Data.DataRelation> Objekte. Sie können auch Erzwingen der Datenintegrität in den <xref:System.Data.DataSet> mithilfe der <xref:System.Data.UniqueConstraint> und <xref:System.Data.ForeignKeyConstraint> Objekte. Weitere Informationen zum Arbeiten mit <xref:System.Data.DataSet> anzuzeigen, [DataSets und Datentabellen "DataViews"](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md).  
  
 Während <xref:System.Data.DataTable> Objekte enthalten, die Daten der <xref:System.Data.DataRelationCollection> können Sie Navigieren in der Tabellenhierarchie. Die Tabellen sind in enthalten eine <xref:System.Data.DataTableCollection> erfolgt über die <xref:System.Data.DataSet.Tables%2A> Eigenschaft. Beim Zugriff auf <xref:System.Data.DataTable> Objekte, beachten Sie, dass sie bedingt Groß-/Kleinschreibung unterschieden werden. Angenommen, eine <xref:System.Data.DataTable> "Mydatatable" benannt ist und eine andere "Mydatatable" benannt ist, wird in eine Zeichenfolge, die zur Suche nach einer der Tabellen die Groß-/ Kleinschreibung. Allerdings wird Wenn "Mydatatable" vorhanden ist, und "Mydatatable", nicht aber, die zu suchende Zeichenfolge wie Groß-/Kleinschreibung beachten betrachtet. Weitere Informationen zum Arbeiten mit <xref:System.Data.DataTable> anzuzeigen, [Erstellen einer "DataTable"](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Ein <xref:System.Data.DataSet> lesen und Schreiben von Daten und das Schema als XML-Dokumente können. Die Daten und das Schema können von einer Anwendung, auf jeder Plattform, die XML-fähig ist dann über HTTP transportiert und verwendet werden. Speichern Sie das Schema als ein XML-Schema mit dem <xref:System.Data.DataSet.WriteXmlSchema%2A> -Methode, und Schema und Daten können gespeichert werden die <xref:System.Data.DataSet.WriteXml%2A> Methode. Verwenden Sie zum Lesen eines XML-Dokuments, das Schema und Daten umfasst die <xref:System.Data.DataSet.ReadXml%2A> Methode.  
  
 In einer typischen mehreren Ebenen, die Schritte zum Erstellen und Aktualisieren einer <xref:System.Data.DataSet>, zu denen wiederum das Aktualisieren der ursprünglichen Daten auf:  
  
1.  Erstellen und füllen Sie jede <xref:System.Data.DataTable> in einem <xref:System.Data.DataSet> mit Daten aus einer Datenquelle mit einem <xref:System.Data.Common.DataAdapter>.  
  
2.  Ändern Sie die Daten in einzelnen <xref:System.Data.DataTable> Objekte hinzufügen, aktualisieren oder Löschen von <xref:System.Data.DataRow> Objekte.  
  
3.  Aufrufen der <xref:System.Data.DataSet.GetChanges%2A> Methode, um eine zweite <xref:System.Data.DataSet> features zur Verfügung, nur die Änderungen an den Daten.  
  
4.  Rufen Sie die <xref:System.Data.Common.DataAdapter.Update%2A> Methode der <xref:System.Data.Common.DataAdapter>, übergeben Sie das zweite <xref:System.Data.DataSet> als Argument.  
  
5.  Aufrufen der <xref:System.Data.DataSet.Merge%2A> Methode, um die Änderungen aus dem zweiten zusammenzuführen <xref:System.Data.DataSet> mit dem ersten.  
  
6.  Aufrufen der <xref:System.Data.DataSet.AcceptChanges%2A> auf die <xref:System.Data.DataSet>. Alternativ Aufrufen <xref:System.Data.DataSet.RejectChanges%2A> um die Änderungen abzubrechen.  
  
> [!NOTE]
>  Die <xref:System.Data.DataSet> und <xref:System.Data.DataTable> Objekte erben von <xref:System.ComponentModel.MarshalByValueComponent>, und unterstützt die <xref:System.Runtime.Serialization.ISerializable> Schnittstelle für das Remoting. Dies sind die einzigen ADO.NET-Objekte, die remotingfähig sind.  
  
> [!NOTE]
>  Von Klassen geerbt <xref:System.Data.DataSet> werden nicht vom Garbage Collector finalisiert, da der Finalizer in unterdrückt wurden <xref:System.Data.DataSet>. Die abgeleitete Klasse aufrufen, kann die <xref:System.GC.ReRegisterForFinalize%2A> Methode in seinem Konstruktor auf die Klasse durch den Garbage Collector freigegeben werden kann.  
  
   
  
## Examples  
 Im folgende Beispiel besteht aus mehreren Methoden, die in Kombination erstellen und Füllen einer <xref:System.Data.DataSet> aus der **Northwind** Datenbank.  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist für schreibgeschützte Vorgänge mit mehreren Threads sicher. Sie müssen alle Schreibvorgänge synchronisieren.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataSet" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataSet" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Implementierung der <xref:System.Data.DataSet> Konstruktor nimmt keine Parameter und einen Standardnamen "NewDataSet", für die neue Instanz erstellt.  
  
 Einen Namen für die <xref:System.Data.DataSet> ist erforderlich, um sicherzustellen, dass die XML-Darstellung der <xref:System.Data.DataSet> verfügt immer über einen Namen für das Dokumentelement das oberste Element in einer Schemadefinition ist.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Data.DataSet>, und fügt zwei <xref:System.Data.DataTable> Objekte.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : string -&gt; System.Data.DataSet" Usage="new System.Data.DataSet dataSetName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">Der Name des <see cref="T:System.Data.DataSet" />.</param>
        <summary>Initialisiert eine neue Instanz einer <see cref="T:System.Data.DataSet" />-Klasse mit dem angegebenen Namen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einen Namen für die <xref:System.Data.DataSet> ist erforderlich, um sicherzustellen, dass die XML-Darstellung der <xref:System.Data.DataSet> verfügt immer über einen Namen für das Dokumentelement der höchsten Level-Element in einer Schemadefinition ist.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Data.DataSet>, dem zwei <xref:System.Data.DataTable> Objekte werden hinzugefügt.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Die zum Serialisieren bzw. Deserialisieren eines Objekts benötigten Daten.</param>
        <param name="context">Die Quelle und das Ziel eines angegebenen serialisierten Streams.</param>
        <summary>Initialisiert eine neue Instanz einer <see cref="T:System.Data.DataSet" />-Klasse, die über die angegebenen Serialisierungsinformationen und den angegebenen Kontext verfügt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext * bool -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context, ConstructSchema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info">Das <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt.</param>
        <param name="context">Das <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt.</param>
        <param name="ConstructSchema">Der boolesche Wert.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Data.DataSet" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataSet.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt einen Commit für alle Änderungen aus, die an diesem <see cref="T:System.Data.DataSet" /> seit dem letzten Ladevorgang oder seit dem letzten Aufruf von <see cref="M:System.Data.DataSet.AcceptChanges" /> vorgenommen wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sowohl die <xref:System.Data.DataRow> und <xref:System.Data.DataTable> Klassen verfügen über <xref:System.Data.DataSet.AcceptChanges%2A> Methoden. Aufrufen von <xref:System.Data.DataTable.AcceptChanges%2A> an die <xref:System.Data.DataTable> -Ebene wird die <xref:System.Data.DataRow.AcceptChanges%2A> Methode für jede <xref:System.Data.DataRow> aufgerufen werden. Auf ähnliche Weise aufrufen <xref:System.Data.DataSet.AcceptChanges%2A> auf die <xref:System.Data.DataSet> bewirkt, dass <xref:System.Data.DataTable.AcceptChanges%2A> aufzurufenden für jede Tabelle in der <xref:System.Data.DataSet>. Auf diese Weise haben Sie mehrere Ebenen, die an denen die Methode aufgerufen werden kann. Aufrufen der <xref:System.Data.DataSet.AcceptChanges%2A> von der <xref:System.Data.DataSet> können Sie die Methode für alle untergeordneten Objekte (z. B. Tabellen und Zeilen) mit einem Aufruf aufrufen.  
  
 Beim Aufruf `AcceptChanges` auf die `DataSet`, stellen alle <xref:System.Data.DataRow> Objekte immer noch im Bearbeitungsmodus Bearbeitungsvorgänge erfolgreich beendet. Die <xref:System.Data.DataRow.RowState%2A> -Eigenschaft jedes <xref:System.Data.DataRow> ändert sich auch; `Added` und `Modified` Zeilen werden `Unchanged`, und `Deleted` Zeilen entfernt werden.  
  
 Wenn die `DataSet` enthält <xref:System.Data.ForeignKeyConstraint> Objekte Aufrufen der `AcceptChanges` Methode bewirkt auch, dass die <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> erzwungen werden.  
  
> [!NOTE]
>  `AcceptChanges` und `RejectChanges` gelten nur für `DataRow` ähnlicher Änderungen (d. h. hinzufügen, entfernen, löschen und ändern). Sie gelten nicht für Schema oder strukturelle Änderungen.  
>   
>  AcceptChanges aufrufen repliziert diese Änderungen an der Datenquelle nicht das DataSet mit "DataAdapter" ausgeführt wurde. In diesem Fall rufen <xref:System.Data.Common.DataAdapter.Update%2A> stattdessen. Finden Sie unter [Aktualisieren von Datenquellen mit "DataAdapters"](http://msdn.microsoft.com/library/33y2221y.aspx) für Weitere Informationen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Data.DataRow> auf eine <xref:System.Data.DataTable> in einem <xref:System.Data.DataSet>. Die <xref:System.Data.DataSet.AcceptChanges%2A> Methode wird aufgerufen, auf die <xref:System.Data.DataSet>, welche nacheinander auf alle <xref:System.Data.DataTable> darin enthaltenen Objekte.  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataSet.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Initialisierung einer <see cref="T:System.Data.DataSet" />, die in einem Formular oder von einer anderen Komponente verwendet wird. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die entwurfsumgebung für Visual Studio .NET verwendet diese Methode, um die Initialisierung einer Komponente zu starten, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Data.DataSet.EndInit%2A> -Methode beendet die Initialisierung. Mithilfe der <xref:System.Data.DataSet.BeginInit%2A> und <xref:System.Data.DataSet.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob bei Zeichenfolgenvergleichen in <see cref="T:System.Data.DataTable" />-Objekten die Groß- und Kleinschreibung berücksichtigt wird, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn bei Zeichenfolgenvergleichen die Groß- und Kleinschreibung berücksichtigt wird, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.CaseSensitive%2A> Eigenschaft wirkt sich auf ausgeführt wie sortieren, suchen und Filtern von Vorgängen auf jedem <xref:System.Data.DataTable> in enthaltenes Objekt eine <xref:System.Data.DataSet> bei Verwendung der <xref:System.Data.DataTable.Select%2A> Methode.  
  
 Standardmäßig Festlegen der <xref:System.Data.DataSet.CaseSensitive%2A> -Eigenschaft für eine <xref:System.Data.DataSet> setzt auch die <xref:System.Data.DataTable.CaseSensitive%2A> -Eigenschaft jeder zugeordneten <xref:System.Data.DataTable> auf den gleichen Wert.  
  
   
  
## Examples  
 Das folgende Beispiel schaltet die <xref:System.Data.DataSet.CaseSensitive%2A> Eigenschaft.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Daten aus dem <see cref="T:System.Data.DataSet" />, indem alle Zeilen in sämtlichen Tabellen entfernt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Data.DataSet> gebunden ist ein <xref:System.Xml.XmlDataDocument>Aufrufen <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> oder <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> löst die <xref:System.NotSupportedException>. Um diese Situation zu vermeiden, Durchsuchen Sie jede Tabelle, entfernen Sie jede Zeile zu einem Zeitpunkt.  
  
   
  
## Examples  
 Das folgende Beispiel löscht die <xref:System.Data.DataSet> aller Zeilen in allen Tabellen.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataSet&#xA;override this.Clone : unit -&gt; System.Data.DataSet" Usage="dataSet.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Struktur des <see cref="T:System.Data.DataSet" />, einschließlich aller Schemas, Beziehungen und Einschränkungen von <see cref="T:System.Data.DataTable" />. Es werden keine Daten kopiert.</summary>
        <returns>Ein neues <see cref="T:System.Data.DataSet" /> mit demselben Schema wie das aktuelle <see cref="T:System.Data.DataSet" />, jedoch nicht mit den darin enthaltenen Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Wenn Sie diese Klassen als Unterklasse haben, wird der Klon denselben Unterklassen aufweisen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt einen Klon einer <xref:System.Data.DataSet> Objektschemas.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataSet" Usage="dataSet.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiert die Struktur und die Daten für diese <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Ein neues <see cref="T:System.Data.DataSet" /> mit derselben Struktur (Tabellenschemas, -beziehungen und -einschränkungen) und denselben Daten wie dieses <see cref="T:System.Data.DataSet" />.  
  
 <block subset="none" type="note"><para>: Wenn diese Klassen in Unterklassen unterteilt wurden, besteht die Kopie aus denselben Unterklassen. </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataSet.Copy%2A> Methode zum Erstellen einer Kopie des Originals <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen <see cref="T:System.Data.DataTableReader" /> mit einem Resultset pro <see cref="T:System.Data.DataTable" /> zurück, und zwar in der Reihenfolge der Tabellen in der <see cref="P:System.Data.DataSet.Tables" />-Auflistung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um sicherzustellen, dass die Reihenfolge der Resultsets im zurückgegebenen <xref:System.Data.DataTableReader>, wenn eine <xref:System.Data.DataTable> innerhalb der <xref:System.Data.DataSet> ist leer, es dargestellt wird durch ein leeres Resultset im zurückgegebenen `DataTableReader`.  
  
   
  
## Examples  
 Diesem Beispiel wird eine Konsolenanwendung erstellt drei <xref:System.Data.DataTable> Instanzen und fügt Sie jedes Element eine <xref:System.Data.DataSet>. Im Beispiel wird die <xref:System.Data.DataSet.CreateDataReader%2A> -Methode und zeigt den Inhalt des zurückgegebenen <xref:System.Data.DataTableReader>. Beachten Sie, dass die Reihenfolge des Ergebnisses in der `DataTableReader` wird gesteuert, von der Reihenfolge der der `DataTable` Instanzen als Parameter übergeben.  
  
> [!NOTE]
>  In diesem Beispiel wird gezeigt, wie mit einer der überladenen Versionen der `CreateDataReader`. Weitere Beispiele für die Verfügbarkeit, finden Sie unter den einzelnen Überladung-Themen.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 Im Beispiel wird den folgenden Code im Konsolenfenster angezeigt:  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see cref="T:System.Data.DataTableReader" /> mit einem Resultset pro <see cref="T:System.Data.DataTable" /> zurück, und zwar in der Reihenfolge der Tabellen in der <see cref="P:System.Data.DataSet.Tables" />-Auflistung.</summary>
        <returns>Ein <see cref="T:System.Data.DataTableReader" /> mit einem oder mehreren Resultsets, die den im Quell-<see cref="T:System.Data.DataTable" /> enthaltenen <see cref="T:System.Data.DataSet" />-Instanzen entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um sicherzustellen, dass die Reihenfolge der Resultsets im zurückgegebenen <xref:System.Data.DataTableReader>, wenn eine <xref:System.Data.DataTable> innerhalb der <xref:System.Data.DataSet> ist leer, dieser wird durch dargestellt eines leeren Resultsets im zurückgegebenen `DataTableReader`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt drei <xref:System.Data.DataTable> Instanzen und fügt Sie jedes Element eine <xref:System.Data.DataSet>. Im Beispiel übergibt dann das ausgefüllte `DataSet` an eine Prozedur, die Aufrufe der <xref:System.Data.DataSet.CreateDataReader%2A> -Methode und fährt zum iterieren durch alle Resultsets, die als Bestandteil der <xref:System.Data.DataTableReader>. Das Beispiel zeigt die Ergebnisse im Konsolenfenster angezeigt.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader dataTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">Ein Array von DataTables, das die Reihenfolge der im <see cref="T:System.Data.DataTableReader" /> zurückzugebenden Resultsets angibt.</param>
        <summary>Gibt einen <see cref="T:System.Data.DataTableReader" /> mit einem Resultset pro <see cref="T:System.Data.DataTable" /> zurück.</summary>
        <returns>Ein <see cref="T:System.Data.DataTableReader" /> mit einem oder mehreren Resultsets, die den im Quell-<see cref="T:System.Data.DataTable" /> enthaltenen <see cref="T:System.Data.DataSet" />-Instanzen entsprechen. Die Resultsets werden in der vom <paramref name="dataTables" />-Parameter angegebenen Reihenfolge zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um sicherzustellen, dass die Reihenfolge des Ergebnisses im zurückgegebenen legt <xref:System.Data.DataTableReader>, wenn eine <xref:System.Data.DataTable> innerhalb der <xref:System.Data.DataSet> ist leer ist, wird durch dargestellt ein leeres Resultset im zurückgegebenen `DataTableReader`. Da diese überladene Version Sie eine Liste der bereitstellen kann `DataTable` Instanzen als Parameter, geben Sie die Reihenfolge der Resultsets im zurückgegebenen `DataTableReader`.  
  
   
  
## Examples  
 Diesem Beispiel wird eine Konsolenanwendung erstellt drei <xref:System.Data.DataTable> Instanzen und fügt Sie jedes Element eine <xref:System.Data.DataSet>. Im Beispiel wird die <xref:System.Data.DataSet.CreateDataReader%2A> -Methode und zeigt den Inhalt des zurückgegebenen <xref:System.Data.DataTableReader>. Beachten Sie, dass die Reihenfolge des Ergebnisses in der `DataTableReader` wird gesteuert, von der Reihenfolge der der `DataTable` Instanzen als Parameter übergeben. Das Beispiel zeigt die Ergebnisse im Konsolenfenster angezeigt.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSetName : string with get, set" Usage="System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des aktuellen <see cref="T:System.Data.DataSet" /> ab oder legt diesen fest.</summary>
        <value>Der Name des <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Data.DataSet> mit der angegebenen <xref:System.Data.DataSet.DataSetName%2A>.  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultViewManager : System.Data.DataViewManager" Usage="System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine benutzerdefinierte Ansicht der im <see cref="T:System.Data.DataSet" /> enthaltenen Daten ab, mit der unter Verwendung eines benutzerdefinierten <see cref="T:System.Data.DataViewManager" /> gefiltert, gesucht und navigiert werden kann.</summary>
        <value>Ein <see cref="T:System.Data.DataViewManager" />-Objekt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataViewManager> zurückgegebenes der <xref:System.Data.DataSet.DefaultViewManager%2A> Eigenschaft ermöglicht Ihnen die Erstellung von benutzerdefinierten Einstellungen für die einzelnen <xref:System.Data.DataTable> in der <xref:System.Data.DataSet>.  
  
 Beim Erwerb einer <xref:System.Data.DataView> aus eine <xref:System.Data.DataTable>, die Sortierreihenfolge, Filter, und <xref:System.Data.DataViewRowState> konfiguriert sind, gemäß den Einstellungen in der <xref:System.Data.DataSet.DefaultViewManager%2A> Eigenschaft.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Standardeinstellung <xref:System.Data.DataViewManager> für eine <xref:System.Data.DataSet>, und fügt eine <xref:System.Data.DataTable> auf die <xref:System.Data.DataTableCollection>.  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt den <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> für ein <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn eine typisierte Deserialisierung <xref:System.Data.DataSet> bestimmen die <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Xml.XmlReader -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Die <see cref="T:System.Xml.XmlReader" />-Instanz, die bei der Deserialisierung des <see cref="T:System.Data.DataSet" /> übergeben wird.</param>
        <summary>Bestimmt den <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> für ein <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Eine <see cref="T:System.Data.SchemaSerializationMode" />-Enumeration, die angibt, ob Schemainformationen aus der Nutzlast ausgelassen wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn eine typisierte Deserialisierung <xref:System.Data.DataSet> bestimmen die <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Die <see cref="T:System.Runtime.Serialization.SerializationInfo" />, mit der der geschützte <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />-Konstruktor eines <see langword="DataSet" /> bei der Deserialisierung in Remotingszenarien aufgerufen wird.</param>
        <param name="context">Die <see cref="T:System.Runtime.Serialization.StreamingContext" />, mit der der geschützte <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />-Konstruktor eines <see langword="DataSet" /> bei der Deserialisierung in Remotingszenarien aufgerufen wird.</param>
        <summary>Bestimmt den <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> für ein <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Eine <see cref="T:System.Data.SchemaSerializationMode" />-Enumeration, die angibt, ob Schemainformationen aus der Nutzlast ausgelassen wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann aufgerufen werden, wenn eine typisierte Deserialisierung <xref:System.Data.DataSet> bestimmen die <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataSet.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die Initialisierung einer <see cref="T:System.Data.DataSet" />, die in einem Formular oder von einer anderen Komponente verwendet wird. Die Initialisierung erfolgt zur Laufzeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die entwurfsumgebung für Visual Studio .NET verwendet diese Methode, um die Initialisierung einer Komponente zu beenden, die in einem Formular oder von einer anderen Komponente verwendet wird. Die <xref:System.Data.DataSet.BeginInit%2A> -Methode startet die Initialisierung. Mithilfe der <xref:System.Data.DataSet.BeginInit%2A> und <xref:System.Data.DataSet.EndInit%2A> Methoden wird verhindert, dass das Steuerelement verwendet werden, bevor er vollständig initialisiert wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnforceConstraints : bool with get, set" Usage="System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob bei Aktualisierungen Einschränkungsregeln beachtet werden, oder legt diesen fest.</summary>
        <value>
          <see langword="true" />, wenn Regeln erzwungen werden, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einschränkungen werden festgelegt, an die <xref:System.Data.DataTable> Ebene (<xref:System.Data.DataTable.Constraints%2A> Eigenschaft). Weitere Informationen zum Erstellen von Einschränkungen finden Sie unter [DataTable-Einschränkungen](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataSet> mit einer Tabelle, eine Spalte, fünf Zeilen und einer <xref:System.Data.UniqueConstraint>. Die <xref:System.Data.DataSet.EnforceConstraints%2A> -Eigenschaftensatz auf `false` und die Werte der einzelnen Zeilen auf den gleichen Wert festgelegt sind. Wenn die <xref:System.Data.DataSet.EnforceConstraints%2A> Eigenschaft wird auf zurückgesetzt `true`, eine <xref:System.Data.ConstraintException> generiert wird.  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Mindestens eine Einschränkung kann nicht erzwungen werden.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dem <see langword="DataSet" /> zugeordnete Auflistung von benutzerdefinierten Benutzerinformationen ab.</summary>
        <value>Eine <see cref="T:System.Data.PropertyCollection" /> mit sämtlichen benutzerdefinierten Benutzerinformationen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.ExtendedProperties%2A> Eigenschaft können Sie zum Speichern von benutzerdefinierten Informationen mit der `DataSet`. Beispielsweise können Sie eine zu speichern, wenn die Daten aktualisiert werden sollen.  
  
 Erweiterte Eigenschaften muss vom Typ <xref:System.String> Wenn gewünscht beibehalten, wenn die <xref:System.Data.DataSet> als XML geschrieben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine benutzerdefinierte Eigenschaft, die <xref:System.Data.PropertyCollection> zurückgegebenes der <xref:System.Data.DataColumn.ExtendedProperties%2A> Eigenschaft. Im zweite Beispiel ruft die benutzerdefinierte Eigenschaft ab.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine Kopie der <see cref="T:System.Data.DataSet" /> ab, die alle seit dem letzten Laden oder seit dem letzten Aufruf von <see cref="M:System.Data.DataSet.AcceptChanges" /> vorgenommenen Änderungen enthält.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataSet" Usage="dataSet.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Kopie des <see cref="T:System.Data.DataSet" /> ab, die sämtliche seit dem letzten Laden oder seit dem letzten Aufruf von <see cref="M:System.Data.DataSet.AcceptChanges" /> vorgenommenen Änderungen enthält.</summary>
        <returns>Eine Kopie der Änderungen aus diesem <see cref="T:System.Data.DataSet" />, für das Aktionen ausgeführt werden können und das nachfolgend durch Verwendung von <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /> wieder zusammengeführt werden kann. Wenn keine geänderten Zeilen gefunden werden, gibt die Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erstellt ein neues <xref:System.Data.DataSet> , enthält eine Kopie aller Zeilen in der ursprünglichen <xref:System.Data.DataSet> , ausstehende Änderungen aufweisen. Beziehung Einschränkungen können dazu führen, dass zusätzliche unveränderte Zeilen in die neue hinzuzufügende <xref:System.Data.DataSet> enthält die unveränderten Zeilen Primärschlüsseln, Fremdschlüsseln in der geänderten Zeilen entspricht. Gibt die Methode `null` , wenn keine Zeilen vorhanden, in der ursprünglichen sind <xref:System.Data.DataSet> , ausstehende Änderungen aufweisen.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine einfache <xref:System.Data.DataSet> mit einer Tabelle, zwei Spalten und zehn Zeilen. Zwei Werte geändert werden, und es wird eine Zeile hinzugefügt. Eine Teilmenge der geänderten Daten wird erstellt, mit der <xref:System.Data.DataSet.GetChanges%2A> Methode. Nach dem Abgleichen der Fehler wird eine neue Spalte, auf die Teilmenge, die Änderung des Schemas hinzugefügt. Wenn die <xref:System.Data.DataSet.Merge%2A> -Methode aufgerufen wird und die `missingSchemaAction` festgelegt `MissingSchemaAction.Add`, die neue Spalte hinzugefügt wird, mit dem ursprünglichen <xref:System.Data.DataSet> Objektschemas.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataSet" Usage="dataSet.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Einer der <see cref="T:System.Data.DataRowState" />-Werte.</param>
        <summary>Ruft eine Kopie der <see cref="T:System.Data.DataSet" /> ab, die alle seit dem letzten Laden oder seit dem letzten Aufruf von <see cref="M:System.Data.DataSet.AcceptChanges" /> vorgenommenen und durch <see cref="T:System.Data.DataRowState" /> gefilterten Änderungen enthält.</summary>
        <returns>Eine gefilterte Kopie des <see cref="T:System.Data.DataSet" />, für die Aktionen durchgeführt werden und die nachfolgend mithilfe von <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /> wieder mit dem Original zusammengeführt werden kann. Wenn keine Zeilen mit dem gewünschten <see cref="T:System.Data.DataRowState" /> gefunden werden, gibt die Methode <see langword="null" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.GetChanges%2A> Methode wird verwendet, um eine zweite erzeugen <xref:System.Data.DataSet> Objekt, das nur die Änderungen enthält, die in der ursprünglichen eingeführt. Verwenden der `rowStates` Argument, um die Art von Änderungen anzugeben, sollte das neue Objekt enthalten.  
  
 Diese Kopie ist so ausgelegt, mit dem ursprünglichen wieder zusammengeführt werden zurückgegeben <xref:System.Data.DataSet>. Beziehung Einschränkungen verursachen markierte Zeilen der übergeordneten `Unchanged` eingeschlossen werden sollen. Wenn keine Zeilen mit dem gewünschten <xref:System.Data.DataRowState> gefunden werden, die <xref:System.Data.DataSet.GetChanges%2A> -Methode zurückkehrt `null`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataSet.GetChanges%2A> Methode, um eine zweite <xref:System.Data.DataSet> -Objekt, das dann zum Aktualisieren einer Datenquelle verwendet wird.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataSetSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataSet.GetDataSetSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Das angegebene Schemaset.</param>
        <summary>Ruft eine Kopie von <see cref="T:System.Xml.Schema.XmlSchemaSet" /> für das DataSet ab.</summary>
        <returns>Eine Kopie des <see cref="T:System.Xml.Schema.XmlSchemaSet" />es.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Eine <see cref="T:System.Runtime.Serialization.SerializationInfo" /> mit den serialisierten Daten, die der <see cref="T:System.Data.DataSet" /> zugeordnet sind.</param>
        <param name="context">Ein <see cref="T:System.Runtime.Serialization.StreamingContext" />, der Quelle und Ziel des serialisierten Streams enthält, der dem <see cref="T:System.Data.DataSet" /> zugeordnet ist.</param>
        <summary>Füllt ein Serialisierungsinformationsobjekt mit den Daten auf, die zum Serialisieren des <see cref="T:System.Data.DataSet" /> erforderlich sind.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="info" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberSignature Language="F#" Value="abstract member GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataSet.GetSchemaSerializable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt eine serialisierbare <see cref="T:System.Xml.Schema.XmlSchema" />-Instanz zurück.</summary>
        <returns>Die <see cref="T:System.Xml.Schema.XmlSchema" />-Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.GetSerializationData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetSerializationData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Die <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Instanz.</param>
        <param name="context">Der Streamingkontext.</param>
        <summary>Deserialisiert die Tabellendaten aus dem Binär- oder XML-Stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberSignature Language="F#" Value="member this.GetXml : unit -&gt; string" Usage="dataSet.GetXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die XML-Darstellung der im <see cref="T:System.Data.DataSet" /> gespeicherten Daten zurück.</summary>
        <returns>Eine Zeichenfolge, die eine Darstellung der im <see cref="T:System.Data.DataSet" /> gespeicherten Daten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen dieser Methode entspricht dem Aufruf <xref:System.Data.DataSet.WriteXml%2A> mit <xref:System.Data.XmlWriteMode> festgelegt <xref:System.Data.XmlWriteMode.IgnoreSchema>.  
  
 <xref:System.Data.DataSet.GetXml%2A> Gibt die XML-Daten als eine Zeichenfolge zurück, und benötigt daher einen höheren Aufwand als <xref:System.Data.DataSet.WriteXml%2A> XML-Code in eine Datei schreiben.  
  
 Wenn Sie erstellen eine <xref:System.Data.DataSet> Schemaherleitung verwenden und die Serialisierung mithilfe von XML oder Webdiensten, die spaltensortierung kann geändert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataSet> und <xref:System.Data.DataTable>, fügt der Beispieldaten und zeigt dann die Daten im XML-Format.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 Dieses Beispiel veranschaulicht, wie Daten aus einem DataSet in eine XML-Datei schreiben und Lesen von Daten in Datasets aus XML. In diesem Beispiel wird ein Dataset mit zwei Tabellen erstellen, verwenden zwei Möglichkeiten, ein Dataset in die XML-Dateien (WriteXml und GetXml) exportieren und verwenden zwei Arten (ReadXml und InferXmlSchema), um ein Dataset aus der XML-Dateien importieren.  
  
 Vor dem Kompilieren und des Beispiels ausführen müssen Sie vier XML-Dateien im Beispielverzeichnis zu erstellen. Erstellen Sie zunächst ElementsWithAttributes.xml:  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 Als Nächstes erstellen Sie ElementsWithChildElementsxml.xml:  
  
```  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 Erstellen Sie jetzt ElementsWithOnlyAttributes.xml:  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 Und schließlich RepeatingElements.xml erstellen:  
  
```  
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 Sie können jetzt kompilieren und führen den folgenden Quellcode.  [Wie Store Daten des Datasets in XML-Datei](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) enthält Visual Basic- und C#-Projekte für dieses Beispiel.  
  
```  
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberSignature Language="F#" Value="member this.GetXmlSchema : unit -&gt; string" Usage="dataSet.GetXmlSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt das XSD-Schema für die XML-Darstellung der im <see cref="T:System.Data.DataSet" /> gespeicherten Daten zurück.</summary>
        <returns>Eine Zeichenfolge, die das XSD-Schema für die XML-Darstellung der im <see cref="T:System.Data.DataSet" /> gespeicherten Daten darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen dieser Methode entspricht dem Aufruf <xref:System.Data.DataSet.WriteXmlSchema%2A>, mit dem Unterschied, dass nur das primäre Schema geschrieben wird.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> Gibt die XML-Daten als eine Zeichenfolge zurück, und benötigt daher einen höheren Aufwand als <xref:System.Data.DataSet.WriteXmlSchema%2A> XML-Code in eine Datei schreiben.  
  
 Wenn Sie erstellen eine <xref:System.Data.DataSet> Schemaherleitung verwenden und die Serialisierung mithilfe von XML oder Webdiensten, die spaltensortierung kann geändert.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Data.DataSet> und <xref:System.Data.DataTable>, und klicken Sie dann das Schema im XML-Format angezeigt.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Data.DataSet" /> Änderungen aufweist, einschließlich neuer, gelöschter oder geänderter Zeilen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberSignature Language="F#" Value="member this.HasChanges : unit -&gt; bool" Usage="dataSet.HasChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Data.DataSet" /> Änderungen aufweist, einschließlich neuer, gelöschter oder geänderter Zeilen.</summary>
        <returns>
          <see langword="true" />, wenn das <see cref="T:System.Data.DataSet" /> Änderungen aufweist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataSet.GetChanges%2A> Methode, um eine zweite <xref:System.Data.DataSet> -Objekt, das dann zum Aktualisieren einer Datenquelle verwendet wird.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.HasChanges : System.Data.DataRowState -&gt; bool" Usage="dataSet.HasChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Einer der <see cref="T:System.Data.DataRowState" />-Werte.</param>
        <summary>Ruft einen Wert ab, der angibt, ob das <see cref="T:System.Data.DataSet" /> Änderungen aufweist, einschließlich neuer, gelöschter oder geänderter Zeilen, gefiltert durch <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>
          <see langword="true" />, wenn das <see cref="T:System.Data.DataSet" /> Änderungen aufweist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Untersuchen Sie die <xref:System.Data.DataSet.HasChanges%2A> Eigenschaft von der `DataSet` vor dem Aufrufen der <xref:System.Data.DataSet.GetChanges%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataSet.GetChanges%2A> Methode, um eine zweite <xref:System.Data.DataSet> -Objekt, das dann zum Aktualisieren einer Datenquelle verwendet wird.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in diesem <see cref="T:System.Data.DataTable" /> in einem der <see cref="T:System.Data.DataSet" />-Objekte Fehler vorliegen.</summary>
        <value>
          <see langword="true" />, wenn eine Tabelle einen Fehler enthält, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede <xref:System.Data.DataTable> in einem <xref:System.Data.DataSet> verfügt auch über eine <xref:System.Data.DataTable.HasErrors%2A> Eigenschaft. Verwenden der `HasErrors` Eigenschaft von der `DataSet` ersten, um festzustellen, ob eine Tabelle Fehler, bevor eine Überprüfung einzelner enthält <xref:System.Data.DataTable> Objekte. Wenn eine `DataTable` weist einen Fehler, die <xref:System.Data.DataTable.GetErrors%2A> Methode gibt ein Array von <xref:System.Data.DataRow> -Objekten, die Fehler enthält.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataSet.HasErrors%2A> -Eigenschaft können Sie bestimmen, ob ein <xref:System.Data.DataSet> -Objekt Fehler enthält. Wenn dies der Fall ist, die Fehler für die einzelnen <xref:System.Data.DataRow> in den einzelnen <xref:System.Data.DataTable> werden gedruckt.  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wendet ein XML-Schema auf das <see cref="T:System.Data.DataSet" /> an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.Stream * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (stream, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">Der <see langword="Stream" />, aus dem das Schema gelesen werden soll.</param>
        <param name="nsArray">Ein Array von Zeichenfolgen für Namespace-URIs (Uniform Resource Identifier), die aus dem Schemarückschluss ausgeschlossen werden sollen.</param>
        <summary>Wendet das XML-Schema aus dem angegebenen <see cref="T:System.IO.Stream" /> auf das <see cref="T:System.Data.DataSet" /> an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.TextReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see langword="TextReader" />, aus dem das Schema gelesen werden soll.</param>
        <param name="nsArray">Ein Array von Zeichenfolgen für Namespace-URIs (Uniform Resource Identifier), die aus dem Schemarückschluss ausgeschlossen werden sollen.</param>
        <summary>Wendet das XML-Schema aus dem angegebenen <see cref="T:System.IO.TextReader" /> auf das <see cref="T:System.Data.DataSet" /> an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : string * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (fileName, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, aus der das Schema gelesen werden soll, einschließlich des Pfades.</param>
        <param name="nsArray">Ein Array von Zeichenfolgen für Namespace-URIs (Uniform Resource Identifier), die aus dem Schemarückschluss ausgeschlossen werden sollen.</param>
        <summary>Wendet das XML-Schema aus der angegebenen Datei auf das <see cref="T:System.Data.DataSet" /> an.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> ist nicht auf <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugeordnete Enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.Xml.XmlReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see langword="XMLReader" />, aus dem das Schema gelesen werden soll.</param>
        <param name="nsArray">Ein Array von Zeichenfolgen für Namespace-URIs (Uniform Resource Identifier), die aus dem Schemarückschluss ausgeschlossen werden sollen.</param>
        <summary>Wendet das XML-Schema aus dem angegebenen <see cref="T:System.Xml.XmlReader" /> auf das <see cref="T:System.Data.DataSet" /> an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt nach dem Initialisieren der <see cref="T:System.Data.DataSet" /> auf.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.Data.DataSet.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberSignature Language="F#" Value="abstract member InitializeDerivedDataSet : unit -&gt; unit&#xA;override this.InitializeDerivedDataSet : unit -&gt; unit" Usage="dataSet.InitializeDerivedDataSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deserialisiert alle Tabellendaten des Dataset aus dem Binär- oder XML-Stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.IsBinarySerialized : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; bool" Usage="dataSet.IsBinarySerialized (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Das <see cref="T:System.Runtime.Serialization.SerializationInfo" />-Objekt.</param>
        <param name="context">Das <see cref="T:System.Runtime.Serialization.StreamingContext" />-Objekt.</param>
        <summary>Überprüft das Format der serialisierten Darstellung des <see langword="DataSet" />.</summary>
        <returns>
          <see langword="true" />, wenn die angegebene <see cref="T:System.Runtime.Serialization.SerializationInfo" /> ein in seinem Binärformat serialisiertes <see langword="DataSet" /> darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member unterstützt die .NET Framework-Infrastruktur und ist nicht für die direkte Verwendung in Code vorgesehen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="T:System.Data.DataSet" /> initialisiert wurde.</summary>
        <value>
          <see langword="true" />, um anzugeben, dass die Initialisierung der Komponente abgeschlossen ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt den Status der <xref:System.Data.DataSet> während der Erstellung, für die Instanz von Visual Studio. Die <xref:System.Data.DataSet.BeginInit%2A> Methode wird auf `false` und <xref:System.Data.DataSet.EndInit%2A> Methode wird auf `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Füllt eine <see cref="T:System.Data.DataSet" /> mit Werten aus einer Datenquelle, die den angegebenen <see cref="T:System.Data.IDataReader" /> verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.Load%2A> Methode bietet eine Möglichkeit zum Füllen einer einzelnen <xref:System.Data.DataTable> mit Daten, aus einer <xref:System.Data.IDataReader> Instanz. Diese Methode bietet dieselbe Funktionalität, ermöglicht aber das Laden mehrerer Resultsets aus einer `IDataReader` in mehrere Tabellen innerhalb einer `DataSet`.  
  
 Wenn die `DataSet` bereits Zeilen enthält, werden die eingehenden Daten aus der Datenquelle mit den vorhandenen Zeilen zusammengeführt.  
  
 Die `Load` Methode kann verwendet werden, in mehrere allgemeine Szenarien, darum Abrufen von Daten aus einer bestimmten Datenquelle und den aktuellen Datencontainer hinzugefügt (in diesem Fall eine `DataSet`). Diese Szenarien beschreiben Standardverfahren für die eine `DataSet`, beschreiben Sie das Update und merge-Verhalten.  
  
 Ein `DataSet` anhand einer einzigen primären Datenquelle synchronisiert oder aktualisiert. Die `DataSet` verfolgt Änderungen, sodass die Synchronisierung mit der primären Datenquelle. Darüber hinaus eine `DataSet` inkrementelle Daten aus einem oder mehreren sekundären Datenquellen akzeptieren können. Die `DataSet` ist nicht verantwortlich für das Nachverfolgen von Änderungen um Synchronisierung mit der sekundären Datenquelle zu ermöglichen.  
  
 Wenn Sie diese beiden hypothetischen Datenquellen, ist ein Benutzer voraussichtlich benötigt eine der folgenden Verhaltensweisen:  
  
-   Initialisieren `DataSet` aus einer primären Datenquelle. In diesem Szenario wird der Benutzer ein leeres initialisieren möchte `DataSet` mit Werten aus der primären Datenquelle. Mindestens ein DataTable-Inhalt wird geändert. Der Benutzer möchte später Weitergeben von Änderungen an der primären Datenquelle.  
  
-   Änderungen beibehalten und erneut über die primäre Datenquelle synchronisieren. In diesem Szenario möchte der Benutzer wird die `DataSet` im vorherigen Szenario gefüllt, und führen Sie eine inkrementelle Synchronisierung mit der primären Datenquelle beibehalten der Änderungen der `DataSet`.  
  
-   Inkrementelle Datenfeed aus sekundären Datenquellen. In diesem Szenario möchten die Benutzer zum Zusammenführen von Änderungen aus einem oder mehreren sekundären Datenquellen und zurück an die primäre Datenquelle weitergeben.  
  
 Die `Load` Methode ermöglicht all diesen Szenarien. Diese Methode ermöglicht Ihnen die Angabe einer Optionsparameter laden, der angibt, wie Zeilen bereits in einer <xref:System.Data.DataTable> mit geladenen Zeilen kombiniert werden. Die folgende Tabelle beschreibt die drei Ladeoptionen gebotenen der <xref:System.Data.LoadOption> Enumeration. In jedem Fall gibt die Beschreibung des Verhaltens, wenn der Primärschlüssel einer Zeile in den empfangenen Daten den Primärschlüssel einer vorhandenen Zeile übereinstimmt.  
  
|Laden Sie die Option|Beschreibung |  
|-----------------|-----------------|  
|`PreserveChanges` (Standardwert)|Aktualisiert die ursprüngliche Version der Zeile mit dem Wert der hinzukommenden Zeile an.|  
|`OverwriteChanges`|Die aktuellen und ursprüngliche Version der Zeile aktualisiert mit dem Wert der hinzukommenden Zeile.|  
|`Upsert`|Aktualisiert die aktuelle Version der Zeile mit dem Wert der hinzukommenden Zeile an.|  
  
 Im Allgemeinen die `PreserveChanges` und `OverwriteChanges` Optionen dienen für Szenarien, in denen der Benutzer synchronisieren muss, die `DataSet` und die Änderungen mit der primären Datenquelle. Die `Upsert` Option erleichtert das Aggregieren Änderungen aus einem oder mehreren sekundären Datenquellen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Data.IDataReader" />, der ein oder mehrere Resultsets bereitstellt.</param>
        <param name="loadOption">Ein Wert aus der <see cref="T:System.Data.LoadOption" />-Enumeration, der angibt, wie bereits in den <see cref="T:System.Data.DataTable" />-Instanzen des <see cref="T:System.Data.DataSet" /> vorhandene Zeilen mit eingehenden Zeilen kombiniert werden, die denselben Primärschlüssel aufweisen.</param>
        <param name="tables">Ein Array von <see cref="T:System.Data.DataTable" />-Instanzen, aus dem die <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />-Methode Namens- und Namespaceinformationen abruft. Jede dieser Tabellen muss ein Member der <see cref="T:System.Data.DataTableCollection" /> sein, die in diesem <see cref="T:System.Data.DataSet" /> enthalten ist.</param>
        <summary>Füllt ein <see cref="T:System.Data.DataSet" /> mit Werten aus einer Datenquelle. Dazu werden der bereitgestellte <see cref="T:System.Data.IDataReader" /> sowie ein Array von <see cref="T:System.Data.DataTable" />-Instanzen verwendet, mit dem Schema- und Namespaceinformationen bereitgestellt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.Load%2A> Methode bietet eine Möglichkeit zum Füllen einer einzelnen <xref:System.Data.DataTable> mit Daten, aus einer <xref:System.Data.IDataReader> Instanz. Diese Methode bietet dieselbe Funktionalität, ermöglicht aber das Laden mehrerer Resultsets aus einer <xref:System.Data.IDataReader> in mehrere Tabellen innerhalb einer <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Der Ladevorgang schlägt mit einer <xref:System.InvalidOperationException> Wenn eine der Spalten in der eingehenden Daten `reader` berechnete Spalten sind.  
  
 Die `loadOption` Parameter können Sie angeben, wie Sie möchten die importierten Daten für die Interaktion mit vorhandenen Daten und können einen der Werte aus den <xref:System.Data.LoadOption> Enumeration. Finden Sie in der Dokumentation für die <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> Methode für die Weitere Informationen zur Verwendung dieses Parameters.  
  
 Die `tables` Parameter ermöglicht Ihnen die Angabe ein Array von <xref:System.Data.DataTable> Instanzen, der die Reihenfolge der Tabellen für jeden aus dem Reader geladen Resultset angibt. Die <xref:System.Data.DataSet.Load%2A> -Methode füllt jede angegebene <xref:System.Data.DataTable> -Instanz mit Daten aus einem einzelnen Resultset aus der Quelle Datenleser. Nach jedem Resultset der <xref:System.Data.DataSet.Load%2A> Methode wechselt zum nächsten Resultset im Reader, bis keine weiteren Resultsets vorhanden sind.  
  
 Schema für diese Methode ist identisch, gefolgt von der <xref:System.Data.Common.DbDataAdapter.Fill%2A> Methode der <xref:System.Data.Common.DbDataAdapter> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine neue <xref:System.Data.DataSet>, addiert zwei <xref:System.Data.DataTable> -Instanzen der <xref:System.Data.DataSet>, und füllt dann die <xref:System.Data.DataSet> mithilfe der <xref:System.Data.DataSet.Load%2A> -Methode, Abrufen von Daten aus einer <xref:System.Data.DataTableReader> , die zwei Resultsets enthält. Schließlich zeigt das Beispiel den Inhalt der Tabellen im Konsolenfenster angezeigt.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * string[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Data.IDataReader" />, der ein oder mehrere Resultsets bereitstellt.</param>
        <param name="loadOption">Ein Wert aus der <see cref="T:System.Data.LoadOption" />-Enumeration, der angibt, wie bereits in den <see cref="T:System.Data.DataTable" />-Instanzen des <see langword="DataSet" /> vorhandene Zeilen mit eingehenden Zeilen kombiniert werden, die denselben Primärschlüssel aufweisen.</param>
        <param name="tables">Ein Zeichenfolgenarray, aus dem die <see langword="Load" />-Methode Tabellennameninformationen abruft.</param>
        <summary>Füllt ein <see cref="T:System.Data.DataSet" /> mit Werten aus einer Datenquelle. Dazu wird der bereitgestellte <see cref="T:System.Data.IDataReader" /> sowie ein Array von Zeichenfolgen verwendet, mit dem die Namen der Tabellen im <see langword="DataSet" /> bereitgestellt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.Load%2A> Methode bietet eine Möglichkeit zum Füllen einer einzelnen <xref:System.Data.DataTable> mit Daten, aus einer <xref:System.Data.IDataReader> Instanz. Diese Methode bietet dieselbe Funktionalität, ermöglicht aber das Laden mehrerer Resultsets aus einer `IDataReader` in mehrere Tabellen innerhalb einer `DataSet`.  
  
> [!NOTE]
>  Der Ladevorgang schlägt mit einer <xref:System.InvalidOperationException> Wenn eine der Spalten in der eingehenden Daten `reader` berechnete Spalten sind.  
  
 Die `loadOption` Parameter können Sie angeben, wie Sie möchten die importierten Daten für die Interaktion mit vorhandenen Daten und können einen der Werte aus den <xref:System.Data.LoadOption> Enumeration. Finden Sie in der Dokumentation für die <xref:System.Data.DataTable.Load%2A> Methode für die Weitere Informationen zur Verwendung dieses Parameters.  
  
 Die `tables` Parameter ermöglicht Ihnen die Angabe ein Array von Tabellennamen, Spaltennamen, der die Reihenfolge der Tabellen für jeden aus dem Reader geladen Resultset angibt. Die `Load` Methode versucht, eine Tabelle innerhalb suchen die `DataSet` stimmen mit dem Namen im Array der Tabellennamen, in der Reihenfolge gefunden. Wenn eine übereinstimmende Tabelle gefunden wird, wird diese Tabelle mit dem Inhalt des aktuellen Resultsets geladen. Wenn keine übereinstimmende Tabelle gefunden wird, wird eine Tabelle erstellt, mit dem Namen in das Array von Tabellennamen angegeben und Schema der neuen Tabelle aus dem Resultset abgeleitet ist. Nach jedem Resultset der `Load` Methode wechselt zum nächsten Resultset im Reader, bis keine weiteren Resultsets vorhanden sind.  
  
 Der Standardnamespace zugeordnet `DataSet`, sofern vorhanden, wird mit jedem neu erstellten zugeordneten `DataTable`. Schema für diese Methode ist identisch, gefolgt von der <xref:System.Data.Common.DbDataAdapter.Fill%2A> Methode der <xref:System.Data.Common.DbDataAdapter> Klasse.  
  
   
  
## Examples  
 Im folgenden Konsolenanwendungsbeispiel zuerst die Tabellen erstellt und lädt Daten aus einem Reader in einer <xref:System.Data.DataSet>unter Verwendung der `Load` Methode. Im Beispiel fügt dann die Tabellen in einer <xref:System.Data.DataSet> und versucht, die Tabellen mit Daten füllen einer <xref:System.Data.DataTableReader>. In diesem Beispiel, da die Parameter, um übergeben die `Load` Methode anzugeben, den Namen einer Tabelle, die nicht vorhanden ist, die `Load` Methode erstellt eine neue Tabelle entsprechend den Namen, die als Parameter übergeben. Sobald die Daten geladen wurden, zeigt das Beispiel den Inhalt aller Tabellen im Konsolenfenster angezeigt.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, errorHandler, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Data.IDataReader" />, der ein oder mehrere Resultsets bereitstellt.</param>
        <param name="loadOption">Ein Wert aus der <see cref="T:System.Data.LoadOption" />-Enumeration, der angibt, wie bereits in den <see cref="T:System.Data.DataTable" />-Instanzen des <see cref="T:System.Data.DataSet" /> vorhandene Zeilen mit eingehenden Zeilen kombiniert werden, die denselben Primärschlüssel aufweisen.</param>
        <param name="errorHandler">Ein <see cref="T:System.Data.FillErrorEventHandler" />-Delegat, der aufgerufen wird, wenn beim Laden von Daten Fehler auftreten.</param>
        <param name="tables">Ein Array von <see cref="T:System.Data.DataTable" />-Instanzen, aus dem die <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />-Methode Namens- und Namespaceinformationen abruft.</param>
        <summary>Füllt ein <see cref="T:System.Data.DataSet" /> mit Werten aus einer Datenquelle. Dazu werden der bereitgestellte <see cref="T:System.Data.IDataReader" /> sowie ein Array von <see cref="T:System.Data.DataTable" />-Instanzen verwendet, mit dem Schema- und Namespaceinformationen bereitgestellt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataTable.Load%2A> Methode bietet eine Möglichkeit zum Füllen einer einzelnen <xref:System.Data.DataTable> mit Daten, aus einer <xref:System.Data.IDataReader> Instanz. Diese Methode bietet dieselbe Funktionalität, ermöglicht aber das Laden mehrerer Resultsets aus einer <xref:System.Data.IDataReader> in mehrere Tabellen innerhalb einer <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Der Ladevorgang schlägt mit einer <xref:System.InvalidOperationException> Wenn eine der Spalten in der eingehenden Daten `reader` berechnete Spalten sind.  
  
 Die `loadOption` Parameter können Sie angeben, wie Sie möchten die importierten Daten für die Interaktion mit vorhandenen Daten und können einen der Werte aus den <xref:System.Data.LoadOption> Enumeration. Finden Sie in der Dokumentation für die <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> Methode für die Weitere Informationen zur Verwendung dieses Parameters.  
  
 Die `errorHandler` Parameter ist ein <xref:System.Data.FillErrorEventHandler> Delegat, der auf eine Prozedur, die aufgerufen wird verweist, tritt ein Fehler beim Laden von Daten. Die <xref:System.Data.FillErrorEventArgs> an die Prozedur übergebenen Parameter enthält Eigenschaften, die Sie zum Abrufen von Informationen zu den aufgetretenen Fehler, die aktuelle Zeile der Daten zu ermöglichen und die <xref:System.Data.DataTable> gefüllt wird. Mithilfe dieses Delegatmechanismus, anstatt ein einfacher Try/Catch-Block, können Sie den Fehler ermitteln die Situation zu behandeln, und die Verarbeitung fortzusetzen bei Bedarf. Die <xref:System.Data.FillErrorEventArgs> Parameter liefert eine <xref:System.Data.FillErrorEventArgs.Continue%2A> Eigenschaft: Legen Sie diese Eigenschaft auf `true` um anzugeben, dass Sie den Fehler und die Verarbeitung zu fortfahren möchten behandelt haben legen Sie die Eigenschaft auf `false` um anzugeben, dass die Verarbeitung angehalten werden soll. Beachten Sie das Festlegen der Eigenschaft auf `false` bewirkt, dass den Code, der das Problem, um eine Ausnahme ausgelöst.  
  
 Die `tables` Parameter ermöglicht Ihnen die Angabe ein Array von <xref:System.Data.DataTable> Instanzen, der die Reihenfolge der Tabellen für jeden aus dem Reader geladen Resultset angibt. Die <xref:System.Data.DataSet.Load%2A> -Methode füllt jede angegebene <xref:System.Data.DataTable> -Instanz mit Daten aus einem einzelnen Resultset aus der Quelle Datenleser. Nach jedem Resultset der <xref:System.Data.DataSet.Load%2A> Methode wechselt zum nächsten Resultset im Reader, bis keine weiteren Resultsets vorhanden sind.  
  
 Schema für diese Methode ist identisch, gefolgt von der <xref:System.Data.Common.DbDataAdapter.Fill%2A> Methode der <xref:System.Data.Common.DbDataAdapter> Klasse.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Tabelle, die eine <xref:System.Data.DataSet>, und versucht anschließend, verwenden Sie die <xref:System.Data.DataSet.Load%2A> -Methode zum Laden von Daten aus einer <xref:System.Data.DataTableReader> , enthält ein Schema nicht kompatibel. Anstatt aufgefangen, in diesem Beispiel verwendet eine <xref:System.Data.FillErrorEventHandler> Delegaten zu untersuchen und der Fehler behandelt werden. Die Ausgabe wird im Konsolenfenster angezeigt.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gebietsschemainformationen ab, die für den Vergleich von Zeichenfolgen in der Tabelle verwendet werden, oder legt diese fest.</summary>
        <value>Eine <see cref="T:System.Globalization.CultureInfo" />, die Daten zum Computergebietsschema des Benutzers enthält. Der Standardwert ist <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.Locale%2A> Eigenschaft gibt das Gebietsschema die Sortierung angewendet wird.  
  
 Standardmäßig Festlegen der <xref:System.Data.DataSet.Locale%2A> für eine <xref:System.Data.DataSet> setzt auch die <xref:System.Data.DataSet.Locale%2A> für jede <xref:System.Data.DataTable> Objekt im, `DataSet` auf den gleichen Wert.  
  
> [!NOTE]
>  In Spalten, Ausdrücke, enthalten, die <xref:System.StringComparison.InvariantCulture> verwendet wird. Die <xref:System.StringComparison.CurrentCulture> wird ignoriert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Globalization.CultureInfo> für eine <xref:System.Data.DataSet> und druckt die <xref:System.Globalization.CultureInfo.DisplayName%2A> und <xref:System.Globalization.CultureInfo.EnglishName%2A> Eigenschaften.  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt ein angegebenes <see cref="T:System.Data.DataSet" />, eine <see cref="T:System.Data.DataTable" /> oder ein Array von <see cref="T:System.Data.DataRow" />-Objekten mit dem aktuellen <see langword="DataSet" /> oder der <see langword="DataTable" /> zusammen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] -&gt; unit" Usage="dataSet.Merge rows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">Das Array von <see langword="DataRow" />-Objekten, das mit dem <see langword="DataSet" /> zusammengeführt werden soll.</param>
        <summary>Führt ein Array von <see cref="T:System.Data.DataRow" />-Objekten mit dem aktuellen <see cref="T:System.Data.DataSet" /> zusammen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.Merge%2A> Methode wird verwendet, um zwei merge <xref:System.Data.DataSet> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataSet>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataSet> mit den neuesten Daten aus der Datenquelle.  
  
 Die <xref:System.Data.DataSet.Merge%2A> Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataSet>.  
  
 In einer Clientanwendung ist es üblich, eine einzelne Schaltfläche, die der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene zu verwenden. In diesem Szenario die <xref:System.Data.DataSet.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataSet> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataSet> Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataSet>. Diese Teilmenge wird in der Regel kleiner und somit effizienter an eine Komponente der mittleren Ebene zurückgegeben. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataSet> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataSet> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataSet> mit der <xref:System.Data.DataSet.Merge%2A> Methode.  
  
 Wenn die <xref:System.Data.DataSet.Merge%2A> -Methode aufgerufen wird, werden die Schemas der beiden <xref:System.Data.DataSet> Objekte verglichen werden, da es möglich ist, dass die Schemas möglicherweise geändert wurden. Z. B. in einem Business-to-Business-Szenario wurden neue Spalten möglicherweise auf ein XML-Schema durch einen automatisierten Prozess hinzugefügt haben. Wenn die Quelle <xref:System.Data.DataSet> Schemaelemente enthält (hinzugefügt <xref:System.Data.DataColumn> Objekte), die nicht im Ziel vorhanden sind, die Elemente des Schemas können mit dem Ziel hinzugefügt werden, durch Festlegen der `missingSchemaAction` Argument `MissingSchemaAction.Add`. In diesem Fall wird das zusammengeführte <xref:System.Data.DataSet> hinzugefügte Schema und Daten enthält.  
  
 Nach dem Zusammenführen von Schemas, werden die Daten zusammengeführt.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataSet> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen werden. Zeilen mit Quelle ein <xref:System.Data.DataRowState> Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
 Beim Zusammenführen werden Einschränkungen deaktiviert. Wenn alle Einschränkungen am Ende einer Zusammenführung aktiviert werden, können keiner <xref:System.Data.ConstraintException> wird generiert, und die zusammengeführten Daten werden beibehalten, während die Einschränkungen deaktiviert sind. In diesem Fall die <xref:System.Data.DataSet.EnforceConstraints%2A> -Eigenschaftensatz auf `false`, und alle Zeilen, die ungültig sind Fehler gekennzeichnet sind. Der Fehler müssen behoben werden, bevor Sie versuchen, Zurücksetzen der <xref:System.Data.DataSet.EnforceConstraints%2A> Eigenschaft `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet -&gt; unit" Usage="dataSet.Merge dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">Die <see langword="DataSet" />, deren Daten und Schema zusammengeführt werden.</param>
        <summary>Führt ein angegebenes <see cref="T:System.Data.DataSet" /> und das entsprechende Schema mit dem aktuellen <see langword="DataSet" /> zusammen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.Merge%2A> Methode wird verwendet, um zwei merge <xref:System.Data.DataSet> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataSet>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataSet> mit den neuesten Daten aus der Datenquelle.  
  
 Die <xref:System.Data.DataSet.Merge%2A> Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataSet>.  
  
 In einer Clientanwendung ist es üblich, eine einzelne Schaltfläche, die der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene zu verwenden. In diesem Szenario die <xref:System.Data.DataSet.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataSet> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataSet> Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataSet>. Diese Teilmenge wird in der Regel kleiner und somit mehr effizient übergeben an eine Komponente der mittleren Ebene. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataSet> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataSet> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataSet> mit der <xref:System.Data.DataSet.Merge%2A> Methode.  
  
 Wenn die <xref:System.Data.DataSet.Merge%2A> -Methode aufgerufen wird, werden die Schemas der beiden <xref:System.Data.DataSet> Objekte verglichen werden, da es möglich ist, dass die Schemas möglicherweise geändert wurden. Z. B. in einem Business-to-Business-Szenario wurden neue Spalten möglicherweise auf ein XML-Schema durch einen automatisierten Prozess hinzugefügt haben. Wenn die Quelle <xref:System.Data.DataSet> Schemaelemente enthält (hinzugefügt <xref:System.Data.DataColumn> Objekte), die nicht im Ziel vorhanden sind, die Elemente des Schemas können mit dem Ziel hinzugefügt werden, durch Festlegen der `missingSchemaAction` Argument `MissingSchemaAction.Add`. In diesem Fall wird das zusammengeführte <xref:System.Data.DataSet> hinzugefügte Schema und Daten enthält.  
  
 Nach dem Zusammenführen von Schemas, werden die Daten zusammengeführt.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataSet> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen werden. Zeilen mit Quelle ein `DataRowState` Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
 Beim Zusammenführen werden Einschränkungen deaktiviert. Wenn alle Einschränkungen am Ende der Zusammenführung aktiviert werden, können keiner <xref:System.Data.ConstraintException> wird generiert, und die zusammengeführten Daten werden beibehalten, während die Einschränkungen deaktiviert sind. In diesem Fall die <xref:System.Data.DataSet.EnforceConstraints%2A> -Eigenschaftensatz auf `false`, und alle Zeilen, die ungültig sind Fehler gekennzeichnet sind. Der Fehler müssen behoben werden, bevor Sie versuchen, Zurücksetzen der <xref:System.Data.DataSet.EnforceConstraints%2A> Eigenschaft `true`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataSet.GetChanges%2A>, Update- und <xref:System.Data.DataSet.Merge%2A> Methoden auf eine <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Mindestens eine Einschränkung kann nicht aktiviert werden.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataSet.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Die <see cref="T:System.Data.DataTable" />, deren Daten und Schema zusammengeführt werden.</param>
        <summary>Führt ein angegebenes <see cref="T:System.Data.DataTable" /> und das entsprechende Schema mit dem aktuellen <see cref="T:System.Data.DataSet" /> zusammen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.Merge%2A> Methode wird verwendet, um zwei merge <xref:System.Data.DataSet> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataSet>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataSet> mit den neuesten Daten aus der Datenquelle.  
  
 Die <xref:System.Data.DataSet.Merge%2A> Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataSet>.  
  
 In einer Clientanwendung ist es üblich, eine einzelne Schaltfläche, die der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene zu verwenden. In diesem Szenario die <xref:System.Data.DataSet.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataSet> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataSet> Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataSet>. Diese Teilmenge wird in der Regel kleiner und somit mehr effizient übergeben an eine Komponente der mittleren Ebene. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataSet> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataSet> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataSet> mit der <xref:System.Data.DataSet.Merge%2A> Methode.  
  
 Wenn die <xref:System.Data.DataSet.Merge%2A> -Methode aufgerufen wird, werden die Schemas der beiden <xref:System.Data.DataSet> Objekte verglichen werden, da es möglich ist, dass die Schemas möglicherweise geändert wurden. Z. B. in einem Business-to-Business-Szenario wurden neue Spalten möglicherweise auf ein XML-Schema durch einen automatisierten Prozess hinzugefügt haben. Wenn die Quelle <xref:System.Data.DataSet> Schemaelemente enthält (hinzugefügt <xref:System.Data.DataColumn> Objekte), die nicht im Ziel vorhanden sind, die Elemente des Schemas können mit dem Ziel hinzugefügt werden, durch Festlegen der `missingSchemaAction` Argument `MissingSchemaAction.Add`. In diesem Fall wird das zusammengeführte <xref:System.Data.DataSet> hinzugefügte Schema und Daten enthält.  
  
 Nach dem Zusammenführen von Schemas, werden die Daten zusammengeführt.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataSet> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen werden. Zeilen mit Quelle ein `DataRowState` Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
 Beim Zusammenführen werden Einschränkungen deaktiviert. Wenn alle Einschränkungen am Ende der Zusammenführung aktiviert werden, können keiner <xref:System.Data.ConstraintException> wird generiert, und die zusammengeführten Daten werden beibehalten, während die Einschränkungen deaktiviert sind. In diesem Fall die <xref:System.Data.DataSet.EnforceConstraints%2A> -Eigenschaftensatz auf `false`, und alle Zeilen, die ungültig sind Fehler gekennzeichnet sind. Der Fehler müssen behoben werden, bevor Sie versuchen, Zurücksetzen der <xref:System.Data.DataSet.EnforceConstraints%2A> Eigenschaft `true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine einfache <xref:System.Data.DataSet> mit einer Tabelle, zwei Spalten und zehn Zeilen. Ein zweites <xref:System.Data.DataTable> wird erstellt, mit dem ersten identisch. Zwei Zeilen werden hinzugefügt, auf die zweite Tabelle, der dann, in zusammengeführt wird der <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="table" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">Die <see langword="DataSet" />, deren Daten und Schema zusammengeführt werden.</param>
        <param name="preserveChanges">
          <see langword="true" />, um am aktuellen <see langword="DataSet" /> vorgenommene Änderungen beizubehalten, andernfalls <see langword="false" />.</param>
        <summary>Führt ein angegebenes <see cref="T:System.Data.DataSet" /> und sein Schema mit dem aktuellen <see langword="DataSet" /> zusammen. Dabei werden entsprechend dem angegebenen Argument alle Änderungen in diesem <see langword="DataSet" /> beibehalten oder verworfen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.Merge%2A> Methode wird verwendet, um zwei merge <xref:System.Data.DataSet> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataSet>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataSet> mit den neuesten Daten aus der Datenquelle.  
  
 Die <xref:System.Data.DataSet.Merge%2A> Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataSet>.  
  
 In einer Clientanwendung ist es üblich, eine einzelne Schaltfläche, die der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene zu verwenden. In diesem Szenario die <xref:System.Data.DataSet.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataSet> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataSet> Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataSet>. Diese Teilmenge wird in der Regel kleiner und somit mehr effizient übergeben an eine Komponente der mittleren Ebene. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataSet> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataSet> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataSet> mit der <xref:System.Data.DataSet.Merge%2A> Methode.  
  
 Wenn die <xref:System.Data.DataSet.Merge%2A> -Methode aufgerufen wird, werden die Schemas der beiden <xref:System.Data.DataSet> Objekte verglichen werden, da es möglich ist, dass die Schemas möglicherweise geändert wurden. Z. B. in einem Business-to-Business-Szenario wurden neue Spalten möglicherweise auf ein XML-Schema durch einen automatisierten Prozess hinzugefügt haben. Wenn die Quelle <xref:System.Data.DataSet> Schemaelemente enthält (hinzugefügt <xref:System.Data.DataColumn> Objekte), die nicht im Ziel vorhanden sind, die Elemente des Schemas können mit dem Ziel hinzugefügt werden, durch Festlegen der `missingSchemaAction` Argument `MissingSchemaAction.Add`. In diesem Fall wird das zusammengeführte <xref:System.Data.DataSet> hinzugefügte Schema und Daten enthält.  
  
 Nach dem Zusammenführen von Schemas, werden die Daten zusammengeführt.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataSet> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen werden. Zeilen mit Quelle ein `DataRowState` Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
 Beim Zusammenführen werden Einschränkungen deaktiviert. Wenn alle Einschränkungen am Ende der Zusammenführung aktiviert werden, können keiner <xref:System.Data.ConstraintException> wird generiert, und die zusammengeführten Daten werden beibehalten, während die Einschränkungen deaktiviert sind. In diesem Fall die <xref:System.Data.DataSet.EnforceConstraints%2A> -Eigenschaftensatz auf `false`, und alle Zeilen, die ungültig sind Fehler gekennzeichnet sind. Der Fehler müssen behoben werden, bevor Sie versuchen, Zurücksetzen der <xref:System.Data.DataSet.EnforceConstraints%2A> Eigenschaft `true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine einfache <xref:System.Data.DataSet> mit einer Tabelle, zwei Spalten und zehn Zeilen. Nach dem Hinzufügen der zehn Zeilen, zwei Werte werden geändert, und eine Zeile hinzugefügt wird. Eine Teilmenge der geänderten Daten wird erstellt, mit der <xref:System.Data.DataSet.GetChanges%2A> Methode. Nach dem Abgleichen von Fehlern, die Daten der Teilmenge der ursprünglichen zusammengeführt <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (rows, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">Das Array von <see cref="T:System.Data.DataRow" />-Objekten, das mit dem <see langword="DataSet" /> zusammengeführt werden soll.</param>
        <param name="preserveChanges">
          <see langword="true" />, um am <see langword="DataSet" /> vorgenommene Änderungen beizubehalten, andernfalls <see langword="false" />.</param>
        <param name="missingSchemaAction">Einer der <see cref="T:System.Data.MissingSchemaAction" />-Werte.</param>
        <summary>Führt ein Array von <see cref="T:System.Data.DataRow" />-Objekten mit dem aktuellen <see cref="T:System.Data.DataSet" /> zusammen. Dabei werden Änderungen des <see langword="DataSet" /> entsprechend den angegebenen Argumenten beibehalten oder verworfen, und ein nicht kompatibles Schema wird entsprechend den angegebenen Argumenten behandelt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.Merge%2A> Methode wird verwendet, um zwei merge <xref:System.Data.DataSet> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataSet>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataSet> mit den neuesten Daten aus der Datenquelle.  
  
 Die <xref:System.Data.DataSet.Merge%2A> Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataSet>.  
  
 In einer Clientanwendung ist es üblich, eine einzelne Schaltfläche, die der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene zu verwenden. In diesem Szenario die <xref:System.Data.DataSet.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataSet> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataSet> Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataSet>. Diese Teilmenge wird in der Regel kleiner und somit mehr effizient übergeben an eine Komponente der mittleren Ebene. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataSet> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataSet> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataSet> mit der <xref:System.Data.DataSet.Merge%2A> Methode.  
  
 Zur Erleichterung der Erläuterung der <xref:System.Data.DataSet.Merge%2A> -Methode, wir verwenden "Ziel", um die aktuelle anzugeben <xref:System.Data.DataSet>, und "Quelle", um das zweite (Parameter) <xref:System.Data.DataSet>. Das Ziel <xref:System.Data.DataSet> ist Bezeichnung stammt daher, da er das Objekt ist auf dem eine Aktion (Merge) ausgeführt wird. Die zweite <xref:System.Data.DataSet> eine "Quelle" wird bezeichnet werden, da die Informationen, die es enthält sich nicht ändert, aber das aktuelle zusammengeführt <xref:System.Data.DataSet>.  
  
 Wenn die <xref:System.Data.DataSet.Merge%2A> -Methode aufgerufen wird, werden die Schemas der beiden <xref:System.Data.DataSet> Objekte verglichen werden, da es möglich ist, dass die Schemas möglicherweise geändert wurden. Z. B. in einem Business-to-Business-Szenario wurden neue Spalten möglicherweise auf ein XML-Schema durch einen automatisierten Prozess hinzugefügt haben. Wenn die Quelle <xref:System.Data.DataSet> Schemaelemente enthält (hinzugefügt <xref:System.Data.DataColumn> Objekte), die nicht im Ziel vorhanden sind, die Elemente des Schemas können mit dem Ziel hinzugefügt werden, durch Festlegen der `missingSchemaAction` Argument `MissingSchemaAction.Add`. In diesem Fall wird das zusammengeführte <xref:System.Data.DataSet> hinzugefügte Schema und Daten enthält.  
  
 Nach dem Zusammenführen von Schemas, werden die Daten zusammengeführt.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataSet> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen werden. Zeilen mit Quelle ein `DataRowState` Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
 Beim Zusammenführen werden Einschränkungen deaktiviert. Wenn alle Einschränkungen am Ende der Zusammenführung aktiviert werden, können keiner <xref:System.Data.ConstraintException> wird generiert, und die zusammengeführten Daten werden beibehalten, während die Einschränkungen deaktiviert sind. In diesem Fall die <xref:System.Data.DataSet.EnforceConstraints%2A> -Eigenschaftensatz auf `false`, und alle Zeilen, die ungültig sind Fehler gekennzeichnet sind. Der Fehler müssen behoben werden, bevor Sie versuchen, Zurücksetzen der <xref:System.Data.DataSet.EnforceConstraints%2A> Eigenschaft `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">Die <see langword="DataSet" />, deren Daten und Schema zusammengeführt werden.</param>
        <param name="preserveChanges">
          <see langword="true" />, um am aktuellen <see langword="DataSet" /> vorgenommene Änderungen beizubehalten, andernfalls <see langword="false" />.</param>
        <param name="missingSchemaAction">Einer der <see cref="T:System.Data.MissingSchemaAction" />-Werte.</param>
        <summary>Führt ein angegebenes <see cref="T:System.Data.DataSet" /> und sein Schema mit dem aktuellen <see langword="DataSet" /> zusammen. Dabei werden Änderungen des aktuellen <see langword="DataSet" /> entsprechend den angegebenen Argumenten beibehalten oder verworfen, und ein nicht kompatibles Schema wird entsprechend den angegebenen Argumenten behandelt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.Merge%2A> Methode wird verwendet, um zwei merge <xref:System.Data.DataSet> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataSet>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataSet> mit den neuesten Daten aus der Datenquelle.  
  
 Die <xref:System.Data.DataSet.Merge%2A> Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataSet>.  
  
 In einer Clientanwendung ist es üblich, eine einzelne Schaltfläche, die der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene zu verwenden. In diesem Szenario die <xref:System.Data.DataSet.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataSet> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataSet> Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataSet>. Diese Teilmenge wird in der Regel kleiner und somit mehr effizient übergeben an eine Komponente der mittleren Ebene. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataSet> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataSet> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataSet> mit der <xref:System.Data.DataSet.Merge%2A> Methode.  
  
 Zur Erleichterung der Erläuterung der <xref:System.Data.DataSet.Merge%2A> -Methode, wir verwenden "Ziel", um die aktuelle anzugeben <xref:System.Data.DataSet>, und "Quelle", um das zweite (Parameter) <xref:System.Data.DataSet>. Das Ziel <xref:System.Data.DataSet> ist Bezeichnung stammt daher, da er das Objekt ist auf dem eine Aktion (Merge) ausgeführt wird. Die zweite <xref:System.Data.DataSet> eine "Quelle" wird bezeichnet werden, da die Informationen, die es enthält sich nicht ändert, aber das aktuelle zusammengeführt <xref:System.Data.DataSet>.  
  
 Wenn die <xref:System.Data.DataSet.Merge%2A> -Methode aufgerufen wird, werden die Schemas der beiden <xref:System.Data.DataSet> Objekte verglichen werden, da es möglich ist, dass die Schemas möglicherweise geändert wurden. Z. B. in einem Business-to-Business-Szenario wurden neue Spalten möglicherweise auf ein XML-Schema durch einen automatisierten Prozess hinzugefügt haben. Wenn die Quelle <xref:System.Data.DataSet> Schemaelemente enthält (hinzugefügt <xref:System.Data.DataColumn> Objekte), die nicht im Ziel vorhanden sind, die Elemente des Schemas können mit dem Ziel hinzugefügt werden, durch Festlegen der `missingSchemaAction` Argument `MissingSchemaAction.Add`. In diesem Fall wird das zusammengeführte <xref:System.Data.DataSet> hinzugefügte Schema und Daten enthält.  
  
 Nach dem Zusammenführen von Schemas, werden die Daten zusammengeführt.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataSet> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen werden. Zeilen mit Quelle ein `DataRowState` Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
 Beim Zusammenführen werden Einschränkungen deaktiviert. Wenn alle Einschränkungen am Ende der Zusammenführung aktiviert werden, können keiner <xref:System.Data.ConstraintException> wird generiert, und die zusammengeführten Daten werden beibehalten, während die Einschränkungen deaktiviert sind. In diesem Fall die <xref:System.Data.DataSet.EnforceConstraints%2A> -Eigenschaftensatz auf `false`, und alle Zeilen, die ungültig sind Fehler gekennzeichnet sind. Der Fehler müssen behoben werden, bevor Sie versuchen, Zurücksetzen der <xref:System.Data.DataSet.EnforceConstraints%2A> Eigenschaft `true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine einfache <xref:System.Data.DataSet> mit einer Tabelle, zwei Spalten und zehn Zeilen. Zwei Werte geändert werden, und es wird eine Zeile hinzugefügt. Eine Teilmenge der geänderten Daten wird erstellt, mit der <xref:System.Data.DataSet.GetChanges%2A> Methode. Nach dem Abgleichen der Fehler wird eine neue Spalte, auf die Teilmenge, die Änderung des Schemas hinzugefügt. Wenn die <xref:System.Data.DataSet.Merge%2A> -Methode aufgerufen wird und die `missingSchemaAction` festgelegt `MissingSchemaAction.Add`, die neue Spalte hinzugefügt wird, mit dem ursprünglichen <xref:System.Data.DataSet> Objektschemas.  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">Die <see langword="DataTable" />, deren Daten und Schema zusammengeführt werden.</param>
        <param name="preserveChanges">Einer der <see cref="T:System.Data.MissingSchemaAction" />-Werte.</param>
        <param name="missingSchemaAction">
          <see langword="true" />, um am <see langword="DataSet" /> vorgenommene Änderungen beizubehalten, andernfalls <see langword="false" />.</param>
        <summary>Führt eine angegebene <see cref="T:System.Data.DataTable" /> und ihr Schema mit dem aktuellen <see langword="DataSet" /> zusammen. Dabei werden Änderungen des aktuellen <see langword="DataSet" /> entsprechend den angegebenen Argumenten beibehalten oder verworfen, und ein nicht kompatibles Schema wird entsprechend den angegebenen Argumenten behandelt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.Merge%2A> Methode wird verwendet, um zwei merge <xref:System.Data.DataSet> Objekte, die Schemas weitgehend ähnlich sind. Eine Zusammenführung wird in der Regel auf eine Clientanwendung verwendet, um die aktuellen Änderungen aus einer Datenquelle in einer vorhandenen integrieren <xref:System.Data.DataSet>. Dies ermöglicht es der Clientanwendung ein aktualisiert haben <xref:System.Data.DataSet> mit den neuesten Daten aus der Datenquelle.  
  
 Die <xref:System.Data.DataSet.Merge%2A> Methodenaufrufs ist in der Regel am Ende einer Reihe von Verfahren, bei denen Änderungen überprüfen, Abgleichen der Fehler, die Datenquelle mit den Änderungen aktualisiert und schließlich aktualisieren die vorhandenen <xref:System.Data.DataSet>.  
  
 eine Clientanwendung ist es üblich, eine einzelne Schaltfläche, die der Benutzer klicken kann, die die geänderten Daten erfasst und überprüft es vor dem Senden an eine Komponente der mittleren Ebene zu verwenden. In diesem Szenario die <xref:System.Data.DataSet.GetChanges%2A> -Methode zuerst aufgerufen. Eine zweite Methodenrückgabe <xref:System.Data.DataSet> für validieren und Zusammenführen optimiert. Dieses zweite <xref:System.Data.DataSet> Objekt enthält nur die <xref:System.Data.DataTable> und <xref:System.Data.DataRow> Objekte, die geändert wurden, was zu einer Teilmenge des ursprünglichen <xref:System.Data.DataSet>. Diese Teilmenge wird in der Regel kleiner und somit mehr effizient übergeben an eine Komponente der mittleren Ebene. Die Komponente der mittleren Ebene aktualisiert dann die ursprüngliche Datenquelle mit den Änderungen mithilfe von gespeicherten Prozeduren. Die mittlere Ebene kann dann zurücksenden entweder ein neues <xref:System.Data.DataSet> enthält, die ursprünglichen Daten und die neuesten Daten aus der Datenquelle (durch die ursprüngliche Abfrage erneut ausführen), oder gesendet werden können, wieder die Teilmenge mit allen Änderungen, die darauf aus der Datenquelle vorgenommen wurden. (Z. B. wenn die Datenquelle automatisch eindeutige Primärschlüsselwerte erstellt, können diese Werte an die Clientanwendung weitergegeben werden.) In beiden Fällen wird das zurückgegebene <xref:System.Data.DataSet> können zusammengeführt werden, wieder in die Clientanwendung ursprünglichen <xref:System.Data.DataSet> mit der <xref:System.Data.DataSet.Merge%2A> Methode.  
  
 Wenn die <xref:System.Data.DataSet.Merge%2A> -Methode aufgerufen wird, werden die Schemas der beiden <xref:System.Data.DataSet> Objekte verglichen werden, da es möglich ist, dass die Schemas möglicherweise geändert wurden. Z. B. in einem Business-to-Business-Szenario wurden neue Spalten möglicherweise auf ein XML-Schema durch einen automatisierten Prozess hinzugefügt haben. Wenn die Quelle <xref:System.Data.DataSet> Schemaelemente enthält (hinzugefügt <xref:System.Data.DataColumn> Objekte), die nicht im Ziel vorhanden sind, die Elemente des Schemas können mit dem Ziel hinzugefügt werden, durch Festlegen der `missingSchemaAction` Argument `MissingSchemaAction.Add`. In diesem Fall wird das zusammengeführte <xref:System.Data.DataSet> hinzugefügte Schema und Daten enthält.  
  
 Nach dem Zusammenführen von Schemas, werden die Daten zusammengeführt.  
  
 Beim Zusammenführen einer neuen Quelle <xref:System.Data.DataSet> in das Ziel Quellzeilen mit einer <xref:System.Data.DataRowState> Wert `Unchanged`, `Modified`, oder `Deleted` Zielzeilen mit den gleichen Primärschlüsselwerten abgeglichen werden. Zeilen mit Quelle ein `DataRowState` Wert `Added` neue Zielzeilen mit den gleichen Primärschlüsselwerten als die neue Quellzeilen zugeordnet sind.  
  
 Beim Zusammenführen werden Einschränkungen deaktiviert. Wenn alle Einschränkungen am Ende der Zusammenführung aktiviert werden, können keiner <xref:System.Data.ConstraintException> wird generiert, und die zusammengeführten Daten werden beibehalten, während die Einschränkungen deaktiviert sind. In diesem Fall die <xref:System.Data.DataSet.EnforceConstraints%2A> -Eigenschaftensatz auf `false`, und alle Zeilen, die ungültig sind Fehler gekennzeichnet sind. Der Fehler müssen behoben werden, bevor Sie versuchen, Zurücksetzen der <xref:System.Data.DataSet.EnforceConstraints%2A> Eigenschaft `true`.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine einfache <xref:System.Data.DataSet> mit einer Tabelle, zwei Spalten und zehn Zeilen. Ein zweites <xref:System.Data.DataTable> wird erstellt, d. h. nahezu identisch mit dem ersten mit dem Unterschied, dass ein neues `DataColumn` der Tabelle hinzugefügt wird. Zwei Zeilen werden hinzugefügt, auf die zweite Tabelle, der dann, in zusammengeführt wird der <xref:System.Data.DataSet> mit der `preserveChanges` Argument festgelegt wird, um `false`, und die `missingSchemaAction` Argument festgelegt wird, um `MissingSchemaAction.Add`.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberSignature Language="F#" Value="member this.MergeFailed : System.Data.MergeFailedEventHandler " Usage="member this.MergeFailed : System.Data.MergeFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Ziel- und eine Quell-<see cref="T:System.Data.DataRow" /> denselben Primärschlüsselwert aufweisen und <see cref="P:System.Data.DataSet.EnforceConstraints" /> auf True festgelegt ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [NIB: Behandeln von Ereignissen](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung von der <xref:System.Data.DataSet.MergeFailed> Ereignis.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namespace der <see cref="T:System.Data.DataSet" /> ab oder legt diesen fest.</summary>
        <value>Der Namespace von <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.Namespace%2A> Eigenschaft wird beim Lesen und Schreiben von einem XML-Dokument verwendet die <xref:System.Data.DataSet> mithilfe der <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>, oder <xref:System.Data.DataSet.WriteXmlSchema%2A> Methoden.  
  
 Der Namespace des XML-Dokuments wird verwendet, um die XML-Attribute und Elemente, die beim Lesen in Bereich eine <xref:System.Data.DataSet>. Z. B. wenn ein <xref:System.Data.DataSet> ein Schema enthält, die beim Lesen aus einem Dokument mit dem Namespace "MyCompany", und es wird versucht, zum Lesen von Daten nur aus einem Dokument mit einem anderen Namespace, alle Daten, die das vorhandene Schema nicht entspricht, werden ignoriert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataSet.Prefix%2A> vor dem Aufruf der <xref:System.Data.DataSet.ReadXml%2A> Methode.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der Namespace enthält bereits Daten.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataSet.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Ein <see cref="T:System.ComponentModel.PropertyChangedEventArgs" />, das die Ereignisdaten enthält.</param>
        <summary>Löst das <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />-Ereignis aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch das Auslösen eines Ereignisses wird der Ereignishandler über einen Delegaten aufgerufen. Eine Übersicht finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Zum Überschreiben <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> werden Sie in einer abgeleiteten Klasse der Basisklasse aufrufen <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> Methode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveRelation : System.Data.DataRelation -&gt; unit&#xA;override this.OnRemoveRelation : System.Data.DataRelation -&gt; unit" Usage="dataSet.OnRemoveRelation relation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">Die <see cref="T:System.Data.DataRelation" />, die entfernt wird.</param>
        <summary>Tritt beim Entfernen eines <see cref="T:System.Data.DataRelation" />-Objekts aus einer <see cref="T:System.Data.DataTable" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte von Unterklassen zum Entfernen von Tabellen einzuschränken außer Kraft gesetzt werden  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveTable : System.Data.DataTable -&gt; unit&#xA;override this.OnRemoveTable : System.Data.DataTable -&gt; unit" Usage="dataSet.OnRemoveTable table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">Die <see cref="T:System.Data.DataTable" />, die entfernt wird.</param>
        <summary>Tritt beim Entfernen einer <see cref="T:System.Data.DataTable" /> aus einem <see cref="T:System.Data.DataSet" /> ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von Unterklassen Tabellen entfernt werden, beschränken überschrieben werden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine abgeleitete Klasse die <xref:System.Data.DataSet> mit der <xref:System.Data.DataSet.OnRemoveTable%2A> Methode überschreiben.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein XML-Präfix ab, das als Alias für den Namespace der <see cref="T:System.Data.DataSet" /> fungiert, oder legt dieses fest.</summary>
        <value>Das XML-Präfix für den <see cref="T:System.Data.DataSet" />-Namespace.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.Prefix%2A> Eigenschaft ist in einem XML-Dokument verwendet, um Elemente zu identifizieren, die den Namespace gehören die <xref:System.Data.DataSet> Objekt (wie durch Festlegen der <xref:System.Data.DataSet.Namespace%2A> Eigenschaft).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataSet.Prefix%2A> vor dem Aufruf der <xref:System.Data.DataSet.ReadXml%2A> Methode.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RaisePropertyChanging : string -&gt; unit" Usage="dataSet.RaisePropertyChanging name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name der Eigenschaft, die gerade geändert wird.</param>
        <summary>Sendet eine Benachrichtigung, dass die angegebene <see cref="T:System.Data.DataSet" />-Eigenschaft gerade geändert wird.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest ein XML-Schema und XML-Daten in das <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Ein von <see cref="T:System.IO.Stream" /> abgeleitetes Objekt.</param>
        <summary>Liest mit dem angegebenen <see cref="T:System.Data.DataSet" /> das XML-Schema und die XML-Daten in die <see cref="T:System.IO.Stream" />.</summary>
        <returns>Der zum Lesen der Daten verwendete <see cref="T:System.Data.XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataSet> aus einem XML-Dokument während der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode liest nur das Schema. Verwenden Sie zum Lesen von Daten und Schema eine der der `ReadXML` Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `ReadSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.WriteXml%2A> und <xref:System.Data.DataSet.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataSet`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
 Wenn das XML-Schema für eine <xref:System.Data.DataSet> enthält `targetNamespace`, möglicherweise keine Daten gelesen und beim Aufrufen können Ausnahmen auftreten <xref:System.Data.DataSet.ReadXml%2A> beim Laden der <xref:System.Data.DataSet> mit XML, das Elemente ohne qualifizierenden Namespace enthält. Legen Sie zum Lesen von nicht qualifizierter Elementen `elementFormDefault` gleich "qualified" im XML-Schema, wie im folgende Beispiel veranschaulicht.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, wird eine Ausnahme ausgelöst, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXml%2A> durch Angabe `XmlReadMode.ReadSchema`. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt zuerst eine einfache <xref:System.Data.DataSet> mit einem <xref:System.Data.DataTable>, zwei Spalten und zehn Zeilen. Die <xref:System.Data.DataSet> Schema und Daten durch den Aufruf auf den Datenträger geschrieben werden die <xref:System.Data.DataSet.WriteXml%2A> Methode. Ein zweites <xref:System.Data.DataSet> wird erstellt und die <xref:System.Data.DataSet.ReadXml%2A> Methode wird verwendet, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see langword="TextReader" />, aus dem das Schema und die Daten gelesen werden sollen.</param>
        <summary>Liest mit dem angegebenen <see cref="T:System.Data.DataSet" /> das XML-Schema und die XML-Daten in die <see cref="T:System.IO.TextReader" />.</summary>
        <returns>Der zum Lesen der Daten verwendete <see cref="T:System.Data.XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataSet> aus einem XML-Dokument während der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode liest nur das Schema. Verwenden Sie zum Lesen von Daten und Schema eine der der `ReadXML` Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `ReadSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.WriteXml%2A> und <xref:System.Data.DataSet.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataSet`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
 Wenn das XML-Schema für eine <xref:System.Data.DataSet> enthält `targetNamespace`, möglicherweise keine Daten gelesen und beim Aufrufen können Ausnahmen auftreten <xref:System.Data.DataSet.ReadXml%2A> beim Laden der <xref:System.Data.DataSet> mit XML, das Elemente ohne qualifizierenden Namespace enthält. Legen Sie zum Lesen von nicht qualifizierter Elementen `elementFormDefault` gleich "qualified" in das XML-Schema wie im folgende Beispiel veranschaulicht.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 Klassen, die von erben die <xref:System.IO.TextReader> -Klasse enthalten die <xref:System.IO.StreamReader> und <xref:System.IO.StringReader> Klassen.  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, wird eine Ausnahme ausgelöst, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXml%2A> durch Angabe `XmlReadMode.ReadSchema`. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt zuerst eine einfache <xref:System.Data.DataSet> mit einem <xref:System.Data.DataTable>, zwei Spalten und zehn Zeilen. Die <xref:System.Data.DataSet> Schema und Daten durch den Aufruf auf den Datenträger geschrieben werden die <xref:System.Data.DataSet.WriteXml%2A> Methode. Ein zweites <xref:System.Data.DataSet> wird erstellt und die <xref:System.Data.DataSet.ReadXml%2A> Methode wird verwendet, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, aus der gelesen werden soll, einschließlich des Pfades.</param>
        <summary>Liest mithilfe der angegebenen Datei das XML-Schema und die XML-Daten in das <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Der zum Lesen der Daten verwendete <see langword="XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataSet> aus einem XML-Dokument während der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode liest nur das Schema. Verwenden Sie zum Lesen von Daten und Schema eine der der `ReadXML` Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `ReadSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.WriteXml%2A> und <xref:System.Data.DataSet.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataSet`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
 Wenn das XML-Schema für eine <xref:System.Data.DataSet> enthält eine `targetNamespace`, möglicherweise keine Daten gelesen und beim Aufrufen können Ausnahmen auftreten <xref:System.Data.DataSet.ReadXml%2A> beim Laden der <xref:System.Data.DataSet> mit XML, das Elemente ohne qualifizierenden Namespace enthält. Legen Sie zum Lesen von nicht qualifizierter Elementen `elementFormDefault` gleich "qualified" in das XML-Schema wie im folgende Beispiel veranschaulicht.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, wird eine Ausnahme ausgelöst, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXml%2A> durch Angabe `XmlReadMode.ReadSchema`. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt zuerst eine einfache <xref:System.Data.DataSet> mit einem <xref:System.Data.DataTable>, zwei Spalten und zehn Zeilen. Die <xref:System.Data.DataSet> Schema und Daten durch den Aufruf auf den Datenträger geschrieben werden die <xref:System.Data.DataSet.WriteXml%2A> Methode. Ein zweites <xref:System.Data.DataSet> wird erstellt und die <xref:System.Data.DataSet.ReadXml%2A> Methode wird verwendet, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> ist nicht auf <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugeordnete Enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see cref="T:System.Xml.XmlReader" />, aus dem gelesen werden soll.</param>
        <summary>Liest mit dem angegebenen <see cref="T:System.Data.DataSet" /> das XML-Schema und die XML-Daten in die <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns>Der zum Lesen der Daten verwendete <see langword="XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataSet> aus einem XML-Dokument während der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode liest nur das Schema. Verwenden Sie zum Lesen von Daten und Schema eine der der `ReadXML` Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `ReadSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.WriteXml%2A> und <xref:System.Data.DataSet.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataSet`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
 Wenn das XML-Schema für eine <xref:System.Data.DataSet> enthält eine `targetNamespace`, möglicherweise keine Daten gelesen und beim Aufrufen können Ausnahmen auftreten <xref:System.Data.DataSet.ReadXml%2A> beim Laden der <xref:System.Data.DataSet> mit XML, das Elemente ohne qualifizierenden Namespace enthält. Legen Sie zum Lesen von nicht qualifizierter Elementen `elementFormDefault` gleich "qualified" in das XML-Schema wie im folgende Beispiel veranschaulicht.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> erbt von <xref:System.Xml.XmlReader>.  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, wird eine Ausnahme ausgelöst, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXml%2A> durch Angabe `XmlReadMode.ReadSchema`. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt zuerst eine einfache <xref:System.Data.DataSet> mit einem <xref:System.Data.DataTable>, zwei Spalten und zehn Zeilen. Die <xref:System.Data.DataSet> Schema und Daten durch den Aufruf auf den Datenträger geschrieben werden die <xref:System.Data.DataSet.WriteXml%2A> Methode. Ein zweites <xref:System.Data.DataSet> wird erstellt und die <xref:System.Data.DataSet.ReadXml%2A> Methode wird verwendet, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">Der <see cref="T:System.IO.Stream" />, aus dem gelesen werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlReadMode" />-Werte.</param>
        <summary>Liest mit dem angegebenen <see cref="T:System.Data.DataSet" /> und im angegebenen <see cref="T:System.IO.Stream" /> das XML-Schema und die XML-Daten in das <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>Der zum Lesen der Daten verwendete <see langword="XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataSet> aus einem XML-Dokument während der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode liest nur das Schema. Verwenden Sie zum Lesen von Daten und Schema eine der der `ReadXML` Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `ReadSchema`.  
  
 Dasselbe gilt für die <xref:System.Data.DataSet.WriteXml%2A> und <xref:System.Data.DataSet.WriteXmlSchema%2A> Methoden bzw.. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataSet`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Bei Verwendung von <xref:System.Data.DataSet.ReadXml%2A> , und legen Sie <xref:System.Data.XmlReadMode> auf `Diffgram`, den Inhalt des Ziels `DataSet` und des Original- `DataSet` unterschiedlich ausfallen, aufgrund wie das DiffGram-Objekt generiert und verarbeitet wird. Weitere Informationen über Diffgrams finden Sie unter [DiffGrams](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md).  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
 Wenn das XML-Schema für eine <xref:System.Data.DataSet> enthält `targetNamespace`, möglicherweise keine Daten gelesen und beim Aufrufen können Ausnahmen auftreten <xref:System.Data.DataSet.ReadXml%2A> beim Laden der <xref:System.Data.DataSet> mit XML, das Elemente ohne qualifizierenden Namespace enthält. Legen Sie zum Lesen von nicht qualifizierter Elementen `elementFormDefault` gleich "qualified" in das XML-Schema wie im folgende Beispiel veranschaulicht.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, wird eine Ausnahme ausgelöst, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXml%2A> durch Angabe `XmlReadMode.ReadSchema`. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see cref="T:System.IO.TextReader" />, aus dem gelesen werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlReadMode" />-Werte.</param>
        <summary>Liest mit dem angegebenen <see cref="T:System.Data.DataSet" /> und im angegebenen <see cref="T:System.IO.TextReader" /> das XML-Schema und die XML-Daten in das <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>Der zum Lesen der Daten verwendete <see langword="XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataSet> aus einem XML-Dokument während der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode liest nur das Schema. Verwenden Sie zum Lesen von Daten und Schema eine der der `ReadXML` Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `ReadSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.WriteXml%2A> und <xref:System.Data.DataSet.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataSet`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
 Wenn das XML-Schema für eine <xref:System.Data.DataSet> enthält `targetNamespace`, möglicherweise keine Daten gelesen und beim Aufrufen können Ausnahmen auftreten <xref:System.Data.DataSet.ReadXml%2A> beim Laden der <xref:System.Data.DataSet> mit XML, das Elemente ohne qualifizierenden Namespace enthält. Legen Sie zum Lesen von nicht qualifizierter Elementen `elementFormDefault` gleich "qualified" in das XML-Schema wie im folgende Beispiel veranschaulicht.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, wird eine Ausnahme ausgelöst, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXml%2A> durch Angabe `XmlReadMode.ReadSchema`. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, aus der gelesen werden soll, einschließlich des Pfades.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlReadMode" />-Werte.</param>
        <summary>Liest mit der angegebenen Datei und im angegebenen <see cref="T:System.Data.DataSet" /> das XML-Schema und die XML-Daten in das <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>Der zum Lesen der Daten verwendete <see langword="XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataSet> aus einem XML-Dokument während der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode liest nur das Schema. Verwenden Sie zum Lesen von Daten und Schema eine der der `ReadXML` Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `ReadSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.WriteXml%2A> und <xref:System.Data.DataSet.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataSet`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
 Wenn das XML-Schema für eine <xref:System.Data.DataSet> enthält eine `targetNamespace`, möglicherweise keine Daten gelesen und beim Aufrufen können Ausnahmen auftreten <xref:System.Data.DataSet.ReadXml%2A> beim Laden der <xref:System.Data.DataSet> mit XML, das Elemente ohne qualifizierenden Namespace enthält. Legen Sie zum Lesen von nicht qualifizierter Elementen `elementFormDefault` gleich "qualified" in das XML-Schema wie im folgende Beispiel veranschaulicht.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, wird eine Ausnahme ausgelöst, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXml%2A> durch Angabe `XmlReadMode.ReadSchema`. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> ist nicht auf <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugeordnete Enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see cref="T:System.Xml.XmlReader" />, aus dem gelesen werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlReadMode" />-Werte.</param>
        <summary>Liest mit dem angegebenen <see cref="T:System.Data.DataSet" /> und im angegebenen <see cref="T:System.Xml.XmlReader" /> das XML-Schema und die XML-Daten in das <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>Der zum Lesen der Daten verwendete <see langword="XmlReadMode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Data.DataSet.ReadXml%2A> Methode bietet eine Möglichkeit, die entweder Daten nur lesen oder Schemas und Daten in einem <xref:System.Data.DataSet> aus einem XML-Dokument während der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode liest nur das Schema. Verwenden Sie zum Lesen von Daten und Schema eine der der `ReadXML` Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `ReadSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.WriteXml%2A> und <xref:System.Data.DataSet.WriteXmlSchema%2A> Methoden bzw. Zum Schreiben von XML-Daten oder Schema und Daten aus der `DataSet`, verwenden Sie die `WriteXml` Methode. Um nur das Schema zu schreiben, verwenden die `WriteXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Wenn ein Inline Schema angegeben ist, wird die Inline-Schema zum Erweitern der vorhandenen relationalen Struktur vor dem Laden der Daten verwendet. Wenn vorliegen Konflikte (z. B. dieselbe Spalte in derselben Tabelle mit unterschiedlichen Datentypen definiert) wird eine Ausnahme ausgelöst.  
  
 Wenn kein in-Line-Schema angegeben ist, wird die relationale Struktur gemäß der Struktur des XML-Dokuments durch Rückschluss nach Bedarf erweitert. Wenn das Schema durch Rückschluss erweitert werden kann um alle Daten verfügbar zu machen, wird eine Ausnahme ausgelöst.  
  
> [!NOTE]
>  Die `DataSet` ein XML-Element mit dem entsprechenden erfolgt keine Zuordnung zwischen `DataColumn` oder `DataTable` beim XML-Zeichen wie ("_") werden mit Escapezeichen versehen im serialisierten XML. Die `DataSet` selbst nur schützt ungültige XML-Zeichen in XML-Elementnamen und kann daher nur diese verarbeiten. Wenn zulässige Zeichen in XML-Elementnamen in Escapezeichen eingeschlossen sind, wird das Element bei der Verarbeitung ignoriert.  
  
 Wenn das XML-Schema für eine <xref:System.Data.DataSet> enthält eine `targetNamespace`, möglicherweise keine Daten gelesen und beim Aufrufen können Ausnahmen auftreten <xref:System.Data.DataSet.ReadXml%2A> beim Laden der <xref:System.Data.DataSet> mit XML, das Elemente ohne qualifizierenden Namespace enthält. Legen Sie zum Lesen von nicht qualifizierter Elementen `elementFormDefault` gleich "qualified" in das XML-Schema wie im folgende Beispiel veranschaulicht.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, wird eine Ausnahme ausgelöst, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXml%2A> durch Angabe `XmlReadMode.ReadSchema`. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest ein XML-Schema in die <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Der <see cref="T:System.IO.Stream" />, aus dem gelesen werden soll.</param>
        <summary>Liest das XML-Schema aus dem angegebenen <see cref="T:System.IO.Stream" /> in das <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataSet>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen. Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
> [!NOTE]
>  Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataSet.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataSet>.  
  
 Abgeleitete Klassen die <xref:System.IO.Stream> Klasse einbeziehen <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, und <xref:System.Net.Sockets.NetworkStream>.  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, eine Ausnahme ausgelöst wird, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXmlSchema%2A>. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.IO.FileStream> -Objekt zum Lesen eines XML-Schemas und ruft die <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode mit dem Objekt.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see cref="T:System.IO.TextReader" />, aus dem gelesen werden soll.</param>
        <summary>Liest das XML-Schema aus dem angegebenen <see cref="T:System.IO.TextReader" /> in das <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataSet>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen. Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
> [!NOTE]
>  Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataSet.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataSet>.  
  
 Klassen, die von erben die <xref:System.IO.TextReader> -Klasse enthalten die <xref:System.IO.StreamReader> und <xref:System.IO.StringReader> Klassen.  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, eine Ausnahme ausgelöst wird, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXmlSchema%2A>. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.IO.StreamReader> -Objekt zum Lesen eines Schemas und ruft die <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode mit dem Objekt.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataSet.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, aus der gelesen werden soll, einschließlich des Pfades.</param>
        <summary>Liest das XML-Schema aus der angegebenen Datei in das <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataSet>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen. Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
> [!NOTE]
>  Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataSet.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, wird eine Ausnahme ausgelöst, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXmlSchema%2A>. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> ist nicht auf <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugeordnete Enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der <see cref="T:System.Xml.XmlReader" />, aus dem gelesen werden soll.</param>
        <summary>Liest das XML-Schema aus dem angegebenen <see cref="T:System.Xml.XmlReader" /> in das <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode zum Erstellen des Schemas für eine <xref:System.Data.DataSet>. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
> [!NOTE]
>  Beschädigte Daten kann auftreten, wenn die Msdata:DataType und die Typen xs: Type stimmen nicht überein. Es wird keine Ausnahme ausgelöst.  
  
 Die <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode in der Regel aufgerufen wird, vor dem Aufrufen der <xref:System.Data.DataSet.ReadXml%2A> Methode dient zum Füllen der <xref:System.Data.DataSet>.  
  
 Die <xref:System.Xml.XmlReader?displayProperty=nameWithType> Klasse ist abstrakt. Eine Klasse, die von erben die `XmlReader` ist die <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> Klasse.  
  
> [!NOTE]
>  Wenn das Schema für Ihre <xref:System.Data.DataSet> enthält Elemente von den gleichen Namen, aber unterschiedlichen Typen im gleichen Namespace, eine Ausnahme ausgelöst wird, wenn Sie versuchen, lesen Sie das Schema in der <xref:System.Data.DataSet> mit <xref:System.Data.DataSet.ReadXmlSchema%2A>. Diese Ausnahme nicht ausgeführt, wenn Sie .NET Framework, Version 1.0 verwenden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.Data.DataSet> und <xref:System.IO.FileStream?displayProperty=nameWithType> Objekt. Die <xref:System.IO.FileStream> Objekt, das mit einem Dateipfad und den Dateinamen, erstellt dient zum Erstellen einer <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> , das als Argument übergeben wird die <xref:System.Data.DataSet.ReadXmlSchema%2A> Methode.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Der angegebene XML-Reader.</param>
        <summary>Ignoriert Attribute und gibt ein leeres DataSet zurück.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberSignature Language="F#" Value="abstract member RejectChanges : unit -&gt; unit&#xA;override this.RejectChanges : unit -&gt; unit" Usage="dataSet.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt einen Rollback aller Änderungen aus, die am <see cref="T:System.Data.DataSet" /> seit dessen Erstellung oder seit dem letzten Aufruf von <see cref="M:System.Data.DataSet.AcceptChanges" /> vorgenommen wurden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType> Aufrufen der <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> -Methode bei allen <xref:System.Data.DataTable> enthaltenen Objekte durch die <xref:System.Data.DataSet>.  
  
 <xref:System.Data.DataRow> Objekte in der <xref:System.Data.DataSet> jedes eingerichtet werden in den Bearbeitungsmodus Aufrufen der <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType> Methode. Nach dem Aufrufen der <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> -Methode, Änderungen können abgelehnt werden, durch Aufrufen der <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> auf die <xref:System.Data.DataTable> , der die <xref:System.Data.DataRow> Objekte gehören.  
  
 Wenn die <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> -Methode aufgerufen wird, alle Zeilen weiterhin im Bearbeitungsmodus Bearbeitungsvorgänge abgebrochen. Neue Zeilen werden entfernt. Geänderten und gelöschte Zeilen an den ursprünglichen Zustand zurückzugeben (`DataRowState.Unchanged`).  
  
 "AcceptChanges" und RejectChanges gelten nur für <xref:System.Data.DataRow> Änderungen bezüglich der (d. h. `Add`, `Remove`, `Delete`, und `Modify`). Sie gelten nicht für Schema oder strukturelle Änderungen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine abgeleitete Klasse die <xref:System.Data.DataSet> Klasse. Die <xref:System.Data.DataSet.RejectChanges%2A> Ereignis innerhalb einer Funktion aus aufgerufen wird.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Relations : System.Data.DataRelationCollection" Usage="System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der Beziehungen ab, die Tabellen verknüpfen und die Navigation von übergeordneten Tabellen zu untergeordneten Tabellen ermöglichen.</summary>
        <value>Ein <see cref="T:System.Data.DataRelationCollection" />, das eine Auflistung von <see cref="T:System.Data.DataRelation" />-Objekten enthält. Wenn keine <see cref="T:System.Data.DataRelation" />-Objekte vorhanden sind, wird eine leere Auflistung zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel gibt den Spaltennamen aller untergeordneten Tabellen über die <xref:System.Data.DataSet.Relations%2A> Eigenschaft.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das <see cref="T:System.Data.SerializationFormat" /> für das beim Remoting verwendete <see cref="T:System.Data.DataSet" /> ab oder legt dieses fest.</summary>
        <value>Ein <see cref="T:System.Data.SerializationFormat" />-Objekt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataSet.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht alle Tabellen und entfernt alle Beziehungen, Einschränkungen und fremden Tabellen von <see cref="T:System.Data.DataSet" />. Untergeordnete Klassen müssen <see cref="M:System.Data.DataSet.Reset" /> überschreiben, um ein <see cref="T:System.Data.DataSet" /> mit dem ursprünglichen Zustand wiederherzustellen.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSerializationMode : System.Data.SchemaSerializationMode with get, set" Usage="System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Data.SchemaSerializationMode" /> für ein <see cref="T:System.Data.DataSet" /> ab oder legt diesen fest.</summary>
        <value>Ruft einen <see cref="T:System.Data.SchemaSerializationMode" /> für ein <see cref="T:System.Data.DataSet" /> ab oder legt diesen fest.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Data.DataSet> serialisiert sein Schema und die Instanz standardmäßig in Webdiensten und Remoting-Szenarien. Festlegen der <xref:System.Data.DataSet.SchemaSerializationMode%2A> Eigenschaft eines typisierten `DataSet` auf <xref:System.Data.SchemaSerializationMode.ExcludeSchema> bewirkt, dass Schemainformationen aus der Serialisierungsnutzlast ausgeschlossen werden sollen.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> unterstützt wird nur für eine typisierte `DataSet`. Für einen nicht typisierten `DataSet` diese Eigenschaft kann nur festgelegt werden, um <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> sollte nur verwendet werden, wenn die Schemainformationen der zugrunde liegenden typisierten `DataTables`, `DataRelations` und `Constraints` wurde nicht geändert. Ggf. Änderungen eingetreten sind, vollständige Schemainformationen serialisiert werden mit <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> wird in Version 2.0 von .NET Framework oder höher unterstützt.  
  
 Wenn <xref:System.Data.SchemaSerializationMode.ExcludeSchema> festgelegt ist, wird nur die oberste Ebene Common Language Runtime-Eigenschaften vorhanden, auf die <xref:System.Data.DataSet> serialisiert werden. Darüber hinaus sind sie nur serialisiert, wenn wiedergibt, von den Standardwerten abweichen. Keines der `Tables`, `Relations` oder `Constraints` serialisiert werden. Die serialisierten Laufzeiteigenschaften enthalten <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>, <xref:System.Data.DataSet.Prefix%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>, und <xref:System.Data.DataSet.CaseSensitive%2A>. Diese Eigenschaften werden serialisiert, um sicherzustellen, dass die gesamte Common Language Runtime die Datenintegrität erhalten bleibt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeRelations : unit -&gt; bool&#xA;override this.ShouldSerializeRelations : unit -&gt; bool" Usage="dataSet.ShouldSerializeRelations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="P:System.Data.DataSet.Relations" />-Eigenschaft beibehalten werden soll.</summary>
        <returns>
          <see langword="true" />, wenn der Eigenschaftswert in einen anderen Wert als den Standardwert geändert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird in der Regel verwenden, wenn Sie entweder einen Designer für das Erstellen der <xref:System.Data.DataSet>, oder erstellen eine eigene Steuerelement einbinden der <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 Die folgenden Beispiele zeigen, eine abgeleitete Klasse die <xref:System.Data.DataSet> Klasse. Die <xref:System.Data.DataSet.Reset%2A> und <xref:System.Data.DataSet.ShouldSerializeRelations%2A> Methoden von innerhalb von Funktionen in der abgeleiteten Klasse aufgerufen werden.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTables : unit -&gt; bool&#xA;override this.ShouldSerializeTables : unit -&gt; bool" Usage="dataSet.ShouldSerializeTables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die <see cref="P:System.Data.DataSet.Tables" />-Eigenschaft beibehalten werden soll.</summary>
        <returns>
          <see langword="true" />, wenn der Eigenschaftswert in einen anderen Wert als den Standardwert geändert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird in der Regel verwenden, nur, wenn Sie entweder einen Designer für das Erstellen der <xref:System.Data.DataSet>, oder erstellen eine eigene Steuerelement einbinden der <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine abgeleitete Klasse die <xref:System.Data.DataSet> Klasse. Die <xref:System.Data.DataSet.ShouldSerializeTables%2A> Methode wird von Funktionen in der abgeleiteten Klasse aufgerufen.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.ComponentModel.ISite" /> für den <see cref="T:System.Data.DataSet" /> ab oder legt diese fest.</summary>
        <value>Ein <see cref="T:System.ComponentModel.ISite" /> für das <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sites Binden einer <xref:System.ComponentModel.Component> auf eine <xref:System.ComponentModel.Container> und ermöglichen die Kommunikation zwischen diesen sowie bieten eine Möglichkeit für den Container, seine Komponenten zu verwalten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Data.DataSet.System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>Eine Beschreibung dieses Elements finden Sie unter <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.ComponentModel.IListSource>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.ComponentModel.IListSource.GetList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.ComponentModel.IListSource>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Ein <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Ein <see cref="T:System.Xml.XmlWriter" />.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Data.DataSet>-Instanz in eine <xref:System.Xml.Serialization.IXmlSerializable>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Tables : System.Data.DataTableCollection" Usage="System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Auflistung der im <see cref="T:System.Data.DataSet" /> enthaltenen Tabellen ab.</summary>
        <value>Die in diesem <see cref="T:System.Data.DataTableCollection" /> enthaltene <see cref="T:System.Data.DataSet" />. Wenn keine <see cref="T:System.Data.DataTable" />-Objekte vorhanden sind, wird eine leere Auflistung zurückgegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie zum Hinzufügen von Tabellen auf die Auflistung <xref:System.Data.DataTableCollection.Add%2A> Methode der <xref:System.Data.DataTableCollection>. Um Tabellen zu entfernen, verwenden Sie die <xref:System.Data.DataTableCollection.Remove%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel gibt die <xref:System.Data.DataSet> des Objekts <xref:System.Data.DataTableCollection>, und die Spalten und Zeilen in jeder Tabelle ausgegeben.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt XML-Daten und bei Bedarf das Schema aus dem <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Ein <see cref="T:System.IO.Stream" />-Objekt, mit dem in eine Datei geschrieben wird.</param>
        <summary>Schreibt mit dem angegebenen <see cref="T:System.Data.DataSet" /> die aktuellen Daten für das <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `WriteXml` Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataSet> in ein XML-Dokument während der <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.ReadXml%2A> und <xref:System.Data.DataSet.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataSet`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.IO.FileStream?displayProperty=nameWithType> Objekt. Das Objekt wird dann verwendet, mit der <xref:System.Data.DataSet.WriteXml%2A> Methode, um ein XML-Dokument zu schreiben.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Das <see cref="T:System.IO.TextWriter" />-Objekt, mit dem geschrieben werden soll.</param>
        <summary>Schreibt mit dem angegebenen <see cref="T:System.Data.DataSet" /> die aktuellen Daten für das <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `WriteXml` Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataSet> in ein XML-Dokument während der <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.ReadXml%2A> und <xref:System.Data.DataSet.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataSet`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataSet.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, in die geschrieben werden soll, einschließlich des Pfades.</param>
        <summary>Schreibt die aktuellen Daten für das <see cref="T:System.Data.DataSet" /> in die angegebene Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `WriteXml` Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataSet> in ein XML-Dokument während der <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.ReadXml%2A> und <xref:System.Data.DataSet.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataSet`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> ist nicht auf <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugeordnete Enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der <see cref="T:System.Xml.XmlWriter" />, mit dem geschrieben werden soll.</param>
        <summary>Schreibt die aktuellen Daten für das <see cref="T:System.Data.DataSet" /> in den angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `WriteXml` Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataSet> in ein XML-Dokument während der <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode schreibt nur das Schema. Verwenden Sie zum Schreiben von Daten und Schema eine der Überladungen, die enthält die `mode` Parameter, und legen Sie dessen Wert auf `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.ReadXml%2A> und <xref:System.Data.DataSet.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataSet`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Ein <see cref="T:System.IO.Stream" />-Objekt, mit dem in eine Datei geschrieben wird.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt mit dem angegebenen <see cref="T:System.Data.DataSet" /> und im angegebenen <see cref="T:System.IO.Stream" /> die aktuellen Daten und bei Bedarf das Schema für die <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `WriteXml` Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataSet> in ein XML-Dokument während der <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, legen die `mode` Parameter `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.ReadXml%2A> und <xref:System.Data.DataSet.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataSet`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Ein <see cref="T:System.IO.TextWriter" />-Objekt, mit dem das Dokument geschrieben wird.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt mit dem angegebenen <see cref="T:System.Data.DataSet" /> und im angegebenen <see cref="T:System.IO.TextWriter" /> die aktuellen Daten und bei Bedarf das Schema für die <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `WriteXml` Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataSet> in ein XML-Dokument während der <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, legen die `mode` Parameter `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.ReadXml%2A> und <xref:System.Data.DataSet.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataSet`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt zuerst eine einfache <xref:System.Data.DataSet> mit einem <xref:System.Data.DataTable>, zwei Spalten und zehn Zeilen. Die <xref:System.Data.DataSet> Schema und Daten durch den Aufruf auf den Datenträger geschrieben werden die <xref:System.Data.DataSet.WriteXml%2A> Methode. Ein zweites <xref:System.Data.DataSet> wird erstellt und die <xref:System.Data.DataSet.ReadXml%2A> Methode wird verwendet, um mit dem Schema und Daten zu füllen.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, in die geschrieben werden soll, einschließlich des Pfades.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt im angegebenen <see cref="T:System.Data.DataSet" /> die aktuellen Daten und bei Bedarf das Schema für die <see cref="T:System.Data.XmlWriteMode" /> in die angegebene Datei. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `WriteXml` Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataSet> in ein XML-Dokument während der <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, legen die `mode` Parameter `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.ReadXml%2A> und <xref:System.Data.DataSet.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataSet`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Data.DataSet.WriteXml%2A> Methode, um ein XML-Dokument zu schreiben.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> ist nicht auf <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugeordnete Enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">Der <see cref="T:System.Xml.XmlWriter" />, mit dem geschrieben werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.Data.XmlWriteMode" />-Werte.</param>
        <summary>Schreibt mit dem angegebenen <see cref="T:System.Data.DataSet" /> und im angegebenen <see cref="T:System.Xml.XmlWriter" /> die aktuellen Daten und bei Bedarf das Schema für die <see cref="T:System.Data.XmlWriteMode" />. Um das Schema zu schreiben, legen Sie den Wert für den <paramref name="mode" />-Parameter auf <see langword="WriteSchema" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `WriteXml` Methode bietet eine Möglichkeit, entweder nur Daten zu schreiben oder Schemas und Daten aus einer <xref:System.Data.DataSet> in ein XML-Dokument während der <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode schreibt nur das Schema. Um Schemas und Daten zu schreiben, legen die `mode` Parameter `WriteSchema`.  
  
 Beachten Sie, dass der gleiche "true" für die <xref:System.Data.DataSet.ReadXml%2A> und <xref:System.Data.DataSet.ReadXmlSchema%2A> Methoden bzw. Zum Lesen von XML-Daten oder Schema und Daten in der `DataSet`, verwenden Sie die `ReadXml` Methode. Um nur das Schema zu lesen, verwenden die `ReadXmlSchema` Methode.  
  
> [!NOTE]
>  Ein <xref:System.InvalidOperationException> wird ausgelöst, wenn der Spaltentyp in der `DataRow` aus gelesen oder geschrieben werden, um implementiert <xref:System.Dynamic.IDynamicMetaObjectProvider> und implementiert nicht die <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.IO.FileStream?displayProperty=nameWithType> -Objekt, das verwendet wird, zum Erstellen eines neuen <xref:System.Xml.XmlTextWriter>. Die <xref:System.Xml.XmlTextWriter> Objekt wird verwendet, mit der <xref:System.Data.DataSet.WriteXml%2A> Methode, um ein XML-Dokument zu schreiben.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schreibt die <see cref="T:System.Data.DataSet" />-Struktur als XML-Schema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Ein <see cref="T:System.IO.Stream" />-Objekt, mit dem in eine Datei geschrieben wird.</param>
        <summary>Schreibt die <see cref="T:System.Data.DataSet" />-Struktur als XML-Schreibt in das angegebene <see cref="T:System.IO.Stream" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataSet.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataSet> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen. Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataSet.WriteXml%2A> Methode.  
  
 Abgeleitete Klassen die <xref:System.IO.Stream> Klasse einbeziehen <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, und <xref:System.Net.Sockets.NetworkStream>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.IO.FileStream> -Objekt, das an die <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode, um das Schema auf den Datenträger zu schreiben.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Das <see cref="T:System.IO.TextWriter" />-Objekt, mit dem geschrieben werden soll.</param>
        <summary>Schreibt die <see cref="T:System.Data.DataSet" />-Struktur als XML-Schreibt in das angegebene <see cref="T:System.IO.TextWriter" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataSet.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataSet> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen. Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataSet.WriteXml%2A> Methode.  
  
 Die von Klassen die <xref:System.IO.TextWriter?displayProperty=nameWithType> -Klasse enthalten die <xref:System.Web.HttpWriter?displayProperty=nameWithType>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, <xref:System.IO.StreamWriter?displayProperty=nameWithType>, und <xref:System.IO.StringWriter?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine <xref:System.Text.StringBuilder?displayProperty=nameWithType> Objekt, dient zum Erstellen eines neuen <xref:System.IO.StringWriter?displayProperty=nameWithType>. Die <xref:System.IO.StringWriter> wird zum Übergeben der <xref:System.Data.DataSet.WriteXmlSchema%2A> -Methode und die resultierende Zeichenfolge wird an das Konsolenfenster ausgegeben.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataSet.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, in die geschrieben werden soll, einschließlich des Pfades.</param>
        <summary>Schreibt die <see cref="T:System.Data.DataSet" />-Struktur als XML-Schema in eine Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataSet.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataSet> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen. Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataSet.WriteXml%2A> Methode.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> ist nicht auf <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> festgelegt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">zum Lesen und Schreiben von Dateien. Zugeordnete Enumeration: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Der <see cref="T:System.Xml.XmlWriter" />, in den geschrieben werden soll.</param>
        <summary>Schreibt die <see cref="T:System.Data.DataSet" />-Struktur als XML-Schema in ein <see cref="T:System.Xml.XmlWriter" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Data.DataSet.WriteXmlSchema%2A> -Methode, schreiben das Schema für eine <xref:System.Data.DataSet> ein XML-Dokument. Das Schema enthält die Tabelle, Beziehung, und Einschränkungsdefinitionen. Um ein Schema in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode.  
  
 Das XML-Schema wird mit dem XSD-Standard geschrieben.  
  
 Um die Daten in ein XML-Dokument zu schreiben, verwenden die <xref:System.Data.DataSet.WriteXml%2A> Methode.  
  
 Eine Klasse, die von erben die <xref:System.Xml.XmlWriter?displayProperty=nameWithType> Klasse ist die <xref:System.Xml.XmlTextWriter> Klasse.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein neues <xref:System.IO.FileStream?displayProperty=nameWithType> Objekt mit dem angegebenen Pfad. Die <xref:System.IO.FileStream> Objekt dient zum Erstellen einer <xref:System.Xml.XmlTextWriter> Objekt. Die <xref:System.Data.DataSet.WriteXmlSchema%2A> Methode wird dann aufgerufen, mit der <xref:System.Xml.XmlTextWriter> Objekt, das Schema auf den Datenträger geschrieben werden.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (stream, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">Ein <see cref="T:System.IO.Stream" />-Objekt, in das geschrieben werden soll.</param>
        <param name="multipleTargetConverter">Ein Delegat, der zum Konvertieren von <see cref="T:System.Type" /> in String verwendet wird.</param>
        <summary>Schreibt die <see cref="T:System.Data.DataSet" />-Struktur als XML-Schreibt in das angegebene <see cref="T:System.IO.Stream" />-Objekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">Ein <see cref="T:System.IO.TextWriter" />-Objekt, in das geschrieben werden soll.</param>
        <param name="multipleTargetConverter">Ein Delegat, der zum Konvertieren von <see cref="T:System.Type" /> in String verwendet wird.</param>
        <summary>Schreibt die <see cref="T:System.Data.DataSet" />-Struktur als XML-Schema in den angegebenen <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (fileName, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">Der Name der Datei, in die geschrieben werden soll.</param>
        <param name="multipleTargetConverter">Ein Delegat, der zum Konvertieren von <see cref="T:System.Type" /> in String verwendet wird.</param>
        <summary>Schreibt die <see cref="T:System.Data.DataSet" />-Struktur als XML-Schema in eine Datei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">Ein <see cref="T:System.Xml.XmlWriter" />-Objekt, in das geschrieben werden soll.</param>
        <param name="multipleTargetConverter">Ein Delegat, der zum Konvertieren von <see cref="T:System.Type" /> in String verwendet wird.</param>
        <summary>Schreibt die <see cref="T:System.Data.DataSet" />-Struktur als XML-Schema in den angegebenen <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>