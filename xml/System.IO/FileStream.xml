<Type Name="FileStream" FullName="System.IO.FileStream">
  <Metadata><Meta Name="ms.openlocfilehash" Value="450ae81433090d293ab80bd6288a526770efbd22" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58700394" /></Metadata><TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class FileStream&#xA;Inherits Stream" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileStream : System::IO::Stream" />
  <TypeSignature Language="F#" Value="type FileStream = class&#xA;    inherit Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen <see cref="T:System.IO.Stream" /> für eine Datei bereit, wobei synchrone und asynchrone Lese- und Schreibvorgänge unterstützt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.IO.FileStream> Klasse zum Lesen, schreiben zu öffnen und Schließen von Dateien in einem Dateisystem und zum anderen dateibezogenen Betriebssystemhandles, z. B. Pipes, Standardeingabe, Standardausgabe und zu bearbeiten. Können Sie die <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, und <xref:System.IO.FileStream.Flush%2A> Methoden zum Durchführen von synchroner Vorgängen oder <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, und <xref:System.IO.FileStream.FlushAsync%2A> Methoden zum asynchronen Ausführen Vorgänge. Verwenden Sie die asynchronen Methoden, um ressourcenintensive Vorgänge ausführen, ohne den Hauptthread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. <xref:System.IO.FileStream> Puffer, die Eingabe und Ausgabe für eine bessere Leistung.  
  
> [!IMPORTANT]
>  Dieser Typ implementiert die <xref:System.IDisposable>-Schnittstelle. Nach Abschluss der Verwendung sollten Sie den Typ entweder direkt oder indirekt löschen. Zum direkten Löschen des Typs rufen Sie seine <xref:System.IDisposable.Dispose%2A>-Methode in einem `try`/`catch`-Block auf. Zum indirekten Löschen verwenden Sie ein Sprachkonstrukt wie `using` (in C#) oder `Using` (in Visual Basic). Weitere Informationen finden Sie im Abschnitt „Verwenden eines Objekts, das IDisposable implementiert“ des Themas „Die <xref:System.IDisposable>-Schnittstelle“.  
  
 Die <xref:System.IO.FileStream.IsAsync%2A> -Eigenschaft erkennt, ob die Dateihandle asynchron geöffnet wurde. Sie geben Sie diesen Wert bei der Erstellung einer Instanz von der <xref:System.IO.FileStream> -Klasse unter Verwendung eines Konstruktors, die eine `isAsync`, `useAsync`, oder `options` Parameter. Wenn die Eigenschaft ist `true`, der Datenstrom verwendet überlappende e/a, um die Dateivorgänge asynchron ausführen. Allerdings die <xref:System.IO.FileStream.IsAsync%2A> Eigenschaft hat keine sein `true` zum Aufrufen der <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, oder <xref:System.IO.Stream.CopyToAsync%2A> Methode. Wenn die <xref:System.IO.FileStream.IsAsync%2A> Eigenschaft `false` und Sie rufen den asynchronen Lesevorgang und Schreibvorgänge, der UI-Thread wird weiterhin nicht blockiert, aber der tatsächliche e/a-Vorgang synchron ausgeführt wird.  
  
 Die <xref:System.IO.FileStream.Seek%2A> Methode unterstützt den zufälligen Zugriff auf Dateien. <xref:System.IO.FileStream.Seek%2A> ermöglicht den Lese-/Schreibposition in einer beliebigen Position innerhalb der Datei verschoben werden. Dies erfolgt mit dem Parameter für den Bezugspunkt Byte. Das Byte-Offset ist relativ zu den Seek-Referenzpunkt an, der den Anfang, der aktuellen Position oder das Ende der zugrunde liegenden Datei sein kann, dargestellt durch die drei Elemente von der <xref:System.IO.SeekOrigin> Enumeration.  
  
> [!NOTE]
>  Dateien auf Datenträgern unterstützen immer den wahlfreien Zugriff. Zum Zeitpunkt der Erstellung der <xref:System.IO.FileStream.CanSeek%2A> Eigenschaftswert wird festgelegt, um `true` oder `false` je nach zugrunde liegenden Dateityp. Wenn die zugrunde liegenden Dateityp FILE_TYPE_DISK ist, wie definiert in winbase.h der <xref:System.IO.FileStream.CanSeek%2A> Eigenschaftswert ist `true`. Andernfalls die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaftswert ist `false`.  
  
 Wenn ein Prozess beendet, klicken Sie mit Teil der Datei gesperrt wird oder schließt eine Datei mit ausstehenden sperren, ist das Verhalten nicht definiert.  
  
 Vorgänge für Verzeichnisse und sonstigen Dateivorgängen finden Sie in der <xref:System.IO.File>, <xref:System.IO.Directory>, und <xref:System.IO.Path> Klassen. Die <xref:System.IO.File> Klasse ist eine Hilfsprogrammklasse, die statische Methoden in erster Linie für die Erstellung von <xref:System.IO.FileStream> Objekten auf der Grundlage von Dateipfaden. Die <xref:System.IO.MemoryStream> -Klasse erstellt einen Datenstrom aus einem Bytearray und ähnelt der <xref:System.IO.FileStream> Klasse.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
## <a name="detection-of-stream-position-changes"></a>Erkennung von Änderungen der Stream-Position  
 Wenn eine <xref:System.IO.FileStream> Objekt hat keinen exklusiven auf das Handle, das ein anderer Thread gleichzeitig Zugriff auf das Dateihandle könnten, und ändern Sie die Position des Dateizeigers von des Betriebssystems, das das Dateihandle zugeordnet ist. In diesem Fall die zwischengespeicherte Position in der <xref:System.IO.FileStream> -Objekt und die zwischengespeicherten Daten in den Puffer können beeinträchtigt werden. Die <xref:System.IO.FileStream> Objekt auf Methoden, die Zugriff auf den zwischengespeicherten Puffer, um sicherzustellen, dass Position für das Betriebssystem-Handles identisch mit die zwischengespeicherte Position ein, die regelmäßig überprüft die <xref:System.IO.FileStream> Objekt.  
  
 Wenn unerwartete Änderungen in die Position des Handles in einem Aufruf von erkannt, wird die <xref:System.IO.FileStream.Read%2A> -Methode, die .NET Framework verwirft den Inhalt des Puffers und liest den Stream aus der Datei noch einmal aus. Dies die Leistung beeinträchtigen kann je nach Größe der Datei und alle anderen Prozesse, die die Position des Dateidatenstroms beeinträchtigen könnten.  
  
 Wenn unerwartete Änderungen in die Position des Handles in einem Aufruf von erkannt wird die <xref:System.IO.FileStream.Write%2A> -Methode, die Inhalte des Puffers werden verworfen und ein <xref:System.IO.IOException> Ausnahme ausgelöst.  
  
 Ein <xref:System.IO.FileStream> -Objekt keinen exklusiven auf das Handle Wenn entweder die <xref:System.IO.FileStream.SafeFileHandle%2A> -Eigenschaft zugegriffen wird, um das Handle verfügbar zu machen oder die <xref:System.IO.FileStream> Objekt erhält die <xref:System.IO.FileStream.SafeFileHandle%2A> Eigenschaft in seinem Konstruktor.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einige der <xref:System.IO.FileStream> Konstruktoren.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 Das folgende Beispiel zeigt, wie asynchron in eine Datei geschrieben wird. Dieser Code ausgeführt wird, in einer WPF-app, die ein TextBlock-Element mit dem Namen UserInput und eine Schaltfläche, um einen Click-Ereignishandler mit dem Namen Button_Click verknüpft ist. Der Dateipfad muss in eine Datei geändert werden, die auf dem Computer vorhanden ist.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.File" />
    <altmember cref="T:System.IO.FileAccess" />
    <altmember cref="T:System.IO.FileMode" />
    <altmember cref="T:System.IO.FileShare" />
    <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md">Gewusst wie: Lesen und Schreiben einer neu erstellten Datendatei</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle und mit der angegebenen Lese- und Schreibberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.IO.Stream.Close%2A> wird aufgerufen, wird auch das Handle geschlossen und der der Datei verringert.  
  
 `FileStream` wird davon ausgegangen, dass dieser exklusive Kontrolle über den Steuerpunkt verfügt. Lesen, schreiben oder möchten, während eine `FileStream` enthält auch ein Handle datenbeschädigung verursachen. Rufen Sie für die datensicherheit, <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie anschließend mit dem Handle.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 `FileShare.Read` ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> ist kein Feld von <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle und mit der angegebenen Lese- und Schreibberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.IO.Stream.Close%2A> wird aufgerufen, wird auch das Handle geschlossen und der der Datei verringert.  
  
 `FileStream` wird davon ausgegangen, dass dieser exklusive Kontrolle über den Steuerpunkt verfügt. Lesen, schreiben oder möchten, während eine `FileStream` enthält auch ein Handle datenbeschädigung verursachen. Rufen Sie für die datensicherheit, <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie anschließend mit dem Handle.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 `FileShare.Read` ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> ist kein Feld von <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit dem angegebenen Pfad und dem angegebenen Erstellungsmodus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, die Namen der Geräte, wie z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein.  
  
 Der Konstruktor erhält Lese-/Schreibzugriff auf die Datei, und es wird geöffnet, und der Lesezugriff freigegeben (d. h. die Anforderungen zum Öffnen der Datei für das Schreiben von diesem oder einem anderen Prozess bis fehl der `FileStream` Objekt geschlossen wurde, Leseversuche jedoch erfolgreich ausgeführt werden).  
  
 Sie können nicht diesen Konstruktor verwenden, um schreibgeschützte Dateien zu öffnen; Sie müssen stattdessen einen Konstruktor, akzeptiert eine `FileAccess` Parameter mit dem der Wert `FileAccess.Read`.  
  
 Die Größe des Puffers, die in die Standardgröße von 4096 Bytes (4 KB) festgelegt ist.  
  
> [!NOTE]
>  `path` ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Sie können einen beliebigen Teil eines Systems sein, die Zugriff über Streams unterstützt. Diese Klasse abhängig von dem System kann beispielsweise ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien kapseln. Wenn `path` gibt an ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für das resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
 Für Konstruktoren ohne eine <xref:System.IO.FileAccess> Parameter, wenn die `mode` Parametersatz zu <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> der Standardzugriff ist. Andernfalls wird der Zugriff auf festgelegt <xref:System.IO.FileAccess.ReadWrite>.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Schreiben von Daten in eine Datei byteweise, und stellen Sie sicher, dass die Daten richtig geschrieben wurde.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="path" /> gibt eine schreibgeschützte Datei an.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="F:System.IO.Path.InvalidPathChars" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine <see cref="T:System.IO.FileAccess" />-Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts festlegt.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung und die Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream` wird davon ausgegangen, dass dieser exklusive Kontrolle über den Steuerpunkt verfügt. Lesen, schreiben oder möchten, während eine `FileStream` enthält auch ein Handle datenbeschädigung verursachen. Rufen Sie für die datensicherheit, <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie anschließend mit dem Handle. Alternativ können Sie lesen und Schreiben Sie auf den Ziehpunkt, vor dem Aufrufen dieser `FileStream` Konstruktor.  
  
 `FileShare.Read` ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="handle" />-Parameter ist ein ungültiges Handle.  
  
- oder - 
Der <paramref name="handle" />-Parameter ist ein synchrones Handle und wurde asynchron verwendet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="bufferSize" />-Parameter ist negativ.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Berechtigung zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <param name="ownsHandle"><see langword="true" />, wenn das Dateihandle im Besitz dieser <see langword="FileStream" />-Instanz sein wird, andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung und für den Besitz der <see langword="FileStream" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileStream` Objekt den angegebenen Zugriff auf die Datei erhält. Der Besitz des Handles werden wie angegeben. Wenn der Prozess das Handle, das einen Aufruf von besitzt das <xref:System.IO.Stream.Close%2A> Methode wird auch das Handle geschlossen und der der Datei verringert. Die `FileStream` Objekt erhält die Standardpuffergröße von 4096 Bytes.  
  
 `FileStream` wird davon ausgegangen, dass dieser exklusive Kontrolle über den Steuerpunkt verfügt. Lesen, schreiben oder möchten, während eine `FileStream` enthält auch ein Handle datenbeschädigung verursachen. Rufen Sie für die datensicherheit, <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie den Aufruf von Methoden außer `Close` Sie anschließend mit dem Handle.  
  
 `FileShare.Read` ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="access" /> ist kein Feld von <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="access">Eine Konstante, die bestimmt, welcher Zugriff auf die Datei für das <see langword="FileStream" />-Objekt zulässig ist. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" /> ist <see langword="true" />, wenn <paramref name="path" /> eine Datei auf einem Datenträger darstellt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus und die Lese-/Schreibberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, die Namen der Geräte, wie z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein.  
  
 Der Konstruktor erhält Lese-/Schreibzugriff auf die Datei, und es wird geöffnet, und der Lesezugriff freigegeben (d. h. die Anforderungen zum Öffnen der Datei für das Schreiben von diesem oder einem anderen Prozess bis fehl der `FileStream` Objekt geschlossen wurde, Leseversuche jedoch erfolgreich ausgeführt werden). Die Größe des Puffers, die in die Standardgröße von 4096 Bytes (4 KB) festgelegt ist.  
  
> [!NOTE]
>  `path` ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Sie können einen beliebigen Teil eines Systems sein, die Zugriff über Streams unterstützt. Diese Klasse abhängig von dem System kann beispielsweise ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien kapseln. Wenn `path` gibt an ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für das resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read` ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeFileHandle, access As FileAccess, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::IO::FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : Microsoft.Win32.SafeHandles.SafeFileHandle * System.IO.FileAccess * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die von diesem <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="isAsync"><see langword="true" />, wenn das Handle asynchron geöffnet wurde (im überlappenden E/A-Modus), andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung, die Puffergröße und den synchronen bzw. asynchronen Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen der `isAsync` Parameter `true` das Datei-Handle asynchron geöffnet. Wenn der Parameter ist `true`, der Datenstrom verwendet überlappende e/a, um die Dateivorgänge asynchron ausführen. Allerdings der-Parameter muss keine werden `true` zum Aufrufen der <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, oder <xref:System.IO.Stream.CopyToAsync%2A> Methode. Wenn die `isAsync` Parameter `false` und Sie rufen den asynchronen Lesevorgang und Schreibvorgänge, der UI-Thread wird weiterhin nicht blockiert, aber der tatsächliche e/a-Vorgang synchron ausgeführt wird.  
  
 `FileStream` wird davon ausgegangen, dass dieser exklusive Kontrolle über den Steuerpunkt verfügt. Lesen, schreiben oder möchten, während eine `FileStream` enthält auch ein Handle datenbeschädigung verursachen. Rufen Sie für die datensicherheit, <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie anschließend mit dem Handle. Alternativ können Sie lesen und Schreiben Sie auf den Ziehpunkt, vor dem Aufrufen dieser `FileStream` Konstruktor.  
  
 `FileShare.Read` ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="handle" />-Parameter ist ein ungültiges Handle.  
  
- oder - 
Der <paramref name="handle" />-Parameter ist ein synchrones Handle und wurde asynchron verwendet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="bufferSize" />-Parameter ist negativ.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Berechtigung zum Aufrufen von nicht verwalteten Codes. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die von diesem <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <param name="ownsHandle"><see langword="true" />, wenn das Dateihandle im Besitz dieser <see langword="FileStream" />-Instanz sein wird, andernfalls <see langword="false" />.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung, den Besitz der <see langword="FileStream" />-Instanz und die Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileStream` Objekt den angegebenen Zugriff auf die Datei erhält. Der Besitz des Handles werden wie angegeben. Wenn diese `FileStream` besitzt das Handle, das einen Aufruf der <xref:System.IO.Stream.Close%2A> Methode wird auch das Handle geschlossen. Insbesondere wird der Handleanzahl der Datei verringert. Die `FileStream` Objekt erhält die angegebenen Puffergröße.  
  
 `FileStream` wird davon ausgegangen, dass dieser exklusive Kontrolle über den Steuerpunkt verfügt. Lesen, schreiben oder möchten, während eine `FileStream` enthält auch ein Handle datenbeschädigung verursachen. Rufen Sie für die datensicherheit, <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie anschließend mit dem Handle. Alternativ können Sie lesen und Schreiben Sie auf den Ziehpunkt, vor dem Aufrufen dieser `FileStream` Konstruktor.  
  
 `FileShare.Read` ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="access">Eine Konstante, die bestimmt, welcher Zugriff auf die Datei für das <see langword="FileStream" />-Objekt zulässig ist. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" /> ist <see langword="true" />, wenn <paramref name="path" /> eine Datei auf einem Datenträger darstellt.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, die Namen der Geräte, wie z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein.  
  
 Der Konstruktor erhält Lese-/Schreibzugriff auf die Datei, und es wird geöffnet, und der Lesezugriff freigegeben (d. h. die Anforderungen zum Öffnen der Datei für das Schreiben von diesem oder einem anderen Prozess bis fehl der `FileStream` Objekt geschlossen wurde, Leseversuche jedoch erfolgreich ausgeführt werden). Die Größe des Puffers, die in die Standardgröße von 4096 Bytes (4 KB) festgelegt ist.  
  
> [!NOTE]
>  `path` ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Sie können einen beliebigen Teil eines Systems sein, die Zugriff über Streams unterstützt. Diese Klasse abhängig von dem System kann beispielsweise ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien kapseln. Wenn `path` gibt an ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für das resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.Lock%2A> Methode.  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
- oder - 
Das System führt Windows 98 oder Windows 98 Zweite Ausgabe aus, und <paramref name="share" /> ist auf <see langword="FileShare.Delete" /> festgelegt.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> enthält einen ungültigen Wert.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr, access As FileAccess, ownsHandle As Boolean, bufferSize As Integer, isAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(IntPtr handle, System::IO::FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : nativeint * System.IO.FileAccess * bool * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (handle, access, ownsHandle, bufferSize, isAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ownsHandle" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="isAsync" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="handle">Ein Dateihandle für die Datei, die von diesem <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="access">Eine Konstante, die die <see cref="P:System.IO.FileStream.CanRead" />-Eigenschaft und die <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaft des <see langword="FileStream" />-Objekts festlegt.</param>
        <param name="ownsHandle"><see langword="true" />, wenn das Dateihandle im Besitz dieser <see langword="FileStream" />-Instanz sein wird, andernfalls <see langword="false" />.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="isAsync"><see langword="true" />, wenn das Handle asynchron geöffnet wurde (im überlappenden E/A-Modus), andernfalls <see langword="false" />.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse für das angegebene Dateihandle mit den Angaben für die Lese-/Schreibberechtigung, den Besitz der <see langword="FileStream" />-Instanz, die Puffergröße und den synchronen bzw. asynchronen Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `FileStream` Objekt den angegebenen Zugriff auf die Datei erhält. Der Besitz des Handles werden wie angegeben. Wenn diese `FileStream` besitzt das Handle, das einen Aufruf der <xref:System.IO.Stream.Close%2A> Methode wird auch das Handle geschlossen. Insbesondere wird der Handleanzahl der Datei verringert. Die `FileStream` Objekt erhält die angegebenen Puffergröße.  
  
 `FileStream` wird davon ausgegangen, dass dieser exklusive Kontrolle über den Steuerpunkt verfügt. Lesen, schreiben oder möchten, während eine `FileStream` enthält auch ein Handle datenbeschädigung verursachen. Rufen Sie für die datensicherheit, <xref:System.IO.FileStream.Flush%2A> vor Verwendung des Handles, und vermeiden Sie durch Aufrufen von Methoden außer `Close` Sie anschließend mit dem Handle. Alternativ können Sie lesen und Schreiben Sie auf den Ziehpunkt, vor dem Aufrufen dieser `FileStream` Konstruktor.  
  
 `FileShare.Read` ist der Standardwert für diese <xref:System.IO.FileStream> Konstruktoren ohne eine `FileShare` Parameter.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="access" /> ist kleiner als <see langword="FileAccess.Read" /> oder größer als <see langword="FileAccess.ReadWrite" /> oder <paramref name="bufferSize" /> ist kleiner als oder gleich 0.</exception>
        <exception cref="T:System.ArgumentException">Das Handle ist ungültig.</exception>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler, z. B. ein Datenträgerfehler, ist aufgetreten.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für das angegebene Dateihandle wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und das Dateihandle schreibgeschützt ist.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff von nicht verwaltetem Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="access">Eine Konstante, die bestimmt, welcher Zugriff auf die Datei für das <see langword="FileStream" />-Objekt zulässig ist. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" /> ist <see langword="true" />, wenn <paramref name="path" /> eine Datei auf einem Datenträger darstellt.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung sowie die Puffergröße.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, die Namen der Geräte, wie z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein.  
  
> [!NOTE]
>  `path` ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Sie können einen beliebigen Teil eines Systems sein, die Zugriff über Streams unterstützt. Diese Klasse abhängig von dem System kann beispielsweise ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien kapseln. Wenn `path` gibt an ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für das resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
- oder - 
 <paramref name="mode" />, <paramref name="access" /> oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
- oder - 
Das System führt Windows 98 oder Windows 98 Zweite Ausgabe aus, und <paramref name="share" /> ist auf <see langword="FileShare.Delete" /> festgelegt.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, useAsync As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * bool -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, useAsync)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="access">Eine Konstante, die bestimmt, welcher Zugriff auf die Datei für das <see langword="FileStream" />-Objekt zulässig ist. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" /> ist <see langword="true" />, wenn <paramref name="path" /> eine Datei auf einem Datenträger darstellt.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="useAsync">Gibt an, ob eine asynchrone E/A oder eine synchrone E/A verwendet wird. Beachten Sie jedoch, dass das zugrunde liegende Betriebssystem möglicherweise keine asynchrone E/A unterstützt, sodass das Handle je nach Plattform auch bei der Angabe von <see langword="true" /> möglicherweise synchron geöffnet wird. Bei asynchronem Öffnen liefern die <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode und die <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />-Methode bei umfangreichen Lese- oder Schreibvorgängen eine höhere Leistung, sind aber möglicherweise bei kleinen Lese- und Schreibvorgängen wesentlich langsamer. Wenn die Anwendung die Vorteile der asynchronen E/A nutzen kann, legen Sie den <paramref name="useAsync" />-Parameter auf <see langword="true" /> fest. Wird die asynchrone E/A richtig eingesetzt, können Anwendungen um ein Zehnfaches beschleunigt werden. Wenn die Anwendung jedoch nicht an eine asynchrone E/A angepasst wurde, kann dies die Leistung auch um das Zehnfache verringern.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung, die Puffergröße und den synchronen bzw. asynchronen Zustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, die Namen der Geräte, wie z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein.  
  
> [!NOTE]
>  `path` ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Sie können einen beliebigen Teil eines Systems sein, die Zugriff über Streams unterstützt. Diese Klasse abhängig von dem System kann beispielsweise ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien kapseln. Wenn `path` gibt an ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für das resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das asynchrone Schreiben von Daten in eine Datei, und stellen Sie sicher, dass die Daten richtig geschrieben wurde. Ein `State` -Objekt erstellt, um Informationen über den Hauptthread, übergeben die `EndReadCallback` und `EndWriteCallback` Methoden.  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
- oder - 
 <paramref name="mode" />, <paramref name="access" /> oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
- oder - 
Das System führt Windows 98 oder Windows 98 Zweite Ausgabe aus, und <paramref name="share" /> ist auf <see langword="FileShare.Delete" /> festgelegt.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <altmember cref="T:System.IO.File" />
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, access, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.IO.FileAccess" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see langword="FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="access">Eine Konstante, die bestimmt, welcher Zugriff auf die Datei für das <see langword="FileStream" />-Objekt zulässig ist. Dies bestimmt ebenfalls die von den <see cref="P:System.IO.FileStream.CanRead" />- und <see cref="P:System.IO.FileStream.CanWrite" />-Eigenschaften des <see langword="FileStream" />-Objekts zurückgegebenen Werte. <see cref="P:System.IO.FileStream.CanSeek" /> ist <see langword="true" />, wenn <paramref name="path" /> eine Datei auf einem Datenträger darstellt.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="options">Ein Wert, der zusätzliche Dateioptionen angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Lese-/Schreib- und Freigabeberechtigung, die Zugriffsmöglichkeiten anderer FileStreams auf die gleiche Datei, die Puffergröße und zusätzliche Dateioptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, die Namen der Geräte, wie z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Die `fileOptions` Parameter wird verwendet, um den Zugriff auf Erweiterte Vorgänge bereitzustellen, die genutzt werden können, beim Erstellen einer <xref:System.IO.FileStream> Objekt.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein.  
  
> [!NOTE]
>  `path` ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Sie können einen beliebigen Teil eines Systems sein, die Zugriff über Streams unterstützt. Diese Klasse abhängig von dem System kann beispielsweise ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien kapseln. Wenn `path` gibt an ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für das resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel schreibt Daten in eine Datei und liest dann die Daten mit der <xref:System.IO.FileStream> Objekt.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
- oder - 
 <paramref name="mode" />, <paramref name="access" /> oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.  
  
- oder - 
 <see cref="F:System.IO.FileOptions.Encrypted" /> ist für <paramref name="options" /> angegeben, aber Dateiverschlüsselung wird auf der aktuellen Plattform nicht unterstützt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene Pfad und/oder Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, rights As FileSystemRights, share As FileShare, bufferSize As Integer, options As FileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="rights">Eine Konstante, die die beim Erstellen der Zugriffs- und Überwachungsregeln für die Datei zu verwendenden Zugriffsrechte festlegt.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="options">Eine Konstante, die zusätzliche Dateioptionen angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Zugriffsrechte und die Freigabeberechtigung, die Puffergröße und zusätzliche Dateioptionen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, die Namen der Geräte, wie z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Verwenden Sie diese Option <xref:System.IO.FileStream.%23ctor%2A> Konstruktor anzuwendende Access rights zum Zeitpunkt der Erstellung einer Datei. Um Zugriff auf oder Ändern von Berechtigungen für eine vorhandene Datei, erwägen Sie die Verwendung der <xref:System.IO.File.GetAccessControl%2A> und <xref:System.IO.File.SetAccessControl%2A> Methoden.  
  
 Die `fileOptions` Parameter wird verwendet, um den Zugriff auf Erweiterte Vorgänge bereitzustellen, die genutzt werden können, beim Erstellen einer <xref:System.IO.FileStream> Objekt.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein.  
  
> [!NOTE]
>  `path` ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Sie können einen beliebigen Teil eines Systems sein, die Zugriff über Streams unterstützt. Diese Klasse abhängig von dem System kann beispielsweise ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien kapseln. Wenn `path` gibt an ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für das resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
- oder - 
 <paramref name="mode" />, <paramref name="access" /> oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.  
  
- oder - 
 <see cref="F:System.IO.FileOptions.Encrypted" /> ist für <paramref name="options" /> angegeben, aber Dateiverschlüsselung wird auf der aktuellen Plattform nicht unterstützt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene <paramref name="path" /> und/oder der angegebene Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FileStream(System::String ^ path, System::IO::FileMode mode, System::Security::AccessControl::FileSystemRights rights, System::IO::FileShare share, int bufferSize, System::IO::FileOptions options, System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="new System.IO.FileStream : string * System.IO.FileMode * System.Security.AccessControl.FileSystemRights * System.IO.FileShare * int * System.IO.FileOptions * System.Security.AccessControl.FileSecurity -&gt; System.IO.FileStream" Usage="new System.IO.FileStream (path, mode, rights, share, bufferSize, options, fileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.IO.FileMode" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="share" Type="System.IO.FileShare" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.IO.FileOptions" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">Ein relativer oder absoluter Pfad zu der Datei, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</param>
        <param name="mode">Eine Konstante, die bestimmt, auf welche Weise die Datei geöffnet oder erstellt werden soll.</param>
        <param name="rights">Eine Konstante, die die beim Erstellen der Zugriffs- und Überwachungsregeln für die Datei zu verwendenden Zugriffsrechte festlegt.</param>
        <param name="share">Eine Konstante zur Bestimmung der Art, in der Prozesse gemeinsam auf die Datei zugreifen.</param>
        <param name="bufferSize">Ein positiver <see cref="T:System.Int32" />-Wert größer als 0 (null), der die Puffergröße angibt. Die Standardpuffergröße ist 4096.</param>
        <param name="options">Eine Konstante, die zusätzliche Dateioptionen angibt.</param>
        <param name="fileSecurity">Eine Konstante, die die Zugriffssteuerung und die Überwachungssicherheit für die Datei bestimmt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.IO.FileStream" />-Klasse mit den Angaben für den Pfad, den Erstellungsmodus, die Zugriffsrechte und die Freigabeberechtigung, die Puffergröße, zusätzliche Dateioptionen, die Zugriffssteuerung und die Überwachungssicherheit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework unterstützt keine direkten Zugriff auf physische Datenträger über Pfade, die Namen der Geräte, wie z. B. "\\\\. \PHYSICALDRIVE0".  
  
 Verwenden Sie diese Option <xref:System.IO.FileStream.%23ctor%2A> Konstruktor anzuwendende Access rights zum Zeitpunkt der Erstellung einer Datei. Um Zugriff auf oder Ändern von Berechtigungen für eine vorhandene Datei, erwägen Sie die Verwendung der <xref:System.IO.File.GetAccessControl%2A> und <xref:System.IO.File.SetAccessControl%2A> Methoden.  
  
 Die `fileOptions` Parameter wird verwendet, um den Zugriff auf Erweiterte Vorgänge bereitzustellen, die genutzt werden können, beim Erstellen einer <xref:System.IO.FileStream> Objekt.  
  
 Die `path` Parameter kann einen Dateinamen, einschließlich einer Datei auf einer Freigabe Universal Naming Convention (UNC) sein.  
  
> [!NOTE]
>  `path` ist nicht erforderlich, um eine Datei auf dem Datenträger gespeichert werden. Sie können einen beliebigen Teil eines Systems sein, die Zugriff über Streams unterstützt. Diese Klasse abhängig von dem System kann beispielsweise ein physisches Gerät zugreifen.  
  
 <xref:System.IO.Stream.CanSeek%2A> ist `true` für alle <xref:System.IO.FileStream> Objekte, die Dateien kapseln. Wenn `path` gibt an ein Gerät, das keine Suchvorgänge, unterstützt die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft für das resultierende <xref:System.IO.FileStream> ist `false`. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Wenn Sie kompilieren Sie eine Gruppe von Zeichen mit einer bestimmten kulturellen Einstellung und die gleichen Zeichen mit der eine andere kultureinstellung abrufen, werden die Zeichen können nicht interpretiert werden und können dazu führen, dass eine Ausnahme ausgelöst werden.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel schreibt Daten in eine Datei und liest dann die Daten mit der <xref:System.IO.FileStream> Objekt.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> ist eine leere Zeichenfolge (""), enthält nur Leerzeichen oder enthält mindestens ein ungültiges Zeichen.  
  
- oder - 
 <paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer NTFS-Umgebung.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="path" /> verweist auf ein Nicht-Datei-Gerät, etwa "con:", "com1:", "lpt1:" usw., in einer Nicht-NTFS-Umgebung.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> ist negativ oder 0 (null).  
  
- oder - 
 <paramref name="mode" />, <paramref name="access" /> oder <paramref name="share" /> enthält einen ungültigen Wert.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei kann nicht gefunden werden. Dies ist z. B. der Fall, wenn <paramref name="mode" /> auf <see langword="FileMode.Truncate" /> oder <see langword="FileMode.Open" /> festgelegt und die durch <paramref name="path" /> angegebene Datei nicht vorhanden ist. Die Datei muss bereits in diesen Modi vorhanden sein.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, beispielsweise weil <see langword="FileMode.CreateNew" /> angegeben wurde, die durch <paramref name="path" /> angegebene Datei aber bereits vorhanden ist.  
  
- oder - 
Der Stream wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Der angegebene Pfad ist ungültig, z. B. befindet er sich auf einem nicht zugeordneten Laufwerk.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der angeforderte <paramref name="access" /> für den angegebenen <paramref name="path" /> wird vom Betriebssystem nicht zugelassen. Dies ist z. B. der Fall, wenn <paramref name="access" /> auf <see langword="Write" /> oder <see langword="ReadWrite" /> festgelegt und die Datei bzw. das Verzeichnis schreibgeschützt ist.  
  
- oder - 
 <see cref="F:System.IO.FileOptions.Encrypted" /> ist für <paramref name="options" /> angegeben, aber Dateiverschlüsselung wird auf der aktuellen Plattform nicht unterstützt.</exception>
        <exception cref="T:System.IO.PathTooLongException">Der angegebene <paramref name="path" /> und/oder der angegebene Dateiname überschreiten die vom System definierte maximale Länge.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Das aktuelle Betriebssystem ist nicht Windows NT oder höher.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen, schreiben und Anfügen von Dateien. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, callback, state)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginRead (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netcore-2.0;netcore-3.0;netframework-1.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">Der Puffer, in den Daten gelesen werden sollen.</param>
        <param name="buffer">To be added.</param>
        <param name="offset">Der Byteoffset im <paramref name="array" />, ab dem gelesen werden soll.</param>
        <param name="numBytes">Die maximale Anzahl der zu lesenden Bytes.</param>
        <param name="count">To be added.</param>
        <param name="callback">Die Methode, die aufgerufen werden soll, wenn der asynchrone Lesevorgang abgeschlossen ist.</param>
        <param name="userCallback">Die Methode, die aufgerufen werden soll, wenn der asynchrone Lesevorgang abgeschlossen ist.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Leseanforderung von anderen Anforderungen unterscheidet.</param>
        <param name="stateObject">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Leseanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Beginnt einen asynchronen Lesevorgang. Verwenden Sie stattdessen <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.</summary>
        <returns>Ein Objekt, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Die Arraylänge minus <paramref name="offset" /> ist kleiner als <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="numBytes" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">Es wurde ein asynchroner Lesevorgang nach Erreichen des Dateiendes versucht.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, callback, state)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (array As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ array, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="fileStream.BeginWrite (array, offset, numBytes, userCallback, stateObject)" FrameworkAlternate="netcore-2.0;netcore-3.0;netframework-1.1" />
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, count As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="numBytes" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-2.0;netcore-3.0;netstandard-2.1" />
        <Parameter Name="stateObject" Type="System.Object" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="array">Der Puffer mit den Daten, die in den aktuellen Stream geschrieben werden sollen.</param>
        <param name="buffer">To be added.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="array" />, ab dem Bytes in den aktuellen Stream kopiert werden.</param>
        <param name="numBytes">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <param name="count">To be added.</param>
        <param name="callback">Die Methode, die aufgerufen werden soll, wenn der asynchrone Schreibvorgang abgeschlossen ist.</param>
        <param name="userCallback">Die Methode, die aufgerufen werden soll, wenn der asynchrone Schreibvorgang abgeschlossen ist.</param>
        <param name="state">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Schreibanforderung von anderen Anforderungen unterscheidet.</param>
        <param name="stateObject">Ein vom Benutzer bereitgestelltes Objekt, das diese asynchrone Schreibanforderung von anderen Anforderungen unterscheidet.</param>
        <summary>Beginnt einen asynchronen Schreibvorgang. Verwenden Sie stattdessen <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.</summary>
        <returns>Ein Objekt, das auf den asynchronen Schreibvorgang verweist.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="array" /> minus <paramref name="offset" /> ist kleiner als <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="numBytes" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt das Schreiben nicht.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Stream Lesevorgänge unterstützt.</summary>
        <value><see langword="true" />, wenn der Stream Lesevorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder ausschließlich mit Schreibzugriff geöffnet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Klasse von abgeleitet <xref:System.IO.Stream> unterstützt keine Lesevorgänge, werden Aufrufe von der <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, und <xref:System.IO.FileStream.BeginRead%2A> Methoden lösen eine <xref:System.NotSupportedException>.  
  
 Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung des der `CanRead` Eigenschaft. Die Ausgabe dieses Codes ist "MyFile.txt nicht beschreibbar ist." Beim Abrufen der ausgabemeldung "MyFile.txt können sowohl in geschrieben und gelesen werden.", Ändern der `FileAccess` Parameter `ReadWrite` in die `FileStream` Konstruktor.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Stream Suchvorgänge unterstützt.</summary>
        <value><see langword="true" />, wenn der Stream Suchvorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder der <see langword="FileStream" /> von einem Betriebssystemhandle, z. B. einer Pipe oder einer Ausgabe in der Konsole, erstellt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Klasse von abgeleitet <xref:System.IO.Stream> unterstützt keine Suchvorgänge, werden Aufrufe von <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, und <xref:System.IO.FileStream.Seek%2A> Auslösen einer <xref:System.NotSupportedException>.  
  
 Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `CanSeek` Eigenschaft zu überprüfen, ob ein Stream Suchvorgänge unterstützt.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Stream Schreibvorgänge unterstützt.</summary>
        <value><see langword="true" />, wenn der Stream Schreibvorgänge unterstützt, <see langword="false" />, wenn der Stream geschlossen ist oder mit schreibgeschütztem Zugriff geöffnet wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Klasse von abgeleitet <xref:System.IO.Stream> unterstützt nicht das Schreiben, handelt es sich bei eines Aufrufs von <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, oder <xref:System.IO.FileStream.WriteByte%2A> löst eine <xref:System.NotSupportedException>.  
  
 Wenn der Stream geschlossen ist, gibt diese Eigenschaft `false`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `CanWrite` Eigenschaft zu überprüfen, ob ein Stream Schreibvorgänge unterstützt.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 Im folgenden finden Sie ein Beispiel mit der `CanWrite` Eigenschaft. Die Ausgabe dieses Codes ist "MyFile.txt geschrieben werden kann." Beim Abrufen der ausgabemeldung "MyFile.txt können sowohl in geschrieben und gelesen werden.", Ändern der `FileAccess` Parameter `ReadWrite` in die `FileStream` Konstruktor.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="fileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dieser Member überschreibt <see cref="M:System.IO.Stream.Close" />. Das zugehörige Thema enthält möglicherweise eine umfassendere Dokumentation.

Schließt den aktuellen Stream und gibt alle dem aktuellen Stream zugeordneten Ressourcen frei (z. B. Sockets und Dateihandles).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="fileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die von <see cref="T:System.IO.FileStream" /> verwendeten nicht verwalteten Ressourcen und optional die verwalteten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen <xref:System.ComponentModel.Component.Dispose%2A> Methode und die <xref:System.Object.Finalize%2A> Methode. <xref:System.ComponentModel.Component.Dispose%2A> Ruft die geschützte <xref:System.IO.FileStream.Dispose%2A> -Methode mit dem `disposing` Parametersatz zu `true`. <xref:System.Object.Finalize%2A> Ruft <xref:System.IO.FileStream.Dispose%2A> mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.IO.FileStream> verweist. Diese Methode ruft die <xref:System.ComponentModel.Component.Dispose%2A>-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> Achten Sie darauf, dass Sie nicht auf Objekte verweisen, die zuvor von einem früheren Aufruf freigegeben wurden <see cref="M:System.ComponentModel.Component.Dispose" />. Weitere Informationen zur Implementierung <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Weitere Informationen zu <see cref="M:System.ComponentModel.Component.Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="DisposeAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask DisposeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask DisposeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.DisposeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function DisposeAsync () As ValueTask" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::ValueTask DisposeAsync();" />
      <MemberSignature Language="F#" Value="override this.DisposeAsync : unit -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.DisposeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="fileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Der Verweis auf die ausstehende asynchrone Anforderung, die abgewartet werden soll.</param>
        <summary>Wartet, bis der ausstehende asynchrone Lesevorgang abgeschlossen ist. (Verwenden Sie stattdessen <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <returns>Die Anzahl der aus dem Stream gelesenen Bytes. Diese Anzahl kann zwischen 0 und der Anzahl der angeforderten Bytes liegen. Streams geben nur am Ende des Streams 0 zurück, andernfalls sollten sie blockieren, bis mindestens 1 Byte verfügbar ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.FileStream.BeginRead%2A> und <xref:System.IO.FileStream.EndRead%2A> , asynchrone Datei-Vorgänge zu implementieren. Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code, jedoch die neuen Async-Methoden, wie z. B. <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, und <xref:System.IO.FileStream.FlushAsync%2A>, Hilfe, die Sie asynchrone Dateivorgänge leichter implementieren.  
  
 <xref:System.IO.FileStream.EndRead%2A> muss aufgerufen werden, genau für jeden Aufruf von <xref:System.IO.FileStream.BeginRead%2A>. Wenn ein Lesevorgang vor einem anderen Lesevorgang beendet kann unerwünschtes Verhalten wie z. B. Deadlocks führen.  
  
 Diese Methode überschreibt <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A> kann aufgerufen werden, auf jedem <xref:System.IAsyncResult> aus <xref:System.IO.FileStream.BeginRead%2A>. Aufrufen von <xref:System.IO.FileStream.EndRead%2A> erfahren Sie, wie viele Bytes aus dem Stream gelesen wurden. <xref:System.IO.FileStream.EndRead%2A> blockiert, bis der e/a-Vorgang abgeschlossen ist.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Dieses <see cref="T:System.IAsyncResult" />-Objekt wurde nicht durch Aufrufen von <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> für diese Klasse erstellt.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> wird mehrmals aufgerufen.</exception>
        <exception cref="T:System.IO.IOException">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">Asynchrone Datei-E/A</related>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="fileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Die ausstehende asynchrone E/A-Anforderung.</param>
        <summary>Beendet einen asynchronen Schreibvorgang und blockiert, bis die E/A-Operation abgeschlossen wurde. (Verwenden Sie stattdessen <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der .NET Framework 4 und früheren Versionen erforderlich, wie z. B. <xref:System.IO.FileStream.BeginWrite%2A> und <xref:System.IO.FileStream.EndWrite%2A> , asynchrone Datei-Vorgänge zu implementieren. Diese Methoden sind weiterhin verfügbar, in der [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zur Unterstützung von legacy-Code, jedoch die neuen Async-Methoden, wie z. B. <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, und <xref:System.IO.FileStream.FlushAsync%2A>, Hilfe, die Sie asynchrone Dateivorgänge leichter implementieren.  
  
 Diese Methode überschreibt <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A> muss genau einmal aufgerufen werden, für jede <xref:System.IAsyncResult> aus <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A> blockiert, bis der e/a-Vorgang abgeschlossen ist.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Dieses <see cref="T:System.IAsyncResult" />-Objekt wurde nicht durch Aufrufen von <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> für diese Klasse erstellt.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> wird mehrmals aufgerufen.</exception>
        <exception cref="T:System.IO.IOException">Der Stream ist geschlossen, oder ein interner Fehler ist aufgetreten.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
        <related type="Article" href="~/docs/standard/io/asynchronous-file-i-o.md">Asynchrone Datei-E/A</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!FileStream ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="fileStream.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt das Freigeben von Ressourcen und das Ausführen anderer Bereinigungsvorgänge sicher, wenn der Garbage Collector den <see langword="FileStream" /> verarbeitet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Garbage Collector ruft `Finalize` Wenn das aktuelle Objekt wird finalisiert werden. `Finalize` Schließt die `FileStream`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Löscht die Puffer für diesen Datenstrom und veranlasst die Ausgabe aller gepufferten Daten in die Datei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="fileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Löscht die Puffer für diesen Datenstrom und veranlasst die Ausgabe aller gepufferten Daten in die Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 Beim Aufrufen der <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> -Methode, die Betriebssystem e/a-Puffer wird ebenfalls geleert.  
  
 Eine streamdatei Encoder wird nicht geleert werden, es sei denn, Sie explizit aufrufen, <xref:System.IO.FileStream.Flush%2A> oder Löschen des Objekts. Festlegen von <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> zu `true` bedeutet, die Daten werden in den Stream, aus dem Puffer geleert werden, aber der Encoderzustand wird nicht geleert. Dadurch wird den Encoder auf seinen Zustand (partielle Zeichen) beibehalten, sodass den nächsten Block Zeichen richtig codiert werden können. Dieses Szenario betrifft, UTF8 und UTF7, in denen bestimmte Zeichen nur verschlüsselt werden können, nachdem der Encoder das bzw. der angrenzenden Zeichen empfangen.  
  
 Da ein Puffer für gelesen oder geschrieben wird, verwendet werden kann <xref:System.IO.FileStream.Flush> führt die folgenden zwei Funktionen:  
  
-   Alle zuvor in den Puffer geschriebenen Daten in die Datei kopiert werden, und der Puffer wird gelöscht, außer den Encoderzustand.  
  
-   Wenn <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> ist `true` Daten wurde zuvor in den Puffer zum Lesen aus der Datei kopiert, und die aktuelle Position in der Datei wird durch die Anzahl der gelesenen Bytes im Puffer verringert. Der Puffer wird dann gelöscht.  
  
 Verwenden der <xref:System.IO.FileStream.Flush%28System.Boolean%29> -methodenüberladung, wenn Sie möchten sicherstellen, dass alle Zwischendateipuffer Daten gepuffert wird geschrieben. auf dem Datenträger.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.Lock%2A> Methode.  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
        <altmember cref="M:System.IO.FileStream.Flush(System.Boolean)" />
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="fileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="flushToDisk"><see langword="true" />, um alle Zwischendateipuffer zu leeren, andernfalls <see langword="false" />.</param>
        <summary>Löscht die Puffer für diesen Datenstrom, veranlasst die Ausgabe aller gepufferten Daten in die Datei und löscht zudem alle Zwischendateipuffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Überladung, wenn Sie möchten, um sicherzustellen, dass alle Daten im Zwischendateipuffer gepuffert geschrieben wird. auf dem Datenträger.  
  
 Beim Aufrufen der <xref:System.IO.FileStream.Flush%2A> -Methode, die Betriebssystem e/a-Puffer wird ebenfalls geleert.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.FileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ FlushAsync(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.FlushAsync : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.FlushAsync cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Das Token zum Überwachen von Abbruchanforderungen.</param>
        <summary>Löscht alle Puffer für diesen Stream asynchron und veranlasst die Ausgabe aller gepufferten Daten an das zugrunde liegende Gerät und überwacht Abbruchanforderungen.</summary>
        <returns>Eine Aufgabe, die die asynchrone Leerung darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen der <xref:System.IO.FileStream.FlushAsync%2A> -Methode, die Betriebssystem e/a-Puffer wird ebenfalls geleert.  
  
 Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen wurde, enthält die zurückgegebene Aufgabe der <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft. Wenn das Handle für die Datei verworfen wird, enthält die zurückgegebene Aufgabe der <xref:System.ObjectDisposedException> Ausnahme in der <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Abbruch</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As FileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::FileSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.FileSecurity" Usage="fileStream.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft ein <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt ab, das die Einträge in der Zugriffssteuerungsliste für die Datei kapselt, das vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt beschrieben wird.</summary>
        <returns>Ein Objekt, das die Zugriffssteuerungseinstellungen für die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt beschriebene Datei kapselt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Während der <xref:System.IO.FileStream> Klasse und <xref:System.IO.FileStream.GetAccessControl%2A> können verwendet werden, um die Zugriffssteuerungseinträge Zugriffssteuerungsliste (ACL) einer vorhandenen Datei abrufen, sollten verwenden <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> -Methode, ist einfacher zu verwenden.  
  
 Verwenden der <xref:System.IO.FileStream.GetAccessControl%2A> Methode, um die ACL-Einträge für eine Datei abzurufen.  
  
 Eine ACL beschreibt Personen bzw. Gruppen besitzen oder verfügen nicht über, Rechte für bestimmte Aktionen für die angegebene Datei. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Datei ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">Beim Öffnen der Datei ist ein E/A-Fehler aufgetreten.</exception>
        <exception cref="T:System.SystemException">Die Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Dieser Vorgang wird von der aktuellen Plattform nicht unterstützt.  
  
- oder -  
Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Dateihandle des Betriebssystems für die Datei ab, die durch das aktuelle <see langword="FileStream" />-Objekt gekapselt wird.</summary>
        <value>Das Dateihandle des Betriebssystems für die vom <see langword="FileStream" />-Objekt gekapselte Datei oder -1, wenn der <see langword="FileStream" /> geschlossen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist ein Betriebssystem-Handle für die Verwendung mit Betriebssystem-System bereitgestellte Systemaufrufe (z. B. `ReadFile` für Windows). Es funktioniert nicht mit Funktionen der C-Bibliothek, die einen Dateideskriptor ist, z. B. erwarten `fread`.  
  
 Das Betriebssystemhandle möglicherweise geöffnet wurden synchron oder asynchron, je nachdem, welche `FileStream` Konstruktor aufgerufen wurde. Verwenden der <xref:System.IO.FileStream.IsAsync%2A> Eigenschaft, um zu ermitteln, ob dieses Handle asynchron geöffnet wurde. In Win32, bedeutet dies, das Handle geöffnet wurde, für die überlappende e/a und erfordert andere Parameter für `ReadFile` und `WriteFile`.  
  
> [!CAUTION]
>  Beschädigung von Daten kann auftreten, wenn eine `FileStream` wird erstellt, dessen Handle übergeben, einige-Vorgang verschiebt den Dateizeiger des Handles, und klicken Sie dann die `FileStream` erneut verwendet wird. Mehrere Threads können nicht sicher gleichzeitig auf dieselbe Datei schreiben und `FileStream` Pufferung Code wird davon ausgegangen, dass es sich ausschließlich um das Handle steuert. `FileStream` löst möglicherweise eine <xref:System.IO.IOException> Wenn `FileStream` erkennt, dass ein anderer Prozess den Dateizeiger verschoben wurde. Um dies zu vermeiden, Sie keine Daten schreiben in einen Teil der Datei, die `FileStream` möglicherweise gepuffert wurde, und den Dateizeiger am Speicherort, der beim Methoden auf zuletzt aufgerufenen wiederherstellen `FileStream`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche Berechtigung.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für den Zugriff auf nicht verwalteten Code. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see langword="FileStream" /> asynchron oder synchron geöffnet wurde.</summary>
        <value><see langword="true" />, wenn <see langword="FileStream" /> asynchron geöffnet wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `IsAsync` Eigenschaft erkennt, ob die `FileStream` Handle asynchron geöffnet wurde, ermöglichen Ihren Code, um die <xref:System.IO.FileStream.Handle%2A> Eigenschaft ordnungsgemäß. In Win32 "" `IsAsync` wird "true" bedeutet, dass das Handle geöffnet wurde, für die überlappende e/a und erfordert daher verschiedene Parameter für `ReadFile` und `WriteFile`.  
  
 Sie geben Sie diesen Wert bei der Erstellung einer Instanz von der <xref:System.IO.FileStream> -Klasse unter Verwendung eines Konstruktors, die eine `isAsync`, `useAsync`, oder `options` Parameter. Wenn die Eigenschaft ist `true`, der Datenstrom verwendet überlappende e/a, um die Dateivorgänge asynchron ausführen. Allerdings die <xref:System.IO.FileStream.IsAsync%2A> Eigenschaft hat keine sein `true` zum Aufrufen der <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, oder <xref:System.IO.Stream.CopyToAsync%2A> Methode. Wenn die <xref:System.IO.FileStream.IsAsync%2A> Eigenschaft `false` und Sie rufen den asynchronen Lesevorgang und Schreibvorgänge, der UI-Thread wird weiterhin nicht blockiert, aber der tatsächliche e/a-Vorgang synchron ausgeführt wird.  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Länge des Streams in Bytes ab.</summary>
        <value>Ein Long-Wert, der die Länge des Streams in Bytes darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Length` und `Position` -Eigenschaften, um für eine End-of-File-Bedingung.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="P:System.IO.FileStream.CanSeek" /> ist für diesen Stream <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Es ist ein E/A-Fehler aufgetreten, z. B. wurde die Datei geschlossen.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Lock : int64 * int64 -&gt; unit&#xA;override this.Lock : int64 * int64 -&gt; unit" Usage="fileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">Der Anfang des zu sperrenden Bereichs. Der Wert dieses Parameters muss größer oder gleich 0 sein.</param>
        <param name="length">Der zu sperrende Bereich.</param>
        <summary>Verhindert, dass andere Prozesse im <see cref="T:System.IO.FileStream" /> lesen oder schreiben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erhalten durch Sperren eines Bereichs eines Dateidatenstroms der Threads von der Sperren exklusiven Zugriff auf dieses Bereichs des Dateidatenstroms.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Teil der Datei zu sperren, damit ein anderer Prozess nicht auf diesen Teil der Datei, obwohl sie Lese-/Schreibzugriff auf die Datei hat zugreifen kann. Führen Sie das Programm gleichzeitig in verschiedenen Befehlsfenster, und untersuchen Sie, die verschiedene Konsolen-Eingabeoptionen verwenden.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ObjectDisposedException">Die Datei ist geschlossen.</exception>
        <exception cref="T:System.IO.IOException">Der Prozess kann nicht auf die Datei zugreifen, da sie teilweise von einem anderen Prozess gesperrt ist.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den absoluten Pfad der Datei auf, die im <see langword="FileStream" /> geöffnet wurde.</summary>
        <value>Eine Zeichenfolge, die den absoluten Pfad der Datei ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Wenn der absolute Pfad nicht bekannt ist, gibt diese Eigenschaft eine Zeichenfolge ähnlich "Unknown".

 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf den Pfad. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Position dieses Streams ab oder legt diese fest.</summary>
        <value>Die aktuelle Position dieses Streams.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 An einem beliebigen Speicherort über die Länge des Streams hinaus Suchvorgänge werden unterstützt.  Wenn Sie über die Länge der Datei hinaus zu suchen, wächst die Dateigröße.  In Microsoft Windows NT und höher werden am Ende der Datei hinzugefügten Daten 0 (null) festgelegt.  In Microsoft Windows 98 oder früher, werden am Ende der Datei hinzugefügten Daten nicht 0 (null), festgelegt, d. h., die zuvor Daten gelöscht, in den Stream angezeigt wird. Die Position des Streams auf einen hohen Wert hinter dem Ende des Streams in Windows 98 oder früher festgelegt wurde, möglicherweise eine Ausnahme ausgelöst wird.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `Length` und `Position` -Eigenschaften, um für eine End-of-File-Bedingung.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Vom Stream wird Suchen nicht unterstützt.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler  
  
- oder - 
Die Position wurde auf einen sehr großen Wert festgelegt, der das Ende des Streams in Windows 98 oder früher überschreitet.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Es wurde versucht, die Position auf einen negativen Wert festzulegen.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Es wurde versucht, über das Ende eines Streams hinaus zu suchen, der dies nicht unterstützt.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;byte&gt; -&gt; int" Usage="fileStream.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (array As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="fileStream.Read (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Enthält nach dem Beenden dieser Methode das angegebene Bytearray mit den Werten zwischen <paramref name="offset" /> und (<paramref name="offset" /> + <paramref name="count" /> - 1<c>)</c>, die durch die aus der aktuellen Quelle gelesenen Bytes ersetzt wurden.</param>
        <param name="offset">Das Byteoffset in <paramref name="array" />, an dem die gelesenen Bytes platziert werden.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Bytes.</param>
        <summary>Liest einen Byteblock aus dem Stream und schreibt die Daten in einen angegebenen Puffer.</summary>
        <returns>Die Gesamtanzahl der in den Puffer gelesenen Bytes. Dies kann weniger als die Anzahl der angeforderten Bytes sein, wenn diese Anzahl an Bytes derzeit nicht verfügbar ist, oder 0, wenn das Streamende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Read%2A>.  
  
 Die `offset` -Parameter gibt den Offset des Bytes in `array` (Pufferindex) gelesen werden soll, und die `count` -Parameter gibt die maximale Anzahl von Bytes, die aus diesem Stream gelesen werden. Der zurückgegebene Wert ist die tatsächliche Anzahl der gelesenen Bytes oder 0 (null), wenn das Ende des Streams erreicht ist. Wenn der Lesevorgang erfolgreich ist, ist die aktuelle Position im Stream um die Anzahl der gelesenen Bytes erweitert. Wenn eine Ausnahme auftritt, wird die aktuelle Position des Streams unverändert.  
  
 Die <xref:System.IO.FileStream.Read%2A> Methode gibt 0 (null) nur nach Erreichen das Ende des Streams zurück. Andernfalls <xref:System.IO.FileStream.Read%2A> immer mindestens ein Byte aus dem Stream liest, vor der Rückgabe. Wenn keine Daten verfügbar, aus dem Stream bei einem Aufruf von sind <xref:System.IO.FileStream.Read%2A>, die Methode blockiert, bis mindestens ein Byte an Daten zurückgegeben werden kann. Eine Implementierung ist weniger Bytes als angefordert zurückgeben, selbst wenn Sie nicht das Ende des Streams erreicht wurde.  
  
 Verwendung <xref:System.IO.BinaryReader> zum Lesen von primitiven Datentypen.  
  
 Unterbrechen Sie keinen Thread, der einen Lesevorgang ausführt. Obwohl die Anwendung angezeigt werden kann, erfolgreich ausgeführt wird, nachdem der Thread nicht blockiert ist, kann die Unterbrechung, Leistung und Zuverlässigkeit Ihrer Anwendungsverzeichnis verringern.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel liest den Inhalt aus einem <xref:System.IO.FileStream> und schreibt ihn in ein anderes <xref:System.IO.FileStream>.  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.NotSupportedException">Lesevorgänge werden vom Stream nicht unterstützt.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> und <paramref name="count" /> bezeichnen einen ungültigen Bereich in <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="fileStream.ReadAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, in den die Daten geschrieben werden sollen.</param>
        <param name="offset">Der Byteoffset im <paramref name="buffer" />, ab dem Daten aus dem Stream geschrieben werden.</param>
        <param name="count">Die maximale Anzahl der zu lesenden Bytes.</param>
        <param name="cancellationToken">Das Token zum Überwachen von Abbruchanforderungen.</param>
        <summary>Liest eine Folge von Bytes asynchron aus aktuellen Stream, erhöht die Position im Stream um die Anzahl der gelesenen Bytes und überwacht Abbruchanfragen.</summary>
        <returns>Eine Aufgabe, die den asynchronen Lesevorgang darstellt. Der Wert des <paramref name="TResult" />-Parameters enthält die Gesamtzahl der Bytes, die in den Puffer gelesen werden. Der Ergebniswert kann niedriger als die Anzahl der angeforderten Bytes sein, wenn die Anzahl an derzeit verfügbaren Bytes kleiner ist als die angeforderte Anzahl, oder sie kann 0 (null) sein, wenn das Datenstromende erreicht ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.FileStream.ReadAsync%2A> Methode können Sie ressourcenintensive Vorgänge ausführen, ohne den Hauptthread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. Die Async-Methoden werden verwendet, in Verbindung mit der `async` und `await` in Visual Basic und C#-Schlüsselwörter.  
  
 Verwenden der <xref:System.IO.FileStream.CanRead%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt.  
  
 Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen wurde, enthält die zurückgegebene Aufgabe der <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft. Wenn das Handle für die Datei verworfen wird, enthält die zurückgegebene Aufgabe der <xref:System.ObjectDisposedException> Ausnahme in der <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie aus einer Datei asynchron zu lesen.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</exception>
        <exception cref="T:System.NotSupportedException">Lesevorgänge werden vom Stream nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream wird zurzeit von einem vorherigen Lesevorgang verwendet.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Abbruch</related>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="fileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest ein Byte aus der Datei und erhöht die Leseposition um ein Byte.</summary>
        <returns>Das Byte, das in <see cref="T:System.Int32" /> umgewandelt wurde, oder -1, wenn das Ende des Streams erreicht wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  Verwenden der <xref:System.IO.FileStream.CanRead%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Lesevorgänge unterstützt. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanRead%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Schreiben von Daten in eine Datei byteweise, und stellen Sie sicher, dass die Daten richtig geschrieben wurde.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lesevorgänge werden vom aktuellen Stream nicht unterstützt.</exception>
        <exception cref="T:System.ObjectDisposedException">Der aktuelle Stream wird geschlossen.</exception>
        <block subset="none" type="overrides"><para>Die Standardimplementierung für <see langword="Stream" /> erstellt ein neues Single-Byte-Array und ruft dann <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Während dies formell richtig ist, ist es ineffizient. Jeder Stream mit einem internen Puffer sollte diese Methode überschreiben, und geben Sie eine effizientere Version, die den Puffer direkt, liest die zusätzlichen Array Zuordnung bei jedem Aufruf zu vermeiden.  
  
Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />-Objekt ab, das das Dateihandle des Betriebssystems für die Datei darstellt, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</summary>
        <value>Ein Objekt, das das Dateihandle des Betriebssystems für die Datei darstellt, von der das aktuelle <see cref="T:System.IO.FileStream" />-Objekt gekapselt wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.FileStream.SafeFileHandle%2A> Eigenschaft automatisch leert den Stream und legt die aktuelle Streamposition auf 0 fest.  Dadurch kann die Datei verschoben werden oder die Position im Stream von einem anderen Stream mit zurückgesetzt werden die <xref:System.IO.FileStream.SafeFileHandle%2A> von dieser Eigenschaft zurückgegeben.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Berechtigung zum Aufrufen von nicht verwalteten Codes.  
  
Security-Aktion: Linkaufruf 
Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="fileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Der Punkt relativ zu <paramref name="origin" />, ab dem gesucht werden soll.</param>
        <param name="origin">Bestimmt den Anfang, das Ende oder die aktuelle Position als Bezugspunkt für <paramref name="offset" /> unter Verwendung eines Werts vom Typ <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Legt die aktuelle Position dieses Streams auf den angegebenen Wert fest.</summary>
        <returns>Die neue Position im Stream.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Verwenden der <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Suchvorgänge unterstützt. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.  
  
 Sie können an jedem Speicherort über die Länge des Streams hinaus zu suchen. Wenn Sie über die Länge der Datei hinaus zu suchen, wächst die Dateigröße. In Windows NT oder höher werden die Daten, die am Ende der Datei auf 0 (null) festgelegt. Im Windows 98 oder früher werden Daten hinzugefügt wurden, an das Ende der Datei nicht 0 (null), festgelegt, d.h., die zuvor Daten gelöscht sichtbar, in den Stream.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Schreiben von Daten in eine Datei byteweise, und stellen Sie sicher, dass die Daten richtig geschrieben wurde.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 Das folgende Beispiel liest Text in umgekehrter Richtung, aus das Ende der Datei an den Anfang der Datei mit den verschiedenen <xref:System.IO.SeekOrigin> Werte mit den <xref:System.IO.FileStream.Seek%2A> Methode.  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">E/A-Fehler</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt beispielsweise keine Suchvorgänge, wenn der <see langword="FileStream" /> aus einer Pipe- oder Konsolenausgabe erstellt wird.</exception>
        <exception cref="T:System.ArgumentException">Es wird versucht, vor Beginn des Streams eine Suche auszuführen.</exception>
        <exception cref="T:System.ObjectDisposedException">Es wurden Methoden aufgerufen, nachdem der Stream geschlossen wurde.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::FileSecurity ^ fileSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.FileSecurity -&gt; unit" Usage="fileStream.SetAccessControl fileSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Ein Objekt, das einen Eintrag in einer Zugriffssteuerungsliste beschreibt, der auf die aktuelle Datei angewendet werden soll.</param>
        <summary>Wendet von einem <see cref="T:System.Security.AccessControl.FileSecurity" />-Objekt beschriebene Einträge in Zugriffssteuerungslisten auf die Datei an, die vom aktuellen <see cref="T:System.IO.FileStream" />-Objekt beschrieben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Während der <xref:System.IO.FileStream> Klasse und <xref:System.IO.FileStream.SetAccessControl%2A> kann auf eine vorhandene Datei verwendet werden, sollten Sie verwenden die <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> -Methode ist einfacher zu verwenden.  
  
 Die <xref:System.IO.FileStream.SetAccessControl%2A> Methode gilt Einträge Access Control List (ACL) für eine Datei, die nicht geerbte Zugriffssteuerungsliste darstellt.  
  
> [!CAUTION]
>  Die ACL angegeben wird, für die `fileSecurity` Parameter ersetzt die vorhandene Zugriffssteuerungsliste für die Datei. Um Berechtigungen für einen neuen Benutzer hinzuzufügen, verwenden die <xref:System.IO.FileStream.GetAccessControl%2A> Methode zum Abrufen der vorhandenen ACL, ändern und dann <xref:System.IO.FileStream.SetAccessControl%2A> es wieder in die Datei angewendet.  
  
 Eine ACL beschreibt Personen bzw. Gruppen besitzen oder verfügen nicht über, Rechte für bestimmte Aktionen für die angegebene Datei. Weitere Informationen finden Sie unter [Gewusst wie: Hinzufügen oder Entfernen von Zugriffssteuerungslisten-Einträgen](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Die Datei ist geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="fileSecurity" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Die Datei konnte nicht gefunden oder geändert werden.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Der aktuelle Prozess hat keinen Zugriff zum Öffnen der Datei.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="fileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Die neue Länge des Streams.</param>
        <summary>Legt die Länge dieses Streams auf den angegebenen Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.SetLength%2A>.  
  
 Wenn der angegebene Wert kleiner als die aktuelle Länge des Streams ist, wird der Stream abgeschnitten. In diesem Szenario wird die aktuelle Position ist die aktuelle Position größer als die Länge der neuen, auf das letzte Byte im Stream verschoben. Wenn der angegebene Wert größer als die aktuelle Länge des Streams ist, wird der Stream erweitert ist, und die aktuelle Position bleibt unverändert. Wenn der Stream erweitert wird, sind die Inhalte des Streams, der zwischen den alten und die neue Länge nicht definiert.  
  
 Ein Stream muss unterstützen sowohl Schreib- und Lesevorgänge für `SetLength` funktioniert.  
  
> [!NOTE]
>  Verwenden der <xref:System.IO.FileStream.CanWrite%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz geschrieben wird, unterstützt und die <xref:System.IO.FileStream.CanSeek%2A> Eigenschaft, um zu bestimmen, ob Suchvorgänge unterstützt werden. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanWrite%2A> und <xref:System.IO.Stream.CanSeek%2A>.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ein E/A-Fehler ist aufgetreten.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt nicht gleichzeitig Schreib- und Suchvorgänge.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Es wurde versucht, den <paramref name="value" />-Parameter auf einen Wert kleiner 0 (null) festzulegen.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="abstract member Unlock : int64 * int64 -&gt; unit&#xA;override this.Unlock : int64 * int64 -&gt; unit" Usage="fileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">Der Anfang des zu entsperrenden Bereichs.</param>
        <param name="length">Der zu entsperrende Bereich.</param>
        <summary>Ermöglicht anderen Prozessen den Zugriff auf die gesamte Datei oder einen Teil der Datei, die zuvor gesperrt war.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, Teil der Datei zu sperren, damit ein anderer Prozess kann nicht dieser Teil der Datei zugreifen, obwohl sie Lese-/Schreibzugriff auf die Datei hat, und entsperren Sie den angegebenen Teil der Datei. Führen Sie das Programm gleichzeitig in verschiedenen Befehlsfenster, und untersuchen Sie, die verschiedene Konsolen-Eingabeoptionen verwenden.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> oder <paramref name="length" /> ist ein negativer Wert.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Write : ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="fileStream.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (array As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ array, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="fileStream.Write (array, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Der Puffer mit den Daten, die in den Stream geschrieben werden sollen.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="array" />, ab dem Bytes in den Stream kopiert werden.</param>
        <param name="count">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <summary>Schreibt einen Block von Bytes in den Dateistream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.Write%2A>.  
  
 Die `offset` -Parameter gibt den Offset des Bytes in `array` (Pufferindex) an, ab dem kopiert wird, und die `count` Parameter enthält die Anzahl der Bytes, die in den Stream geschrieben werden. Wenn der Schreibvorgang erfolgreich ist, ist die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes erweitert. Wenn eine Ausnahme auftritt, wird die aktuelle Position des Streams unverändert.  
  
> [!NOTE]
>  Verwenden der <xref:System.IO.FileStream.CanWrite%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanWrite%2A>.  
  
 Unterbrechen Sie keinen Thread, der einen Schreibvorgang ausführt. Obwohl die Anwendung angezeigt werden kann, erfolgreich ausgeführt wird, nachdem der Thread nicht blockiert ist, kann die Unterbrechung, Leistung und Zuverlässigkeit Ihrer Anwendungsverzeichnis verringern.  
  
 Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.IO.FileStream.Lock%2A> Methode.  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> und <paramref name="count" /> bezeichnen einen ungültigen Bereich in <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.IO.IOException">E/A-Fehler  
  
- oder - 
Ein anderer Thread hat möglicherweise eine unerwartete Änderung der Position des Dateihandles des Betriebssystems verursacht.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Die aktuelle Streaminstanz unterstützt keine Schreibvorgänge.</exception>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask WriteAsync (ReadOnlyMemory&lt;byte&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask WriteAsync(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : ReadOnlyMemory&lt;byte&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="fileStream.WriteAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteAsync(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteAsync : byte[] * int * int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="fileStream.WriteAsync (buffer, offset, count, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">Der Puffer, aus dem Daten geschrieben werden sollen.</param>
        <param name="offset">Der nullbasierte Byteoffset im <paramref name="buffer" />, ab dem Bytes in den Stream kopiert werden.</param>
        <param name="count">Die maximale Anzahl der zu schreibenden Bytes.</param>
        <param name="cancellationToken">Das Token zum Überwachen von Abbruchanforderungen.</param>
        <summary>Schreibt beim Überschreiben in einer abgeleiteten Klasse eine Folge von Bytes asynchron in den aktuellen Stream und erhöht die aktuelle Position im Stream um die Anzahl der geschriebenen Bytes und überwacht Abbruchanforderungen.</summary>
        <returns>Eine Aufgabe, die den asynchronen Schreibvorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.IO.FileStream.WriteAsync%2A> Methode können Sie ressourcenintensive Vorgänge ausführen, ohne den Hauptthread zu blockieren. Diese Überlegungen zur Leistung sind insbesondere in einer [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] -App oder [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] -App wichtig, bei der ein zeitaufwendiger Streamvorgang den UI-Thread blockieren kann und es dann den Anschein hat, dass Ihre App nicht funktioniert. Die Async-Methoden werden verwendet, in Verbindung mit der `async` und `await` in Visual Basic und C#-Schlüsselwörter.  
  
 Verwenden der <xref:System.IO.FileStream.CanWrite%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt.  
  
 Wenn der Vorgang abgebrochen wird, bevor er abgeschlossen wurde, enthält die zurückgegebene Aufgabe der <xref:System.Threading.Tasks.TaskStatus.Canceled> Wert für die <xref:System.Threading.Tasks.Task.Status%2A> Eigenschaft. Wenn das Handle für die Datei verworfen wird, enthält die zurückgegebene Aufgabe der <xref:System.ObjectDisposedException> Ausnahme in der <xref:System.Threading.Tasks.Task.Exception%2A> Eigenschaft.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie asynchron in eine Datei geschrieben wird.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> oder <paramref name="count" /> ist ein negativer Wert.</exception>
        <exception cref="T:System.ArgumentException">Die Summe von <paramref name="offset" /> und <paramref name="count" /> ist größer als die Pufferlänge.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt das Schreiben nicht.</exception>
        <exception cref="T:System.ObjectDisposedException">Der Stream wurde verworfen.</exception>
        <exception cref="T:System.InvalidOperationException">Der Stream wird zurzeit von einem vorherigen Schreibvorgang verwendet.</exception>
        <related type="Article" href="~/docs/standard/threading/cancellation-in-managed-threads.md">Abbruch</related>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="fileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Ein Byte, das in den Stream geschrieben werden soll.</param>
        <summary>Schreibt ein Byte an die aktuelle Position im Dateistream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.IO.Stream.WriteByte%2A>.  
  
 Verwendung `WriteByte` einen Byte, das Schreiben einer `FileStream` effizient. Wenn der Stream geschlossen oder schreibgeschützt ist, wird eine Ausnahme ausgelöst werden.  
  
> [!NOTE]
>  Verwenden der <xref:System.IO.FileStream.CanWrite%2A> Eigenschaft, um zu bestimmen, ob die aktuelle Instanz Schreibvorgänge unterstützt. Weitere Informationen finden Sie unter <xref:System.IO.Stream.CanWrite%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel veranschaulicht das Schreiben von Daten in eine Datei byteweise, und stellen Sie sicher, dass die Daten richtig geschrieben wurde.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der Stream ist geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Der Stream unterstützt das Schreiben nicht.</exception>
        <block subset="none" type="overrides"><para>Die Standardimplementierung für <see langword="Stream" /> erstellt ein neues Single-Byte-Array und ruft dann <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Während dies formell richtig ist, ist es ineffizient. Jeder Stream mit einem internen Puffer sollte diese Methode überschreiben, und geben Sie eine effizientere Version, die den Puffer direkt, liest die zusätzlichen Array Zuordnung bei jedem Aufruf zu vermeiden.  
  
Eine Liste der allgemeinen Datei- und Verzeichnisvorgänge, finden Sie unter [e/a-Aufgaben](~/docs/standard/io/common-i-o-tasks.md).</para></block>
        <related type="Article" href="~/docs/standard/io/index.md">Datei- und Stream-E/A</related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md">Gewusst wie: Lesen aus einer Textdatei</related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md">Gewusst wie: Schreiben von Text in eine Datei</related>
      </Docs>
    </Member>
  </Members>
</Type>